/**
* @module vue-mdc-adapter 0.19.0-beta
* @exports VueMDCAdapter
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"@material/tabs":"^0.43.0","material-components-web":"^0.43.0"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.VueMDCAdapter = factory());
}(this, function () { 'use strict';

  var supportsPassive_;
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */

  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = {
              passive: true
            };
          }

        });
      } catch (e) {//empty
      }

      supportsPassive_ = isSupported;
    }

    return supportsPassive_;
  }

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;

    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }

    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.19.0-beta',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var CustomElement = {
    functional: true,
    render: function render(createElement, context) {
      return createElement(context.props.is || context.props.tag || 'div', context.data, context.children);
    }
  };
  var CustomElementMixin = {
    components: {
      CustomElement: CustomElement
    }
  };

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _extends() {
    _extends = Object.assign || function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };

    return _extends.apply(this, arguments);
  }

  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);

      if (typeof Object.getOwnPropertySymbols === 'function') {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }

      ownKeys.forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    }

    return target;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: {
        type: String,
        default: 'a'
      },
      link: Object
    },
    render: function render(h, context) {
      var element;

      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({
          tag: context.props.tag
        }, context.props.link);

        if (data.on.click) {
          data.nativeOn = {
            click: data.on.click
          };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };
  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */
  function emitCustomEvent(el, evtType, evtData) {
    var shouldBubble = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var evt;

    if (typeof CustomEvent === 'function') {
      evt = new CustomEvent(evtType, {
        detail: evtData,
        bubbles: shouldBubble
      });
    } else {
      evt = document.createEvent('CustomEvent');
      evt.initCustomEvent(evtType, shouldBubble, false, evtData);
    }

    el.dispatchEvent(evt);
  }

  var CustomButton = {
    name: 'custom-button',
    functional: true,
    props: {
      link: Object
    },
    render: function render(h, context) {
      var element;

      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({
          tag: context.props.tag
        }, context.props.link);
        data.attrs.role = 'button';

        if (data.on.click) {
          data.nativeOn = {
            click: data.on.click
          };
        }
      } else if (data.attrs && data.attrs.href) {
        // href case
        element = 'a';
        data.attrs.role = 'button';
      } else {
        // button fallback
        element = 'button';
      }

      return h(element, data, context.children);
    }
  };
  var CustomButtonMixin = {
    props: {
      href: String,
      disabled: Boolean,
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomButton: CustomButton
    }
  };

  function extractIconProp(iconProp) {
    if (typeof iconProp === 'string') {
      return {
        classes: {
          'material-icons': true
        },
        content: iconProp
      };
    } else if (iconProp instanceof Array) {
      return {
        classes: iconProp.reduce(function (result, value) {
          return _extends(result, _defineProperty({}, value, true));
        }, {})
      };
    } else if (_typeof(iconProp) === 'object') {
      return {
        classes: iconProp.className.split(' ').reduce(function (result, value) {
          return _extends(result, _defineProperty({}, value, true));
        }, {}),
        content: iconProp.textContent
      };
    }
  }

  var DispatchEventMixin = {
    props: {
      event: String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        evt && this.$emit(evt.type, evt);

        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(_toConsumableArray(args)));
        }
      }
    },
    computed: {
      listeners: function listeners() {
        var _this = this;

        return _objectSpread({}, this.$listeners, {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        });
      }
    }
  };

  var DispatchFocusMixin = {
    data: function data() {
      return {
        hasFocus: false
      };
    },
    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);

        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  var scope = Math.floor(Math.random() * Math.floor(0x10000000)).toString() + '-';
  var VMAUniqueIdMixin = {
    beforeCreate: function beforeCreate() {
      this.vma_uid_ = scope + this._uid;
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @template A
   */
  var MDCFoundation =
  /*#__PURE__*/
  function () {
    _createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }
      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }
      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }
      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    _createClass(MDCFoundation, [{
      key: "init",
      value: function init() {// Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {// Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);

    return MDCFoundation;
  }();

  /**
   * @template F
   */

  var MDCComponent =
  /*#__PURE__*/
  function () {
    _createClass(MDCComponent, null, [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }
      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;

      _classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args); // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.

      /** @protected {!F} */

      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    _createClass(MDCComponent, [{
      key: "initialize",
      value: function initialize()
      /* ...args */
      {} // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.

      /**
       * @return {!F} foundation
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {// Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }
      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "listen",
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }
      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "unlisten",
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }
      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: "emit",
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var evt;

        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);

    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCRippleAdapter() {
      _classCallCheck(this, MDCRippleAdapter);
    }

    _createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}
      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}
      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}
      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}
      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);

    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$1 = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };
  var strings = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };
  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225,
    // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150,
    // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices

  };

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_;
  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */

  var supportsPassive_$1;
  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */

  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node); // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397

    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }
  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */


  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var supportsCssVariables = supportsCssVariables_;

    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';

    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes'); // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari

    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }

    return supportsCssVariables;
  } //

  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|!EventListenerOptions}
   */


  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;

      try {
        globalObj.document.addEventListener('test', null, {
          get passive() {
            isSupported = true;
            return isSupported;
          }

        });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ?
    /** @type {!EventListenerOptions} */
    {
      passive: true
    } : false;
  }
  /**
   * @param {!Object} HTMLElementPrototype
   * @return {string}
   */


  function getMatchesProperty(HTMLElementPrototype) {
    /**
     * Order is important because we return the first existing method we find.
     * Do not change the order of the items in the below array.
     */
    var matchesMethods = ['matches', 'webkitMatchesSelector', 'msMatchesSelector'];
    var method = 'matches';

    for (var i = 0; i < matchesMethods.length; i++) {
      var matchesMethod = matchesMethods[i];

      if (matchesMethod in HTMLElementPrototype) {
        method = matchesMethod;
        break;
      }
    }

    return method;
  }
  /**
   * @param {!Event} ev
   * @param {{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {{x: number, y: number}}
   */


  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;
    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;
    var normalizedX;
    var normalizedY; // Determine touch point relative to the ripple container.

    if (ev.type === 'touchstart') {
      ev =
      /** @type {!TouchEvent} */
      ev;
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      ev =
      /** @type {!MouseEvent} */
      ev;
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return {
      x: normalizedX,
      y: normalizedY
    };
  }

  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown']; // Deactivation events registered on documentElement when a pointer-related down event occurs

  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup', 'contextmenu']; // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations

  /** @type {!Array<!EventTarget>} */

  var activatedTargets = [];
  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCRippleFoundation, _MDCFoundation);

    _createClass(MDCRippleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$1;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars()
          /* boolean - cached */
          {},
          isUnbounded: function isUnbounded()
          /* boolean */
          {},
          isSurfaceActive: function isSurfaceActive()
          /* boolean */
          {},
          isSurfaceDisabled: function isSurfaceDisabled()
          /* boolean */
          {},
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          containsEventTarget: function containsEventTarget()
          /* target: !EventTarget */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler()
          /* evtType: string, handler: EventListener */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          updateCssVariable: function updateCssVariable()
          /* varName: string, value: string */
          {},
          computeBoundingRect: function computeBoundingRect()
          /* ClientRect */
          {},
          getWindowPageOffset: function getWindowPageOffset()
          /* {x: number, y: number} */
          {}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCRippleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCRippleFoundation).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {!ClientRect} */

      _this.frame_ =
      /** @type {!ClientRect} */
      {
        width: 0,
        height: 0
      };
      /** @private {!ActivationStateType} */

      _this.activationState_ = _this.defaultActivationState_();
      /** @private {number} */

      _this.initialSize_ = 0;
      /** @private {number} */

      _this.maxRadius_ = 0;
      /** @private {function(!Event)} */

      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };
      /** @private {function(!Event=)} */


      _this.deactivateHandler_ = function () {
        return _this.deactivate_();
      };
      /** @private {function(!Event=)} */


      _this.focusHandler_ = function () {
        return _this.handleFocus();
      };
      /** @private {function(!Event=)} */


      _this.blurHandler_ = function () {
        return _this.handleBlur();
      };
      /** @private {!Function} */


      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      /** @private {{left: number, top:number}} */


      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };
      /** @private {number} */

      _this.fgScale_ = 0;
      /** @private {number} */

      _this.activationTimer_ = 0;
      /** @private {number} */

      _this.fgDeactivationRemovalTimer_ = 0;
      /** @private {boolean} */

      _this.activationAnimationHasEnded_ = false;
      /** @private {!Function} */

      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;

        _this.runDeactivationUXLogicIfReady_();
      };
      /** @private {!Event|undefined} */


      _this.previousActivationEvent_;
      return _this;
    }
    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    _createClass(MDCRippleFoundation, [{
      key: "supportsPressRipple_",
      value: function supportsPressRipple_() {
        return this.adapter_.browserSupportsCssVars();
      }
      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: "defaultActivationState_",
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: undefined,
          isProgrammatic: false
        };
      }
      /** @override */

    }, {
      key: "init",
      value: function init() {
        var _this2 = this;

        var supportsPressRipple = this.supportsPressRipple_();
        this.registerRootHandlers_(supportsPressRipple);

        if (supportsPressRipple) {
          var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$.ROOT,
              UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;
          requestAnimationFrame(function () {
            _this2.adapter_.addClass(ROOT);

            if (_this2.adapter_.isUnbounded()) {
              _this2.adapter_.addClass(UNBOUNDED); // Unbounded ripples need layout logic applied immediately to set coordinates for both shade and ripple


              _this2.layoutInternal_();
            }
          });
        }
      }
      /** @override */

    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        if (this.supportsPressRipple_()) {
          if (this.activationTimer_) {
            clearTimeout(this.activationTimer_);
            this.activationTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_ACTIVATION);
          }

          if (this.fgDeactivationRemovalTimer_) {
            clearTimeout(this.fgDeactivationRemovalTimer_);
            this.fgDeactivationRemovalTimer_ = 0;
            this.adapter_.removeClass(MDCRippleFoundation.cssClasses.FG_DEACTIVATION);
          }

          var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
              ROOT = _MDCRippleFoundation$2.ROOT,
              UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;
          requestAnimationFrame(function () {
            _this3.adapter_.removeClass(ROOT);

            _this3.adapter_.removeClass(UNBOUNDED);

            _this3.removeCssVars_();
          });
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();
      }
      /**
       * @param {boolean} supportsPressRipple Passed from init to save a redundant function call
       * @private
       */

    }, {
      key: "registerRootHandlers_",
      value: function registerRootHandlers_(supportsPressRipple) {
        var _this4 = this;

        if (supportsPressRipple) {
          ACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
          });

          if (this.adapter_.isUnbounded()) {
            this.adapter_.registerResizeHandler(this.resizeHandler_);
          }
        }

        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
      }
      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: "registerDeactivationHandlers_",
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }
      /** @private */

    }, {
      key: "deregisterRootHandlers_",
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);

        if (this.adapter_.isUnbounded()) {
          this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        }
      }
      /** @private */

    }, {
      key: "deregisterDeactivationHandlers_",
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }
      /** @private */

    }, {
      key: "removeCssVars_",
      value: function removeCssVars_() {
        var _this8 = this;

        var strings$$1 = MDCRippleFoundation.strings;
        Object.keys(strings$$1).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings$$1[k], null);
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "activate_",
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;

        if (activationState.isActivated) {
          return;
        } // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction


        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e !== undefined && previousActivationEvent.type !== e.type;

        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === undefined;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e !== undefined && (e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown');
        var hasActivatedChild = e !== undefined && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });

        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e !== undefined) {
          activatedTargets.push(
          /** @type {!EventTarget} */
          e.target);
          this.registerDeactivationHandlers_(e);
        }

        activationState.wasElementMadeActive = this.checkElementMadeActive_(e);

        if (activationState.wasElementMadeActive) {
          this.animateActivation_();
        }

        requestAnimationFrame(function () {
          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];

          if (!activationState.wasElementMadeActive && e !== undefined && (e.key === ' ' || e.keyCode === 32)) {
            // If space was pressed, try again within an rAF call to detect :active, because different UAs report
            // active states inconsistently when they're called within event handling code:
            // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
            // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
            // We try first outside rAF to support Edge, which does not exhibit this problem, but will crash if a CSS
            // variable is set within a rAF callback for a submit button interaction (#2241).
            activationState.wasElementMadeActive = _this9.checkElementMadeActive_(e);

            if (activationState.wasElementMadeActive) {
              _this9.animateActivation_();
            }
          }

          if (!activationState.wasElementMadeActive) {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }
        });
      }
      /**
       * @param {!Event=} e
       * @private
       */

    }, {
      key: "checkElementMadeActive_",
      value: function checkElementMadeActive_(e) {
        return e !== undefined && e.type === 'keydown' ? this.adapter_.isSurfaceActive() : true;
      }
      /**
       * @param {!Event=} event Optional event containing position information.
       */

    }, {
      key: "activate",
      value: function activate(event) {
        this.activate_(event);
      }
      /** @private */

    }, {
      key: "animateActivation_",
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;
        this.layoutInternal_();
        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _this$getFgTranslatio = this.getFgTranslationCoordinates_(),
              startPoint = _this$getFgTranslatio.startPoint,
              endPoint = _this$getFgTranslatio.endPoint;

          translateStart = "".concat(startPoint.x, "px, ").concat(startPoint.y, "px");
          translateEnd = "".concat(endPoint.x, "px, ").concat(endPoint.y, "px");
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd); // Cancel any ongoing activation/deactivation animations

        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION); // Force layout in order to re-trigger the animation.

        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }
      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: "getFgTranslationCoordinates_",
      value: function getFgTranslationCoordinates_() {
        var _this$activationState = this.activationState_,
            activationEvent = _this$activationState.activationEvent,
            wasActivatedByPointer = _this$activationState.wasActivatedByPointer;
        var startPoint;

        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */
          activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        } // Center the element around the start point.


        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };
        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };
        return {
          startPoint: startPoint,
          endPoint: endPoint
        };
      }
      /** @private */

    }, {
      key: "runDeactivationUXLogicIfReady_",
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _this$activationState2 = this.activationState_,
            hasDeactivationUXRun = _this$activationState2.hasDeactivationUXRun,
            isActivated = _this$activationState2.isActivated;
        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }
      /** @private */

    }, {
      key: "rmBoundedActivationClasses_",
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;
        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: "resetActivationState_",
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_(); // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.

        setTimeout(function () {
          return _this12.previousActivationEvent_ = undefined;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }
      /**
       * @private
       */

    }, {
      key: "deactivate_",
      value: function deactivate_() {
        var _this13 = this;

        var activationState = this.activationState_; // This can happen in scenarios such as when you have a keyup event that blurs the element.

        if (!activationState.isActivated) {
          return;
        }

        var state =
        /** @type {!ActivationStateType} */
        _extends({}, activationState);

        if (activationState.isProgrammatic) {
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;

            _this13.animateDeactivation_(state);

            _this13.resetActivationState_();
          });
        }
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.deactivate_();
      }
      /**
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: "animateDeactivation_",
      value: function animateDeactivation_(_ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();

          _this14.layoutFrame_ = 0;
        });
      }
      /** @private */

    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width); // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.

        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius(); // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform

        this.initialSize_ = Math.floor(maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE);
        this.fgScale_ = this.maxRadius_ / this.initialSize_;
        this.updateLayoutCssVars_();
      }
      /** @private */

    }, {
      key: "updateLayoutCssVars_",
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;
        this.adapter_.updateCssVariable(VAR_FG_SIZE, "".concat(this.initialSize_, "px"));
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };
          this.adapter_.updateCssVariable(VAR_LEFT, "".concat(this.unboundedCoords_.left, "px"));
          this.adapter_.updateCssVariable(VAR_TOP, "".concat(this.unboundedCoords_.top, "px"));
        }
      }
      /** @param {boolean} unbounded */

    }, {
      key: "setUnbounded",
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }, {
      key: "handleFocus",
      value: function handleFocus() {
        var _this16 = this;

        requestAnimationFrame(function () {
          return _this16.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }, {
      key: "handleBlur",
      value: function handleBlur() {
        var _this17 = this;

        requestAnimationFrame(function () {
          return _this17.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      }
    }]);

    return MDCRippleFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCRippleFoundation>
   */

  var MDCRipple =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCRipple, _MDCComponent);

    /** @param {...?} args */
    function MDCRipple() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCRipple);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCRipple)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @type {boolean} */

      _this.disabled = false;
      /** @private {boolean} */

      _this.unbounded_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @param {{isUnbounded: (boolean|undefined)}=} options
     * @return {!MDCRipple}
     */


    _createClass(MDCRipple, [{
      key: "setUnbounded_",

      /**
       * Closure Compiler throws an access control error when directly accessing a
       * protected or private property inside a getter/setter, like unbounded above.
       * By accessing the protected property inside a method, we solve that problem.
       * That's why this function exists.
       * @private
       */
      value: function setUnbounded_() {
        this.foundation_.setUnbounded(this.unbounded_);
      }
    }, {
      key: "activate",
      value: function activate() {
        this.foundation_.activate();
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.foundation_.deactivate();
      }
    }, {
      key: "layout",
      value: function layout() {
        this.foundation_.layout();
      }
      /**
       * @return {!MDCRippleFoundation}
       * @override
       */

    }, {
      key: "getDefaultFoundation",
      value: function getDefaultFoundation() {
        return new MDCRippleFoundation(MDCRipple.createAdapter(this));
      }
      /** @override */

    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.unbounded = 'mdcRippleIsUnbounded' in this.root_.dataset;
      }
    }, {
      key: "unbounded",

      /** @return {boolean} */
      get: function get() {
        return this.unbounded_;
      }
      /** @param {boolean} unbounded */
      ,
      set: function set(unbounded) {
        this.unbounded_ = Boolean(unbounded);
        this.setUnbounded_();
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref$isUnbounded = _ref.isUnbounded,
            isUnbounded = _ref$isUnbounded === void 0 ? undefined : _ref$isUnbounded;

        var ripple = new MDCRipple(root); // Only override unbounded behavior if option is explicitly specified

        if (isUnbounded !== undefined) {
          ripple.unbounded =
          /** @type {boolean} */
          isUnbounded;
        }

        return ripple;
      }
      /**
       * @param {!RippleCapableSurface} instance
       * @return {!MDCRippleAdapter}
       */

    }, {
      key: "createAdapter",
      value: function createAdapter(instance) {
        var MATCHES = getMatchesProperty(HTMLElement.prototype);
        return {
          browserSupportsCssVars: function browserSupportsCssVars() {
            return supportsCssVariables(window);
          },
          isUnbounded: function isUnbounded() {
            return instance.unbounded;
          },
          isSurfaceActive: function isSurfaceActive() {
            return instance.root_[MATCHES](':active');
          },
          isSurfaceDisabled: function isSurfaceDisabled() {
            return instance.disabled;
          },
          addClass: function addClass(className) {
            return instance.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return instance.root_.classList.remove(className);
          },
          containsEventTarget: function containsEventTarget(target) {
            return instance.root_.contains(target);
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return instance.root_.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return instance.root_.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
          },
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
            return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
          },
          registerResizeHandler: function registerResizeHandler(handler) {
            return window.addEventListener('resize', handler);
          },
          deregisterResizeHandler: function deregisterResizeHandler(handler) {
            return window.removeEventListener('resize', handler);
          },
          updateCssVariable: function updateCssVariable(varName, value) {
            return instance.root_.style.setProperty(varName, value);
          },
          computeBoundingRect: function computeBoundingRect() {
            return instance.root_.getBoundingClientRect();
          },
          getWindowPageOffset: function getWindowPageOffset() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          }
        };
      }
    }]);

    return MDCRipple;
  }(MDCComponent);
  /**
   * See Material Design spec for more details on when to use ripples.
   * https://material.io/guidelines/motion/choreography.html#choreography-creation
   * @record
   */


  var RippleCapableSurface = function RippleCapableSurface() {
    _classCallCheck(this, RippleCapableSurface);
  };
  /** @protected {!Element} */


  RippleCapableSurface.prototype.root_;
  /**
   * Whether or not the ripple bleeds out of the bounds of the element.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.unbounded;
  /**
   * Whether or not the ripple is attached to a disabled component.
   * @type {boolean|undefined}
   */

  RippleCapableSurface.prototype.disabled;

  var RippleBase =
  /*#__PURE__*/
  function (_MDCRippleFoundation) {
    _inherits(RippleBase, _MDCRippleFoundation);

    _createClass(RippleBase, null, [{
      key: "isSurfaceActive",
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: "MATCHES",
      get: function get() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      _classCallCheck(this, RippleBase);

      return _possibleConstructorReturn(this, _getPrototypeOf(RippleBase).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },
        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler, applyPassive$1());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler, applyPassive$1());
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return {
            x: window.pageXOffset,
            y: window.pageYOffset
          };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);
  var RippleMixin = {
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  //
  var script = {
    name: 'mdc-ripple',
    mixins: [CustomElementMixin, RippleMixin],
    props: {
      tag: String
    }
  };

  function normalizeComponent(compiledTemplate, injectStyle, defaultExport, scopeId, isFunctionalTemplate, moduleIdentifier
  /* server only */
  , isShadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof isShadowMode === 'function') {
      createInjectorSSR = createInjector;
      createInjector = isShadowMode;
      isShadowMode = false;
    } // Vue.extend constructor export interop


    var options = typeof defaultExport === 'function' ? defaultExport.options : defaultExport; // render functions

    if (compiledTemplate && compiledTemplate.render) {
      options.render = compiledTemplate.render;
      options.staticRenderFns = compiledTemplate.staticRenderFns;
      options._compiled = true; // functional template

      if (isFunctionalTemplate) {
        options.functional = true;
      }
    } // scopedId


    if (scopeId) {
      options._scopeId = scopeId;
    }

    var hook;

    if (moduleIdentifier) {
      // server build
      hook = function hook(context) {
        // 2.3 injection
        context = context || // cached call
        this.$vnode && this.$vnode.ssrContext || // stateful
        this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional
        // 2.2 with runInNewContext: true

        if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
          context = __VUE_SSR_CONTEXT__;
        } // inject component styles


        if (injectStyle) {
          injectStyle.call(this, createInjectorSSR(context));
        } // register component module identifier for async chunk inference


        if (context && context._registeredComponents) {
          context._registeredComponents.add(moduleIdentifier);
        }
      }; // used by ssr in case component is cached and beforeCreate
      // never gets called


      options._ssrRegister = hook;
    } else if (injectStyle) {
      hook = isShadowMode ? function () {
        injectStyle.call(this, createInjectorShadow(this.$root.$options.shadowRoot));
      } : function (context) {
        injectStyle.call(this, createInjector(context));
      };
    }

    if (hook) {
      if (options.functional) {
        // register for functional component in vue file
        var originalRender = options.render;

        options.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = options.beforeCreate;
        options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }

    return defaultExport;
  }

  /* script */
  const __vue_script__ = script;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script.__file = "/ddata/extra/vma/components/ripple/mdc-ripple.vue";

  /* template */
  var __vue_render__ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-element",
      {
        staticClass: "mdc-ripple",
        attrs: { tag: _vm.tag, classes: _vm.classes, styles: _vm.styles }
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__ = [];
  __vue_render__._withStripped = true;

    /* style */
    const __vue_inject_styles__ = undefined;
    /* scoped */
    const __vue_scope_id__ = undefined;
    /* module identifier */
    const __vue_module_identifier__ = undefined;
    /* functional template */
    const __vue_is_functional_template__ = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcRipple = normalizeComponent(
      { render: __vue_render__, staticRenderFns: __vue_staticRenderFns__ },
      __vue_inject_styles__,
      __vue_script__,
      __vue_scope_id__,
      __vue_is_functional_template__,
      __vue_module_identifier__,
      undefined,
      undefined
    );

  var VueMDCRipple = BasePlugin({
    mdcRipple: mdcRipple
  });

  //
  var script$1 = {
    name: 'mdc-button-base',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  /* script */
  const __vue_script__$1 = script$1;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$1.__file = "/ddata/extra/vma/components/button/mdc-button-base.vue";

  /* template */
  var __vue_render__$1 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-button",
      _vm._g(
        {
          ref: "root",
          class: _vm.classes,
          style: _vm.styles,
          attrs: { href: _vm.href, link: _vm.link, disabled: _vm.disabled }
        },
        _vm.listeners
      ),
      [_c("span", { staticClass: "mdc-button__label" }, [_vm._t("default")], 2)]
    )
  };
  var __vue_staticRenderFns__$1 = [];
  __vue_render__$1._withStripped = true;

    /* style */
    const __vue_inject_styles__$1 = undefined;
    /* scoped */
    const __vue_scope_id__$1 = undefined;
    /* module identifier */
    const __vue_module_identifier__$1 = undefined;
    /* functional template */
    const __vue_is_functional_template__$1 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcButtonBase = normalizeComponent(
      { render: __vue_render__$1, staticRenderFns: __vue_staticRenderFns__$1 },
      __vue_inject_styles__$1,
      __vue_script__$1,
      __vue_scope_id__$1,
      __vue_is_functional_template__$1,
      __vue_module_identifier__$1,
      undefined,
      undefined
    );

  var script$2 = {
    name: 'mdc-button',
    extends: mdcButtonBase,
    props: {
      raised: Boolean,
      unelevated: Boolean,
      outlined: Boolean,
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-button--raised': this.raised,
          'mdc-button--unelevated': this.unelevated,
          'mdc-button--outlined': this.outlined,
          'mdc-button--dense': this.dense
        }
      };
    },
    watch: {
      raised: function raised() {
        this.$set(this.classes, 'mdc-button--raised', this.raised);
      },
      unelevated: function unelevated() {
        this.$set(this.classes, 'mdc-button--unelevated', this.unelevated);
      },
      outlined: function outlined() {
        this.$set(this.classes, 'mdc-button--outlined', this.outlined);
      },
      dense: function dense() {
        this.$set(this.classes, 'mdc-button--dense', this.dense);
      }
    }
  };

  /* script */
  const __vue_script__$2 = script$2;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$2.__file = "/ddata/extra/vma/components/button/mdc-button.vue";

  /* template */

    /* style */
    const __vue_inject_styles__$2 = undefined;
    /* scoped */
    const __vue_scope_id__$2 = undefined;
    /* module identifier */
    const __vue_module_identifier__$2 = undefined;
    /* functional template */
    const __vue_is_functional_template__$2 = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcButton = normalizeComponent(
      {},
      __vue_inject_styles__$2,
      __vue_script__$2,
      __vue_scope_id__$2,
      __vue_is_functional_template__$2,
      __vue_module_identifier__$2,
      undefined,
      undefined
    );

  var VueMDCButton = BasePlugin({
    mdcButton: mdcButton
  });

  //
  //
  //
  //
  //
  //
  //
  //
  var script$3 = {
    name: 'mdc-card',
    props: {
      outlined: Boolean
    }
  };

  /* script */
  const __vue_script__$3 = script$3;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$3.__file = "/ddata/extra/vma/components/card/mdc-card.vue";

  /* template */
  var __vue_render__$2 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-card", class: { "mdc-card--outlined": _vm.outlined } },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$2 = [];
  __vue_render__$2._withStripped = true;

    /* style */
    const __vue_inject_styles__$3 = undefined;
    /* scoped */
    const __vue_scope_id__$3 = undefined;
    /* module identifier */
    const __vue_module_identifier__$3 = undefined;
    /* functional template */
    const __vue_is_functional_template__$3 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCard = normalizeComponent(
      { render: __vue_render__$2, staticRenderFns: __vue_staticRenderFns__$2 },
      __vue_inject_styles__$3,
      __vue_script__$3,
      __vue_scope_id__$3,
      __vue_is_functional_template__$3,
      __vue_module_identifier__$3,
      undefined,
      undefined
    );

  //
  var script$4 = {
    name: 'mdc-card-primary-action',
    mixins: [DispatchEventMixin, CustomLinkMixin, RippleMixin],
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    }
  };

  /* script */
  const __vue_script__$4 = script$4;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$4.__file = "/ddata/extra/vma/components/card/mdc-card-primary-action.vue";

  /* template */
  var __vue_render__$3 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-link",
      _vm._g(
        {
          staticClass: "mdc-card-primary-action mdc-card__primary-action",
          class: _vm.classes,
          style: _vm.styles,
          attrs: { link: _vm.link }
        },
        _vm.listeners
      ),
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$3 = [];
  __vue_render__$3._withStripped = true;

    /* style */
    const __vue_inject_styles__$4 = undefined;
    /* scoped */
    const __vue_scope_id__$4 = undefined;
    /* module identifier */
    const __vue_module_identifier__$4 = undefined;
    /* functional template */
    const __vue_is_functional_template__$4 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardPrimaryAction = normalizeComponent(
      { render: __vue_render__$3, staticRenderFns: __vue_staticRenderFns__$3 },
      __vue_inject_styles__$4,
      __vue_script__$4,
      __vue_scope_id__$4,
      __vue_is_functional_template__$4,
      __vue_module_identifier__$4,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$5 = {
    name: 'mdc-card-media',
    props: {
      src: String,
      square: Boolean
    },
    computed: {
      styles: function styles() {
        var styles = {
          backgroundImage: "url(".concat(this.src, ")")
        };
        return styles;
      },
      classes: function classes() {
        return this.square ? 'mdc-card__media--square' : 'mdc-card__media--16-9';
      }
    }
  };

  /* script */
  const __vue_script__$5 = script$5;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$5.__file = "/ddata/extra/vma/components/card/mdc-card-media.vue";

  /* template */
  var __vue_render__$4 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      {
        staticClass: "mdc-card-media mdc-card__media",
        class: _vm.classes,
        style: _vm.styles
      },
      [
        _vm.$slots.default
          ? _c(
              "div",
              { staticClass: "mdc-card__media-content" },
              [_vm._t("default")],
              2
            )
          : _vm._e()
      ]
    )
  };
  var __vue_staticRenderFns__$4 = [];
  __vue_render__$4._withStripped = true;

    /* style */
    const __vue_inject_styles__$5 = undefined;
    /* scoped */
    const __vue_scope_id__$5 = undefined;
    /* module identifier */
    const __vue_module_identifier__$5 = undefined;
    /* functional template */
    const __vue_is_functional_template__$5 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardMedia = normalizeComponent(
      { render: __vue_render__$4, staticRenderFns: __vue_staticRenderFns__$4 },
      __vue_inject_styles__$5,
      __vue_script__$5,
      __vue_scope_id__$5,
      __vue_is_functional_template__$5,
      __vue_module_identifier__$5,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$6 = {
    name: 'mdc-card-header',
    props: {
      title: String,
      subtitle: String,
      'large-title': {
        type: Boolean,
        default: true
      }
    }
  };

  /* script */
  const __vue_script__$6 = script$6;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$6.__file = "/ddata/extra/vma/components/card/mdc-card-header.vue";

  /* template */
  var __vue_render__$5 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      { staticClass: "mdc-card-header mdc-card__primary" },
      [
        _vm._t("default", [
          _vm.title
            ? _c(
                "h1",
                {
                  staticClass: "mdc-card__title",
                  class: { "mdc-card__title--large": _vm.largeTitle }
                },
                [_vm._v("\n      " + _vm._s(_vm.title) + "\n    ")]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.subtitle
            ? _c("h2", { staticClass: "mdc-card__subtitle" }, [
                _vm._v("\n      " + _vm._s(_vm.subtitle) + " \n    ")
              ])
            : _vm._e()
        ])
      ],
      2
    )
  };
  var __vue_staticRenderFns__$5 = [];
  __vue_render__$5._withStripped = true;

    /* style */
    const __vue_inject_styles__$6 = undefined;
    /* scoped */
    const __vue_scope_id__$6 = undefined;
    /* module identifier */
    const __vue_module_identifier__$6 = undefined;
    /* functional template */
    const __vue_is_functional_template__$6 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardHeader = normalizeComponent(
      { render: __vue_render__$5, staticRenderFns: __vue_staticRenderFns__$5 },
      __vue_inject_styles__$6,
      __vue_script__$6,
      __vue_scope_id__$6,
      __vue_is_functional_template__$6,
      __vue_module_identifier__$6,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var script$7 = {
    name: 'mdc-card-title',
    props: {
      large: Boolean
    }
  };

  /* script */
  const __vue_script__$7 = script$7;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$7.__file = "/ddata/extra/vma/components/card/mdc-card-title.vue";

  /* template */
  var __vue_render__$6 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "h1",
      {
        staticClass: "mdc-card-title mdc-card__title",
        class: { "mdc-card__title--large": _vm.large }
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$6 = [];
  __vue_render__$6._withStripped = true;

    /* style */
    const __vue_inject_styles__$7 = undefined;
    /* scoped */
    const __vue_scope_id__$7 = undefined;
    /* module identifier */
    const __vue_module_identifier__$7 = undefined;
    /* functional template */
    const __vue_is_functional_template__$7 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardTitle = normalizeComponent(
      { render: __vue_render__$6, staticRenderFns: __vue_staticRenderFns__$6 },
      __vue_inject_styles__$7,
      __vue_script__$7,
      __vue_scope_id__$7,
      __vue_is_functional_template__$7,
      __vue_module_identifier__$7,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var script$8 = {
    name: 'mdc-card-subtitle'
  };

  /* script */
  const __vue_script__$8 = script$8;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$8.__file = "/ddata/extra/vma/components/card/mdc-card-subtitle.vue";

  /* template */
  var __vue_render__$7 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "h2",
      { staticClass: "mdc-card-subtitle mdc-card__subtitle" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$7 = [];
  __vue_render__$7._withStripped = true;

    /* style */
    const __vue_inject_styles__$8 = undefined;
    /* scoped */
    const __vue_scope_id__$8 = undefined;
    /* module identifier */
    const __vue_module_identifier__$8 = undefined;
    /* functional template */
    const __vue_is_functional_template__$8 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardSubtitle = normalizeComponent(
      { render: __vue_render__$7, staticRenderFns: __vue_staticRenderFns__$7 },
      __vue_inject_styles__$8,
      __vue_script__$8,
      __vue_scope_id__$8,
      __vue_is_functional_template__$8,
      __vue_module_identifier__$8,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$9 = {
    name: 'mdc-card-text'
  };

  /* script */
  const __vue_script__$9 = script$9;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$9.__file = "/ddata/extra/vma/components/card/mdc-card-text.vue";

  /* template */
  var __vue_render__$8 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      { staticClass: "mdc-card-text mdc-card__supporting-text" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$8 = [];
  __vue_render__$8._withStripped = true;

    /* style */
    const __vue_inject_styles__$9 = undefined;
    /* scoped */
    const __vue_scope_id__$9 = undefined;
    /* module identifier */
    const __vue_module_identifier__$9 = undefined;
    /* functional template */
    const __vue_is_functional_template__$9 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardText = normalizeComponent(
      { render: __vue_render__$8, staticRenderFns: __vue_staticRenderFns__$8 },
      __vue_inject_styles__$9,
      __vue_script__$9,
      __vue_scope_id__$9,
      __vue_is_functional_template__$9,
      __vue_module_identifier__$9,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var script$a = {
    name: 'mdc-card-actions',
    props: {
      fullBleed: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-card__actions--full-bleed': this.fullBleed
        };
      }
    }
  };

  /* script */
  const __vue_script__$a = script$a;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$a.__file = "/ddata/extra/vma/components/card/mdc-card-actions.vue";

  /* template */
  var __vue_render__$9 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      { staticClass: "mdc-card-actions mdc-card__actions", class: _vm.classes },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$9 = [];
  __vue_render__$9._withStripped = true;

    /* style */
    const __vue_inject_styles__$a = undefined;
    /* scoped */
    const __vue_scope_id__$a = undefined;
    /* module identifier */
    const __vue_module_identifier__$a = undefined;
    /* functional template */
    const __vue_is_functional_template__$a = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardActions = normalizeComponent(
      { render: __vue_render__$9, staticRenderFns: __vue_staticRenderFns__$9 },
      __vue_inject_styles__$a,
      __vue_script__$a,
      __vue_scope_id__$a,
      __vue_is_functional_template__$a,
      __vue_module_identifier__$a,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$b = {
    name: 'mdc-card-action-buttons'
  };

  /* script */
  const __vue_script__$b = script$b;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$b.__file = "/ddata/extra/vma/components/card/mdc-card-action-buttons.vue";

  /* template */
  var __vue_render__$a = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-card-action-buttons mdc-card__action-buttons" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$a = [];
  __vue_render__$a._withStripped = true;

    /* style */
    const __vue_inject_styles__$b = undefined;
    /* scoped */
    const __vue_scope_id__$b = undefined;
    /* module identifier */
    const __vue_module_identifier__$b = undefined;
    /* functional template */
    const __vue_is_functional_template__$b = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardActionButtons = normalizeComponent(
      { render: __vue_render__$a, staticRenderFns: __vue_staticRenderFns__$a },
      __vue_inject_styles__$b,
      __vue_script__$b,
      __vue_scope_id__$b,
      __vue_is_functional_template__$b,
      __vue_module_identifier__$b,
      undefined,
      undefined
    );

  var script$c = {
    name: 'mdc-card-action-button',
    extends: mdcButtonBase,
    data: function data() {
      return {
        classes: {
          'mdc-button': true,
          'mdc-card__action': true,
          'mdc-card-action-button': true
        }
      };
    }
  };

  /* script */
  const __vue_script__$c = script$c;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$c.__file = "/ddata/extra/vma/components/card/mdc-card-action-button.vue";

  /* template */

    /* style */
    const __vue_inject_styles__$c = undefined;
    /* scoped */
    const __vue_scope_id__$c = undefined;
    /* module identifier */
    const __vue_module_identifier__$c = undefined;
    /* functional template */
    const __vue_is_functional_template__$c = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardActionButton = normalizeComponent(
      {},
      __vue_inject_styles__$c,
      __vue_script__$c,
      __vue_scope_id__$c,
      __vue_is_functional_template__$c,
      __vue_module_identifier__$c,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$d = {
    name: 'mdc-card-action-icons'
  };

  /* script */
  const __vue_script__$d = script$d;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$d.__file = "/ddata/extra/vma/components/card/mdc-card-action-icons.vue";

  /* template */
  var __vue_render__$b = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-card-action-icons mdc-card__action-icons" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$b = [];
  __vue_render__$b._withStripped = true;

    /* style */
    const __vue_inject_styles__$d = undefined;
    /* scoped */
    const __vue_scope_id__$d = undefined;
    /* module identifier */
    const __vue_module_identifier__$d = undefined;
    /* functional template */
    const __vue_is_functional_template__$d = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardActionIcons = normalizeComponent(
      { render: __vue_render__$b, staticRenderFns: __vue_staticRenderFns__$b },
      __vue_inject_styles__$d,
      __vue_script__$d,
      __vue_scope_id__$d,
      __vue_is_functional_template__$d,
      __vue_module_identifier__$d,
      undefined,
      undefined
    );

  //
  var script$e = {
    name: 'mdc-card-action-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    },
    data: function data() {
      return {
        classes: {
          'mdc-card-action-icon': true,
          'material-icons': !!this.icon,
          'mdc-card__action': true,
          'mdc-card__action--icon': true,
          'mdc-icon-toggle': true
        },
        styles: {}
      };
    },
    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', !!this.icon);
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  /* script */
  const __vue_script__$e = script$e;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$e.__file = "/ddata/extra/vma/components/card/mdc-card-action-icon.vue";

  /* template */
  var __vue_render__$c = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      _vm._g({ class: _vm.classes, style: _vm.styles }, _vm.listeners),
      [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
      2
    )
  };
  var __vue_staticRenderFns__$c = [];
  __vue_render__$c._withStripped = true;

    /* style */
    const __vue_inject_styles__$e = undefined;
    /* scoped */
    const __vue_scope_id__$e = undefined;
    /* module identifier */
    const __vue_module_identifier__$e = undefined;
    /* functional template */
    const __vue_is_functional_template__$e = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCardActionIcon = normalizeComponent(
      { render: __vue_render__$c, staticRenderFns: __vue_staticRenderFns__$c },
      __vue_inject_styles__$e,
      __vue_script__$e,
      __vue_scope_id__$e,
      __vue_is_functional_template__$e,
      __vue_module_identifier__$e,
      undefined,
      undefined
    );

  var VueMDCCard = BasePlugin({
    mdcCard: mdcCard,
    mdcCardPrimaryAction: mdcCardPrimaryAction,
    mdcCardMedia: mdcCardMedia,
    mdcCardHeader: mdcCardHeader,
    mdcCardTitle: mdcCardTitle,
    mdcCardSubtitle: mdcCardSubtitle,
    mdcCardText: mdcCardText,
    mdcCardActions: mdcCardActions,
    mdcCardActionButtons: mdcCardActionButtons,
    mdcCardActionButton: mdcCardActionButton,
    mdcCardActionIcons: mdcCardActionIcons,
    mdcCardActionIcon: mdcCardActionIcon
  });

  /**
   * @record
   */

  var MDCSelectionControl =
  /*#__PURE__*/
  function () {
    function MDCSelectionControl() {
      _classCallCheck(this, MDCSelectionControl);
    }

    _createClass(MDCSelectionControl, [{
      key: "ripple",

      /** @return {?MDCRipple} */
      get: function get() {}
    }]);

    return MDCSelectionControl;
  }();

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Checkbox. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCCheckboxAdapter =
  /*#__PURE__*/
  function () {
    function MDCCheckboxAdapter() {
      _classCallCheck(this, MDCCheckboxAdapter);
    }

    _createClass(MDCCheckboxAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Sets an attribute with a given value on the input element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setNativeControlAttr",
      value: function setNativeControlAttr(attr, value) {}
      /**
       * Removes an attribute from the input element.
       * @param {string} attr
       */

    }, {
      key: "removeNativeControlAttr",
      value: function removeNativeControlAttr(attr) {}
    }, {
      key: "forceLayout",
      value: function forceLayout() {}
      /** @return {boolean} */

    }, {
      key: "isAttachedToDOM",
      value: function isAttachedToDOM() {}
      /** @return {boolean} */

    }, {
      key: "isIndeterminate",
      value: function isIndeterminate() {}
      /** @return {boolean} */

    }, {
      key: "isChecked",
      value: function isChecked() {}
      /** @return {boolean} */

    }, {
      key: "hasNativeControl",
      value: function hasNativeControl() {}
      /** @param {boolean} disabled */

    }, {
      key: "setNativeControlDisabled",
      value: function setNativeControlDisabled(disabled) {}
    }]);

    return MDCCheckboxAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @const {string} */
  var ROOT = 'mdc-checkbox';
  /** @enum {string} */

  var cssClasses$2 = {
    UPGRADED: 'mdc-checkbox--upgraded',
    CHECKED: 'mdc-checkbox--checked',
    INDETERMINATE: 'mdc-checkbox--indeterminate',
    DISABLED: 'mdc-checkbox--disabled',
    ANIM_UNCHECKED_CHECKED: 'mdc-checkbox--anim-unchecked-checked',
    ANIM_UNCHECKED_INDETERMINATE: 'mdc-checkbox--anim-unchecked-indeterminate',
    ANIM_CHECKED_UNCHECKED: 'mdc-checkbox--anim-checked-unchecked',
    ANIM_CHECKED_INDETERMINATE: 'mdc-checkbox--anim-checked-indeterminate',
    ANIM_INDETERMINATE_CHECKED: 'mdc-checkbox--anim-indeterminate-checked',
    ANIM_INDETERMINATE_UNCHECKED: 'mdc-checkbox--anim-indeterminate-unchecked'
  };
  /** @enum {string} */

  var strings$1 = {
    NATIVE_CONTROL_SELECTOR: ".".concat(ROOT, "__native-control"),
    TRANSITION_STATE_INIT: 'init',
    TRANSITION_STATE_CHECKED: 'checked',
    TRANSITION_STATE_UNCHECKED: 'unchecked',
    TRANSITION_STATE_INDETERMINATE: 'indeterminate',
    ARIA_CHECKED_ATTR: 'aria-checked',
    ARIA_CHECKED_INDETERMINATE_VALUE: 'mixed'
  };
  /** @enum {number} */

  var numbers$1 = {
    ANIM_END_LATCH_MS: 250
  };

  /**
   * @extends {MDCFoundation<!MDCCheckboxAdapter>}
   */

  var MDCCheckboxFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCCheckboxFoundation, _MDCFoundation);

    _createClass(MDCCheckboxFoundation, null, [{
      key: "cssClasses",

      /** @return enum {cssClasses} */
      get: function get() {
        return cssClasses$2;
      }
      /** @return enum {strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$1;
      }
      /** @return enum {numbers} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$1;
      }
      /** @return {!MDCCheckboxAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCCheckboxAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            setNativeControlAttr: function setNativeControlAttr()
            /* attr: string, value: string */
            {},
            removeNativeControlAttr: function removeNativeControlAttr()
            /* attr: string */
            {},
            forceLayout: function forceLayout() {},
            isAttachedToDOM: function isAttachedToDOM()
            /* boolean */
            {},
            isIndeterminate: function isIndeterminate()
            /* boolean */
            {},
            isChecked: function isChecked()
            /* boolean */
            {},
            hasNativeControl: function hasNativeControl()
            /* boolean */
            {},
            setNativeControlDisabled: function setNativeControlDisabled()
            /* disabled: boolean */
            {}
          }
        );
      }
    }]);

    function MDCCheckboxFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCCheckboxFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCCheckboxFoundation).call(this, _extends(MDCCheckboxFoundation.defaultAdapter, adapter)));
      /** @private {string} */

      _this.currentCheckState_ = strings$1.TRANSITION_STATE_INIT;
      /** @private {string} */

      _this.currentAnimationClass_ = '';
      /** @private {number} */

      _this.animEndLatchTimer_ = 0;
      /** @private {boolean} */

      _this.enableAnimationEndHandler_ = false;
      return _this;
    }
    /** @override */


    _createClass(MDCCheckboxFoundation, [{
      key: "init",
      value: function init() {
        this.currentCheckState_ = this.determineCheckState_();
        this.updateAriaChecked_();
        this.adapter_.addClass(cssClasses$2.UPGRADED);
      }
      /** @override */

    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this.animEndLatchTimer_);
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        this.adapter_.setNativeControlDisabled(disabled);

        if (disabled) {
          this.adapter_.addClass(cssClasses$2.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$2.DISABLED);
        }
      }
      /**
       * Handles the animationend event for the checkbox
       */

    }, {
      key: "handleAnimationEnd",
      value: function handleAnimationEnd() {
        var _this2 = this;

        if (!this.enableAnimationEndHandler_) return;
        clearTimeout(this.animEndLatchTimer_);
        this.animEndLatchTimer_ = setTimeout(function () {
          _this2.adapter_.removeClass(_this2.currentAnimationClass_);

          _this2.enableAnimationEndHandler_ = false;
        }, numbers$1.ANIM_END_LATCH_MS);
      }
      /**
       * Handles the change event for the checkbox
       */

    }, {
      key: "handleChange",
      value: function handleChange() {
        this.transitionCheckState_();
      }
      /** @private */

    }, {
      key: "transitionCheckState_",
      value: function transitionCheckState_() {
        if (!this.adapter_.hasNativeControl()) {
          return;
        }

        var oldState = this.currentCheckState_;
        var newState = this.determineCheckState_();

        if (oldState === newState) {
          return;
        }

        this.updateAriaChecked_(); // Check to ensure that there isn't a previously existing animation class, in case for example
        // the user interacted with the checkbox before the animation was finished.

        if (this.currentAnimationClass_.length > 0) {
          clearTimeout(this.animEndLatchTimer_);
          this.adapter_.forceLayout();
          this.adapter_.removeClass(this.currentAnimationClass_);
        }

        this.currentAnimationClass_ = this.getTransitionAnimationClass_(oldState, newState);
        this.currentCheckState_ = newState; // Check for parentNode so that animations are only run when the element is attached
        // to the DOM.

        if (this.adapter_.isAttachedToDOM() && this.currentAnimationClass_.length > 0) {
          this.adapter_.addClass(this.currentAnimationClass_);
          this.enableAnimationEndHandler_ = true;
        }
      }
      /**
       * @return {string}
       * @private
       */

    }, {
      key: "determineCheckState_",
      value: function determineCheckState_() {
        var TRANSITION_STATE_INDETERMINATE = strings$1.TRANSITION_STATE_INDETERMINATE,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;

        if (this.adapter_.isIndeterminate()) {
          return TRANSITION_STATE_INDETERMINATE;
        }

        return this.adapter_.isChecked() ? TRANSITION_STATE_CHECKED : TRANSITION_STATE_UNCHECKED;
      }
      /**
       * @param {string} oldState
       * @param {string} newState
       * @return {string}
       */

    }, {
      key: "getTransitionAnimationClass_",
      value: function getTransitionAnimationClass_(oldState, newState) {
        var TRANSITION_STATE_INIT = strings$1.TRANSITION_STATE_INIT,
            TRANSITION_STATE_CHECKED = strings$1.TRANSITION_STATE_CHECKED,
            TRANSITION_STATE_UNCHECKED = strings$1.TRANSITION_STATE_UNCHECKED;
        var _MDCCheckboxFoundatio = MDCCheckboxFoundation.cssClasses,
            ANIM_UNCHECKED_CHECKED = _MDCCheckboxFoundatio.ANIM_UNCHECKED_CHECKED,
            ANIM_UNCHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_UNCHECKED_INDETERMINATE,
            ANIM_CHECKED_UNCHECKED = _MDCCheckboxFoundatio.ANIM_CHECKED_UNCHECKED,
            ANIM_CHECKED_INDETERMINATE = _MDCCheckboxFoundatio.ANIM_CHECKED_INDETERMINATE,
            ANIM_INDETERMINATE_CHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_CHECKED,
            ANIM_INDETERMINATE_UNCHECKED = _MDCCheckboxFoundatio.ANIM_INDETERMINATE_UNCHECKED;

        switch (oldState) {
          case TRANSITION_STATE_INIT:
            if (newState === TRANSITION_STATE_UNCHECKED) {
              return '';
            }

          // fallthrough

          case TRANSITION_STATE_UNCHECKED:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_UNCHECKED_CHECKED : ANIM_UNCHECKED_INDETERMINATE;

          case TRANSITION_STATE_CHECKED:
            return newState === TRANSITION_STATE_UNCHECKED ? ANIM_CHECKED_UNCHECKED : ANIM_CHECKED_INDETERMINATE;
          // TRANSITION_STATE_INDETERMINATE

          default:
            return newState === TRANSITION_STATE_CHECKED ? ANIM_INDETERMINATE_CHECKED : ANIM_INDETERMINATE_UNCHECKED;
        }
      }
    }, {
      key: "updateAriaChecked_",
      value: function updateAriaChecked_() {
        // Ensure aria-checked is set to mixed if checkbox is in indeterminate state.
        if (this.adapter_.isIndeterminate()) {
          this.adapter_.setNativeControlAttr(strings$1.ARIA_CHECKED_ATTR, strings$1.ARIA_CHECKED_INDETERMINATE_VALUE);
        } else {
          // The on/off state does not need to keep track of aria-checked, since
          // the screenreader uses the checked property on the checkbox element.
          this.adapter_.removeNativeControlAttr(strings$1.ARIA_CHECKED_ATTR);
        }
      }
    }]);

    return MDCCheckboxFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Form Field. Provides an interface for managing
   * - event handlers
   * - ripple activation
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCFormFieldAdapter =
  /*#__PURE__*/
  function () {
    function MDCFormFieldAdapter() {
      _classCallCheck(this, MDCFormFieldAdapter);
    }

    _createClass(MDCFormFieldAdapter, [{
      key: "registerInteractionHandler",

      /**
       * @param {string} type
       * @param {!EventListener} handler
       */
      value: function registerInteractionHandler(type, handler) {}
      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
    }, {
      key: "activateInputRipple",
      value: function activateInputRipple() {}
    }, {
      key: "deactivateInputRipple",
      value: function deactivateInputRipple() {}
    }]);

    return MDCFormFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$3 = {
    ROOT: 'mdc-form-field'
  };
  /** @enum {string} */

  var strings$2 = {
    LABEL_SELECTOR: '.mdc-form-field > label'
  };

  /**
   * @extends {MDCFoundation<!MDCFormFieldAdapter>}
   */

  var MDCFormFieldFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCFormFieldFoundation, _MDCFoundation);

    _createClass(MDCFormFieldFoundation, null, [{
      key: "cssClasses",

      /** @return enum {cssClasses} */
      get: function get() {
        return cssClasses$3;
      }
      /** @return enum {strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$2;
      }
      /** @return {!MDCFormFieldAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          registerInteractionHandler: function registerInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          activateInputRipple: function activateInputRipple() {},
          deactivateInputRipple: function deactivateInputRipple() {}
        };
      }
    }]);

    function MDCFormFieldFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCFormFieldFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCFormFieldFoundation).call(this, _extends(MDCFormFieldFoundation.defaultAdapter, adapter)));
      /** @private {!EventListener} */

      _this.clickHandler_ =
      /** @type {!EventListener} */
      function () {
        return _this.handleClick_();
      };

      return _this;
    }

    _createClass(MDCFormFieldFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
      }
      /** @private */

    }, {
      key: "handleClick_",
      value: function handleClick_() {
        var _this2 = this;

        this.adapter_.activateInputRipple();
        requestAnimationFrame(function () {
          return _this2.adapter_.deactivateInputRipple();
        });
      }
    }]);

    return MDCFormFieldFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /** @const {Object<string, !VendorPropertyMapType>} */

  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };
  /** @const {Object<string, !VendorPropertyMapType>} */

  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };
  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */

  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }
  /**
   * @param {string} eventType
   * @return {boolean}
   */


  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }
  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */


  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }
  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map =
    /** @type {!Object<string, !VendorPropertyMapType>} */
    eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  } // Public functions to access getAnimationName() for JavaScript events or CSS
  // property names.


  var transformStyleProperties = ['transform', 'WebkitTransform', 'MozTransform', 'OTransform', 'MSTransform'];
  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */

  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }
  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */


  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  //
  var CB_PROTO_PROPS = ['checked', 'indeterminate'];
  var script$f = {
    name: 'mdc-checkbox',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: [Boolean, Array],
      indeterminate: Boolean,
      disabled: Boolean,
      label: String,
      'align-end': Boolean,
      value: {
        type: [String, Number],
        default: function _default() {
          return 'on';
        }
      },
      name: String
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },
    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      },
      formFieldClasses: function formFieldClasses() {
        return {
          'mdc-form-field': this.hasLabel,
          'mdc-form-field--align-end': this.hasLabel && this.alignEnd
        };
      }
    },
    watch: {
      checked: 'setChecked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      },
      indeterminate: function indeterminate(value) {
        this.setIndeterminate(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCCheckboxFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlAttr: function setNativeControlAttr(attr, value) {
          _this.$refs.control.setAttribute(attr, value);
        },
        removeNativeControlAttr: function removeNativeControlAttr(attr) {
          _this.$refs.control.removeAttribute(attr);
        },
        // getNativeControl: () => this.$refs.control,
        isIndeterminate: function isIndeterminate() {
          return _this.$refs.control.indeterminate;
        },
        isChecked: function isChecked() {
          return _this.checked;
        },
        hasNativeControl: function hasNativeControl() {
          return !!_this.$refs.control;
        },
        setNativeControlDisabled: function setNativeControlDisabled(disabled) {
          return _this.$refs.control.disabled = disabled;
        },
        forceLayout: function forceLayout() {
          return _this.$refs.root.offsetWidth;
        },
        isAttachedToDOM: function isAttachedToDOM() {
          return Boolean(_this.$el.parentNode);
        }
      });

      this.handleAnimationEnd_ = function () {
        return _this.foundation.handleAnimationEnd();
      };

      this.$el.addEventListener(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
      this.installPropertyChangeHooks_();
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return RippleBase.isSurfaceActive(_this.$refs.control);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });
      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });
      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.setIndeterminate(this.indeterminate);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener(getCorrectEventName(window, 'animationend'), this.handleAnimationEnd_);
      this.formField.destroy();
      this.ripple.destroy();
      this.uninstallPropertyChangeHooks_();
      this.foundation.destroy();
    },
    methods: {
      setChecked: function setChecked(checked) {
        this.$refs.control.checked = Array.isArray(checked) ? checked.indexOf(this.value) > -1 : checked;
      },
      setIndeterminate: function setIndeterminate(indeterminate) {
        this.$refs.control.indeterminate = indeterminate;
      },
      onChange: function onChange() {
        this.$emit('update:indeterminate', this.indeterminate);
        var isChecked = this.$refs.control.checked;

        if (Array.isArray(this.checked)) {
          var idx = this.checked.indexOf(this.value);

          if (isChecked) {
            idx < 0 && this.$emit('change', this.checked.concat(this.value));
          } else {
            idx > -1 && this.$emit('change', this.checked.slice(0, idx).concat(this.checked.slice(idx + 1)));
          }
        } else {
          this.$emit('change', isChecked);
        }
      },
      installPropertyChangeHooks_: function installPropertyChangeHooks_() {
        var _this2 = this;

        var nativeCb = this.$refs.control;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc = Object.getOwnPropertyDescriptor(cbProto, controlState); // We have to check for this descriptor, since some browsers (Safari) don't support its return.
          // See: https://bugs.webkit.org/show_bug.cgi?id=49739

          if (validDescriptor(desc)) {
            var nativeCbDesc =
            /** @type {!ObjectPropertyDescriptor} */
            {
              get: desc.get,
              set: function set(state) {
                desc.set.call(nativeCb, state);

                _this2.foundation.handleChange();
              },
              configurable: desc.configurable,
              enumerable: desc.enumerable
            };
            Object.defineProperty(nativeCb, controlState, nativeCbDesc);
          }
        });
      },
      uninstallPropertyChangeHooks_: function uninstallPropertyChangeHooks_() {
        var nativeCb = this.$refs.control;
        var cbProto = Object.getPrototypeOf(nativeCb);
        CB_PROTO_PROPS.forEach(function (controlState) {
          var desc =
          /** @type {!ObjectPropertyDescriptor} */
          Object.getOwnPropertyDescriptor(cbProto, controlState);

          if (validDescriptor(desc)) {
            Object.defineProperty(nativeCb, controlState, desc);
          }
        });
      }
    } // ===
    // Private functions
    // ===

  };

  function validDescriptor(inputPropDesc) {
    return !!inputPropDesc && typeof inputPropDesc.set === 'function';
  }

  /* script */
  const __vue_script__$f = script$f;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$f.__file = "/ddata/extra/vma/components/checkbox/mdc-checkbox.vue";

  /* template */
  var __vue_render__$d = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-checkbox-wrapper", class: _vm.formFieldClasses },
      [
        _c(
          "div",
          {
            ref: "root",
            staticClass: "mdc-checkbox",
            class: _vm.classes,
            style: _vm.styles
          },
          [
            _c("input", {
              ref: "control",
              staticClass: "mdc-checkbox__native-control",
              attrs: { id: _vm.vma_uid_, name: _vm.name, type: "checkbox" },
              domProps: { value: _vm.value },
              on: { change: _vm.onChange }
            }),
            _vm._v(" "),
            _c("div", { staticClass: "mdc-checkbox__background" }, [
              _c(
                "svg",
                {
                  staticClass: "mdc-checkbox__checkmark",
                  attrs: { viewBox: "0 0 24 24" }
                },
                [
                  _c("path", {
                    staticClass: "mdc-checkbox__checkmark-path",
                    attrs: {
                      fill: "none",
                      stroke: "white",
                      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
                    }
                  })
                ]
              ),
              _vm._v(" "),
              _c("div", { staticClass: "mdc-checkbox__mixedmark" })
            ])
          ]
        ),
        _vm._v(" "),
        _c(
          "label",
          { ref: "label", attrs: { for: _vm.vma_uid_ } },
          [_vm._t("default", [_vm._v(_vm._s(_vm.label))])],
          2
        )
      ]
    )
  };
  var __vue_staticRenderFns__$d = [];
  __vue_render__$d._withStripped = true;

    /* style */
    const __vue_inject_styles__$f = undefined;
    /* scoped */
    const __vue_scope_id__$f = undefined;
    /* module identifier */
    const __vue_module_identifier__$f = undefined;
    /* functional template */
    const __vue_is_functional_template__$f = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcCheckbox = normalizeComponent(
      { render: __vue_render__$d, staticRenderFns: __vue_staticRenderFns__$d },
      __vue_inject_styles__$f,
      __vue_script__$f,
      __vue_scope_id__$f,
      __vue_is_functional_template__$f,
      __vue_module_identifier__$f,
      undefined,
      undefined
    );

  var VueMDCCheckbox = BasePlugin({
    mdcCheckbox: mdcCheckbox
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipAdapter =
  /*#__PURE__*/
  function () {
    function MDCChipAdapter() {
      _classCallCheck(this, MDCChipAdapter);
    }

    _createClass(MDCChipAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Adds a class to the leading icon element.
       * @param {string} className
       */

    }, {
      key: "addClassToLeadingIcon",
      value: function addClassToLeadingIcon(className) {}
      /**
       * Removes a class from the leading icon element.
       * @param {string} className
       */

    }, {
      key: "removeClassFromLeadingIcon",
      value: function removeClassFromLeadingIcon(className) {}
      /**
       * Returns true if target has className, false otherwise.
       * @param {!EventTarget} target
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "eventTargetHasClass",
      value: function eventTargetHasClass(target, className) {}
      /**
       * Emits a custom "MDCChip:interaction" event denoting the chip has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyInteraction",
      value: function notifyInteraction() {}
      /**
       * Emits a custom "MDCChip:selection" event denoting the chip has been selected or deselected.
       * @param {boolean} selected
       */

    }, {
      key: "notifySelection",
      value: function notifySelection(selected) {}
      /**
       * Emits a custom "MDCChip:trailingIconInteraction" event denoting the trailing icon has been
       * interacted with (typically on click or keydown).
       */

    }, {
      key: "notifyTrailingIconInteraction",
      value: function notifyTrailingIconInteraction() {}
      /**
       * Emits a custom event "MDCChip:removal" denoting the chip will be removed.
       */

    }, {
      key: "notifyRemoval",
      value: function notifyRemoval() {}
      /**
       * Returns the computed property value of the given style property on the root element.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getComputedStyleValue",
      value: function getComputedStyleValue(propertyName) {}
      /**
       * Sets the property value of the given style property on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyleProperty",
      value: function setStyleProperty(propertyName, value) {}
    }]);

    return MDCChipAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$3 = {
    ENTRY_ANIMATION_NAME: 'mdc-chip-entry',
    INTERACTION_EVENT: 'MDCChip:interaction',
    SELECTION_EVENT: 'MDCChip:selection',
    TRAILING_ICON_INTERACTION_EVENT: 'MDCChip:trailingIconInteraction',
    REMOVAL_EVENT: 'MDCChip:removal',
    CHECKMARK_SELECTOR: '.mdc-chip__checkmark',
    LEADING_ICON_SELECTOR: '.mdc-chip__icon--leading',
    TRAILING_ICON_SELECTOR: '.mdc-chip__icon--trailing'
  };
  /** @enum {string} */

  var cssClasses$4 = {
    CHECKMARK: 'mdc-chip__checkmark',
    CHIP_EXIT: 'mdc-chip--exit',
    HIDDEN_LEADING_ICON: 'mdc-chip__icon--leading-hidden',
    LEADING_ICON: 'mdc-chip__icon--leading',
    TRAILING_ICON: 'mdc-chip__icon--trailing',
    SELECTED: 'mdc-chip--selected'
  };

  /**
   * @extends {MDCFoundation<!MDCChipAdapter>}
   * @final
   */

  var MDCChipFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCChipFoundation, _MDCFoundation);

    _createClass(MDCChipFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$3;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$4;
      }
      /**
       * {@see MDCChipAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCChipAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            addClassToLeadingIcon: function addClassToLeadingIcon() {},
            removeClassFromLeadingIcon: function removeClassFromLeadingIcon() {},
            eventTargetHasClass: function eventTargetHasClass() {},
            notifyInteraction: function notifyInteraction() {},
            notifySelection: function notifySelection() {},
            notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {},
            notifyRemoval: function notifyRemoval() {},
            getComputedStyleValue: function getComputedStyleValue() {},
            setStyleProperty: function setStyleProperty() {}
          }
        );
      }
      /**
       * @param {!MDCChipAdapter} adapter
       */

    }]);

    function MDCChipFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCChipFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCChipFoundation).call(this, _extends(MDCChipFoundation.defaultAdapter, adapter)));
      /**
       * Whether a trailing icon click should immediately trigger exit/removal of the chip.
       * @private {boolean}
       * */

      _this.shouldRemoveOnTrailingIconClick_ = true;
      return _this;
    }
    /**
     * @return {boolean}
     */


    _createClass(MDCChipFoundation, [{
      key: "isSelected",
      value: function isSelected() {
        return this.adapter_.hasClass(cssClasses$4.SELECTED);
      }
      /**
       * @param {boolean} selected
       */

    }, {
      key: "setSelected",
      value: function setSelected(selected) {
        if (selected) {
          this.adapter_.addClass(cssClasses$4.SELECTED);
        } else {
          this.adapter_.removeClass(cssClasses$4.SELECTED);
        }

        this.adapter_.notifySelection(selected);
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "getShouldRemoveOnTrailingIconClick",
      value: function getShouldRemoveOnTrailingIconClick() {
        return this.shouldRemoveOnTrailingIconClick_;
      }
      /**
       * @param {boolean} shouldRemove
       */

    }, {
      key: "setShouldRemoveOnTrailingIconClick",
      value: function setShouldRemoveOnTrailingIconClick(shouldRemove) {
        this.shouldRemoveOnTrailingIconClick_ = shouldRemove;
      }
      /**
       * Begins the exit animation which leads to removal of the chip.
       */

    }, {
      key: "beginExit",
      value: function beginExit() {
        this.adapter_.addClass(cssClasses$4.CHIP_EXIT);
      }
      /**
       * Handles an interaction event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyInteraction();
        }
      }
      /**
       * Handles a transition end event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        var _this2 = this;

        // Handle transition end event on the chip when it is about to be removed.
        if (this.adapter_.eventTargetHasClass(
        /** @type {!EventTarget} */
        evt.target, cssClasses$4.CHIP_EXIT)) {
          if (evt.propertyName === 'width') {
            this.adapter_.notifyRemoval();
          } else if (evt.propertyName === 'opacity') {
            // See: https://css-tricks.com/using-css-transitions-auto-dimensions/#article-header-id-5
            var chipWidth = this.adapter_.getComputedStyleValue('width'); // On the next frame (once we get the computed width), explicitly set the chip's width
            // to its current pixel width, so we aren't transitioning out of 'auto'.

            requestAnimationFrame(function () {
              _this2.adapter_.setStyleProperty('width', chipWidth); // To mitigate jitter, start transitioning padding and margin before width.


              _this2.adapter_.setStyleProperty('padding', '0');

              _this2.adapter_.setStyleProperty('margin', '0'); // On the next frame (once width is explicitly set), transition width to 0.


              requestAnimationFrame(function () {
                _this2.adapter_.setStyleProperty('width', '0');
              });
            });
          }

          return;
        } // Handle a transition end event on the leading icon or checkmark, since the transition end event bubbles.


        if (evt.propertyName !== 'opacity') {
          return;
        }

        if (this.adapter_.eventTargetHasClass(
        /** @type {!EventTarget} */
        evt.target, cssClasses$4.LEADING_ICON) && this.adapter_.hasClass(cssClasses$4.SELECTED)) {
          this.adapter_.addClassToLeadingIcon(cssClasses$4.HIDDEN_LEADING_ICON);
        } else if (this.adapter_.eventTargetHasClass(
        /** @type {!EventTarget} */
        evt.target, cssClasses$4.CHECKMARK) && !this.adapter_.hasClass(cssClasses$4.SELECTED)) {
          this.adapter_.removeClassFromLeadingIcon(cssClasses$4.HIDDEN_LEADING_ICON);
        }
      }
      /**
       * Handles an interaction event on the trailing icon element. This is used to
       * prevent the ripple from activating on interaction with the trailing icon.
       * @param {!Event} evt
       */

    }, {
      key: "handleTrailingIconInteraction",
      value: function handleTrailingIconInteraction(evt) {
        evt.stopPropagation();

        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyTrailingIconInteraction();

          if (this.shouldRemoveOnTrailingIconClick_) {
            this.beginExit();
          }
        }
      }
    }]);

    return MDCChipFoundation;
  }(MDCFoundation);

  var script$g = {
    name: 'mdc-chip',
    mixins: [CustomLinkMixin],
    props: {
      leadingIcon: [String],
      trailingIcon: [String],
      leadingIconClasses: [Object],
      trailingIconClasses: [Object]
    },
    inject: ['mdcChipSet'],
    data: function data() {
      return {
        classes: {
          'mdc-chip': true
        },
        styles: {},
        id: ''
      };
    },
    computed: {
      selected: {
        get: function get() {
          return this.foundation.isSelected();
        },
        set: function set(nv) {
          this.foundation.setSelected(nv);
        }
      },
      isFilter: function isFilter() {
        return this.mdcChipSet && this.mdcChipSet.filter;
      },
      haveleadingIcon: function haveleadingIcon() {
        return !!this.leadingIcon || this.leadingIconClasses;
      },
      havetrailingIcon: function havetrailingIcon() {
        return !!this.trailingIcon || this.trailingIconClasses;
      },
      leadingClasses: function leadingClasses() {
        return _extends({}, {
          'material-icons': !!this.leadingIcon
        }, this.leadingIconClasses);
      },
      trailingClasses: function trailingClasses() {
        return _extends({}, {
          'material-icons': !!this.trailingIcon
        }, this.trailingIconClasses);
      }
    },
    created: function created() {
      this.id = this.mdcChipSet.nextId();
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClassToLeadingIcon: function addClassToLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.add(className);
          }
        },
        removeClassFromLeadingIcon: function removeClassFromLeadingIcon(className) {
          if (_this.haveleadingIcon) {
            _this.$refs.leadingIcon.classList.remove(className);
          }
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        notifyInteraction: function notifyInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.INTERACTION_EVENT, {
            chipId: _this.id
          }, true);
          _this.mdcChipSet && _this.mdcChipSet.handleInteraction;
        },
        notifySelection: function notifySelection(selected) {
          return emitCustomEvent(_this.$el, MDCChipFoundation.strings.SELECTION_EVENT, {
            chipId: _this.id,
            selected: selected
          }, true
          /* shouldBubble */
          );
        },
        notifyTrailingIconInteraction: function notifyTrailingIconInteraction() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.TRAILING_ICON_INTERACTION_EVENT, {
            chipId: _this.id
          }, true);
        },
        notifyRemoval: function notifyRemoval() {
          emitCustomEvent(_this.$el, MDCChipFoundation.strings.REMOVAL_EVENT, {
            chipId: _this.id,
            root: _this.$el
          }, true);
        },
        getComputedStyleValue: function getComputedStyleValue(propertyName) {
          return window.getComputedStyle(_this.$el).getPropertyValue(propertyName);
        },
        setStyleProperty: function setStyleProperty(property, value) {
          return _this.$set(_this.styles, property, value);
        }
      });
      this.foundation.init();
      this.mdcChipSet.chips.push(this);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    },
    methods: {
      handleInteraction: function handleInteraction(evt) {
        this.foundation.handleInteraction(evt);
      },
      handleTransitionEnd: function handleTransitionEnd(evt) {
        this.foundation.handleTransitionEnd(evt);
      },
      handleTrailingIconInteraction: function handleTrailingIconInteraction(evt) {
        this.foundation.handleTrailingIconInteraction(evt);
      },
      toggleSelected: function toggleSelected() {
        this.foundation.toggleSelected();
      },
      isSelected: function isSelected() {
        return this.foundation.isSelected();
      }
    }
  };

  /* script */
  const __vue_script__$g = script$g;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$g.__file = "/ddata/extra/vma/components/chips/mdc-chip.vue";

  /* template */
  var __vue_render__$e = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        class: _vm.classes,
        style: _vm.styles,
        attrs: { id: _vm.id, tabindex: "0" },
        on: {
          click: _vm.handleInteraction,
          keydown: _vm.handleInteraction,
          transitionend: _vm.handleTransitionEnd
        }
      },
      [
        _vm.haveleadingIcon
          ? _c(
              "i",
              {
                ref: "leadingIcon",
                staticClass: "mdc-chip__icon mdc-chip__icon--leading",
                class: _vm.leadingClasses
              },
              [_vm._v(_vm._s(_vm.leadingIcon))]
            )
          : _vm._e(),
        _vm._v(" "),
        _vm.isFilter
          ? _c("div", { staticClass: "mdc-chip__checkmark" }, [
              _c(
                "svg",
                {
                  staticClass: "mdc-chip__checkmark-svg",
                  attrs: { viewBox: "-2 -3 30 30" }
                },
                [
                  _c("path", {
                    staticClass: "mdc-chip__checkmark-path",
                    attrs: {
                      fill: "none",
                      stroke: "black",
                      d: "M1.73,12.91 8.1,19.28 22.79,4.59"
                    }
                  })
                ]
              )
            ])
          : _vm._e(),
        _vm._v(" "),
        _c("div", { staticClass: "mdc-chip__text" }, [_vm._t("default")], 2),
        _vm._v(" "),
        _vm.havetrailingIcon
          ? _c(
              "i",
              {
                ref: "trailingIcon",
                staticClass: "mdc-chip__icon mdc-chip__icon--trailing",
                class: _vm.trailingClasses,
                attrs: { tabindex: "0", role: "button" },
                on: {
                  click: _vm.handleTrailingIconInteraction,
                  keydown: _vm.handleTrailingIconInteraction
                }
              },
              [_vm._v(_vm._s(_vm.trailingIcon))]
            )
          : _vm._e()
      ]
    )
  };
  var __vue_staticRenderFns__$e = [];
  __vue_render__$e._withStripped = true;

    /* style */
    const __vue_inject_styles__$g = undefined;
    /* scoped */
    const __vue_scope_id__$g = undefined;
    /* module identifier */
    const __vue_module_identifier__$g = undefined;
    /* functional template */
    const __vue_is_functional_template__$g = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcChip = normalizeComponent(
      { render: __vue_render__$e, staticRenderFns: __vue_staticRenderFns__$e },
      __vue_inject_styles__$g,
      __vue_script__$g,
      __vue_scope_id__$g,
      __vue_is_functional_template__$g,
      __vue_module_identifier__$g,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Chip Set.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Chip Set into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCChipSetAdapter =
  /*#__PURE__*/
  function () {
    function MDCChipSetAdapter() {
      _classCallCheck(this, MDCChipSetAdapter);
    }

    _createClass(MDCChipSetAdapter, [{
      key: "hasClass",

      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}
      /**
       * Removes the chip with the given id from the chip set.
       * @param {string} chipId
       */

    }, {
      key: "removeChip",
      value: function removeChip(chipId) {}
      /**
       * Sets the selected state of the chip with the given id.
       * @param {string} chipId
       * @param {boolean} selected
       */

    }, {
      key: "setSelected",
      value: function setSelected(chipId, selected) {}
    }]);

    return MDCChipSetAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$4 = {
    CHIP_SELECTOR: '.mdc-chip'
  };
  /** @enum {string} */

  var cssClasses$5 = {
    CHOICE: 'mdc-chip-set--choice',
    FILTER: 'mdc-chip-set--filter'
  };

  /**
   * @extends {MDCFoundation<!MDCChipSetAdapter>}
   * @final
   */

  var MDCChipSetFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCChipSetFoundation, _MDCFoundation);

    _createClass(MDCChipSetFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$4;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$5;
      }
      /**
       * {@see MDCChipSetAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCChipSetAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCChipSetAdapter} */
          {
            hasClass: function hasClass() {},
            removeChip: function removeChip() {},
            setSelected: function setSelected() {}
          }
        );
      }
      /**
       * @param {!MDCChipSetAdapter} adapter
       */

    }]);

    function MDCChipSetFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCChipSetFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCChipSetFoundation).call(this, _extends(MDCChipSetFoundation.defaultAdapter, adapter)));
      /**
       * The ids of the selected chips in the set. Only used for choice chip set or filter chip set.
       * @private {!Array<string>}
       */

      _this.selectedChipIds_ = [];
      return _this;
    }
    /**
     * Returns an array of the IDs of all selected chips.
     * @return {!Array<string>}
     */


    _createClass(MDCChipSetFoundation, [{
      key: "getSelectedChipIds",
      value: function getSelectedChipIds() {
        return this.selectedChipIds_;
      }
      /**
       * Toggles selection of the chip with the given id.
       * @private
       * @param {string} chipId
       */

    }, {
      key: "toggleSelect_",
      value: function toggleSelect_(chipId) {
        if (this.selectedChipIds_.indexOf(chipId) >= 0) {
          this.deselect_(chipId);
        } else {
          this.select(chipId);
        }
      }
      /**
       * Selects the chip with the given id. Deselects all other chips if the chip set is of the choice variant.
       * @param {string} chipId
       */

    }, {
      key: "select",
      value: function select(chipId) {
        if (this.selectedChipIds_.indexOf(chipId) >= 0) {
          return;
        }

        if (this.adapter_.hasClass(cssClasses$5.CHOICE) && this.selectedChipIds_.length > 0) {
          var previouslySelectedChip = this.selectedChipIds_[0];
          this.selectedChipIds_.length = 0;
          this.adapter_.setSelected(previouslySelectedChip, false);
        }

        this.selectedChipIds_.push(chipId);
        this.adapter_.setSelected(chipId, true);
      }
      /**
       * Deselects the chip with the given id.
       * @private
       * @param {string} chipId
       */

    }, {
      key: "deselect_",
      value: function deselect_(chipId) {
        var index = this.selectedChipIds_.indexOf(chipId);

        if (index >= 0) {
          this.selectedChipIds_.splice(index, 1);
          this.adapter_.setSelected(chipId, false);
        }
      }
      /**
       * Handles a chip interaction event
       * @param {string} chipId
       */

    }, {
      key: "handleChipInteraction",
      value: function handleChipInteraction(chipId) {
        if (this.adapter_.hasClass(cssClasses$5.CHOICE) || this.adapter_.hasClass(cssClasses$5.FILTER)) {
          this.toggleSelect_(chipId);
        }
      }
      /**
       * Handles a chip selection event, used to handle discrepancy when selection state is set directly on the Chip.
       * @param {string} chipId
       * @param {boolean} selected
       */

    }, {
      key: "handleChipSelection",
      value: function handleChipSelection(chipId, selected) {
        var chipIsSelected = this.selectedChipIds_.indexOf(chipId) >= 0;

        if (selected && !chipIsSelected) {
          this.select(chipId);
        } else if (!selected && chipIsSelected) {
          this.deselect_(chipId);
        }
      }
      /**
       * Handles the event when a chip is removed.
       * @param {string} chipId
       */

    }, {
      key: "handleChipRemoval",
      value: function handleChipRemoval(chipId) {
        this.deselect_(chipId);
        this.adapter_.removeChip(chipId);
      }
    }]);

    return MDCChipSetFoundation;
  }(MDCFoundation);

  var idCounter = 0;
  var script$h = {
    name: 'mdc-chip-set',
    props: {
      choice: [Boolean],
      filter: [Boolean],
      input: [Boolean]
    },
    provide: function provide() {
      return {
        mdcChipSet: this
      };
    },
    data: function data() {
      return {
        classes: {
          'mdc-chip-set': true,
          'mdc-chip-set--choice': this.choice,
          'mdc-chip-set--filter': this.filter,
          'mdc-chip-set--input': this.input
        },
        chips: []
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCChipSetFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        removeChip: function removeChip(chipId) {
          var index = _this.findChipIndex(chipId);

          if (index > 0) {
            _this.$nextTick(function () {
              _this.chips.splice(index, 1);
            });
          }
        },
        setSelected: function setSelected(chipId, selected) {
          var index = _this.findChipIndex(chipId);

          if (index >= 0) {
            _this.chips[index].selected = selected;
          }
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    methods: {
      nextId: function nextId() {
        return "mdc-chip-".concat(++idCounter);
      },
      findChipIndex: function findChipIndex(chipId) {
        for (var i = 0; i < this.chips.length; i++) {
          if (this.chips[i].id === chipId) {
            return i;
          }
        }

        return -1;
      },
      handleChipInteraction: function handleChipInteraction(evt) {
        this.foundation.handleChipInteraction(evt.detail.chipId);
      },
      handleChipRemoval: function handleChipRemoval(evt) {
        this.foundation.handleChipRemoval(evt.detail.chipId);
      },
      handleChipSelection: function handleChipSelection(evt) {
        this.foundation.handleChipSelection(evt.detail.chipId, evt.detail.selected);
      }
    },
    render: function render(h) {
      var _this2 = this,
          _on;

      return h('div', {
        class: this.classes,
        on: (_on = {}, _defineProperty(_on, MDCChipFoundation.strings.INTERACTION_EVENT, function (evt) {
          return _this2.handleChipInteraction(evt);
        }), _defineProperty(_on, MDCChipFoundation.strings.SELECTION_EVENT, function (evt) {
          return _this2.handleChipSelection(evt);
        }), _defineProperty(_on, MDCChipFoundation.strings.REMOVAL_EVENT, function (evt) {
          return _this2.handleChipRemoval(evt);
        }), _on)
      }, this.$slots.default);
    }
  };

  /* script */
  const __vue_script__$h = script$h;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$h.__file = "/ddata/extra/vma/components/chips/mdc-chip-set.vue";

  /* template */

    /* style */
    const __vue_inject_styles__$h = undefined;
    /* scoped */
    const __vue_scope_id__$h = undefined;
    /* module identifier */
    const __vue_module_identifier__$h = undefined;
    /* functional template */
    const __vue_is_functional_template__$h = undefined;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcChipSet = normalizeComponent(
      {},
      __vue_inject_styles__$h,
      __vue_script__$h,
      __vue_scope_id__$h,
      __vue_is_functional_template__$h,
      __vue_module_identifier__$h,
      undefined,
      undefined
    );

  var VueMDCChipSet = BasePlugin({
    mdcChip: mdcChip,
    mdcChipSet: mdcChipSet
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Dialog. Provides an interface for managing:
   * - CSS classes
   * - DOM
   * - Event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCDialogAdapter =
  /*#__PURE__*/
  function () {
    function MDCDialogAdapter() {
      _classCallCheck(this, MDCDialogAdapter);
    }

    _createClass(MDCDialogAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /** @param {string} className */

    }, {
      key: "addBodyClass",
      value: function addBodyClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeBodyClass",
      value: function removeBodyClass(className) {}
      /**
       * @param {!EventTarget} target
       * @param {string} selector
       * @return {boolean}
       */

    }, {
      key: "eventTargetMatches",
      value: function eventTargetMatches(target, selector) {}
    }, {
      key: "trapFocus",
      value: function trapFocus() {}
    }, {
      key: "releaseFocus",
      value: function releaseFocus() {}
      /** @return {boolean} */

    }, {
      key: "isContentScrollable",
      value: function isContentScrollable() {}
      /** @return {boolean} */

    }, {
      key: "areButtonsStacked",
      value: function areButtonsStacked() {}
      /**
       * @param {!Event} event
       * @return {?string}
       */

    }, {
      key: "getActionFromEvent",
      value: function getActionFromEvent(event) {}
    }, {
      key: "clickDefaultButton",
      value: function clickDefaultButton() {}
    }, {
      key: "reverseButtons",
      value: function reverseButtons() {}
    }, {
      key: "notifyOpening",
      value: function notifyOpening() {}
    }, {
      key: "notifyOpened",
      value: function notifyOpened() {}
      /**
       * @param {string} action
       */

    }, {
      key: "notifyClosing",
      value: function notifyClosing(action) {}
      /**
       * @param {string} action
       */

    }, {
      key: "notifyClosed",
      value: function notifyClosed(action) {}
    }]);

    return MDCDialogAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$6 = {
    OPEN: 'mdc-dialog--open',
    OPENING: 'mdc-dialog--opening',
    CLOSING: 'mdc-dialog--closing',
    SCROLLABLE: 'mdc-dialog--scrollable',
    STACKED: 'mdc-dialog--stacked',
    SCROLL_LOCK: 'mdc-dialog-scroll-lock'
  };
  var strings$5 = {
    SCRIM_SELECTOR: '.mdc-dialog__scrim',
    CONTAINER_SELECTOR: '.mdc-dialog__container',
    SURFACE_SELECTOR: '.mdc-dialog__surface',
    CONTENT_SELECTOR: '.mdc-dialog__content',
    BUTTON_SELECTOR: '.mdc-dialog__button',
    DEFAULT_BUTTON_SELECTOR: '.mdc-dialog__button--default',
    SUPPRESS_DEFAULT_PRESS_SELECTOR: ['textarea', '.mdc-menu .mdc-list-item'].join(', '),
    OPENING_EVENT: 'MDCDialog:opening',
    OPENED_EVENT: 'MDCDialog:opened',
    CLOSING_EVENT: 'MDCDialog:closing',
    CLOSED_EVENT: 'MDCDialog:closed',
    ACTION_ATTRIBUTE: 'data-mdc-dialog-action',
    CLOSE_ACTION: 'close',
    DESTROY_ACTION: 'destroy'
  };
  var numbers$2 = {
    DIALOG_ANIMATION_OPEN_TIME_MS: 150,
    DIALOG_ANIMATION_CLOSE_TIME_MS: 75
  };

  var MDCDialogFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCDialogFoundation, _MDCFoundation);

    _createClass(MDCDialogFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$6;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$5;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers$2;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCDialogAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass()
            /* className: string */
            {},
            addBodyClass: function addBodyClass()
            /* className: string */
            {},
            removeBodyClass: function removeBodyClass()
            /* className: string */
            {},
            eventTargetMatches: function eventTargetMatches()
            /* target: !EventTarget, selector: string */
            {},
            trapFocus: function trapFocus() {},
            releaseFocus: function releaseFocus() {},
            isContentScrollable: function isContentScrollable() {},
            areButtonsStacked: function areButtonsStacked() {},
            getActionFromEvent: function getActionFromEvent()
            /* event: !Event */
            {},
            clickDefaultButton: function clickDefaultButton() {},
            reverseButtons: function reverseButtons() {},
            notifyOpening: function notifyOpening() {},
            notifyOpened: function notifyOpened() {},
            notifyClosing: function notifyClosing()
            /* action: ?string */
            {},
            notifyClosed: function notifyClosed()
            /* action: ?string */
            {}
          }
        );
      }
      /**
       * @param {!MDCDialogAdapter=} adapter
       */

    }]);

    function MDCDialogFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCDialogFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCDialogFoundation).call(this, _extends(MDCDialogFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.animationFrame_ = 0;
      /** @private {number} */

      _this.animationTimer_ = 0;
      /** @private {number} */

      _this.layoutFrame_ = 0;
      /** @private {string} */

      _this.escapeKeyAction_ = strings$5.CLOSE_ACTION;
      /** @private {string} */

      _this.scrimClickAction_ = strings$5.CLOSE_ACTION;
      /** @private {boolean} */

      _this.autoStackButtons_ = true;
      /** @private {boolean} */

      _this.areButtonsStacked_ = false;
      return _this;
    }

    _createClass(MDCDialogFoundation, [{
      key: "init",
      value: function init() {
        if (this.adapter_.hasClass(cssClasses$6.STACKED)) {
          this.setAutoStackButtons(false);
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        if (this.isOpen_) {
          this.close(strings$5.DESTROY_ACTION);
        }

        if (this.animationTimer_) {
          clearTimeout(this.animationTimer_);
          this.handleAnimationTimerEnd_();
        }

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
          this.layoutFrame_ = 0;
        }
      }
    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.addClass(cssClasses$6.OPENING); // Wait a frame once display is no longer "none", to establish basis for animation

        this.runNextAnimationFrame_(function () {
          _this2.adapter_.addClass(cssClasses$6.OPEN);

          _this2.adapter_.addBodyClass(cssClasses$6.SCROLL_LOCK);

          _this2.layout();

          _this2.animationTimer_ = setTimeout(function () {
            _this2.handleAnimationTimerEnd_();

            _this2.adapter_.trapFocus();

            _this2.adapter_.notifyOpened();
          }, numbers$2.DIALOG_ANIMATION_OPEN_TIME_MS);
        });
      }
      /**
       * @param {string=} action
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (!this.isOpen_) {
          // Avoid redundant close calls (and events), e.g. from keydown on elements that inherently emit click
          return;
        }

        this.isOpen_ = false;
        this.adapter_.notifyClosing(action);
        this.adapter_.addClass(cssClasses$6.CLOSING);
        this.adapter_.removeClass(cssClasses$6.OPEN);
        this.adapter_.removeBodyClass(cssClasses$6.SCROLL_LOCK);
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
          _this3.adapter_.releaseFocus();

          _this3.handleAnimationTimerEnd_();

          _this3.adapter_.notifyClosed(action);
        }, numbers$2.DIALOG_ANIMATION_CLOSE_TIME_MS);
      }
    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /** @return {string} */

    }, {
      key: "getEscapeKeyAction",
      value: function getEscapeKeyAction() {
        return this.escapeKeyAction_;
      }
      /** @param {string} action */

    }, {
      key: "setEscapeKeyAction",
      value: function setEscapeKeyAction(action) {
        this.escapeKeyAction_ = action;
      }
      /** @return {string} */

    }, {
      key: "getScrimClickAction",
      value: function getScrimClickAction() {
        return this.scrimClickAction_;
      }
      /** @param {string} action */

    }, {
      key: "setScrimClickAction",
      value: function setScrimClickAction(action) {
        this.scrimClickAction_ = action;
      }
      /** @return {boolean} */

    }, {
      key: "getAutoStackButtons",
      value: function getAutoStackButtons() {
        return this.autoStackButtons_;
      }
      /** @param {boolean} autoStack */

    }, {
      key: "setAutoStackButtons",
      value: function setAutoStackButtons(autoStack) {
        this.autoStackButtons_ = autoStack;
      }
    }, {
      key: "layout",
      value: function layout() {
        var _this4 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }

        this.layoutFrame_ = requestAnimationFrame(function () {
          _this4.layoutInternal_();

          _this4.layoutFrame_ = 0;
        });
      }
    }, {
      key: "layoutInternal_",
      value: function layoutInternal_() {
        if (this.autoStackButtons_) {
          this.detectStackedButtons_();
        }

        this.detectScrollableContent_();
      }
      /** @private */

    }, {
      key: "detectStackedButtons_",
      value: function detectStackedButtons_() {
        // Remove the class first to let us measure the buttons' natural positions.
        this.adapter_.removeClass(cssClasses$6.STACKED);
        var areButtonsStacked = this.adapter_.areButtonsStacked();

        if (areButtonsStacked) {
          this.adapter_.addClass(cssClasses$6.STACKED);
        }

        if (areButtonsStacked !== this.areButtonsStacked_) {
          this.adapter_.reverseButtons();
          this.areButtonsStacked_ = areButtonsStacked;
        }
      }
      /** @private */

    }, {
      key: "detectScrollableContent_",
      value: function detectScrollableContent_() {
        // Remove the class first to let us measure the natural height of the content.
        this.adapter_.removeClass(cssClasses$6.SCROLLABLE);

        if (this.adapter_.isContentScrollable()) {
          this.adapter_.addClass(cssClasses$6.SCROLLABLE);
        }
      }
      /**
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        var isClick = evt.type === 'click';
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13; // Check for scrim click first since it doesn't require querying ancestors

        if (isClick && this.adapter_.eventTargetMatches(evt.target, strings$5.SCRIM_SELECTOR) && this.scrimClickAction_ !== '') {
          this.close(this.scrimClickAction_);
        } else if (isClick || evt.key === 'Space' || evt.keyCode === 32 || isEnter) {
          var action = this.adapter_.getActionFromEvent(evt);

          if (action) {
            this.close(action);
          } else if (isEnter && !this.adapter_.eventTargetMatches(evt.target, strings$5.SUPPRESS_DEFAULT_PRESS_SELECTOR)) {
            this.adapter_.clickDefaultButton();
          }
        }
      }
      /**
       * @param {!KeyboardEvent} evt
       * @private
       */

    }, {
      key: "handleDocumentKeydown",
      value: function handleDocumentKeydown(evt) {
        if ((evt.key === 'Escape' || evt.keyCode === 27) && this.escapeKeyAction_ !== '') {
          this.close(this.escapeKeyAction_);
        }
      }
      /** @private */

    }, {
      key: "handleAnimationTimerEnd_",
      value: function handleAnimationTimerEnd_() {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(cssClasses$6.OPENING);
        this.adapter_.removeClass(cssClasses$6.CLOSING);
      }
      /**
       * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
       * @param {Function} callback
       * @private
       */

    }, {
      key: "runNextAnimationFrame_",
      value: function runNextAnimationFrame_(callback) {
        var _this5 = this;

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
          _this5.animationFrame_ = 0;
          clearTimeout(_this5.animationTimer_);
          _this5.animationTimer_ = setTimeout(callback, 0);
        });
      }
    }]);

    return MDCDialogFoundation;
  }(MDCFoundation);

  var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])'];
  var candidateSelector = candidateSelectors.join(',');
  var matches = typeof Element === 'undefined' ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;

  function tabbable(el, options) {
    options = options || {};
    var elementDocument = el.ownerDocument || el;
    var regularTabbables = [];
    var orderedTabbables = [];
    var untouchabilityChecker = new UntouchabilityChecker(elementDocument);
    var candidates = el.querySelectorAll(candidateSelector);

    if (options.includeContainer) {
      if (matches.call(el, candidateSelector)) {
        candidates = Array.prototype.slice.apply(candidates);
        candidates.unshift(el);
      }
    }

    var i, candidate, candidateTabindex;

    for (i = 0; i < candidates.length; i++) {
      candidate = candidates[i];
      if (!isNodeMatchingSelectorTabbable(candidate, untouchabilityChecker)) continue;
      candidateTabindex = getTabindex(candidate);

      if (candidateTabindex === 0) {
        regularTabbables.push(candidate);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          node: candidate
        });
      }
    }

    var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function (a) {
      return a.node;
    }).concat(regularTabbables);
    return tabbableNodes;
  }

  tabbable.isTabbable = isTabbable;
  tabbable.isFocusable = isFocusable;

  function isNodeMatchingSelectorTabbable(node, untouchabilityChecker) {
    if (!isNodeMatchingSelectorFocusable(node, untouchabilityChecker) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
      return false;
    }

    return true;
  }

  function isTabbable(node, untouchabilityChecker) {
    if (!node) throw new Error('No node provided');
    if (matches.call(node, candidateSelector) === false) return false;
    return isNodeMatchingSelectorTabbable(node, untouchabilityChecker);
  }

  function isNodeMatchingSelectorFocusable(node, untouchabilityChecker) {
    untouchabilityChecker = untouchabilityChecker || new UntouchabilityChecker(node.ownerDocument || node);

    if (node.disabled || isHiddenInput(node) || untouchabilityChecker.isUntouchable(node)) {
      return false;
    }

    return true;
  }

  var focusableCandidateSelector = candidateSelectors.concat('iframe').join(',');

  function isFocusable(node, untouchabilityChecker) {
    if (!node) throw new Error('No node provided');
    if (matches.call(node, focusableCandidateSelector) === false) return false;
    return isNodeMatchingSelectorFocusable(node, untouchabilityChecker);
  }

  function getTabindex(node) {
    var tabindexAttr = parseInt(node.getAttribute('tabindex'), 10);
    if (!isNaN(tabindexAttr)) return tabindexAttr; // Browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.

    if (isContentEditable(node)) return 0;
    return node.tabIndex;
  }

  function sortOrderedTabbables(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  } // Array.prototype.find not available in IE.


  function find(list, predicate) {
    for (var i = 0, length = list.length; i < length; i++) {
      if (predicate(list[i])) return list[i];
    }
  }

  function isContentEditable(node) {
    return node.contentEditable === 'true';
  }

  function isInput(node) {
    return node.tagName === 'INPUT';
  }

  function isHiddenInput(node) {
    return isInput(node) && node.type === 'hidden';
  }

  function isRadio(node) {
    return isInput(node) && node.type === 'radio';
  }

  function isNonTabbableRadio(node) {
    return isRadio(node) && !isTabbableRadio(node);
  }

  function getCheckedRadio(nodes) {
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].checked) {
        return nodes[i];
      }
    }
  }

  function isTabbableRadio(node) {
    if (!node.name) return true; // This won't account for the edge case where you have radio groups with the same
    // in separate forms on the same page.

    var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
    var checked = getCheckedRadio(radioSet);
    return !checked || checked === node;
  } // An element is "untouchable" if *it or one of its ancestors* has
  // `visibility: hidden` or `display: none`.


  function UntouchabilityChecker(elementDocument) {
    this.doc = elementDocument; // Node cache must be refreshed on every check, in case
    // the content of the element has changed. The cache contains tuples
    // mapping nodes to their boolean result.

    this.cache = [];
  } // getComputedStyle accurately reflects `visibility: hidden` of ancestors
  // but not `display: none`, so we need to recursively check parents.


  UntouchabilityChecker.prototype.hasDisplayNone = function hasDisplayNone(node, nodeComputedStyle) {
    if (node.nodeType !== Node.ELEMENT_NODE) return false; // Search for a cached result.

    var cached = find(this.cache, function (item) {
      return item === node;
    });
    if (cached) return cached[1];
    nodeComputedStyle = nodeComputedStyle || this.doc.defaultView.getComputedStyle(node);
    var result = false;

    if (nodeComputedStyle.display === 'none') {
      result = true;
    } else if (node.parentNode) {
      result = this.hasDisplayNone(node.parentNode);
    }

    this.cache.push([node, result]);
    return result;
  };

  UntouchabilityChecker.prototype.isUntouchable = function isUntouchable(node) {
    if (node === this.doc.documentElement) return false;
    var computedStyle = this.doc.defaultView.getComputedStyle(node);
    if (this.hasDisplayNone(node, computedStyle)) return true;
    return computedStyle.visibility === 'hidden';
  };

  var tabbable_1 = tabbable;

  var immutable = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;

  function extend() {
    var target = {};

    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  }

  var activeFocusTraps = function () {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];

          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }

        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          // move this existing trap to the front of the queue
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }

        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();

  function focusTrap(element, userOptions) {
    var doc = document;
    var container = typeof element === 'string' ? doc.querySelector(element) : element;
    var config = immutable({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    }, userOptions);
    var state = {
      firstTabbableNode: null,
      lastTabbableNode: null,
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false
    };
    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };
    return trap;

    function activate(activateOptions) {
      if (state.active) return;
      updateTabbableNodes();
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

      if (onActivate) {
        onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!state.active) return;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps.deactivateTrap(trap);
      var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

      if (onDeactivate) {
        onDeactivate();
      }

      var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

      if (returnFocus) {
        delay(function () {
          tryFocus(state.nodeFocusedBeforeActivation);
        });
      }

      return trap;
    }

    function pause() {
      if (state.paused || !state.active) return;
      state.paused = true;
      removeListeners();
    }

    function unpause() {
      if (!state.paused || !state.active) return;
      state.paused = false;
      addListeners();
    }

    function addListeners() {
      if (!state.active) return; // There can be only one listening focus trap at a time

      activeFocusTraps.activateTrap(trap);
      updateTabbableNodes(); // Delay ensures that the focused element doesn't capture the event
      // that caused the focus trap activation.

      delay(function () {
        tryFocus(getInitialFocusNode());
      });
      doc.addEventListener('focusin', checkFocusIn, true);
      doc.addEventListener('mousedown', checkPointerDown, true);
      doc.addEventListener('touchstart', checkPointerDown, true);
      doc.addEventListener('click', checkClick, true);
      doc.addEventListener('keydown', checkKey, true);
      return trap;
    }

    function removeListeners() {
      if (!state.active) return;
      doc.removeEventListener('focusin', checkFocusIn, true);
      doc.removeEventListener('mousedown', checkPointerDown, true);
      doc.removeEventListener('touchstart', checkPointerDown, true);
      doc.removeEventListener('click', checkClick, true);
      doc.removeEventListener('keydown', checkKey, true);
      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;

      if (!optionValue) {
        return null;
      }

      if (typeof optionValue === 'string') {
        node = doc.querySelector(optionValue);

        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }

      if (typeof optionValue === 'function') {
        node = optionValue();

        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }

      return node;
    }

    function getInitialFocusNode() {
      var node;

      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(doc.activeElement)) {
        node = doc.activeElement;
      } else {
        node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error("You can't have a focus-trap without at least one focusable element");
      }

      return node;
    } // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.


    function checkPointerDown(e) {
      if (container.contains(e.target)) return;

      if (config.clickOutsideDeactivates) {
        deactivate({
          returnFocus: !tabbable_1.isFocusable(e.target)
        });
      } else {
        e.preventDefault();
      }
    } // In case focus escapes the trap for some strange reason, pull it back in.


    function checkFocusIn(e) {
      // In Firefox when you Tab out of an iframe the Document is briefly focused.
      if (container.contains(e.target) || e.target instanceof Document) {
        return;
      }

      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }

    function checkKey(e) {
      if (config.escapeDeactivates !== false && isEscapeEvent(e)) {
        e.preventDefault();
        deactivate();
        return;
      }

      if (isTabEvent(e)) {
        checkTab(e);
        return;
      }
    } // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.


    function checkTab(e) {
      updateTabbableNodes();

      if (e.shiftKey && e.target === state.firstTabbableNode) {
        e.preventDefault();
        tryFocus(state.lastTabbableNode);
        return;
      }

      if (!e.shiftKey && e.target === state.lastTabbableNode) {
        e.preventDefault();
        tryFocus(state.firstTabbableNode);
        return;
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function updateTabbableNodes() {
      var tabbableNodes = tabbable_1(container);
      state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
      state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
    }

    function tryFocus(node) {
      if (node === doc.activeElement) return;

      if (!node || !node.focus) {
        tryFocus(getInitialFocusNode());
        return;
      }

      node.focus();
      state.mostRecentlyFocusedNode = node;

      if (isSelectableInput(node)) {
        node.select();
      }
    }
  }

  function isSelectableInput(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
  }

  function isEscapeEvent(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function isTabEvent(e) {
    return e.key === 'Tab' || e.keyCode === 9;
  }

  function delay(fn) {
    return setTimeout(fn, 0);
  }

  var focusTrap_1 = focusTrap;

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * @param {!Element} surfaceEl
   * @param {?Element=} initialFocusEl
   * @param {function(!Element, !FocusTrapCreateOptions): !FocusTrapInstance} focusTrapFactory
   * @return {!FocusTrapInstance}
   */

  function createFocusTrapInstance(surfaceEl) {
    var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusTrap_1;
    var initialFocusEl = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return focusTrapFactory(surfaceEl, {
      initialFocus: initialFocusEl,
      escapeDeactivates: false,
      // Dialog foundation handles escape key
      clickOutsideDeactivates: true // Allow handling of scrim clicks

    });
  }
  /**
   * @param {!Element} el
   * @return {boolean}
   */


  function isScrollable(el) {
    return el.scrollHeight > el.offsetHeight;
  }
  /**
   * @param {!Array<!Element>|!NodeList} els
   * @return {boolean}
   */


  function areTopsMisaligned(els) {
    var tops = new Set();
    [].forEach.call(els, function (el) {
      return tops.add(el.offsetTop);
    });
    return tops.size > 1;
  }

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /**
   * @fileoverview A "ponyfill" is a polyfill that doesn't modify the global prototype chain.
   * This makes ponyfills safer than traditional polyfills, especially for libraries like MDC.
   */

  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {?Element}
   */
  function closest(element, selector) {
    if (element.closest) {
      return element.closest(selector);
    }

    var el = element;

    while (el) {
      if (matches$1(el, selector)) {
        return el;
      }

      el = el.parentElement;
    }

    return null;
  }
  /**
   * @param {!Element} element
   * @param {string} selector
   * @return {boolean}
   */


  function matches$1(element, selector) {
    var nativeMatches = element.matches || element.webkitMatchesSelector || element.msMatchesSelector;
    return nativeMatches.call(element, selector);
  }

  var activeFocusTraps$1 = function () {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];

          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }

        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          // move this existing trap to the front of the queue
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);

        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }

        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();

  function focusTrap$1(element, userOptions) {
    var doc = document;
    var container = typeof element === 'string' ? doc.querySelector(element) : element;
    var config = immutable({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true
    }, userOptions);
    var state = {
      firstTabbableNode: null,
      lastTabbableNode: null,
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false
    };
    var trap = {
      activate: activate,
      deactivate: deactivate,
      pause: pause,
      unpause: unpause
    };
    return trap;

    function activate(activateOptions) {
      if (state.active) return;
      updateTabbableNodes();
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      var onActivate = activateOptions && activateOptions.onActivate ? activateOptions.onActivate : config.onActivate;

      if (onActivate) {
        onActivate();
      }

      addListeners();
      return trap;
    }

    function deactivate(deactivateOptions) {
      if (!state.active) return;
      removeListeners();
      state.active = false;
      state.paused = false;
      activeFocusTraps$1.deactivateTrap(trap);
      var onDeactivate = deactivateOptions && deactivateOptions.onDeactivate !== undefined ? deactivateOptions.onDeactivate : config.onDeactivate;

      if (onDeactivate) {
        onDeactivate();
      }

      var returnFocus = deactivateOptions && deactivateOptions.returnFocus !== undefined ? deactivateOptions.returnFocus : config.returnFocusOnDeactivate;

      if (returnFocus) {
        delay$1(function () {
          tryFocus(state.nodeFocusedBeforeActivation);
        });
      }

      return trap;
    }

    function pause() {
      if (state.paused || !state.active) return;
      state.paused = true;
      removeListeners();
    }

    function unpause() {
      if (!state.paused || !state.active) return;
      state.paused = false;
      addListeners();
    }

    function addListeners() {
      if (!state.active) return; // There can be only one listening focus trap at a time

      activeFocusTraps$1.activateTrap(trap);
      updateTabbableNodes(); // Delay ensures that the focused element doesn't capture the event
      // that caused the focus trap activation.

      delay$1(function () {
        tryFocus(getInitialFocusNode());
      });
      doc.addEventListener('focusin', checkFocusIn, true);
      doc.addEventListener('mousedown', checkPointerDown, true);
      doc.addEventListener('touchstart', checkPointerDown, true);
      doc.addEventListener('click', checkClick, true);
      doc.addEventListener('keydown', checkKey, true);
      return trap;
    }

    function removeListeners() {
      if (!state.active) return;
      doc.removeEventListener('focusin', checkFocusIn, true);
      doc.removeEventListener('mousedown', checkPointerDown, true);
      doc.removeEventListener('touchstart', checkPointerDown, true);
      doc.removeEventListener('click', checkClick, true);
      doc.removeEventListener('keydown', checkKey, true);
      return trap;
    }

    function getNodeForOption(optionName) {
      var optionValue = config[optionName];
      var node = optionValue;

      if (!optionValue) {
        return null;
      }

      if (typeof optionValue === 'string') {
        node = doc.querySelector(optionValue);

        if (!node) {
          throw new Error('`' + optionName + '` refers to no known node');
        }
      }

      if (typeof optionValue === 'function') {
        node = optionValue();

        if (!node) {
          throw new Error('`' + optionName + '` did not return a node');
        }
      }

      return node;
    }

    function getInitialFocusNode() {
      var node;

      if (getNodeForOption('initialFocus') !== null) {
        node = getNodeForOption('initialFocus');
      } else if (container.contains(doc.activeElement)) {
        node = doc.activeElement;
      } else {
        node = state.firstTabbableNode || getNodeForOption('fallbackFocus');
      }

      if (!node) {
        throw new Error("You can't have a focus-trap without at least one focusable element");
      }

      return node;
    } // This needs to be done on mousedown and touchstart instead of click
    // so that it precedes the focus event.


    function checkPointerDown(e) {
      if (container.contains(e.target)) return;

      if (config.clickOutsideDeactivates) {
        deactivate({
          returnFocus: !tabbable_1.isFocusable(e.target)
        });
      } else {
        e.preventDefault();
      }
    } // In case focus escapes the trap for some strange reason, pull it back in.


    function checkFocusIn(e) {
      // In Firefox when you Tab out of an iframe the Document is briefly focused.
      if (container.contains(e.target) || e.target instanceof Document) {
        return;
      }

      e.stopImmediatePropagation();
      tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
    }

    function checkKey(e) {
      if (config.escapeDeactivates !== false && isEscapeEvent$1(e)) {
        e.preventDefault();
        deactivate();
        return;
      }

      if (isTabEvent$1(e)) {
        checkTab(e);
        return;
      }
    } // Hijack Tab events on the first and last focusable nodes of the trap,
    // in order to prevent focus from escaping. If it escapes for even a
    // moment it can end up scrolling the page and causing confusion so we
    // kind of need to capture the action at the keydown phase.


    function checkTab(e) {
      updateTabbableNodes();

      if (e.shiftKey && e.target === state.firstTabbableNode) {
        e.preventDefault();
        tryFocus(state.lastTabbableNode);
        return;
      }

      if (!e.shiftKey && e.target === state.lastTabbableNode) {
        e.preventDefault();
        tryFocus(state.firstTabbableNode);
        return;
      }
    }

    function checkClick(e) {
      if (config.clickOutsideDeactivates) return;
      if (container.contains(e.target)) return;
      e.preventDefault();
      e.stopImmediatePropagation();
    }

    function updateTabbableNodes() {
      var tabbableNodes = tabbable_1(container);
      state.firstTabbableNode = tabbableNodes[0] || getInitialFocusNode();
      state.lastTabbableNode = tabbableNodes[tabbableNodes.length - 1] || getInitialFocusNode();
    }

    function tryFocus(node) {
      if (node === doc.activeElement) return;

      if (!node || !node.focus) {
        tryFocus(getInitialFocusNode());
        return;
      }

      node.focus();
      state.mostRecentlyFocusedNode = node;

      if (isSelectableInput$1(node)) {
        node.select();
      }
    }
  }

  function isSelectableInput$1(node) {
    return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
  }

  function isEscapeEvent$1(e) {
    return e.key === 'Escape' || e.key === 'Esc' || e.keyCode === 27;
  }

  function isTabEvent$1(e) {
    return e.key === 'Tab' || e.keyCode === 9;
  }

  function delay$1(fn) {
    return setTimeout(fn, 0);
  }

  var focusTrap_1$1 = focusTrap$1;

  //
  var strings$6 = MDCDialogFoundation.strings;
  var script$i = {
    name: 'mdc-dialog',
    components: {
      mdcButton: mdcButton
    },
    mixins: [VMAUniqueIdMixin],
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      title: {
        type: String
      },
      accept: {
        type: String,
        default: 'Ok'
      },
      acceptDisabled: Boolean,
      acceptRaised: {
        type: Boolean,
        default: false
      },
      cancel: {
        type: String
      },
      cancelRaised: {
        type: Boolean,
        default: false
      },
      accent: Boolean,
      scrollable: Boolean,
      open: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-theme--dark': this.dark
        },
        styles: {},
        surfaceClasses: {},
        bodyClasses: {
          'mdc-dialog__body--scrollable': this.scrollable
        }
      };
    },
    watch: {
      open: 'onOpen_'
    },
    mounted: function mounted() {
      var _this = this;

      if (this.accept) {
        this.focusTrap = createFocusTrapInstance(this.$refs.container, focusTrap_1$1);
      }

      this.buttons_ = [].slice.call(this.$el.querySelectorAll(strings$6.BUTTON_SELECTOR));
      this.foundation = new MDCDialogFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetMatches: function eventTargetMatches(target, selector) {
          return matches$1(target, selector);
        },
        trapFocus: function trapFocus() {
          return _this.focusTrap && _this.focusTrap.activate();
        },
        releaseFocus: function releaseFocus() {
          return _this.focusTrap && _this.focusTrap.deactivate();
        },
        isContentScrollable: function isContentScrollable() {
          return !!_this.$refs.content && isScrollable(_this.$refs.content);
        },
        areButtonsStacked: function areButtonsStacked() {
          return areTopsMisaligned(_this.buttons_);
        },
        getActionFromEvent: function getActionFromEvent(event) {
          var element = closest(event.target, "[".concat(strings$6.ACTION_ATTRIBUTE, "]"));
          return element && element.getAttribute(strings$6.ACTION_ATTRIBUTE);
        },
        clickDefaultButton: function clickDefaultButton() {
          if (_this.$refs.defaultButton) {
            _this.$refs.defaultButton.click();
          }
        },
        reverseButtons: function reverseButtons() {
          _this.buttons_.reverse();

          _this.buttons_.forEach(function (button) {
            return button.parentElement.appendChild(button);
          });
        },
        notifyOpening: function notifyOpening() {
          return _this.$emit(strings$6.OPENING_EVENT, {});
        },
        notifyOpened: function notifyOpened() {
          return _this.$emit(strings$6.OPENED_EVENT, {});
        },
        notifyClosing: function notifyClosing(action) {
          _this.$emit('change', false); // console.log(action)


          _this.$emit(strings$6.CLOSING_EVENT, action ? {
            action: action
          } : {});
        },
        notifyClosed: function notifyClosed(action) {
          return _this.$emit(strings$6.CLOSED_EVENT, action ? {
            action: action
          } : {});
        }
      });
      this.foundation.init();
      this.open && this.foundation.open();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    methods: {
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      onClick: function onClick(event) {
        this.foundation.handleInteraction(event);
      },
      onCancel: function onCancel() {
        var _this2 = this;

        if (this.$listeners['validateCancel']) {
          this.$emit('validateCancel', {
            cancel: function cancel() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this2.$emit('change', false);
              }

              _this2.foundation.cancel(notify);
            }
          });
        } else {
          this.foundation.cancel(true);
        }
      },
      onAccept: function onAccept() {
        var _this3 = this;

        if (this.$listeners['validate']) {
          this.$emit('validate', {
            accept: function accept() {
              var notify = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

              // if notify = false, the dialog will close
              // but the notifyAccept method will not be called
              // so we need to notify listeners the open state
              // is changing.
              if (!notify) {
                _this3.$emit('change', false);
              }

              _this3.foundation.accept(notify);
            }
          });
        } else {
          this.foundation.accept(true);
        }
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      }
    }
  };

  /* script */
  const __vue_script__$i = script$i;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$i.__file = "/ddata/extra/vma/components/dialog/mdc-dialog.vue";

  /* template */
  var __vue_render__$f = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        ref: "root",
        staticClass: "mdc-dialog",
        class: _vm.classes,
        style: _vm.styles,
        attrs: {
          "aria-modal": "true",
          "aria-labelledby": "label" + _vm.vma_uid_,
          "aria-describedby": "desc" + _vm.vma_uid_,
          role: "alertdialog"
        },
        on: { click: _vm.onClick, keydown: _vm.onClick }
      },
      [
        _c("div", { ref: "container", staticClass: "mdc-dialog__container" }, [
          _c(
            "div",
            {
              ref: "surface",
              staticClass: "mdc-dialog__surface",
              class: _vm.surfaceClasses
            },
            [
              _vm.title
                ? _c(
                    "h2",
                    {
                      staticClass: "mdc-dialog__title",
                      attrs: { id: "label" + _vm.vma_uid_ }
                    },
                    [_vm._v(_vm._s(_vm.title))]
                  )
                : _vm._e(),
              _vm._v(" "),
              _c(
                "div",
                {
                  ref: "content",
                  staticClass: "mdc-dialog__content",
                  attrs: { id: "desc" + _vm.vma_uid_ }
                },
                [_vm._t("default")],
                2
              ),
              _vm._v(" "),
              _vm.accept || _vm.cancel
                ? _c("footer", { staticClass: "mdc-dialog__actions" }, [
                    _vm.cancel
                      ? _c(
                          "button",
                          {
                            staticClass: "mdc-button mdc-dialog__button",
                            attrs: {
                              type: "button",
                              "data-mdc-dialog-action": "no"
                            }
                          },
                          [
                            _vm._v(
                              "\n          " + _vm._s(_vm.cancel) + "\n        "
                            )
                          ]
                        )
                      : _vm._e(),
                    _vm._v(" "),
                    _c(
                      "button",
                      {
                        ref: "defaultButton",
                        staticClass: "mdc-button mdc-dialog__button ",
                        attrs: {
                          type: "button",
                          disabled: _vm.acceptDisabled,
                          "data-mdc-dialog-action": "yes"
                        }
                      },
                      [_vm._v("\n          " + _vm._s(_vm.accept) + "\n        ")]
                    )
                  ])
                : _vm._e()
            ]
          )
        ]),
        _vm._v(" "),
        _c("div", { staticClass: "mdc-dialog__scrim" })
      ]
    )
  };
  var __vue_staticRenderFns__$f = [];
  __vue_render__$f._withStripped = true;

    /* style */
    const __vue_inject_styles__$i = undefined;
    /* scoped */
    const __vue_scope_id__$i = undefined;
    /* module identifier */
    const __vue_module_identifier__$i = undefined;
    /* functional template */
    const __vue_is_functional_template__$i = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDialog = normalizeComponent(
      { render: __vue_render__$f, staticRenderFns: __vue_staticRenderFns__$f },
      __vue_inject_styles__$i,
      __vue_script__$i,
      __vue_scope_id__$i,
      __vue_is_functional_template__$i,
      __vue_module_identifier__$i,
      undefined,
      undefined
    );

  var VueMDCDialog = BasePlugin({
    mdcDialog: mdcDialog
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Drawer
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Drawer into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCDrawerAdapter =
  /*#__PURE__*/
  function () {
    function MDCDrawerAdapter() {
      _classCallCheck(this, MDCDrawerAdapter);
    }

    _createClass(MDCDrawerAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * @param {!Element} element target element to verify class name
       * @param {string} className class name
       */

    }, {
      key: "elementHasClass",
      value: function elementHasClass(element, className) {}
      /**
       * Saves the focus of currently active element.
       */

    }, {
      key: "saveFocus",
      value: function saveFocus() {}
      /**
       * Restores focus to element previously saved with 'saveFocus'.
       */

    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}
      /**
       * Focuses the active / selected navigation item.
       */

    }, {
      key: "focusActiveNavigationItem",
      value: function focusActiveNavigationItem() {}
      /**
       * Emits a custom event "MDCDrawer:closed" denoting the drawer has closed.
       */

    }, {
      key: "notifyClose",
      value: function notifyClose() {}
      /**
       * Emits a custom event "MDCDrawer:opened" denoting the drawer has opened.
       */

    }, {
      key: "notifyOpen",
      value: function notifyOpen() {}
      /**
       * Traps focus on root element and focuses the active navigation element.
       */

    }, {
      key: "trapFocus",
      value: function trapFocus() {}
      /**
       * Releases focus trap from root element which was set by `trapFocus`
       * and restores focus to where it was prior to calling `trapFocus`.
       */

    }, {
      key: "releaseFocus",
      value: function releaseFocus() {}
    }]);

    return MDCDrawerAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$7 = {
    ROOT: 'mdc-drawer',
    DISMISSIBLE: 'mdc-drawer--dismissible',
    MODAL: 'mdc-drawer--modal',
    OPEN: 'mdc-drawer--open',
    ANIMATE: 'mdc-drawer--animate',
    OPENING: 'mdc-drawer--opening',
    CLOSING: 'mdc-drawer--closing'
  };
  /** @enum {string} */

  var strings$7 = {
    APP_CONTENT_SELECTOR: '.mdc-drawer-app-content',
    SCRIM_SELECTOR: '.mdc-drawer-scrim',
    CLOSE_EVENT: 'MDCDrawer:closed',
    OPEN_EVENT: 'MDCDrawer:opened'
  };

  /**
   * @extends {MDCFoundation<!MDCDrawerAdapter>}
   */

  var MDCDismissibleDrawerFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCDismissibleDrawerFoundation, _MDCFoundation);

    _createClass(MDCDismissibleDrawerFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$7;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$7;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCDrawerAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass()
            /* className: string */
            {},
            elementHasClass: function elementHasClass()
            /* element: !Element, className: string */
            {},
            notifyClose: function notifyClose() {},
            notifyOpen: function notifyOpen() {},
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            focusActiveNavigationItem: function focusActiveNavigationItem() {},
            trapFocus: function trapFocus() {},
            releaseFocus: function releaseFocus() {}
          }
        );
      }
    }]);

    function MDCDismissibleDrawerFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCDismissibleDrawerFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCDismissibleDrawerFoundation).call(this, _extends(MDCDismissibleDrawerFoundation.defaultAdapter, adapter)));
      /** @private {number} */

      _this.animationFrame_ = 0;
      /** @private {number} */

      _this.animationTimer_ = 0;
      return _this;
    }

    _createClass(MDCDismissibleDrawerFoundation, [{
      key: "destroy",
      value: function destroy() {
        if (this.animationFrame_) {
          cancelAnimationFrame(this.animationFrame_);
        }

        if (this.animationTimer_) {
          clearTimeout(this.animationTimer_);
        }
      }
      /**
       * Function to open the drawer.
       */

    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        if (this.isOpen() || this.isOpening() || this.isClosing()) {
          return;
        }

        this.adapter_.addClass(cssClasses$7.OPEN);
        this.adapter_.addClass(cssClasses$7.ANIMATE); // Wait a frame once display is no longer "none", to establish basis for animation

        this.runNextAnimationFrame_(function () {
          _this2.adapter_.addClass(cssClasses$7.OPENING);
        });
        this.adapter_.saveFocus();
      }
      /**
       * Function to close the drawer.
       */

    }, {
      key: "close",
      value: function close() {
        if (!this.isOpen() || this.isOpening() || this.isClosing()) {
          return;
        }

        this.adapter_.addClass(cssClasses$7.CLOSING);
      }
      /**
       * Extension point for when drawer finishes open animation.
       * @protected
       */

    }, {
      key: "opened",
      value: function opened() {}
      /**
       * Extension point for when drawer finishes close animation.
       * @protected
       */

    }, {
      key: "closed",
      value: function closed() {}
      /**
       * Returns true if drawer is in open state.
       * @return {boolean}
       */

    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.adapter_.hasClass(cssClasses$7.OPEN);
      }
      /**
       * Returns true if drawer is animating open.
       * @return {boolean}
       */

    }, {
      key: "isOpening",
      value: function isOpening() {
        return this.adapter_.hasClass(cssClasses$7.OPENING) || this.adapter_.hasClass(cssClasses$7.ANIMATE);
      }
      /**
       * Returns true if drawer is animating closed.
       * @return {boolean}
       */

    }, {
      key: "isClosing",
      value: function isClosing() {
        return this.adapter_.hasClass(cssClasses$7.CLOSING);
      }
      /**
       * Keydown handler to close drawer when key is escape.
       * @param evt
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt) {
        var keyCode = evt.keyCode,
            key = evt.key;
        var isEscape = key === 'Escape' || keyCode === 27;

        if (isEscape) {
          this.close();
        }
      }
      /**
       * Handles a transition end event on the root element.
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        var OPENING = cssClasses$7.OPENING,
            CLOSING = cssClasses$7.CLOSING,
            OPEN = cssClasses$7.OPEN,
            ANIMATE = cssClasses$7.ANIMATE,
            ROOT = cssClasses$7.ROOT; // In Edge, transitionend on ripple pseudo-elements yields a target without classList, so check for Element first.

        var isElement = evt.target instanceof Element;

        if (!isElement || !this.adapter_.elementHasClass(
        /** @type {!Element} */
        evt.target, ROOT)) {
          return;
        }

        if (this.isClosing()) {
          this.adapter_.removeClass(OPEN);
          this.adapter_.restoreFocus();
          this.closed();
          this.adapter_.notifyClose();
        } else {
          this.adapter_.focusActiveNavigationItem();
          this.opened();
          this.adapter_.notifyOpen();
        }

        this.adapter_.removeClass(ANIMATE);
        this.adapter_.removeClass(OPENING);
        this.adapter_.removeClass(CLOSING);
      }
      /**
       * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
       * @param {Function} callback
       * @private
       */

    }, {
      key: "runNextAnimationFrame_",
      value: function runNextAnimationFrame_(callback) {
        var _this3 = this;

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
          _this3.animationFrame_ = 0;
          clearTimeout(_this3.animationTimer_);
          _this3.animationTimer_ = setTimeout(callback, 0);
        });
      }
    }]);

    return MDCDismissibleDrawerFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCDismissibleDrawerFoundation}
   */

  var MDCModalDrawerFoundation =
  /*#__PURE__*/
  function (_MDCDismissibleDrawer) {
    _inherits(MDCModalDrawerFoundation, _MDCDismissibleDrawer);

    function MDCModalDrawerFoundation() {
      _classCallCheck(this, MDCModalDrawerFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCModalDrawerFoundation).apply(this, arguments));
    }

    _createClass(MDCModalDrawerFoundation, [{
      key: "opened",

      /**
       * Called when drawer finishes open animation.
       * @override
       */
      value: function opened() {
        this.adapter_.trapFocus();
      }
      /**
       * Called when drawer finishes close animation.
       * @override
       */

    }, {
      key: "closed",
      value: function closed() {
        this.adapter_.releaseFocus();
      }
      /**
       * Handles click event on scrim.
       */

    }, {
      key: "handleScrimClick",
      value: function handleScrimClick() {
        this.close();
      }
    }]);

    return MDCModalDrawerFoundation;
  }(MDCDismissibleDrawerFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC List. Provides an interface for managing focus.
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCListAdapter =
  /*#__PURE__*/
  function () {
    function MDCListAdapter() {
      _classCallCheck(this, MDCListAdapter);
    }

    _createClass(MDCListAdapter, [{
      key: "getListItemCount",

      /** @return {number} */
      value: function getListItemCount() {}
      /**
       * @return {number} */

    }, {
      key: "getFocusedElementIndex",
      value: function getFocusedElementIndex() {}
      /**
       * @param {number} index
       * @param {string} attribute
       * @param {string} value
       */

    }, {
      key: "setAttributeForElementIndex",
      value: function setAttributeForElementIndex(index, attribute, value) {}
      /**
       * @param {number} index
       * @param {string} attribute
       */

    }, {
      key: "removeAttributeForElementIndex",
      value: function removeAttributeForElementIndex(index, attribute) {}
      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "addClassForElementIndex",
      value: function addClassForElementIndex(index, className) {}
      /**
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "removeClassForElementIndex",
      value: function removeClassForElementIndex(index, className) {}
      /**
       * Focuses list item at the index specified.
       * @param {number} index
       */

    }, {
      key: "focusItemAtIndex",
      value: function focusItemAtIndex(index) {}
      /**
       * Sets the tabindex to the value specified for all button/a element children of
       * the list item at the index specified.
       * @param {number} listItemIndex
       * @param {number} tabIndexValue
       */

    }, {
      key: "setTabIndexForListItemChildren",
      value: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {}
      /**
       * If the given element has an href, follows the link.
       * @param {!Element} ele
       */

    }, {
      key: "followHref",
      value: function followHref(ele) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if radio button is present at given list item index.
       */

    }, {
      key: "hasRadioAtIndex",
      value: function hasRadioAtIndex(index) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if checkbox is present at given list item index.
       */

    }, {
      key: "hasCheckboxAtIndex",
      value: function hasCheckboxAtIndex(index) {}
      /**
       * @param {number} index
       * @return {boolean} Returns true if checkbox inside a list item is checked.
       */

    }, {
      key: "isCheckboxCheckedAtIndex",
      value: function isCheckboxCheckedAtIndex(index) {}
      /**
       * Sets the checked status of checkbox or radio at given list item index.
       * @param {number} index
       * @param {boolean} isChecked
       */

    }, {
      key: "setCheckedCheckboxOrRadioAtIndex",
      value: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {}
      /**
       * @return {boolean} Returns true when the current focused element is inside list root.
       */

    }, {
      key: "isFocusInsideList",
      value: function isFocusInsideList() {}
    }]);

    return MDCListAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$8 = {
    ROOT: 'mdc-list',
    LIST_ITEM_CLASS: 'mdc-list-item',
    LIST_ITEM_SELECTED_CLASS: 'mdc-list-item--selected',
    LIST_ITEM_ACTIVATED_CLASS: 'mdc-list-item--activated'
  };
  /** @enum {string} */

  var strings$8 = {
    ARIA_ORIENTATION: 'aria-orientation',
    ARIA_ORIENTATION_HORIZONTAL: 'horizontal',
    ARIA_SELECTED: 'aria-selected',
    ARIA_CHECKED: 'aria-checked',
    ARIA_CHECKED_RADIO_SELECTOR: '[role="radio"][aria-checked="true"]',
    ARIA_ROLE_CHECKBOX_SELECTOR: '[role="checkbox"]',
    ARIA_CHECKED_CHECKBOX_SELECTOR: '[role="checkbox"][aria-checked="true"]',
    RADIO_SELECTOR: 'input[type="radio"]:not(:disabled)',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]:not(:disabled)',
    CHECKBOX_RADIO_SELECTOR: 'input[type="checkbox"]:not(:disabled), input[type="radio"]:not(:disabled)',
    CHILD_ELEMENTS_TO_TOGGLE_TABINDEX: ".".concat(cssClasses$8.LIST_ITEM_CLASS, " button:not(:disabled),\n  .").concat(cssClasses$8.LIST_ITEM_CLASS, " a"),
    FOCUSABLE_CHILD_ELEMENTS: ".".concat(cssClasses$8.LIST_ITEM_CLASS, " button:not(:disabled), .").concat(cssClasses$8.LIST_ITEM_CLASS, " a,\n  .").concat(cssClasses$8.LIST_ITEM_CLASS, " input[type=\"radio\"]:not(:disabled),\n  .").concat(cssClasses$8.LIST_ITEM_CLASS, " input[type=\"checkbox\"]:not(:disabled)"),
    ENABLED_ITEMS_SELECTOR: '.mdc-list-item:not(.mdc-list-item--disabled)'
  };

  var ELEMENTS_KEY_ALLOWED_IN = ['input', 'button', 'textarea', 'select'];

  var MDCListFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCListFoundation, _MDCFoundation);

    _createClass(MDCListFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$8;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$8;
      }
      /**
       * {@see MDCListAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCListAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCListAdapter} */
          {
            getListItemCount: function getListItemCount() {},
            getFocusedElementIndex: function getFocusedElementIndex() {},
            setAttributeForElementIndex: function setAttributeForElementIndex() {},
            removeAttributeForElementIndex: function removeAttributeForElementIndex() {},
            addClassForElementIndex: function addClassForElementIndex() {},
            removeClassForElementIndex: function removeClassForElementIndex() {},
            focusItemAtIndex: function focusItemAtIndex() {},
            setTabIndexForListItemChildren: function setTabIndexForListItemChildren() {},
            followHref: function followHref() {},
            hasRadioAtIndex: function hasRadioAtIndex() {},
            hasCheckboxAtIndex: function hasCheckboxAtIndex() {},
            isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex() {},
            setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex() {},
            isFocusInsideList: function isFocusInsideList() {}
          }
        );
      }
      /**
       * @param {!MDCListAdapter=} adapter
       */

    }]);

    function MDCListFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCListFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCListFoundation).call(this, _extends(MDCListFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.wrapFocus_ = false;
      /** @private {boolean} */

      _this.isVertical_ = true;
      /** @private {boolean} */

      _this.isSingleSelectionList_ = false;
      /** @private {!Index} */

      _this.selectedIndex_ = -1;
      /** @private {number} */

      _this.focusedItemIndex_ = -1;
      /** @private {boolean} */

      _this.useActivatedClass_ = false;
      /** @private {boolean} */

      _this.isCheckboxList_ = false;
      /** @private {boolean} */

      _this.isRadioList_ = false;
      return _this;
    }

    _createClass(MDCListFoundation, [{
      key: "layout",
      value: function layout() {
        if (this.adapter_.getListItemCount() === 0) return;

        if (this.adapter_.hasCheckboxAtIndex(0)) {
          this.isCheckboxList_ = true;
        } else if (this.adapter_.hasRadioAtIndex(0)) {
          this.isRadioList_ = true;
        }
      }
      /**
       * Sets the private wrapFocus_ variable.
       * @param {boolean} value
       */

    }, {
      key: "setWrapFocus",
      value: function setWrapFocus(value) {
        this.wrapFocus_ = value;
      }
      /**
       * Sets the isVertical_ private variable.
       * @param {boolean} value
       */

    }, {
      key: "setVerticalOrientation",
      value: function setVerticalOrientation(value) {
        this.isVertical_ = value;
      }
      /**
       * Sets the isSingleSelectionList_ private variable.
       * @param {boolean} value
       */

    }, {
      key: "setSingleSelection",
      value: function setSingleSelection(value) {
        this.isSingleSelectionList_ = value;
      }
      /**
       * Sets the useActivatedClass_ private variable.
       * @param {boolean} useActivated
       */

    }, {
      key: "setUseActivatedClass",
      value: function setUseActivatedClass(useActivated) {
        this.useActivatedClass_ = useActivated;
      }
      /** @return {!Index} */

    }, {
      key: "getSelectedIndex",
      value: function getSelectedIndex() {
        return this.selectedIndex_;
      }
      /** @param {!Index} index */

    }, {
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {
        if (!this.isIndexValid_(index)) return;

        if (this.isCheckboxList_) {
          this.setCheckboxAtIndex_(
          /** @type {!Array<number>} */
          index);
        } else if (this.isRadioList_) {
          this.setRadioAtIndex_(
          /** @type {number} */
          index);
        } else {
          this.setSingleSelectionAtIndex_(
          /** @type {number} */
          index);
        }
      }
      /**
       * Focus in handler for the list items.
       * @param evt
       * @param {number} listItemIndex
       */

    }, {
      key: "handleFocusIn",
      value: function handleFocusIn(evt, listItemIndex) {
        if (listItemIndex >= 0) {
          this.adapter_.setTabIndexForListItemChildren(listItemIndex, 0);
        }
      }
      /**
       * Focus out handler for the list items.
       * @param {Event} evt
       * @param {number} listItemIndex
       */

    }, {
      key: "handleFocusOut",
      value: function handleFocusOut(evt, listItemIndex) {
        var _this2 = this;

        if (listItemIndex >= 0) {
          this.adapter_.setTabIndexForListItemChildren(listItemIndex, -1);
        }
        /**
         * Between Focusout & Focusin some browsers do not have focus on any element. Setting a delay to wait till the focus
         * is moved to next element.
         */


        setTimeout(function () {
          if (!_this2.adapter_.isFocusInsideList()) {
            _this2.setTabindexToFirstSelectedItem_();
          }
        }, 0);
      }
      /**
       * Key handler for the list.
       * @param {Event} evt
       * @param {boolean} isRootListItem
       * @param {number} listItemIndex
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt, isRootListItem, listItemIndex) {
        var arrowLeft = evt.key === 'ArrowLeft' || evt.keyCode === 37;
        var arrowUp = evt.key === 'ArrowUp' || evt.keyCode === 38;
        var arrowRight = evt.key === 'ArrowRight' || evt.keyCode === 39;
        var arrowDown = evt.key === 'ArrowDown' || evt.keyCode === 40;
        var isHome = evt.key === 'Home' || evt.keyCode === 36;
        var isEnd = evt.key === 'End' || evt.keyCode === 35;
        var isEnter = evt.key === 'Enter' || evt.keyCode === 13;
        var isSpace = evt.key === 'Space' || evt.keyCode === 32;
        var currentIndex = this.adapter_.getFocusedElementIndex();
        var nextIndex = -1;

        if (currentIndex === -1) {
          currentIndex = listItemIndex;

          if (currentIndex < 0) {
            // If this event doesn't have a mdc-list-item ancestor from the
            // current list (not from a sublist), return early.
            return;
          }
        }

        if (this.isVertical_ && arrowDown || !this.isVertical_ && arrowRight) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusNextElement(currentIndex);
        } else if (this.isVertical_ && arrowUp || !this.isVertical_ && arrowLeft) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusPrevElement(currentIndex);
        } else if (isHome) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusFirstElement();
        } else if (isEnd) {
          this.preventDefaultEvent_(evt);
          nextIndex = this.focusLastElement();
        } else if (isEnter || isSpace) {
          if (isRootListItem) {
            if (this.isSelectableList_()) {
              this.setSelectedIndexOnAction_(currentIndex);
              this.preventDefaultEvent_(evt);
            } // Explicitly activate links, since we're preventing default on Enter, and Space doesn't activate them.


            this.adapter_.followHref(currentIndex);
          }
        }

        this.focusedItemIndex_ = currentIndex;

        if (nextIndex >= 0) {
          this.setTabindexAtIndex_(nextIndex);
          this.focusedItemIndex_ = nextIndex;
        }
      }
      /**
       * Click handler for the list.
       * @param {number} index
       * @param {boolean} toggleCheckbox
       */

    }, {
      key: "handleClick",
      value: function handleClick(index, toggleCheckbox) {
        if (index === -1) return;

        if (this.isSelectableList_()) {
          this.setSelectedIndexOnAction_(index, toggleCheckbox);
        }

        this.setTabindexAtIndex_(index);
        this.focusedItemIndex_ = index;
      }
      /**
       * Ensures that preventDefault is only called if the containing element doesn't
       * consume the event, and it will cause an unintended scroll.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "preventDefaultEvent_",
      value: function preventDefaultEvent_(evt) {
        var tagName = "".concat(evt.target.tagName).toLowerCase();

        if (ELEMENTS_KEY_ALLOWED_IN.indexOf(tagName) === -1) {
          evt.preventDefault();
        }
      }
      /**
       * Focuses the next element on the list.
       * @param {number} index
       * @return {number}
       */

    }, {
      key: "focusNextElement",
      value: function focusNextElement(index) {
        var count = this.adapter_.getListItemCount();
        var nextIndex = index + 1;

        if (nextIndex >= count) {
          if (this.wrapFocus_) {
            nextIndex = 0;
          } else {
            // Return early because last item is already focused.
            return index;
          }
        }

        this.adapter_.focusItemAtIndex(nextIndex);
        return nextIndex;
      }
      /**
       * Focuses the previous element on the list.
       * @param {number} index
       * @return {number}
       */

    }, {
      key: "focusPrevElement",
      value: function focusPrevElement(index) {
        var prevIndex = index - 1;

        if (prevIndex < 0) {
          if (this.wrapFocus_) {
            prevIndex = this.adapter_.getListItemCount() - 1;
          } else {
            // Return early because first item is already focused.
            return index;
          }
        }

        this.adapter_.focusItemAtIndex(prevIndex);
        return prevIndex;
      }
      /**
       * @return {number}
       */

    }, {
      key: "focusFirstElement",
      value: function focusFirstElement() {
        this.adapter_.focusItemAtIndex(0);
        return 0;
      }
      /**
       * @return {number}
       */

    }, {
      key: "focusLastElement",
      value: function focusLastElement() {
        var lastIndex = this.adapter_.getListItemCount() - 1;
        this.adapter_.focusItemAtIndex(lastIndex);
        return lastIndex;
      }
      /**
       * @param {number} index
       * @private
       */

    }, {
      key: "setSingleSelectionAtIndex_",
      value: function setSingleSelectionAtIndex_(index) {
        var selectedClassName = cssClasses$8.LIST_ITEM_SELECTED_CLASS;

        if (this.useActivatedClass_) {
          selectedClassName = cssClasses$8.LIST_ITEM_ACTIVATED_CLASS;
        }

        if (this.selectedIndex_ >= 0 && this.selectedIndex_ !== index) {
          this.adapter_.removeClassForElementIndex(this.selectedIndex_, selectedClassName);
          this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$8.ARIA_SELECTED, 'false');
        }

        this.adapter_.addClassForElementIndex(index, selectedClassName);
        this.adapter_.setAttributeForElementIndex(index, strings$8.ARIA_SELECTED, 'true');
        this.selectedIndex_ = index;
      }
      /**
       * Toggles radio at give index. Radio doesn't change the checked state if it is already checked.
       * @param {number} index
       * @private
       */

    }, {
      key: "setRadioAtIndex_",
      value: function setRadioAtIndex_(index) {
        this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, true);

        if (this.selectedIndex_ >= 0) {
          this.adapter_.setAttributeForElementIndex(this.selectedIndex_, strings$8.ARIA_CHECKED, 'false');
        }

        this.adapter_.setAttributeForElementIndex(index, strings$8.ARIA_CHECKED, 'true');
        this.selectedIndex_ = index;
      }
      /**
       * @param {!Array<number>} index
       * @private
       */

    }, {
      key: "setCheckboxAtIndex_",
      value: function setCheckboxAtIndex_(index) {
        for (var i = 0; i < this.adapter_.getListItemCount(); i++) {
          var isChecked = false;

          if (index.indexOf(i) >= 0) {
            isChecked = true;
          }

          this.adapter_.setCheckedCheckboxOrRadioAtIndex(i, isChecked);
          this.adapter_.setAttributeForElementIndex(i, strings$8.ARIA_CHECKED, isChecked ? 'true' : 'false');
        }

        this.selectedIndex_ = index;
      }
      /**
       * @param {number} index
       * @private
       */

    }, {
      key: "setTabindexAtIndex_",
      value: function setTabindexAtIndex_(index) {
        if (this.focusedItemIndex_ === -1 && index !== 0) {
          // If no list item was selected set first list item's tabindex to -1.
          // Generally, tabindex is set to 0 on first list item of list that has no preselected items.
          this.adapter_.setAttributeForElementIndex(0, 'tabindex', -1);
        } else if (this.focusedItemIndex_ >= 0 && this.focusedItemIndex_ !== index) {
          this.adapter_.setAttributeForElementIndex(this.focusedItemIndex_, 'tabindex', -1);
        }

        this.adapter_.setAttributeForElementIndex(index, 'tabindex', 0);
      }
      /**
       * @return {boolean} Return true if it is single selectin list, checkbox list or radio list.
       * @private
       */

    }, {
      key: "isSelectableList_",
      value: function isSelectableList_() {
        return this.isSingleSelectionList_ || this.isCheckboxList_ || this.isRadioList_;
      }
      /** @private */

    }, {
      key: "setTabindexToFirstSelectedItem_",
      value: function setTabindexToFirstSelectedItem_() {
        var targetIndex = 0;

        if (this.isSelectableList_()) {
          if (typeof this.selectedIndex_ === 'number' && this.selectedIndex_ !== -1) {
            targetIndex = this.selectedIndex_;
          } else if (this.selectedIndex_ instanceof Array && this.selectedIndex_.length > 0) {
            targetIndex = this.selectedIndex_.reduce(function (currentIndex, minIndex) {
              return Math.min(currentIndex, minIndex);
            });
          }
        }

        this.setTabindexAtIndex_(targetIndex);
      }
      /**
       * @param {!Index} index
       * @return {boolean}
       * @private
       */

    }, {
      key: "isIndexValid_",
      value: function isIndexValid_(index) {
        var _this3 = this;

        if (index instanceof Array) {
          if (!this.isCheckboxList_) {
            throw new Error('MDCListFoundation: Array of index is only supported for checkbox based list');
          }

          if (index.length === 0) {
            return true;
          } else {
            return index.some(function (i) {
              return _this3.isIndexInRange_(i);
            });
          }
        } else if (typeof index === 'number') {
          if (this.isCheckboxList_) {
            throw new Error('MDCListFoundation: Expected array of index for checkbox based list but got number: ' + index);
          }

          return this.isIndexInRange_(index);
        } else {
          return false;
        }
      }
      /**
       * @param {number} index
       * @return {boolean}
       * @private
       */

    }, {
      key: "isIndexInRange_",
      value: function isIndexInRange_(index) {
        var listSize = this.adapter_.getListItemCount();
        return index >= 0 && index < listSize;
      }
      /**
       * @param {number} index
       * @param {boolean=} toggleCheckbox
       * @private
       */

    }, {
      key: "setSelectedIndexOnAction_",
      value: function setSelectedIndexOnAction_(index) {
        var toggleCheckbox = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

        if (this.isCheckboxList_) {
          this.toggleCheckboxAtIndex_(index, toggleCheckbox);
        } else {
          this.setSelectedIndex(index);
        }
      }
      /**
       * @param {number} index
       * @param {boolean} toggleCheckbox
       * @private
       */

    }, {
      key: "toggleCheckboxAtIndex_",
      value: function toggleCheckboxAtIndex_(index, toggleCheckbox) {
        var isChecked = this.adapter_.isCheckboxCheckedAtIndex(index);

        if (toggleCheckbox) {
          isChecked = !isChecked;
          this.adapter_.setCheckedCheckboxOrRadioAtIndex(index, isChecked);
        }

        this.adapter_.setAttributeForElementIndex(index, strings$8.ARIA_CHECKED, isChecked ? 'true' : 'false'); // If none of the checkbox items are selected and selectedIndex is not initialized then provide a default value.

        if (this.selectedIndex_ === -1) {
          this.selectedIndex_ = [];
        }

        if (isChecked) {
          this.selectedIndex_.push(index);
        } else {
          this.selectedIndex_ = this.selectedIndex_.filter(function (i) {
            return i !== index;
          });
        }
      }
    }]);

    return MDCListFoundation;
  }(MDCFoundation);

  /**
   * @extends MDCComponent<!MDCListFoundation>
   */

  var MDCList =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCList, _MDCComponent);

    /** @param {...?} args */
    function MDCList() {
      var _getPrototypeOf2;

      var _this;

      _classCallCheck(this, MDCList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(MDCList)).call.apply(_getPrototypeOf2, [this].concat(args)));
      /** @private {!Function} */

      _this.handleKeydown_;
      /** @private {!Function} */

      _this.handleClick_;
      /** @private {!Function} */

      _this.focusInEventListener_;
      /** @private {!Function} */

      _this.focusOutEventListener_;
      return _this;
    }
    /**
     * @param {!Element} root
     * @return {!MDCList}
     */


    _createClass(MDCList, [{
      key: "destroy",
      value: function destroy() {
        this.root_.removeEventListener('keydown', this.handleKeydown_);
        this.root_.removeEventListener('click', this.handleClick_);
        this.root_.removeEventListener('focusin', this.focusInEventListener_);
        this.root_.removeEventListener('focusout', this.focusOutEventListener_);
      }
    }, {
      key: "initialSyncWithDOM",
      value: function initialSyncWithDOM() {
        this.handleClick_ = this.handleClickEvent_.bind(this);
        this.handleKeydown_ = this.handleKeydownEvent_.bind(this);
        this.focusInEventListener_ = this.handleFocusInEvent_.bind(this);
        this.focusOutEventListener_ = this.handleFocusOutEvent_.bind(this);
        this.root_.addEventListener('keydown', this.handleKeydown_);
        this.root_.addEventListener('focusin', this.focusInEventListener_);
        this.root_.addEventListener('focusout', this.focusOutEventListener_);
        this.root_.addEventListener('click', this.handleClick_);
        this.layout();
        this.initializeListType();
      }
    }, {
      key: "layout",
      value: function layout() {
        var direction = this.root_.getAttribute(strings$8.ARIA_ORIENTATION);
        this.vertical = direction !== strings$8.ARIA_ORIENTATION_HORIZONTAL; // List items need to have at least tabindex=-1 to be focusable.

        [].slice.call(this.root_.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
          ele.setAttribute('tabindex', -1);
        }); // Child button/a elements are not tabbable until the list item is focused.

        [].slice.call(this.root_.querySelectorAll(strings$8.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
          return ele.setAttribute('tabindex', -1);
        });
        this.foundation_.layout();
      }
      /**
       * Used to figure out which list item this event is targetting. Or returns -1 if
       * there is no list item
       * @param {Event} evt
       * @private
       */

    }, {
      key: "getListItemIndex_",
      value: function getListItemIndex_(evt) {
        var eventTarget =
        /** @type {HTMLElement} */
        evt.target;
        var index = -1; // Find the first ancestor that is a list item or the list.

        while (!eventTarget.classList.contains(cssClasses$8.LIST_ITEM_CLASS) && !eventTarget.classList.contains(cssClasses$8.ROOT)) {
          eventTarget = eventTarget.parentElement;
        } // Get the index of the element if it is a list item.


        if (eventTarget.classList.contains(cssClasses$8.LIST_ITEM_CLASS)) {
          index = this.listElements.indexOf(eventTarget);
        }

        return index;
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleFocusInEvent_",
      value: function handleFocusInEvent_(evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusIn(evt, index);
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleFocusOutEvent_",
      value: function handleFocusOutEvent_(evt) {
        var index = this.getListItemIndex_(evt);
        this.foundation_.handleFocusOut(evt, index);
      }
      /**
       * Used to figure out which element was focused when keydown event occurred before sending the event to the
       * foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleKeydownEvent_",
      value: function handleKeydownEvent_(evt) {
        var index = this.getListItemIndex_(evt);

        if (index >= 0) {
          this.foundation_.handleKeydown(evt, evt.target.classList.contains(cssClasses$8.LIST_ITEM_CLASS), index);
        }
      }
      /**
       * Used to figure out which element was clicked before sending the event to the foundation.
       * @param {Event} evt
       * @private
       */

    }, {
      key: "handleClickEvent_",
      value: function handleClickEvent_(evt) {
        var index = this.getListItemIndex_(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

        var toggleCheckbox = !matches$1(
        /** @type {!Element} */
        evt.target, strings$8.CHECKBOX_RADIO_SELECTOR);
        this.foundation_.handleClick(index, toggleCheckbox);
      }
      /**
       * Initialize selectedIndex value based on pre-selected checkbox list items, single selection or radio.
       */

    }, {
      key: "initializeListType",
      value: function initializeListType() {
        var _this2 = this;

        var checkboxListItems = this.root_.querySelectorAll(strings$8.ARIA_ROLE_CHECKBOX_SELECTOR);
        var singleSelectedListItem = this.root_.querySelector(".".concat(cssClasses$8.LIST_ITEM_ACTIVATED_CLASS, ",\n        .").concat(cssClasses$8.LIST_ITEM_SELECTED_CLASS));
        var radioSelectedListItem = this.root_.querySelector(strings$8.ARIA_CHECKED_RADIO_SELECTOR);

        if (checkboxListItems.length) {
          var preselectedItems = this.root_.querySelectorAll(strings$8.ARIA_CHECKED_CHECKBOX_SELECTOR);
          this.selectedIndex = [].map.call(preselectedItems, function (listItem) {
            return _this2.listElements.indexOf(listItem);
          });
        } else if (singleSelectedListItem) {
          if (singleSelectedListItem.classList.contains(cssClasses$8.LIST_ITEM_ACTIVATED_CLASS)) {
            this.foundation_.setUseActivatedClass(true);
          }

          this.singleSelection = true;
          this.selectedIndex = this.listElements.indexOf(singleSelectedListItem);
        } else if (radioSelectedListItem) {
          this.selectedIndex = this.listElements.indexOf(radioSelectedListItem);
        }
      }
      /** @param {boolean} value */

    }, {
      key: "getDefaultFoundation",

      /** @return {!MDCListFoundation} */
      value: function getDefaultFoundation() {
        var _this3 = this;

        return new MDCListFoundation(
        /** @type {!MDCListAdapter} */
        _extends({
          getListItemCount: function getListItemCount() {
            return _this3.listElements.length;
          },
          getFocusedElementIndex: function getFocusedElementIndex() {
            return _this3.listElements.indexOf(document.activeElement);
          },
          setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
            var element = _this3.listElements[index];

            if (element) {
              element.setAttribute(attr, value);
            }
          },
          removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
            var element = _this3.listElements[index];

            if (element) {
              element.removeAttribute(attr);
            }
          },
          addClassForElementIndex: function addClassForElementIndex(index, className) {
            var element = _this3.listElements[index];

            if (element) {
              element.classList.add(className);
            }
          },
          removeClassForElementIndex: function removeClassForElementIndex(index, className) {
            var element = _this3.listElements[index];

            if (element) {
              element.classList.remove(className);
            }
          },
          focusItemAtIndex: function focusItemAtIndex(index) {
            var element = _this3.listElements[index];

            if (element) {
              element.focus();
            }
          },
          setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
            var element = _this3.listElements[listItemIndex];
            var listItemChildren = [].slice.call(element.querySelectorAll(strings$8.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
            listItemChildren.forEach(function (ele) {
              return ele.setAttribute('tabindex', tabIndexValue);
            });
          },
          followHref: function followHref(index) {
            var listItem = _this3.listElements[index];

            if (listItem && listItem.href) {
              listItem.click();
            }
          },
          hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
            var listItem = _this3.listElements[index];
            return !!listItem.querySelector(strings$8.CHECKBOX_SELECTOR);
          },
          hasRadioAtIndex: function hasRadioAtIndex(index) {
            var listItem = _this3.listElements[index];
            return !!listItem.querySelector(strings$8.RADIO_SELECTOR);
          },
          isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
            var listItem = _this3.listElements[index];
            var toggleEl = listItem.querySelector(strings$8.CHECKBOX_SELECTOR);
            return toggleEl.checked;
          },
          setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
            var listItem = _this3.listElements[index];
            var toggleEl = listItem.querySelector(strings$8.CHECKBOX_RADIO_SELECTOR);
            toggleEl.checked = isChecked;
            var event = document.createEvent('Event');
            event.initEvent('change', true, true);
            toggleEl.dispatchEvent(event);
          },
          isFocusInsideList: function isFocusInsideList() {
            return _this3.root_.contains(document.activeElement);
          }
        }));
      }
    }, {
      key: "vertical",
      set: function set(value) {
        this.foundation_.setVerticalOrientation(value);
      }
      /** @return Array<!Element>*/

    }, {
      key: "listElements",
      get: function get() {
        return [].slice.call(this.root_.querySelectorAll(strings$8.ENABLED_ITEMS_SELECTOR));
      }
      /** @param {boolean} value */

    }, {
      key: "wrapFocus",
      set: function set(value) {
        this.foundation_.setWrapFocus(value);
      }
      /** @param {boolean} isSingleSelectionList */

    }, {
      key: "singleSelection",
      set: function set(isSingleSelectionList) {
        this.foundation_.setSingleSelection(isSingleSelectionList);
      }
      /** @return {!Index} */

    }, {
      key: "selectedIndex",
      get: function get() {
        return this.foundation_.getSelectedIndex();
      }
      /** @param {!Index} index */
      ,
      set: function set(index) {
        this.foundation_.setSelectedIndex(index);
      }
    }], [{
      key: "attachTo",
      value: function attachTo(root) {
        return new MDCList(root);
      }
    }]);

    return MDCList;
  }(MDCComponent);

  var media = new (
  /*#__PURE__*/
  function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    _createClass(_class, [{
      key: "small",
      get: function get() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: "large",
      get: function get() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);

    return _class;
  }())();
  var script$j = {
    name: 'mdc-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      modal: Boolean,
      open: Boolean,
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: {
        type: Object,
        required: false
      },
      openOn: String,
      openOnSource: {
        type: Object,
        required: false
      },
      closeOn: String,
      closeOnSource: {
        type: Object,
        required: false
      }
    },
    provide: function provide() {
      return {
        mdcDrawer: this
      };
    },
    data: function data() {
      return {
        // open_: false,
        classes: {}
      };
    },
    computed: {
      type: function type() {},
      isModal: function isModal() {
        return this.modal;
      }
    },
    watch: {
      open: 'onOpen_'
    },
    mounted: function mounted() {
      var _this = this;

      this.drawer_ = this.$refs.drawer;
      var adapter = {
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.drawer_.classList.contains(className);
        },
        elementHasClass: function elementHasClass(element, className) {
          return element.classList.contains(className);
        },
        saveFocus: function saveFocus() {
          _this.previousFocus_ = document.activeElement;
        },
        restoreFocus: function restoreFocus() {
          var previousFocus = _this.previousFocus_ && _this.previousFocus_.focus;

          if (_this.drawer_.contains(document.activeElement) && previousFocus) {
            _this.previousFocus_.focus();
          }
        },
        focusActiveNavigationItem: function focusActiveNavigationItem() {
          var activeNavItemEl = _this.drawer_.querySelector(".".concat(MDCListFoundation.cssClasses.LIST_ITEM_ACTIVATED_CLASS));

          if (activeNavItemEl) {
            activeNavItemEl.focus();
          }
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);

          _this.$emit('close');
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);

          _this.$emit('open');
        },
        trapFocus: function trapFocus() {
          return _this.focusTrap_.activate();
        },
        releaseFocus: function releaseFocus() {
          return _this.focusTrap_.deactivate();
        }
      };
      var _MDCDismissibleDrawer = MDCDismissibleDrawerFoundation.cssClasses,
          DISMISSIBLE = _MDCDismissibleDrawer.DISMISSIBLE,
          MODAL = _MDCDismissibleDrawer.MODAL;

      if (this.drawer_.classList.contains(DISMISSIBLE)) {
        this.foundation = new MDCDismissibleDrawerFoundation(adapter);
      } else if (this.drawer_.classList.contains(MODAL)) {
        this.foundation = new MDCModalDrawerFoundation(adapter);
      } else {
        throw new Error("MDCDrawer: Failed to instantiate component. Supported variants are ".concat(DISMISSIBLE, " and ").concat(MODAL, "."));
      }

      this.foundation && this.foundation.init();
      this.initialSyncWithDOM();

      if (this.toggleOn) {
        this.toggleOnEventSource = this.toggleOnSource || this.$root;
        this.toggleOnEventSource.$on(this.toggleOn, this.toggle);
      }

      if (this.openOn) {
        this.openOnEventSource = this.openOnSource || this.$root;
        this.openOnEventSource.$on(this.openOn, this.show);
      }

      if (this.closeOn) {
        this.closeOnEventSource = this.closeOnSource || this.$root;
        this.closeOnEventSource.$on(this.closeOn, this.close);
      } // media.small.addListener(this.refreshMedia)
      // media.large.addListener(this.refreshMedia)
      // this.$nextTick(() => this.refreshMedia())

    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null; // media.small.removeListener(this.refreshMedia)
      // media.large.removeListener(this.refreshMedia)

      if (this.toggleOnEventSource) {
        this.toggleOnEventSource.$off(this.toggleOn, this.toggle);
      }

      if (this.openOnEventSource) {
        this.openOnEventSource.$off(this.openOn, this.show);
      }

      if (this.closeOnEventSource) {
        this.closeOnEventSource.$off(this.closeOn, this.close);
      }
    },
    methods: {
      initialSyncWithDOM: function initialSyncWithDOM() {
        var _this2 = this;

        var MODAL = MDCDismissibleDrawerFoundation.cssClasses.MODAL;

        if (this.drawer_.classList.contains(MODAL)) {
          var SCRIM_SELECTOR = MDCDismissibleDrawerFoundation.strings.SCRIM_SELECTOR;
          this.scrim_ = this.drawer_.parentElement.querySelector(SCRIM_SELECTOR);

          this.handleScrimClick_ = function () {
            return _this2.foundation.handleScrimClick();
          };

          this.scrim_.addEventListener('click', this.handleScrimClick_);
          this.focusTrap_ = createFocusTrapInstance$1(this.drawer_, this.focusTrapFactory_);
        }

        this.handleKeydown_ = function (evt) {
          return _this2.foundation.handleKeydown(evt);
        };

        this.handleTransitionEnd_ = function (evt) {
          return _this2.foundation.handleTransitionEnd(evt);
        };

        this.$el.addEventListener('keydown', this.handleKeydown_);
        this.$el.addEventListener('transitionend', this.handleTransitionEnd_);
      },
      onOpen_: function onOpen_(value) {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      },
      onChange: function onChange(event) {
        this.$emit('change', event);
        this.$root.$emit('vma:layout');
      },
      show: function show() {
        this.foundation.open();
      },
      close: function close() {
        this.foundation.close();
      },
      toggle: function toggle() {
        this.foundation.isOpen() ? this.foundation.close() : this.foundation.open();
      },
      isOpen: function isOpen() {
        return this.foundation.isOpen();
      },
      refreshMedia: function refreshMedia() {// this.small = media.small.matches
        // this.large = media.large.matches
        // if (this.isResponsive) {
        //   if (this.large) {
        //     this.show()
        //   } else {
        //     this.close()
        //   }
        // }
      }
    }
  };

  function createFocusTrapInstance$1(surfaceEl) {
    var focusTrapFactory = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : focusTrap_1$1;
    return focusTrapFactory(surfaceEl, {
      clickOutsideDeactivates: true,
      initialFocus: false,
      // Navigation drawer handles focusing on active nav item.
      escapeDeactivates: false,
      // Navigation drawer handles ESC.
      returnFocusOnDeactivate: false // Navigation drawer handles restore focus.

    });
  }

  /* script */
  const __vue_script__$j = script$j;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$j.__file = "/ddata/extra/vma/components/drawer/mdc-drawer.vue";

  /* template */
  var __vue_render__$g = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c(
        "aside",
        {
          ref: "drawer",
          staticClass: "mdc-drawer mdc-drawer--modal",
          class: _vm.classes
        },
        [
          _vm.$slots["header"] ? _vm._t("header") : _vm._e(),
          _vm._v(" "),
          _c(
            "div",
            { staticClass: "mdc-drawer__content" },
            [_vm._t("default")],
            2
          )
        ],
        2
      ),
      _vm._v(" "),
      _c("div", { staticClass: "mdc-drawer-scrim" }),
      _vm._v(" "),
      _vm.toolbarSpacer
        ? _c("div", { staticClass: "mdc-top-app-bar--fixed-adjust" })
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$g = [];
  __vue_render__$g._withStripped = true;

    /* style */
    const __vue_inject_styles__$j = undefined;
    /* scoped */
    const __vue_scope_id__$j = undefined;
    /* module identifier */
    const __vue_module_identifier__$j = undefined;
    /* functional template */
    const __vue_is_functional_template__$j = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDrawer = normalizeComponent(
      { render: __vue_render__$g, staticRenderFns: __vue_staticRenderFns__$g },
      __vue_inject_styles__$j,
      __vue_script__$j,
      __vue_scope_id__$j,
      __vue_is_functional_template__$j,
      __vue_module_identifier__$j,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$k = {
    name: 'mdc-drawer-header'
  };

  /* script */
  const __vue_script__$k = script$k;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$k.__file = "/ddata/extra/vma/components/drawer/mdc-drawer-header.vue";

  /* template */
  var __vue_render__$h = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-drawer-header mdc-drawer__header" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$h = [];
  __vue_render__$h._withStripped = true;

    /* style */
    const __vue_inject_styles__$k = undefined;
    /* scoped */
    const __vue_scope_id__$k = undefined;
    /* module identifier */
    const __vue_module_identifier__$k = undefined;
    /* functional template */
    const __vue_is_functional_template__$k = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDrawerHeader = normalizeComponent(
      { render: __vue_render__$h, staticRenderFns: __vue_staticRenderFns__$h },
      __vue_inject_styles__$k,
      __vue_script__$k,
      __vue_scope_id__$k,
      __vue_is_functional_template__$k,
      __vue_module_identifier__$k,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var script$l = {
    name: 'mdc-drawer-list',
    props: {
      dense: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  /* script */
  const __vue_script__$l = script$l;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$l.__file = "/ddata/extra/vma/components/drawer/mdc-drawer-list.vue";

  /* template */
  var __vue_render__$i = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "nav",
      { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$i = [];
  __vue_render__$i._withStripped = true;

    /* style */
    const __vue_inject_styles__$l = undefined;
    /* scoped */
    const __vue_scope_id__$l = undefined;
    /* module identifier */
    const __vue_module_identifier__$l = undefined;
    /* functional template */
    const __vue_is_functional_template__$l = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDrawerList = normalizeComponent(
      { render: __vue_render__$i, staticRenderFns: __vue_staticRenderFns__$i },
      __vue_inject_styles__$l,
      __vue_script__$l,
      __vue_scope_id__$l,
      __vue_is_functional_template__$l,
      __vue_module_identifier__$l,
      undefined,
      undefined
    );

  var script$m = {
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      modalClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    computed: {
      mylisteners: function mylisteners() {
        var _this = this;

        return _objectSpread({}, this.$listeners, {
          click: function click(e) {
            _this.mdcDrawer.isModal && _this.modalClose && _this.mdcDrawer.close();

            _this.dispatchEvent(e);
          }
        });
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  /* script */
  const __vue_script__$m = script$m;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$m.__file = "/ddata/extra/vma/components/drawer/mdc-drawer-item.vue";

  /* template */
  var __vue_render__$j = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-link",
      _vm._g(
        {
          staticClass: "mdc-drawer-item mdc-list-item",
          class: [_vm.classes, _vm.itemClasses],
          style: _vm.styles,
          attrs: { link: _vm.link }
        },
        _vm.mylisteners
      ),
      [
        _vm.hasStartDetail
          ? _c(
              "span",
              { staticClass: "mdc-list-item__graphic" },
              [
                _vm._t("start-detail", [
                  _c(
                    "i",
                    {
                      staticClass: "material-icons",
                      attrs: { "aria-hidden": "true" }
                    },
                    [_vm._v(_vm._s(_vm.startIcon))]
                  )
                ])
              ],
              2
            )
          : _vm._e(),
        _vm._v(" "),
        _vm._t("default")
      ],
      2
    )
  };
  var __vue_staticRenderFns__$j = [];
  __vue_render__$j._withStripped = true;

    /* style */
    const __vue_inject_styles__$m = undefined;
    /* scoped */
    const __vue_scope_id__$m = undefined;
    /* module identifier */
    const __vue_module_identifier__$m = undefined;
    /* functional template */
    const __vue_is_functional_template__$m = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDrawerItem = normalizeComponent(
      { render: __vue_render__$j, staticRenderFns: __vue_staticRenderFns__$j },
      __vue_inject_styles__$m,
      __vue_script__$m,
      __vue_scope_id__$m,
      __vue_is_functional_template__$m,
      __vue_module_identifier__$m,
      undefined,
      undefined
    );

  //
  //
  //
  //
  var script$n = {
    name: 'mdc-drawer-divider'
  };

  /* script */
  const __vue_script__$n = script$n;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$n.__file = "/ddata/extra/vma/components/drawer/mdc-drawer-divider.vue";

  /* template */
  var __vue_render__$k = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("hr", { staticClass: "mdc-list-divider" })
  };
  var __vue_staticRenderFns__$k = [];
  __vue_render__$k._withStripped = true;

    /* style */
    const __vue_inject_styles__$n = undefined;
    /* scoped */
    const __vue_scope_id__$n = undefined;
    /* module identifier */
    const __vue_module_identifier__$n = undefined;
    /* functional template */
    const __vue_is_functional_template__$n = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcDrawerDivider = normalizeComponent(
      { render: __vue_render__$k, staticRenderFns: __vue_staticRenderFns__$k },
      __vue_inject_styles__$n,
      __vue_script__$n,
      __vue_scope_id__$n,
      __vue_is_functional_template__$n,
      __vue_module_identifier__$n,
      undefined,
      undefined
    );

  var VueMDCDrawer = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  //
  //
  //
  //
  //
  //
  //
  //
  var script$o = {
    name: 'mdc-elevation',
    props: {
      z: {
        type: [Number, String],
        default: function _default() {
          return 1;
        }
      }
    },
    data: function data() {
      var elevationClasses = {};
      elevationClasses["mdc-elevation--z".concat(this.z)] = true;
      return {
        classes: elevationClasses
      };
    }
  };

  /* script */
  const __vue_script__$o = script$o;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$o.__file = "/ddata/extra/vma/components/elevation/mdc-elevation.vue";

  /* template */
  var __vue_render__$l = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-elevation", class: _vm.classes },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$l = [];
  __vue_render__$l._withStripped = true;

    /* style */
    const __vue_inject_styles__$o = undefined;
    /* scoped */
    const __vue_scope_id__$o = undefined;
    /* module identifier */
    const __vue_module_identifier__$o = undefined;
    /* functional template */
    const __vue_is_functional_template__$o = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcElevation = normalizeComponent(
      { render: __vue_render__$l, staticRenderFns: __vue_staticRenderFns__$l },
      __vue_inject_styles__$o,
      __vue_script__$o,
      __vue_scope_id__$o,
      __vue_is_functional_template__$o,
      __vue_module_identifier__$o,
      undefined,
      undefined
    );

  var VueMDCElevation = BasePlugin({
    mdcElevation: mdcElevation
  });

  //
  var script$p = {
    name: 'mdc-fab',
    mixins: [DispatchEventMixin, CustomButtonMixin, RippleMixin],
    props: {
      icon: String,
      mini: Boolean,
      absolute: Boolean,
      fixed: Boolean
    },
    data: function data() {
      return {
        classes: {
          'material-icons': this.icon,
          'mdc-fab--mini': this.mini,
          'mdc-fab--absolute': this.absolute,
          'mdc-fab--fixed': this.fixed
        },
        styles: {}
      };
    },
    watch: {
      icon: function icon() {
        this.$set(this.classes, 'material-icons', this.icon);
      },
      mini: function mini() {
        this.$set(this.classes, 'mdc-fab--mini', this.mini);
      }
    }
  };

  /* script */
  const __vue_script__$p = script$p;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$p.__file = "/ddata/extra/vma/components/fab/mdc-fab.vue";

  /* template */
  var __vue_render__$m = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-button",
      _vm._g(
        {
          staticClass: "mdc-fab",
          class: _vm.classes,
          style: _vm.styles,
          attrs: { href: _vm.href, link: _vm.link }
        },
        _vm.listeners
      ),
      [
        _c(
          "span",
          { staticClass: "mdc-fab__icon" },
          [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
          2
        )
      ]
    )
  };
  var __vue_staticRenderFns__$m = [];
  __vue_render__$m._withStripped = true;

    /* style */
    const __vue_inject_styles__$p = undefined;
    /* scoped */
    const __vue_scope_id__$p = undefined;
    /* module identifier */
    const __vue_module_identifier__$p = undefined;
    /* functional template */
    const __vue_is_functional_template__$p = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcFAB = normalizeComponent(
      { render: __vue_render__$m, staticRenderFns: __vue_staticRenderFns__$m },
      __vue_inject_styles__$p,
      __vue_script__$p,
      __vue_scope_id__$p,
      __vue_is_functional_template__$p,
      __vue_module_identifier__$p,
      undefined,
      undefined
    );

  var VueMDCFab = BasePlugin({
    mdcFAB: mdcFAB
  });

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var strings$9 = {
    TILES_SELECTOR: '.mdc-grid-list__tiles',
    TILE_SELECTOR: '.mdc-grid-tile'
  };

  var MDCGridListFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCGridListFoundation, _MDCFoundation);

    _createClass(MDCGridListFoundation, null, [{
      key: "strings",
      get: function get() {
        return strings$9;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          getOffsetWidth: function getOffsetWidth() {
            return (
              /* number */
              0
            );
          },
          getNumberOfTiles: function getNumberOfTiles() {
            return (
              /* number */
              0
            );
          },
          getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex() {
            return (
              /* index: number */

              /* number */
              0
            );
          },
          setStyleForTilesElement: function setStyleForTilesElement()
          /* property: string, value: string */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {}
        };
      }
    }]);

    function MDCGridListFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCGridListFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCGridListFoundation).call(this, _extends(MDCGridListFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.alignCenter();
      };

      _this.resizeFrame_ = 0;
      return _this;
    }

    _createClass(MDCGridListFoundation, [{
      key: "init",
      value: function init() {
        this.alignCenter();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "alignCenter",
      value: function alignCenter() {
        var _this2 = this;

        if (this.resizeFrame_ !== 0) {
          cancelAnimationFrame(this.resizeFrame_);
        }

        this.resizeFrame_ = requestAnimationFrame(function () {
          _this2.alignCenter_();

          _this2.resizeFrame_ = 0;
        });
      }
    }, {
      key: "alignCenter_",
      value: function alignCenter_() {
        if (this.adapter_.getNumberOfTiles() == 0) {
          return;
        }

        var gridWidth = this.adapter_.getOffsetWidth();
        var itemWidth = this.adapter_.getOffsetWidthForTileAtIndex(0);
        var tilesWidth = itemWidth * Math.floor(gridWidth / itemWidth);
        this.adapter_.setStyleForTilesElement('width', "".concat(tilesWidth, "px"));
      }
    }]);

    return MDCGridListFoundation;
  }(MDCFoundation);

  //
  var script$q = {
    name: 'mdc-grid-list',
    props: {
      width: [String, Number],
      ratio: String,
      'narrow-gutter': Boolean,
      'header-caption': Boolean,
      'icon-align-start': Boolean,
      'icon-align-end': Boolean,
      'with-support-text': Boolean,
      interactive: Boolean
    },
    provide: function provide() {
      return {
        mdcGrid: this
      };
    },
    computed: {
      classes: function classes() {
        var classes = {};
        classes['mdc-grid-list--tile-gutter-1'] = this.narrowGutter;
        classes['mdc-grid-list--header-caption'] = this.headerCaption;
        classes["mdc-grid-list--tile-aspect-".concat(this.ratio)] = this.ratio;
        classes['mdc-grid-list--with-icon-align-start'] = this.iconAlignStart;
        classes['mdc-grid-list--with-icon-align-end'] = this.iconAlignEnd;
        classes['mdc-grid-list--twoline-caption'] = this.withSupportText;
        classes['mdc-grid-list--non-interactive'] = !this.interactive;
        return classes;
      },
      styles: function styles() {
        var defaultWidth = 200;
        return {
          '--mdc-grid-list-tile-width': "".concat(this.width || defaultWidth, "px")
        };
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCGridListFoundation({
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getNumberOfTiles: function getNumberOfTiles() {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR).length;
        },
        getOffsetWidthForTileAtIndex: function getOffsetWidthForTileAtIndex(index) {
          return _this.$el.querySelectorAll(MDCGridListFoundation.strings.TILE_SELECTOR)[index].offsetWidth;
        },
        setStyleForTilesElement: function setStyleForTilesElement(property, value) {
          _this.$el.querySelector(MDCGridListFoundation.strings.TILES_SELECTOR).style[property] = value;
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$q = script$q;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$q.__file = "/ddata/extra/vma/components/grid-list/mdc-grid-list.vue";

  /* template */
  var __vue_render__$n = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-grid-list" }, [
      _c(
        "ul",
        {
          staticClass: "mdc-grid-list__tiles",
          class: _vm.classes,
          style: _vm.styles
        },
        [_vm._t("default")],
        2
      )
    ])
  };
  var __vue_staticRenderFns__$n = [];
  __vue_render__$n._withStripped = true;

    /* style */
    const __vue_inject_styles__$q = undefined;
    /* scoped */
    const __vue_scope_id__$q = undefined;
    /* module identifier */
    const __vue_module_identifier__$q = undefined;
    /* functional template */
    const __vue_is_functional_template__$q = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcGridList = normalizeComponent(
      { render: __vue_render__$n, staticRenderFns: __vue_staticRenderFns__$n },
      __vue_inject_styles__$q,
      __vue_script__$q,
      __vue_scope_id__$q,
      __vue_is_functional_template__$q,
      __vue_module_identifier__$q,
      undefined,
      undefined
    );

  //
  var script$r = {
    name: 'mdc-grid-tile',
    inject: ['mdcGrid'],
    mixins: [DispatchEventMixin],
    props: {
      src: String,
      cover: Boolean,
      icon: String,
      title: String,
      'support-text': String,
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    computed: {
      clickListener: function clickListener() {
        var _this = this;

        return {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        };
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-grid-tile--selected': this.selected,
          'mdc-grid-tile--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcGrid && this.mdcGrid.interactive;
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      },
      hasEndDetail: function hasEndDetail() {
        return this.endIcon || this.$slots['end-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },
    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  /* script */
  const __vue_script__$r = script$r;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$r.__file = "/ddata/extra/vma/components/grid-list/mdc-grid-tile.vue";

  /* template */
  var __vue_render__$o = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      _vm._g(
        {
          staticClass: "mdc-grid-tile",
          class: [_vm.classes, _vm.itemClasses],
          style: _vm.styles,
          attrs: { tabindex: _vm.isInteractive ? "0" : undefined }
        },
        _vm.isInteractive ? _vm.listeners : _vm.clickListener
      ),
      [
        _vm.cover
          ? _c("div", { staticClass: "mdc-grid-tile__primary" }, [
              _c("div", {
                staticClass: "mdc-grid-tile__primary-content",
                style: { backgroundImage: "url(" + _vm.src + ")" }
              })
            ])
          : _c("div", { staticClass: "mdc-grid-tile__primary" }, [
              _c("img", {
                staticClass: "mdc-grid-tile__primary-content",
                attrs: { src: _vm.src }
              })
            ]),
        _vm._v(" "),
        _vm.title || _vm.supportText
          ? _c("span", { staticClass: "mdc-grid-tile__secondary" }, [
              _vm.icon
                ? _c("i", { staticClass: "mdc-grid-tile__icon material-icons" }, [
                    _vm._v(_vm._s(_vm.icon))
                  ])
                : _vm._e(),
              _vm._v(" "),
              _vm.title
                ? _c("span", { staticClass: "mdc-grid-tile__title" }, [
                    _vm._v(_vm._s(_vm.title))
                  ])
                : _vm._e(),
              _vm._v(" "),
              _vm.supportText
                ? _c("span", { staticClass: "mdc-grid-tile__support-text" }, [
                    _vm._v(_vm._s(_vm.supportText))
                  ])
                : _vm._e()
            ])
          : _vm._e()
      ]
    )
  };
  var __vue_staticRenderFns__$o = [];
  __vue_render__$o._withStripped = true;

    /* style */
    const __vue_inject_styles__$r = undefined;
    /* scoped */
    const __vue_scope_id__$r = undefined;
    /* module identifier */
    const __vue_module_identifier__$r = undefined;
    /* functional template */
    const __vue_is_functional_template__$r = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcGridTile = normalizeComponent(
      { render: __vue_render__$o, staticRenderFns: __vue_staticRenderFns__$o },
      __vue_inject_styles__$r,
      __vue_script__$r,
      __vue_scope_id__$r,
      __vue_is_functional_template__$r,
      __vue_module_identifier__$r,
      undefined,
      undefined
    );

  var VueMDCGridList = BasePlugin({
    mdcGridList: mdcGridList,
    mdcGridTile: mdcGridTile
  });

  //
  //
  //
  //
  //
  //
  //
  //
  var script$s = {
    name: 'mdc-icon',
    props: {
      icon: String
    }
  };

  /* script */
  const __vue_script__$s = script$s;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$s.__file = "/ddata/extra/vma/components/icon/mdc-icon.vue";

  /* template */
  var __vue_render__$p = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      {
        staticClass: "mdc-icon mdc-icon--material",
        class: { "material-icons": !!_vm.icon }
      },
      [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
      2
    )
  };
  var __vue_staticRenderFns__$p = [];
  __vue_render__$p._withStripped = true;

    /* style */
    const __vue_inject_styles__$s = undefined;
    /* scoped */
    const __vue_scope_id__$s = undefined;
    /* module identifier */
    const __vue_module_identifier__$s = undefined;
    /* functional template */
    const __vue_is_functional_template__$s = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcIcon = normalizeComponent(
      { render: __vue_render__$p, staticRenderFns: __vue_staticRenderFns__$p },
      __vue_inject_styles__$s,
      __vue_script__$s,
      __vue_scope_id__$s,
      __vue_is_functional_template__$s,
      __vue_module_identifier__$s,
      undefined,
      undefined
    );

  var VueMDCIcon = BasePlugin({
    mdcIcon: mdcIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Button Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCIconButtonToggleAdapter =
  /*#__PURE__*/
  function () {
    function MDCIconButtonToggleAdapter() {
      _classCallCheck(this, MDCIconButtonToggleAdapter);
    }

    _createClass(MDCIconButtonToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       * */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * @param {string} attrName
       * @param {string} attrValue
       */

    }, {
      key: "setAttr",
      value: function setAttr(attrName, attrValue) {}
      /** @param {!IconButtonToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);

    return MDCIconButtonToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$9 = {
    ROOT: 'mdc-icon-button',
    ICON_BUTTON_ON: 'mdc-icon-button--on'
  };
  /** @enum {string} */

  var strings$a = {
    ARIA_PRESSED: 'aria-pressed',
    CHANGE_EVENT: 'MDCIconButtonToggle:change'
  };

  /**
   * @extends {MDCFoundation<!MDCIconButtonToggleAdapter>}
   */

  var MDCIconButtonToggleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCIconButtonToggleFoundation, _MDCFoundation);

    _createClass(MDCIconButtonToggleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$9;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$a;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass() {},
          removeClass: function removeClass() {},
          hasClass: function hasClass() {},
          setAttr: function setAttr() {},
          notifyChange: function notifyChange() {}
        };
      }
    }]);

    function MDCIconButtonToggleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCIconButtonToggleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCIconButtonToggleFoundation).call(this, _extends(MDCIconButtonToggleFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.disabled_ = false;
      return _this;
    }

    _createClass(MDCIconButtonToggleFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.setAttr(strings$a.ARIA_PRESSED, "".concat(this.isOn()));
      }
    }, {
      key: "handleClick",
      value: function handleClick() {
        this.toggle();
        this.adapter_.notifyChange(
        /** @type {!IconButtonToggleEvent} */
        {
          isOn: this.isOn()
        });
      }
      /** @return {boolean} */

    }, {
      key: "isOn",
      value: function isOn() {
        return this.adapter_.hasClass(cssClasses$9.ICON_BUTTON_ON);
      }
      /** @param {boolean=} isOn */

    }, {
      key: "toggle",
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.isOn();

        if (isOn) {
          this.adapter_.addClass(cssClasses$9.ICON_BUTTON_ON);
        } else {
          this.adapter_.removeClass(cssClasses$9.ICON_BUTTON_ON);
        }

        this.adapter_.setAttr(strings$a.ARIA_PRESSED, "".concat(isOn));
      }
    }]);

    return MDCIconButtonToggleFoundation;
  }(MDCFoundation);

  //
  var script$t = {
    name: 'mdc-icon-button',
    model: {
      prop: 'isOn',
      event: 'change'
    },
    props: {
      isOn: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    watch: {
      isOn: 'onOn_'
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconButtonToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        setAttr: function setAttr(attrName, attrValue) {
          return _this.$el.setAttribute(attrName, attrValue);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit(MDCIconButtonToggleFoundation.strings.CHANGE_EVENT, evtData);

          _this.$emit('change', evtData.isOn);
        }
      });
      this.foundation.init();
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        }
      });
      this.ripple.init();
      this.foundation.toggle(this.isOn);
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
      this.foundation.destroy();
    },
    methods: {
      onOn_: function onOn_(isOn) {
        if (this.isOn !== isOn) {
          this.foundation.toggle(isOn);
        }
      },
      onClick: function onClick(evt) {
        this.foundation.handleClick(evt);
      }
    },
    computed: {
      isLink: function isLink() {
        return this.$el && Boolean(this.$el.getAttribute('href'));
      }
    }
  };

  /* script */
  const __vue_script__$t = script$t;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$t.__file = "/ddata/extra/vma/components/icon-button/mdc-icon-button.vue";

  /* template */
  var __vue_render__$q = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _vm.isLink
      ? _c(
          "a",
          _vm._b(
            {
              staticClass: "mdc-icon-button material-icons",
              class: _vm.classes,
              style: _vm.styles,
              on: { click: _vm.onClick }
            },
            "a",
            _vm.$attrs,
            false
          ),
          [_vm._t("default")],
          2
        )
      : _c(
          "button",
          _vm._b(
            {
              staticClass: "mdc-icon-button material-icons",
              class: _vm.classes,
              style: _vm.styles,
              on: { click: _vm.onClick }
            },
            "button",
            _vm.$attrs,
            false
          ),
          [_vm._t("default")],
          2
        )
  };
  var __vue_staticRenderFns__$q = [];
  __vue_render__$q._withStripped = true;

    /* style */
    const __vue_inject_styles__$t = undefined;
    /* scoped */
    const __vue_scope_id__$t = undefined;
    /* module identifier */
    const __vue_module_identifier__$t = undefined;
    /* functional template */
    const __vue_is_functional_template__$t = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcIconButton = normalizeComponent(
      { render: __vue_render__$q, staticRenderFns: __vue_staticRenderFns__$q },
      __vue_inject_styles__$t,
      __vue_script__$t,
      __vue_scope_id__$t,
      __vue_is_functional_template__$t,
      __vue_module_identifier__$t,
      undefined,
      undefined
    );

  var VueMDCIconButton = BasePlugin({
    mdcIconButton: mdcIconButton
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Icon Toggle. Provides an interface for managing
   * - classes
   * - dom
   * - inner text
   * - event handlers
   * - event dispatch
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCIconToggleAdapter =
  /*#__PURE__*/
  function () {
    function MDCIconToggleAdapter() {
      _classCallCheck(this, MDCIconToggleAdapter);
    }

    _createClass(MDCIconToggleAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}
      /**
       * @param {string} type
       * @param {!EventListener} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
      /** @param {string} text */

    }, {
      key: "setText",
      value: function setText(text) {}
      /** @return {number} */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}
      /** @param {number} tabIndex */

    }, {
      key: "setTabIndex",
      value: function setTabIndex(tabIndex) {}
      /**
       * @param {string} name
       * @return {string}
       */

    }, {
      key: "getAttr",
      value: function getAttr(name) {}
      /**
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(name, value) {}
      /** @param {string} name */

    }, {
      key: "rmAttr",
      value: function rmAttr(name) {}
      /** @param {!IconToggleEvent} evtData */

    }, {
      key: "notifyChange",
      value: function notifyChange(evtData) {}
    }]);

    return MDCIconToggleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$a = {
    ROOT: 'mdc-icon-toggle',
    DISABLED: 'mdc-icon-toggle--disabled'
  };
  /** @enum {string} */

  var strings$b = {
    DATA_TOGGLE_ON: 'data-toggle-on',
    DATA_TOGGLE_OFF: 'data-toggle-off',
    ARIA_PRESSED: 'aria-pressed',
    ARIA_DISABLED: 'aria-disabled',
    ARIA_LABEL: 'aria-label',
    CHANGE_EVENT: 'MDCIconToggle:change'
  };

  /**
   * @extends {MDCFoundation<!MDCIconToggleAdapter>}
   */

  var MDCIconToggleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCIconToggleFoundation, _MDCFoundation);

    _createClass(MDCIconToggleFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$a;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$b;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          registerInteractionHandler: function registerInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          deregisterInteractionHandler: function deregisterInteractionHandler()
          /* type: string, handler: EventListener */
          {},
          setText: function setText()
          /* text: string */
          {},
          getTabIndex: function getTabIndex() {
            return (
              /* number */
              0
            );
          },
          setTabIndex: function setTabIndex()
          /* tabIndex: number */
          {},
          getAttr: function getAttr() {
            return (
              /* name: string */

              /* string */
              ''
            );
          },
          setAttr: function setAttr()
          /* name: string, value: string */
          {},
          rmAttr: function rmAttr()
          /* name: string */
          {},
          notifyChange: function notifyChange()
          /* evtData: IconToggleEvent */
          {}
        };
      }
    }]);

    function MDCIconToggleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCIconToggleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCIconToggleFoundation).call(this, _extends(MDCIconToggleFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.on_ = false;
      /** @private {boolean} */

      _this.disabled_ = false;
      /** @private {number} */

      _this.savedTabIndex_ = -1;
      /** @private {?IconToggleState} */

      _this.toggleOnData_ = null;
      /** @private {?IconToggleState} */

      _this.toggleOffData_ = null;

      _this.clickHandler_ =
      /** @private {!EventListener} */
      function () {
        return _this.toggleFromEvt_();
      };
      /** @private {boolean} */


      _this.isHandlingKeydown_ = false;

      _this.keydownHandler_ =
      /** @private {!EventListener} */
      function (
      /** @type {!KeyboardKey} */
      evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = true;
          return evt.preventDefault();
        }
      };

      _this.keyupHandler_ =
      /** @private {!EventListener} */
      function (
      /** @type {!KeyboardKey} */
      evt) {
        if (isSpace(evt)) {
          _this.isHandlingKeydown_ = false;

          _this.toggleFromEvt_();
        }
      };

      return _this;
    }

    _createClass(MDCIconToggleFoundation, [{
      key: "init",
      value: function init() {
        this.refreshToggleData();
        this.savedTabIndex_ = this.adapter_.getTabIndex();
        this.adapter_.registerInteractionHandler('click', this.clickHandler_);
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('keyup', this.keyupHandler_);
      }
    }, {
      key: "refreshToggleData",
      value: function refreshToggleData() {
        var _MDCIconToggleFoundat = MDCIconToggleFoundation.strings,
            DATA_TOGGLE_ON = _MDCIconToggleFoundat.DATA_TOGGLE_ON,
            DATA_TOGGLE_OFF = _MDCIconToggleFoundat.DATA_TOGGLE_OFF;
        this.toggleOnData_ = this.parseJsonDataAttr_(DATA_TOGGLE_ON);
        this.toggleOffData_ = this.parseJsonDataAttr_(DATA_TOGGLE_OFF);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('click', this.clickHandler_);
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('keyup', this.keyupHandler_);
      }
      /** @private */

    }, {
      key: "toggleFromEvt_",
      value: function toggleFromEvt_() {
        this.toggle();
        var isOn = this.on_;
        this.adapter_.notifyChange(
        /** @type {!IconToggleEvent} */
        {
          isOn: isOn
        });
      }
      /** @return {boolean} */

    }, {
      key: "isOn",
      value: function isOn() {
        return this.on_;
      }
      /** @param {boolean=} isOn */

    }, {
      key: "toggle",
      value: function toggle() {
        var isOn = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !this.on_;
        this.on_ = isOn;
        var _MDCIconToggleFoundat2 = MDCIconToggleFoundation.strings,
            ARIA_LABEL = _MDCIconToggleFoundat2.ARIA_LABEL,
            ARIA_PRESSED = _MDCIconToggleFoundat2.ARIA_PRESSED;

        if (this.on_) {
          this.adapter_.setAttr(ARIA_PRESSED, 'true');
        } else {
          this.adapter_.setAttr(ARIA_PRESSED, 'false');
        }

        var _ref = this.on_ ? this.toggleOffData_ : this.toggleOnData_,
            classToRemove = _ref.cssClass;

        if (classToRemove) {
          this.adapter_.removeClass(classToRemove);
        }

        var _ref2 = this.on_ ? this.toggleOnData_ : this.toggleOffData_,
            content = _ref2.content,
            label = _ref2.label,
            cssClass = _ref2.cssClass;

        if (cssClass) {
          this.adapter_.addClass(cssClass);
        }

        if (content) {
          this.adapter_.setText(content);
        }

        if (label) {
          this.adapter_.setAttr(ARIA_LABEL, label);
        }
      }
      /**
       * @param {string} dataAttr
       * @return {!IconToggleState}
       */

    }, {
      key: "parseJsonDataAttr_",
      value: function parseJsonDataAttr_(dataAttr) {
        var val = this.adapter_.getAttr(dataAttr);

        if (!val) {
          return {};
        }

        return (
          /** @type {!IconToggleState} */
          JSON.parse(val)
        );
      }
      /** @return {boolean} */

    }, {
      key: "isDisabled",
      value: function isDisabled() {
        return this.disabled_;
      }
      /** @param {boolean} isDisabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(isDisabled) {
        this.disabled_ = isDisabled;
        var DISABLED = MDCIconToggleFoundation.cssClasses.DISABLED;
        var ARIA_DISABLED = MDCIconToggleFoundation.strings.ARIA_DISABLED;

        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setTabIndex(-1);
          this.adapter_.setAttr(ARIA_DISABLED, 'true');
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.setTabIndex(this.savedTabIndex_);
          this.adapter_.rmAttr(ARIA_DISABLED);
          this.adapter_.removeClass(DISABLED);
        }
      }
      /** @return {boolean} */

    }, {
      key: "isKeyboardActivated",
      value: function isKeyboardActivated() {
        return this.isHandlingKeydown_;
      }
    }]);

    return MDCIconToggleFoundation;
  }(MDCFoundation);
  /**
   * @param {!KeyboardKey} keyboardKey
   * @return {boolean}
   */

  function isSpace(keyboardKey) {
    return keyboardKey.key === 'Space' || keyboardKey.keyCode === 32;
  }
  /** @record */


  var IconToggleState = function IconToggleState() {
    _classCallCheck(this, IconToggleState);
  };
  /**
   * The aria-label value of the icon toggle, or undefined if there is no aria-label.
   * @export {string|undefined}
   */


  IconToggleState.prototype.label;
  /**
   * The text for the icon toggle, or undefined if there is no text.
   * @export {string|undefined}
   */

  IconToggleState.prototype.content;
  /**
   * The CSS class to add to the icon toggle, or undefined if there is no CSS class.
   * @export {string|undefined}
   */

  IconToggleState.prototype.cssClass;

  //
  var script$u = {
    name: 'mdc-icon-toggle',
    props: {
      toggleOn: [String, Object],
      toggleOff: [String, Object],
      value: Boolean,
      disabled: Boolean,
      accent: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-icon-toggle--accent': this.accent
        },
        styles: {},
        iconClasses: {},
        tabIndex: 0,
        text: ''
      };
    },
    computed: {
      toggleOnData: function toggleOnData() {
        var toggle = this.toggleOn;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      },
      toggleOffData: function toggleOffData() {
        var toggle = this.toggleOff;
        return toggle && JSON.stringify(typeof toggle === 'string' ? {
          content: toggle,
          cssClass: 'material-icons'
        } : {
          content: toggle.icon || toggle.content,
          label: toggle.label,
          cssClass: toggle.icon ? 'material-icons' : toggle.cssClass
        });
      }
    },
    watch: {
      value: function value(_value) {
        this.foundation && this.foundation.toggle(_value);
      },
      disabled: function disabled(_disabled) {
        this.foundation && this.foundation.setDisabled(_disabled);
      },
      toggleOnData: function toggleOnData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      toggleOffData: function toggleOffData() {
        this.foundation && this.foundation.refreshToggleData();
      },
      accent: function accent(value) {
        this.$set(this.classes, 'mdc-icon-toggle--secondary', value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCIconToggleFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.iconClasses, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.iconClasses, className);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          return _this.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          return _this.$el.removeEventListener(evt, handler);
        },
        setText: function setText(text) {
          _this.text = text;
        },
        getTabIndex: function getTabIndex() {
          return _this.tabIndex;
        },
        setTabIndex: function setTabIndex(tabIndex) {
          _this.tabIndex = tabIndex;
        },
        getAttr: function getAttr(name, value) {
          return _this.$el.getAttribute(name, value);
        },
        setAttr: function setAttr(name, value) {
          _this.$el.setAttribute(name, value);
        },
        rmAttr: function rmAttr(name) {
          _this.$el.removeAttribute(name);
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('input', evtData.isOn);
        }
      });
      this.foundation.init();
      this.foundation.toggle(this.value);
      this.foundation.setDisabled(this.disabled);
      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        isSurfaceActive: function isSurfaceActive() {
          return _this.foundation.isKeyboardActivated();
        }
      });
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
      this.ripple.destroy();
    }
  };

  /* script */
  const __vue_script__$u = script$u;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$u.__file = "/ddata/extra/vma/components/icon-toggle/mdc-icon-toggle.vue";

  /* template */
  var __vue_render__$r = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "span",
      {
        staticClass: "mdc-icon-toggle",
        class: _vm.classes,
        style: _vm.styles,
        attrs: {
          tabindex: _vm.tabIndex,
          "data-toggle-on": _vm.toggleOnData,
          "data-toggle-off": _vm.toggleOffData,
          role: "button",
          "aria-pressed": "false"
        }
      },
      [
        _c("i", { class: _vm.iconClasses, attrs: { "aria-hidden": "true" } }, [
          _vm._v(_vm._s(_vm.text))
        ])
      ]
    )
  };
  var __vue_staticRenderFns__$r = [];
  __vue_render__$r._withStripped = true;

    /* style */
    const __vue_inject_styles__$u = undefined;
    /* scoped */
    const __vue_scope_id__$u = undefined;
    /* module identifier */
    const __vue_module_identifier__$u = undefined;
    /* functional template */
    const __vue_is_functional_template__$u = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcIConToggle = normalizeComponent(
      { render: __vue_render__$r, staticRenderFns: __vue_staticRenderFns__$r },
      __vue_inject_styles__$u,
      __vue_script__$u,
      __vue_scope_id__$u,
      __vue_is_functional_template__$u,
      __vue_module_identifier__$u,
      undefined,
      undefined
    );

  var VueMDCIconToggle = BasePlugin({
    mdcIConToggle: mdcIConToggle
  });

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$v = {
    name: 'mdc-layout-app'
  };

  /* script */
  const __vue_script__$v = script$v;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$v.__file = "/ddata/extra/vma/components/layout-app/mdc-layout-app.vue";

  /* template */
  var __vue_render__$s = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-layout-app" }, [
      _c(
        "div",
        { staticClass: "mdc-layout-app--topappbar-wrapper" },
        [_vm._t("topappbar")],
        2
      ),
      _vm._v(" "),
      _c("div", { staticClass: "mdc-layout-app--main-container" }, [
        _c(
          "div",
          { staticClass: "mdc-layout-app--drawer-wrapper" },
          [_vm._t("drawer")],
          2
        ),
        _vm._v(" "),
        _c(
          "div",
          { staticClass: "mdc-layout-app--content-wrapper" },
          [_vm._t("default")],
          2
        )
      ])
    ])
  };
  var __vue_staticRenderFns__$s = [];
  __vue_render__$s._withStripped = true;

    /* style */
    const __vue_inject_styles__$v = undefined;
    /* scoped */
    const __vue_scope_id__$v = undefined;
    /* module identifier */
    const __vue_module_identifier__$v = undefined;
    /* functional template */
    const __vue_is_functional_template__$v = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcLayoutApp = normalizeComponent(
      { render: __vue_render__$s, staticRenderFns: __vue_staticRenderFns__$s },
      __vue_inject_styles__$v,
      __vue_script__$v,
      __vue_scope_id__$v,
      __vue_is_functional_template__$v,
      __vue_module_identifier__$v,
      undefined,
      undefined
    );

  var VueMDCLayoutApp = BasePlugin({
    mdcLayoutApp: mdcLayoutApp
  });

  //
  //
  //
  //
  //
  //
  //
  //
  var script$w = {
    name: 'mdc-layout-grid',
    props: {
      'fixed-column-width': Boolean,
      'align-left': Boolean,
      'align-right': Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-layout-grid': true,
          'mdc-layout-grid--fixed-column-width': this.fixedColumnWidth,
          'mdc-layout-grid--align-left': this.alignLeft,
          'mdc-layout-grid--align-right': this.alignRight
        };
      }
    }
  };

  /* script */
  const __vue_script__$w = script$w;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$w.__file = "/ddata/extra/vma/components/layout-grid/mdc-layout-grid.vue";

  /* template */
  var __vue_render__$t = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { class: _vm.classes }, [
      _c("div", { staticClass: "mdc-layout-grid__inner" }, [_vm._t("default")], 2)
    ])
  };
  var __vue_staticRenderFns__$t = [];
  __vue_render__$t._withStripped = true;

    /* style */
    const __vue_inject_styles__$w = undefined;
    /* scoped */
    const __vue_scope_id__$w = undefined;
    /* module identifier */
    const __vue_module_identifier__$w = undefined;
    /* functional template */
    const __vue_is_functional_template__$w = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcLayoutGrid = normalizeComponent(
      { render: __vue_render__$t, staticRenderFns: __vue_staticRenderFns__$t },
      __vue_inject_styles__$w,
      __vue_script__$w,
      __vue_scope_id__$w,
      __vue_is_functional_template__$w,
      __vue_module_identifier__$w,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var spanOptions = {
    type: [String, Number],
    default: null,
    validator: function validator(value) {
      var num = Number(value);
      return isFinite(num) && num <= 12 && num > 0;
    }
  };
  var script$x = {
    name: 'mdc-layout-cell',
    props: {
      span: spanOptions,
      order: spanOptions,
      phone: spanOptions,
      tablet: spanOptions,
      desktop: spanOptions,
      align: {
        type: String,
        validator: function validator(value) {
          return ['top', 'bottom', 'middle'].indexOf(value) !== -1;
        }
      }
    },
    computed: {
      classes: function classes() {
        var classes = [];

        if (this.span) {
          classes.push("mdc-layout-grid__cell--span-".concat(this.span));
        }

        if (this.order) {
          classes.push("mdc-layout-grid__cell--order-".concat(this.order));
        }

        if (this.phone) {
          classes.push("mdc-layout-grid__cell--span-".concat(this.phone, "-phone"));
        }

        if (this.tablet) {
          classes.push("mdc-layout-grid__cell--span-".concat(this.tablet, "-tablet"));
        }

        if (this.desktop) {
          classes.push("mdc-layout-grid__cell--span-".concat(this.desktop, "-desktop"));
        }

        if (this.align) {
          classes.push("mdc-layout-grid__cell--align-".concat(this.align));
        }

        return classes;
      }
    }
  };

  /* script */
  const __vue_script__$x = script$x;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$x.__file = "/ddata/extra/vma/components/layout-grid/mdc-layout-cell.vue";

  /* template */
  var __vue_render__$u = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-layout-cell mdc-layout-grid__cell",
        class: _vm.classes
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$u = [];
  __vue_render__$u._withStripped = true;

    /* style */
    const __vue_inject_styles__$x = undefined;
    /* scoped */
    const __vue_scope_id__$x = undefined;
    /* module identifier */
    const __vue_module_identifier__$x = undefined;
    /* functional template */
    const __vue_is_functional_template__$x = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcLayoutCell = normalizeComponent(
      { render: __vue_render__$u, staticRenderFns: __vue_staticRenderFns__$u },
      __vue_inject_styles__$x,
      __vue_script__$x,
      __vue_scope_id__$x,
      __vue_is_functional_template__$x,
      __vue_module_identifier__$x,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$y = {
    name: 'mdc-layout-inner-grid'
  };

  /* script */
  const __vue_script__$y = script$y;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$y.__file = "/ddata/extra/vma/components/layout-grid/mdc-layout-inner-grid.vue";

  /* template */
  var __vue_render__$v = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-layout-inner-grid mdc-layout-grid__inner" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$v = [];
  __vue_render__$v._withStripped = true;

    /* style */
    const __vue_inject_styles__$y = undefined;
    /* scoped */
    const __vue_scope_id__$y = undefined;
    /* module identifier */
    const __vue_module_identifier__$y = undefined;
    /* functional template */
    const __vue_is_functional_template__$y = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcLayoutInnerGrid = normalizeComponent(
      { render: __vue_render__$v, staticRenderFns: __vue_staticRenderFns__$v },
      __vue_inject_styles__$y,
      __vue_script__$y,
      __vue_scope_id__$y,
      __vue_is_functional_template__$y,
      __vue_module_identifier__$y,
      undefined,
      undefined
    );

  var VueMDCLayoutGrid = BasePlugin({
    mdcLayoutGrid: mdcLayoutGrid,
    mdcLayoutCell: mdcLayoutCell,
    mdcLayoutInnerGrid: mdcLayoutInnerGrid
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$b = {
    CLOSED_CLASS: 'mdc-linear-progress--closed',
    INDETERMINATE_CLASS: 'mdc-linear-progress--indeterminate',
    REVERSED_CLASS: 'mdc-linear-progress--reversed'
  };
  var strings$c = {
    PRIMARY_BAR_SELECTOR: '.mdc-linear-progress__primary-bar',
    BUFFER_SELECTOR: '.mdc-linear-progress__buffer'
  };

  var MDCLinearProgressFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCLinearProgressFoundation, _MDCFoundation);

    _createClass(MDCLinearProgressFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$b;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$c;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          addClass: function addClass()
          /* className: string */
          {},
          getPrimaryBar: function getPrimaryBar()
          /* el: Element */
          {},
          getBuffer: function getBuffer()
          /* el: Element */
          {},
          hasClass: function hasClass() {
            return (
              /* className: string */
              false
            );
          },
          removeClass: function removeClass()
          /* className: string */
          {},
          setStyle: function setStyle()
          /* el: Element, styleProperty: string, value: string */
          {}
        };
      }
    }]);

    function MDCLinearProgressFoundation(adapter) {
      _classCallCheck(this, MDCLinearProgressFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCLinearProgressFoundation).call(this, _extends(MDCLinearProgressFoundation.defaultAdapter, adapter)));
    }

    _createClass(MDCLinearProgressFoundation, [{
      key: "init",
      value: function init() {
        this.determinate_ = !this.adapter_.hasClass(cssClasses$b.INDETERMINATE_CLASS);
        this.reverse_ = this.adapter_.hasClass(cssClasses$b.REVERSED_CLASS);
        this.progress_ = 0;
      }
    }, {
      key: "setDeterminate",
      value: function setDeterminate(isDeterminate) {
        this.determinate_ = isDeterminate;

        if (this.determinate_) {
          this.adapter_.removeClass(cssClasses$b.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), this.progress_);
        } else {
          this.adapter_.addClass(cssClasses$b.INDETERMINATE_CLASS);
          this.setScale_(this.adapter_.getPrimaryBar(), 1);
          this.setScale_(this.adapter_.getBuffer(), 1);
        }
      }
    }, {
      key: "setProgress",
      value: function setProgress(value) {
        this.progress_ = value;

        if (this.determinate_) {
          this.setScale_(this.adapter_.getPrimaryBar(), value);
        }
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(value) {
        if (this.determinate_) {
          this.setScale_(this.adapter_.getBuffer(), value);
        }
      }
    }, {
      key: "setReverse",
      value: function setReverse(isReversed) {
        this.reverse_ = isReversed;

        if (this.reverse_) {
          this.adapter_.addClass(cssClasses$b.REVERSED_CLASS);
        } else {
          this.adapter_.removeClass(cssClasses$b.REVERSED_CLASS);
        }
      }
    }, {
      key: "open",
      value: function open() {
        this.adapter_.removeClass(cssClasses$b.CLOSED_CLASS);
      }
    }, {
      key: "close",
      value: function close() {
        this.adapter_.addClass(cssClasses$b.CLOSED_CLASS);
      }
    }, {
      key: "setScale_",
      value: function setScale_(el, scaleValue) {
        var _this = this;

        var value = 'scaleX(' + scaleValue + ')';
        transformStyleProperties.forEach(function (transformStyleProperty) {
          _this.adapter_.setStyle(el, transformStyleProperty, value);
        });
      }
    }]);

    return MDCLinearProgressFoundation;
  }(MDCFoundation);

  //
  var ProgressPropType = {
    type: [Number, String],
    validator: function validator(value) {
      return Number(value) >= 0 && Number(value) <= 1;
    }
  };
  var script$z = {
    name: 'mdc-linear-progress',
    props: {
      open: {
        type: Boolean,
        default: true
      },
      indeterminate: Boolean,
      reverse: Boolean,
      accent: Boolean,
      progress: ProgressPropType,
      buffer: ProgressPropType
    },
    data: function data() {
      return {
        classes: {
          'mdc-linear-progress--accent': this.accent
        },
        styles: {}
      };
    },
    watch: {
      open: function open() {
        if (this.open) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      progress: function progress() {
        this.foundation.setProgress(Number(this.progress));
      },
      buffer: function buffer() {
        this.foundation.setBuffer(Number(this.buffer));
      },
      indeterminate: function indeterminate() {
        this.foundation.setDeterminate(!this.indeterminate);
      },
      reverse: function reverse() {
        this.foundation.setReverse(this.reverse);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLinearProgressFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        getPrimaryBar: function getPrimaryBar()
        /* el: Element */
        {
          return _this.$refs.primary;
        },
        getBuffer: function getBuffer()
        /* el: Element */
        {
          return _this.$refs.buffer;
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        setStyle: function setStyle(el, styleProperty, value) {
          el.style[styleProperty] = value;
        }
      });
      this.foundation.init();
      this.foundation.setReverse(this.reverse);
      this.foundation.setProgress(Number(this.progress));
      this.foundation.setBuffer(Number(this.buffer));
      this.foundation.setDeterminate(!this.indeterminate);

      if (this.open) {
        this.foundation.open();
      } else {
        this.foundation.close();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$z = script$z;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$z.__file = "/ddata/extra/vma/components/linear-progress/mdc-linear-progress.vue";

  /* template */
  var __vue_render__$w = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-linear-progress",
        class: _vm.classes,
        style: _vm.styles,
        attrs: { role: "progressbar" }
      },
      [
        _c("div", { staticClass: "mdc-linear-progress__buffering-dots" }),
        _vm._v(" "),
        _c("div", { ref: "buffer", staticClass: "mdc-linear-progress__buffer" }),
        _vm._v(" "),
        _c(
          "div",
          {
            ref: "primary",
            staticClass:
              "mdc-linear-progress__bar mdc-linear-progress__primary-bar"
          },
          [_c("span", { staticClass: "mdc-linear-progress__bar-inner" })]
        ),
        _vm._v(" "),
        _vm._m(0)
      ]
    )
  };
  var __vue_staticRenderFns__$w = [
    function() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c(
        "div",
        {
          staticClass:
            "mdc-linear-progress__bar mdc-linear-progress__secondary-bar"
        },
        [_c("span", { staticClass: "mdc-linear-progress__bar-inner" })]
      )
    }
  ];
  __vue_render__$w._withStripped = true;

    /* style */
    const __vue_inject_styles__$z = undefined;
    /* scoped */
    const __vue_scope_id__$z = undefined;
    /* module identifier */
    const __vue_module_identifier__$z = undefined;
    /* functional template */
    const __vue_is_functional_template__$z = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcLinearProgress = normalizeComponent(
      { render: __vue_render__$w, staticRenderFns: __vue_staticRenderFns__$w },
      __vue_inject_styles__$z,
      __vue_script__$z,
      __vue_scope_id__$z,
      __vue_is_functional_template__$z,
      __vue_module_identifier__$z,
      undefined,
      undefined
    );

  var VueMDCLinearProgress = BasePlugin({
    mdcLinearProgress: mdcLinearProgress
  });

  //
  var script$A = {
    name: 'mdc-list',
    props: {
      dense: Boolean,
      avatarList: Boolean,
      twoLine: Boolean,
      bordered: Boolean,
      interactive: {
        type: Boolean,
        default: true
      },
      singleSelection: Boolean,
      vertical: {
        type: Boolean,
        default: true
      }
    },
    provide: function provide() {
      return {
        mdcList: this
      };
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list--dense': this.dense,
          'mdc-list--avatar-list': this.avatarList,
          'mdc-list--two-line': this.twoLine,
          'mdc-list--bordered': this.bordered,
          'mdc-list--non-interactive': !this.interactive
        };
      },
      orientation: function orientation() {
        return this.vertical ? 'vertical' : 'horizontal';
      },
      listElements: function listElements() {
        return [].slice.call(this.$el.querySelectorAll(MDCListFoundation.strings.ENABLED_ITEMS_SELECTOR));
      }
    },
    methods: {
      handleFocusInEvent: function handleFocusInEvent(evt) {
        var index = this.getListItemIndex(evt);
        this.foundation.handleFocusIn(evt, index);
      },
      handleFocusOutEvent: function handleFocusOutEvent(evt) {
        var index = this.getListItemIndex(evt);
        this.foundation.handleFocusOut(evt, index);
      },
      handleKeydownEvent: function handleKeydownEvent(evt) {
        var index = this.getListItemIndex(evt);

        if (index >= 0) {
          this.foundation.handleKeydown(evt, evt.target.classList.contains(MDCListFoundation.cssClasses.LIST_ITEM_CLASS), index);
        }
      },
      handleClickEvent: function handleClickEvent(evt) {
        var index = this.getListItemIndex(evt); // Toggle the checkbox only if it's not the target of the event, or the checkbox will have 2 change events.

        var toggleCheckbox = !matches$1(evt.target, MDCListFoundation.strings.CHECKBOX_RADIO_SELECTOR);
        this.foundation.handleClick(index, toggleCheckbox);
      },
      layout: function layout() {
        [].slice.call(this.$el.querySelectorAll('.mdc-list-item:not([tabindex])')).forEach(function (ele) {
          ele.setAttribute('tabindex', -1);
        }) // Child button/a elements are not tabbable until the list item is focused.
        ;
        [].slice.call(this.$el.querySelectorAll(MDCListFoundation.strings.FOCUSABLE_CHILD_ELEMENTS)).forEach(function (ele) {
          return ele.setAttribute('tabindex', -1);
        });
      },
      initializeListType: function initializeListType() {
        // Automatically set single selection if selected/activated classes are present.
        var preselectedElement = this.$el.querySelector(".".concat(MDCListFoundation.cssClasses.LIST_ITEM_ACTIVATED_CLASS, ", .").concat(MDCListFoundation.cssClasses.LIST_ITEM_SELECTED_CLASS));

        if (preselectedElement) {
          if (preselectedElement.classList.contains(MDCListFoundation.cssClasses.LIST_ITEM_ACTIVATED_CLASS)) {
            this.foundation.setUseActivatedClass(true);
          }

          this.singleSelection = true;
          this.selectedIndex = this.listElements.indexOf(preselectedElement);
        }
      },
      getListItemIndex: function getListItemIndex(evt) {
        var eventTarget = evt.target;
        var index = -1; // Find the first ancestor that is a list item or the list.

        while (!eventTarget.classList.contains(MDCListFoundation.cssClasses.LIST_ITEM_CLASS) && !eventTarget.classList.contains(MDCListFoundation.cssClasses.ROOT)) {
          eventTarget = eventTarget.parentElement;
        } // Get the index of the element if it is a list item.


        if (eventTarget.classList.contains(MDCListFoundation.cssClasses.LIST_ITEM_CLASS)) {
          index = this.listElements.indexOf(eventTarget);
        }

        return index;
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCListFoundation({
        getListItemCount: function getListItemCount() {
          return _this.listElements.length;
        },
        getFocusedElementIndex: function getFocusedElementIndex() {
          return _this.listElements.indexOf(document.activeElement);
        },
        setAttributeForElementIndex: function setAttributeForElementIndex(index, attr, value) {
          var element = _this.listElements[index];

          if (element) {
            element.setAttribute(attr, value);
          }
        },
        removeAttributeForElementIndex: function removeAttributeForElementIndex(index, attr) {
          var element = _this.listElements[index];

          if (element) {
            element.removeAttribute(attr);
          }
        },
        addClassForElementIndex: function addClassForElementIndex(index, className) {
          var element = _this.listElements[index];

          if (element) {
            element.classList.add(className);
          }
        },
        removeClassForElementIndex: function removeClassForElementIndex(index, className) {
          var element = _this.listElements[index];

          if (element) {
            element.classList.remove(className);
          }
        },
        focusItemAtIndex: function focusItemAtIndex(index) {
          var element = _this.listElements[index];

          if (element) {
            element.focus();
          }
        },
        setTabIndexForListItemChildren: function setTabIndexForListItemChildren(listItemIndex, tabIndexValue) {
          var element = _this.listElements[listItemIndex];
          var listItemChildren = [].slice.call(element.querySelectorAll(MDCListFoundation.strings.CHILD_ELEMENTS_TO_TOGGLE_TABINDEX));
          listItemChildren.forEach(function (ele) {
            return ele.setAttribute('tabindex', tabIndexValue);
          });
        },
        followHref: function followHref(index) {
          var listItem = _this.listElements[index];

          if (listItem && listItem.href) {
            listItem.click();
          }
        },
        hasCheckboxAtIndex: function hasCheckboxAtIndex(index) {
          var listItem = _this.listElements[index];
          return !!listItem.querySelector(MDCListFoundation.strings.CHECKBOX_SELECTOR);
        },
        hasRadioAtIndex: function hasRadioAtIndex(index) {
          var listItem = _this.listElements[index];
          return !!listItem.querySelector(MDCListFoundation.strings.RADIO_SELECTOR);
        },
        isCheckboxCheckedAtIndex: function isCheckboxCheckedAtIndex(index) {
          var listItem = _this.listElements[index];
          var toggleEl = listItem.querySelector(MDCListFoundation.strings.CHECKBOX_SELECTOR);
          return toggleEl.checked;
        },
        setCheckedCheckboxOrRadioAtIndex: function setCheckedCheckboxOrRadioAtIndex(index, isChecked) {
          var listItem = _this.listElements[index];
          var toggleEl = listItem.querySelector(MDCListFoundation.strings.CHECKBOX_RADIO_SELECTOR);
          toggleEl.checked = isChecked;
          var event = document.createEvent('Event');
          event.initEvent('change', true, true);
          toggleEl.dispatchEvent(event);
        }
      });
      this.foundation.init();
      this.foundation.setSingleSelection(this.singleSelection);
      this.foundation.setVerticalOrientation(this.vertical);
      this.layout();
    }
  };

  /* script */
  const __vue_script__$A = script$A;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$A.__file = "/ddata/extra/vma/components/list/mdc-list.vue";

  /* template */
  var __vue_render__$x = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "ul",
      {
        staticClass: "mdc-list",
        class: _vm.classes,
        attrs: { "aria-orientation": _vm.orientation },
        on: {
          click: _vm.handleClickEvent,
          keydown: _vm.handleKeydownEvent,
          focusin: _vm.handleFocusInEvent,
          focusout: _vm.handleFocusOutEvent
        }
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$x = [];
  __vue_render__$x._withStripped = true;

    /* style */
    const __vue_inject_styles__$A = undefined;
    /* scoped */
    const __vue_scope_id__$A = undefined;
    /* module identifier */
    const __vue_module_identifier__$A = undefined;
    /* functional template */
    const __vue_is_functional_template__$A = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcList = normalizeComponent(
      { render: __vue_render__$x, staticRenderFns: __vue_staticRenderFns__$x },
      __vue_inject_styles__$A,
      __vue_script__$A,
      __vue_scope_id__$A,
      __vue_is_functional_template__$A,
      __vue_module_identifier__$A,
      undefined,
      undefined
    );

  //
  var script$B = {
    name: 'mdc-list-item',
    inject: ['mdcList'],
    props: {
      selected: Boolean,
      activated: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    computed: {
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--selected': this.selected,
          'mdc-list-item--activated': this.activated
        };
      },
      isInteractive: function isInteractive() {
        return this.mdcList && this.mdcList.interactive;
      },
      hasSecondary: function hasSecondary() {
        return this.$slots['secondary'] && this.mdcList && this.mdcList.twoLine;
      },
      hasEndDetail: function hasEndDetail() {
        return !!this.$slots['end-detail'];
      },
      hasStartDetail: function hasStartDetail() {
        return !!this.$slots['start-detail'];
      }
    },
    watch: {
      isInteractive: function isInteractive(value) {
        if (value) {
          this.addRipple();
        } else {
          this.removeRipple();
        }
      }
    },
    mounted: function mounted() {
      this.isInteractive && this.addRipple();
    },
    beforeDestroy: function beforeDestroy() {
      this.removeRipple();
    },
    methods: {
      addRipple: function addRipple() {
        if (!this.ripple) {
          var ripple = new RippleBase(this);
          ripple.init();
          this.ripple = ripple;
        }
      },
      removeRipple: function removeRipple() {
        if (this.ripple) {
          var ripple = this.ripple;
          this.ripple = null;
          ripple.destroy();
        }
      }
    }
  };

  /* script */
  const __vue_script__$B = script$B;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$B.__file = "/ddata/extra/vma/components/list/mdc-list-item.vue";

  /* template */
  var __vue_render__$y = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      _vm._g(
        {
          staticClass: "mdc-list-item",
          class: [_vm.classes, _vm.itemClasses],
          style: _vm.styles,
          attrs: { tabindex: _vm.isInteractive ? "0" : undefined }
        },
        _vm.isInteractive ? _vm.$listeners : {}
      ),
      [
        _vm._t("start-detail"),
        _vm._v(" "),
        _vm.hasSecondary
          ? _c("span", { staticClass: "mdc-list-item__text" }, [
              _c(
                "span",
                { staticClass: "mdc-list-item__primary-text" },
                [_vm._t("default")],
                2
              ),
              _vm._v(" "),
              _vm.hasSecondary
                ? _c(
                    "span",
                    { staticClass: "mdc-list-item__secondary-text" },
                    [_vm._t("secondary")],
                    2
                  )
                : _vm._e()
            ])
          : _c(
              "span",
              { staticClass: "mdc-list-item__text" },
              [_vm._t("default")],
              2
            ),
        _vm._v(" "),
        _vm._t("end-detail")
      ],
      2
    )
  };
  var __vue_staticRenderFns__$y = [];
  __vue_render__$y._withStripped = true;

    /* style */
    const __vue_inject_styles__$B = undefined;
    /* scoped */
    const __vue_scope_id__$B = undefined;
    /* module identifier */
    const __vue_module_identifier__$B = undefined;
    /* functional template */
    const __vue_is_functional_template__$B = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcListItem = normalizeComponent(
      { render: __vue_render__$y, staticRenderFns: __vue_staticRenderFns__$y },
      __vue_inject_styles__$B,
      __vue_script__$B,
      __vue_scope_id__$B,
      __vue_is_functional_template__$B,
      __vue_module_identifier__$B,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  var script$C = {
    name: 'mdc-list-divider',
    props: {
      inset: Boolean,
      padded: Boolean
    },
    computed: {
      classes: function classes() {
        return {
          'mdc-list-divider--inset': this.inset,
          'mdc-list-divider--padded': this.padded
        };
      }
    }
  };

  /* script */
  const __vue_script__$C = script$C;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$C.__file = "/ddata/extra/vma/components/list/mdc-list-divider.vue";

  /* template */
  var __vue_render__$z = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", {
      staticClass: "mdc-list-divider",
      class: _vm.classes,
      attrs: { role: "separator" }
    })
  };
  var __vue_staticRenderFns__$z = [];
  __vue_render__$z._withStripped = true;

    /* style */
    const __vue_inject_styles__$C = undefined;
    /* scoped */
    const __vue_scope_id__$C = undefined;
    /* module identifier */
    const __vue_module_identifier__$C = undefined;
    /* functional template */
    const __vue_is_functional_template__$C = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcListDivider = normalizeComponent(
      { render: __vue_render__$z, staticRenderFns: __vue_staticRenderFns__$z },
      __vue_inject_styles__$C,
      __vue_script__$C,
      __vue_scope_id__$C,
      __vue_is_functional_template__$C,
      __vue_module_identifier__$C,
      undefined,
      undefined
    );

  //
  //
  //
  //
  var script$D = {
    name: 'mdc-list-group'
  };

  /* script */
  const __vue_script__$D = script$D;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$D.__file = "/ddata/extra/vma/components/list/mdc-list-group.vue";

  /* template */
  var __vue_render__$A = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-list-group" }, [_vm._t("default")], 2)
  };
  var __vue_staticRenderFns__$A = [];
  __vue_render__$A._withStripped = true;

    /* style */
    const __vue_inject_styles__$D = undefined;
    /* scoped */
    const __vue_scope_id__$D = undefined;
    /* module identifier */
    const __vue_module_identifier__$D = undefined;
    /* functional template */
    const __vue_is_functional_template__$D = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcListGroup = normalizeComponent(
      { render: __vue_render__$A, staticRenderFns: __vue_staticRenderFns__$A },
      __vue_inject_styles__$D,
      __vue_script__$D,
      __vue_scope_id__$D,
      __vue_is_functional_template__$D,
      __vue_module_identifier__$D,
      undefined,
      undefined
    );

  //
  //
  //
  //
  var script$E = {
    name: 'mdc-list-group-header'
  };

  /* script */
  const __vue_script__$E = script$E;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$E.__file = "/ddata/extra/vma/components/list/mdc-list-group-header.vue";

  /* template */
  var __vue_render__$B = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "h3",
      { staticClass: "mdc-list-group-header mdc-list-group__subheader" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$B = [];
  __vue_render__$B._withStripped = true;

    /* style */
    const __vue_inject_styles__$E = undefined;
    /* scoped */
    const __vue_scope_id__$E = undefined;
    /* module identifier */
    const __vue_module_identifier__$E = undefined;
    /* functional template */
    const __vue_is_functional_template__$E = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcListGroupHeader = normalizeComponent(
      { render: __vue_render__$B, staticRenderFns: __vue_staticRenderFns__$B },
      __vue_inject_styles__$E,
      __vue_script__$E,
      __vue_scope_id__$E,
      __vue_is_functional_template__$E,
      __vue_module_identifier__$E,
      undefined,
      undefined
    );

  //
  //
  //
  //
  var script$F = {
    name: 'mdc-list-group-divider'
  };

  /* script */
  const __vue_script__$F = script$F;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$F.__file = "/ddata/extra/vma/components/list/mdc-list-group-divider.vue";

  /* template */
  var __vue_render__$C = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("hr", { staticClass: "mdc-list-group-divider mdc-list-divider" })
  };
  var __vue_staticRenderFns__$C = [];
  __vue_render__$C._withStripped = true;

    /* style */
    const __vue_inject_styles__$F = undefined;
    /* scoped */
    const __vue_scope_id__$F = undefined;
    /* module identifier */
    const __vue_module_identifier__$F = undefined;
    /* functional template */
    const __vue_is_functional_template__$F = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcListGroupDivider = normalizeComponent(
      { render: __vue_render__$C, staticRenderFns: __vue_staticRenderFns__$C },
      __vue_inject_styles__$F,
      __vue_script__$F,
      __vue_scope_id__$F,
      __vue_is_functional_template__$F,
      __vue_module_identifier__$F,
      undefined,
      undefined
    );

  var VueMDCList = BasePlugin({
    mdcList: mdcList,
    mdcListItem: mdcListItem,
    mdcListDivider: mdcListDivider,
    mdcListGroup: mdcListGroup,
    mdcListGroupHeader: mdcListGroupHeader,
    mdcListGroupDivider: mdcListGroupDivider
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Menu. Provides an interface for managing
   * - selected element classes
   * - get focused elements
   * - toggling a checkbox inside a list item
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuAdapter =
  /*#__PURE__*/
  function () {
    function MDCMenuAdapter() {
      _classCallCheck(this, MDCMenuAdapter);
    }

    _createClass(MDCMenuAdapter, [{
      key: "addClassToElementAtIndex",

      /**
       * Adds a class to the element at the index provided.
       * @param {number} index
       * @param {string} className
       */
      value: function addClassToElementAtIndex(index, className) {}
      /**
       * Removes a class from the element at the index provided
       * @param {number} index
       * @param {string} className
       */

    }, {
      key: "removeClassFromElementAtIndex",
      value: function removeClassFromElementAtIndex(index, className) {}
      /**
       * Adds an attribute, with value, to the element at the index provided.
       * @param {number} index
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "addAttributeToElementAtIndex",
      value: function addAttributeToElementAtIndex(index, attr, value) {}
      /**
       * Removes an attribute from an element at the index provided.
       * @param {number} index
       * @param {string} attr
       */

    }, {
      key: "removeAttributeFromElementAtIndex",
      value: function removeAttributeFromElementAtIndex(index, attr) {}
      /**
       * Returns true if the element contains the className.
       * @param {?HTMLElement} element
       * @param {string} className
       * @return {boolean} true if the element contains the className
       */

    }, {
      key: "elementContainsClass",
      value: function elementContainsClass(element, className) {}
      /**
       * Closes the menu-surface.
       */

    }, {
      key: "closeSurface",
      value: function closeSurface() {}
      /**
       * Returns the index for the element provided.
       * @param {?HTMLElement} element
       * @return {number} index of the element in the list or -1 if it is not in the list.
       */

    }, {
      key: "getElementIndex",
      value: function getElementIndex(element) {}
      /**
       * Returns the parentElement of the provided element.
       * @param {?HTMLElement} element
       * @return {?HTMLElement} parentElement of the element provided.
       */

    }, {
      key: "getParentElement",
      value: function getParentElement(element) {}
      /**
       * Returns the element within the selectionGroup containing the selected element class.
       * @param {!HTMLElement} selectionGroup
       * @return {number} element within the selectionGroup that contains the selected element class.
       */

    }, {
      key: "getSelectedElementIndex",
      value: function getSelectedElementIndex(selectionGroup) {}
      /**
       * Emits an event using the evtData.
       * @param {{
      *    index: number
      *   }} evtData
       */

    }, {
      key: "notifySelected",
      value: function notifySelected(evtData) {}
    }]);

    return MDCMenuAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$c = {
    ROOT: 'mdc-menu',
    MENU_SELECTED_LIST_ITEM: 'mdc-menu-item--selected',
    MENU_SELECTION_GROUP: 'mdc-menu__selection-group'
  };
  /** @enum {string} */

  var strings$d = {
    SELECTED_EVENT: 'MDCMenu:selected',
    ARIA_SELECTED_ATTR: 'aria-selected',
    LIST_SELECTOR: '.mdc-list',
    CHECKBOX_SELECTOR: 'input[type="checkbox"]'
  };

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDCMenuSurface. Provides an interface for managing
   * - classes
   * - dom
   * - focus
   * - position
   * - dimensions
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCMenuSurfaceAdapter =
  /*#__PURE__*/
  function () {
    function MDCMenuSurfaceAdapter() {
      _classCallCheck(this, MDCMenuSurfaceAdapter);
    }

    _createClass(MDCMenuSurfaceAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /** @return {boolean} */

    }, {
      key: "hasAnchor",
      value: function hasAnchor() {}
      /** Emits an event when the menu surface is closed. */

    }, {
      key: "notifyClose",
      value: function notifyClose() {}
      /** Emits an event when the menu surface is opened. */

    }, {
      key: "notifyOpen",
      value: function notifyOpen() {}
      /**
       * @return {boolean}
       * @param {EventTarget} el
       */

    }, {
      key: "isElementInContainer",
      value: function isElementInContainer(el) {}
      /** @return {boolean} */

    }, {
      key: "isRtl",
      value: function isRtl() {}
      /** @param {string} origin */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(origin) {}
      /** @return {boolean} */

    }, {
      key: "isFocused",
      value: function isFocused() {}
      /** Saves the element that was focused before the menu surface was opened. */

    }, {
      key: "saveFocus",
      value: function saveFocus() {}
      /** Restores focus to the element that was focused before the menu surface was opened. */

    }, {
      key: "restoreFocus",
      value: function restoreFocus() {}
      /** @return {boolean} */

    }, {
      key: "isFirstElementFocused",
      value: function isFirstElementFocused() {}
      /** @return {boolean} */

    }, {
      key: "isLastElementFocused",
      value: function isLastElementFocused() {}
      /** Focuses the first focusable element in the menu-surface. */

    }, {
      key: "focusFirstElement",
      value: function focusFirstElement() {}
      /** Focuses the first focusable element in the menu-surface. */

    }, {
      key: "focusLastElement",
      value: function focusLastElement() {}
      /** @return {!{width: number, height: number}} */

    }, {
      key: "getInnerDimensions",
      value: function getInnerDimensions() {}
      /** @return {!{width: number, height: number, top: number, right: number, bottom: number, left: number}} */

    }, {
      key: "getAnchorDimensions",
      value: function getAnchorDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getWindowDimensions",
      value: function getWindowDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getBodyDimensions",
      value: function getBodyDimensions() {}
      /** @return {!{ width: number, height: number }} */

    }, {
      key: "getWindowScroll",
      value: function getWindowScroll() {}
      /** @param {!{
      *   top: (string|undefined),
      *   right: (string|undefined),
      *   bottom: (string|undefined),
      *   left: (string|undefined)
      * }} position */

    }, {
      key: "setPosition",
      value: function setPosition(position) {}
      /** @param {string} height */

    }, {
      key: "setMaxHeight",
      value: function setMaxHeight(height) {}
    }]);

    return MDCMenuSurfaceAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$d = {
    ANCHOR: 'mdc-menu-surface--anchor',
    ANIMATING_CLOSED: 'mdc-menu-surface--animating-closed',
    ANIMATING_OPEN: 'mdc-menu-surface--animating-open',
    FIXED: 'mdc-menu-surface--fixed',
    OPEN: 'mdc-menu-surface--open',
    ROOT: 'mdc-menu-surface'
  };
  /** @enum {string} */

  var strings$e = {
    CLOSED_EVENT: 'MDCMenuSurface:closed',
    OPENED_EVENT: 'MDCMenuSurface:opened',
    FOCUSABLE_ELEMENTS: 'button:not(:disabled), [href]:not([aria-disabled="true"]), input:not(:disabled), ' + 'select:not(:disabled), textarea:not(:disabled), [tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  };
  /** @enum {number} */

  var numbers$3 = {
    // Total duration of menu-surface open animation.
    TRANSITION_OPEN_DURATION: 120,
    // Total duration of menu-surface close animation.
    TRANSITION_CLOSE_DURATION: 75,
    // Margin left to the edge of the viewport when menu-surface is at maximum possible height.
    MARGIN_TO_EDGE: 32,
    // Ratio of anchor width to menu-surface width for switching from corner positioning to center positioning.
    ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67
  };
  /**
   * Enum for bits in the {@see Corner) bitmap.
   * @enum {number}
   */

  var CornerBit = {
    BOTTOM: 1,
    CENTER: 2,
    RIGHT: 4,
    FLIP_RTL: 8
  };
  /**
   * Enum for representing an element corner for positioning the menu-surface.
   *
   * The START constants map to LEFT if element directionality is left
   * to right and RIGHT if the directionality is right to left.
   * Likewise END maps to RIGHT or LEFT depending on the directionality.
   *
   * @enum {number}
   */

  var Corner = {
    TOP_LEFT: 0,
    TOP_RIGHT: CornerBit.RIGHT,
    BOTTOM_LEFT: CornerBit.BOTTOM,
    BOTTOM_RIGHT: CornerBit.BOTTOM | CornerBit.RIGHT,
    TOP_START: CornerBit.FLIP_RTL,
    TOP_END: CornerBit.FLIP_RTL | CornerBit.RIGHT,
    BOTTOM_START: CornerBit.BOTTOM | CornerBit.FLIP_RTL,
    BOTTOM_END: CornerBit.BOTTOM | CornerBit.RIGHT | CornerBit.FLIP_RTL
  };

  /**
   * @extends {MDCFoundation<!MDCMenuSurfaceAdapter>}
   */

  var MDCMenuSurfaceFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCMenuSurfaceFoundation, _MDCFoundation);

    _createClass(MDCMenuSurfaceFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        return cssClasses$d;
      }
      /** @return enum{string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$e;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$3;
      }
      /** @return enum{number} */

    }, {
      key: "Corner",
      get: function get() {
        return Corner;
      }
      /**
       * {@see MDCMenuSurfaceAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuSurfaceAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCMenuSurfaceAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {
              return false;
            },
            hasAnchor: function hasAnchor() {
              return false;
            },
            notifyClose: function notifyClose() {},
            notifyOpen: function notifyOpen() {},
            isElementInContainer: function isElementInContainer() {
              return false;
            },
            isRtl: function isRtl() {
              return false;
            },
            setTransformOrigin: function setTransformOrigin() {},
            isFocused: function isFocused() {
              return false;
            },
            saveFocus: function saveFocus() {},
            restoreFocus: function restoreFocus() {},
            isFirstElementFocused: function isFirstElementFocused() {},
            isLastElementFocused: function isLastElementFocused() {},
            focusFirstElement: function focusFirstElement() {},
            focusLastElement: function focusLastElement() {},
            getInnerDimensions: function getInnerDimensions() {
              return {};
            },
            getAnchorDimensions: function getAnchorDimensions() {
              return {};
            },
            getWindowDimensions: function getWindowDimensions() {
              return {};
            },
            getBodyDimensions: function getBodyDimensions() {
              return {};
            },
            getWindowScroll: function getWindowScroll() {
              return {};
            },
            setPosition: function setPosition() {},
            setMaxHeight: function setMaxHeight() {}
          }
        );
      }
      /** @param {!MDCMenuSurfaceAdapter} adapter */

    }]);

    function MDCMenuSurfaceFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCMenuSurfaceFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCMenuSurfaceFoundation).call(this, _extends(MDCMenuSurfaceFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.openAnimationEndTimerId_ = 0;
      /** @private {number} */

      _this.closeAnimationEndTimerId_ = 0;
      /** @private {number} */

      _this.animationRequestId_ = 0;
      /** @private {!{ width: number, height: number }} */

      _this.dimensions_;
      /** @private {!Corner} */

      _this.anchorCorner_ = Corner.TOP_START;
      /** @private {!AnchorMargin} */

      _this.anchorMargin_ = {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
      };
      /** @private {?AutoLayoutMeasurements} */

      _this.measures_ = null;
      /** @private {boolean} */

      _this.quickOpen_ = false;
      /** @private {boolean} */

      _this.hoistedElement_ = false;
      /** @private {boolean} */

      _this.isFixedPosition_ = false;
      /** @private {!{x: number, y: number}} */

      _this.position_ = {
        x: 0,
        y: 0
      };
      return _this;
    }

    _createClass(MDCMenuSurfaceFoundation, [{
      key: "init",
      value: function init() {
        var _MDCMenuSurfaceFounda = MDCMenuSurfaceFoundation.cssClasses,
            ROOT = _MDCMenuSurfaceFounda.ROOT,
            OPEN = _MDCMenuSurfaceFounda.OPEN;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error("".concat(ROOT, " class required in root element."));
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        clearTimeout(this.openAnimationEndTimerId_);
        clearTimeout(this.closeAnimationEndTimerId_); // Cancel any currently running animations.

        cancelAnimationFrame(this.animationRequestId_);
      }
      /**
       * @param {!Corner} corner Default anchor corner alignment of top-left menu surface corner.
       */

    }, {
      key: "setAnchorCorner",
      value: function setAnchorCorner(corner) {
        this.anchorCorner_ = corner;
      }
      /**
       * @param {!AnchorMargin} margin set of margin values from anchor.
       */

    }, {
      key: "setAnchorMargin",
      value: function setAnchorMargin(margin) {
        this.anchorMargin_.top = typeof margin.top === 'number' ? margin.top : 0;
        this.anchorMargin_.right = typeof margin.right === 'number' ? margin.right : 0;
        this.anchorMargin_.bottom = typeof margin.bottom === 'number' ? margin.bottom : 0;
        this.anchorMargin_.left = typeof margin.left === 'number' ? margin.left : 0;
      }
      /**
       * Used to indicate if the menu-surface is hoisted to the body.
       * @param {boolean} isHoisted
       */

    }, {
      key: "setIsHoisted",
      value: function setIsHoisted(isHoisted) {
        this.hoistedElement_ = isHoisted;
      }
      /**
       * Used to set the menu-surface calculations based on a fixed position menu.
       * @param {boolean} isFixedPosition
       */

    }, {
      key: "setFixedPosition",
      value: function setFixedPosition(isFixedPosition) {
        this.isFixedPosition_ = isFixedPosition;
      }
      /**
       * Sets the menu-surface position on the page.
       * @param {number} x
       * @param {number} y
       */

    }, {
      key: "setAbsolutePosition",
      value: function setAbsolutePosition(x, y) {
        this.position_.x = this.typeCheckisFinite_(x) ? x : 0;
        this.position_.y = this.typeCheckisFinite_(y) ? y : 0;
      }
      /** @param {boolean} quickOpen */

    }, {
      key: "setQuickOpen",
      value: function setQuickOpen(quickOpen) {
        this.quickOpen_ = quickOpen;
      }
      /**
       * Handle clicks and close if not within menu-surface element.
       * @param {!Event} evt
       */

    }, {
      key: "handleBodyClick",
      value: function handleBodyClick(evt) {
        var el = evt.target;

        if (this.adapter_.isElementInContainer(el)) {
          return;
        }

        this.close();
      }
    }, {
      key: "handleKeydown",

      /**
       * Handle keys that close the surface.
       * @param {!Event} evt
       */
      value: function handleKeydown(evt) {
        var keyCode = evt.keyCode,
            key = evt.key,
            shiftKey = evt.shiftKey;
        var isEscape = key === 'Escape' || keyCode === 27;
        var isTab = key === 'Tab' || keyCode === 9;

        if (isEscape) {
          this.close();
        } else if (isTab) {
          if (this.adapter_.isLastElementFocused() && !shiftKey) {
            this.adapter_.focusFirstElement();
            evt.preventDefault();
          } else if (this.adapter_.isFirstElementFocused() && shiftKey) {
            this.adapter_.focusLastElement();
            evt.preventDefault();
          }
        }
      }
      /**
       * @return {!AutoLayoutMeasurements} Measurements used to position menu surface popup.
       */

    }, {
      key: "getAutoLayoutMeasurements_",
      value: function getAutoLayoutMeasurements_() {
        var anchorRect = this.adapter_.getAnchorDimensions();
        var viewport = this.adapter_.getWindowDimensions();
        var bodyDimensions = this.adapter_.getBodyDimensions();
        var windowScroll = this.adapter_.getWindowScroll();

        if (!anchorRect) {
          anchorRect =
          /** @type {ClientRect} */
          {
            x: this.position_.x,
            y: this.position_.y,
            top: this.position_.y,
            bottom: this.position_.y,
            left: this.position_.x,
            right: this.position_.x,
            height: 0,
            width: 0
          };
        }

        return {
          viewport: viewport,
          bodyDimensions: bodyDimensions,
          windowScroll: windowScroll,
          viewportDistance: {
            top: anchorRect.top,
            right: viewport.width - anchorRect.right,
            left: anchorRect.left,
            bottom: viewport.height - anchorRect.bottom
          },
          anchorHeight: anchorRect.height,
          anchorWidth: anchorRect.width,
          surfaceHeight: this.dimensions_.height,
          surfaceWidth: this.dimensions_.width
        };
      }
      /**
       * Computes the corner of the anchor from which to animate and position the menu surface.
       * @return {!Corner}
       * @private
       */

    }, {
      key: "getOriginCorner_",
      value: function getOriginCorner_() {
        // Defaults: open from the top left.
        var corner = Corner.TOP_LEFT;
        var _this$measures_ = this.measures_,
            viewportDistance = _this$measures_.viewportDistance,
            anchorHeight = _this$measures_.anchorHeight,
            anchorWidth = _this$measures_.anchorWidth,
            surfaceHeight = _this$measures_.surfaceHeight,
            surfaceWidth = _this$measures_.surfaceWidth;
        var isBottomAligned = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var availableTop = isBottomAligned ? viewportDistance.top + anchorHeight + this.anchorMargin_.bottom : viewportDistance.top + this.anchorMargin_.top;
        var availableBottom = isBottomAligned ? viewportDistance.bottom - this.anchorMargin_.bottom : viewportDistance.bottom + anchorHeight - this.anchorMargin_.top;
        var topOverflow = surfaceHeight - availableTop;
        var bottomOverflow = surfaceHeight - availableBottom;

        if (bottomOverflow > 0 && topOverflow < bottomOverflow) {
          corner |= CornerBit.BOTTOM;
        }

        var isRtl = this.adapter_.isRtl();
        var isFlipRtl = Boolean(this.anchorCorner_ & CornerBit.FLIP_RTL);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);
        var isAlignedRight = avoidHorizontalOverlap && !isRtl || !avoidHorizontalOverlap && isFlipRtl && isRtl;
        var availableLeft = isAlignedRight ? viewportDistance.left + anchorWidth + this.anchorMargin_.right : viewportDistance.left + this.anchorMargin_.left;
        var availableRight = isAlignedRight ? viewportDistance.right - this.anchorMargin_.right : viewportDistance.right + anchorWidth - this.anchorMargin_.left;
        var leftOverflow = surfaceWidth - availableLeft;
        var rightOverflow = surfaceWidth - availableRight;

        if (leftOverflow < 0 && isAlignedRight && isRtl || avoidHorizontalOverlap && !isAlignedRight && leftOverflow < 0 || rightOverflow > 0 && leftOverflow < rightOverflow) {
          corner |= CornerBit.RIGHT;
        }

        return (
          /** @type {Corner} */
          corner
        );
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Horizontal offset of menu surface origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: "getHorizontalOriginOffset_",
      value: function getHorizontalOriginOffset_(corner) {
        var anchorWidth = this.measures_.anchorWidth; // isRightAligned corresponds to using the 'right' property on the surface.

        var isRightAligned = Boolean(corner & CornerBit.RIGHT);
        var avoidHorizontalOverlap = Boolean(this.anchorCorner_ & CornerBit.RIGHT);

        if (isRightAligned) {
          var rightOffset = avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.left : this.anchorMargin_.right; // For hoisted or fixed elements, adjust the offset by the difference between viewport width and body width so
          // when we calculate the right value (`adjustPositionForHoistedElement_`) based on the element position,
          // the right property is correct.

          if (this.hoistedElement_ || this.isFixedPosition_) {
            return rightOffset - (this.measures_.viewport.width - this.measures_.bodyDimensions.width);
          }

          return rightOffset;
        }

        return avoidHorizontalOverlap ? anchorWidth - this.anchorMargin_.right : this.anchorMargin_.left;
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Vertical offset of menu surface origin corner from corresponding anchor corner.
       * @private
       */

    }, {
      key: "getVerticalOriginOffset_",
      value: function getVerticalOriginOffset_(corner) {
        var anchorHeight = this.measures_.anchorHeight;
        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var avoidVerticalOverlap = Boolean(this.anchorCorner_ & CornerBit.BOTTOM);
        var y = 0;

        if (isBottomAligned) {
          y = avoidVerticalOverlap ? anchorHeight - this.anchorMargin_.top : -this.anchorMargin_.bottom;
        } else {
          y = avoidVerticalOverlap ? anchorHeight + this.anchorMargin_.bottom : this.anchorMargin_.top;
        }

        return y;
      }
      /**
       * @param {!Corner} corner Origin corner of the menu surface.
       * @return {number} Maximum height of the menu surface, based on available space. 0 indicates should not be set.
       * @private
       */

    }, {
      key: "getMenuSurfaceMaxHeight_",
      value: function getMenuSurfaceMaxHeight_(corner) {
        var maxHeight = 0;
        var viewportDistance = this.measures_.viewportDistance;
        var isBottomAligned = Boolean(corner & CornerBit.BOTTOM);
        var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation.numbers.MARGIN_TO_EDGE; // When maximum height is not specified, it is handled from css.

        if (isBottomAligned) {
          maxHeight = viewportDistance.top + this.anchorMargin_.top - MARGIN_TO_EDGE;

          if (!(this.anchorCorner_ & CornerBit.BOTTOM)) {
            maxHeight += this.measures_.anchorHeight;
          }
        } else {
          maxHeight = viewportDistance.bottom - this.anchorMargin_.bottom + this.measures_.anchorHeight - MARGIN_TO_EDGE;

          if (this.anchorCorner_ & CornerBit.BOTTOM) {
            maxHeight -= this.measures_.anchorHeight;
          }
        }

        return maxHeight;
      }
      /** @private */

    }, {
      key: "autoPosition_",
      value: function autoPosition_() {
        var _position;

        // Compute measurements for autoposition methods reuse.
        this.measures_ = this.getAutoLayoutMeasurements_();
        var corner = this.getOriginCorner_();
        var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight_(corner);
        var verticalAlignment = corner & CornerBit.BOTTOM ? 'bottom' : 'top';
        var horizontalAlignment = corner & CornerBit.RIGHT ? 'right' : 'left';
        var horizontalOffset = this.getHorizontalOriginOffset_(corner);
        var verticalOffset = this.getVerticalOriginOffset_(corner);
        var position = (_position = {}, _defineProperty(_position, horizontalAlignment, horizontalOffset ? horizontalOffset : '0'), _defineProperty(_position, verticalAlignment, verticalOffset ? verticalOffset : '0'), _position);
        var _this$measures_2 = this.measures_,
            anchorWidth = _this$measures_2.anchorWidth,
            surfaceWidth = _this$measures_2.surfaceWidth; // Center align when anchor width is comparable or greater than menu surface, otherwise keep corner.

        if (anchorWidth / surfaceWidth > numbers$3.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
          horizontalAlignment = 'center';
        } // If the menu-surface has been hoisted to the body, it's no longer relative to the anchor element


        if (this.hoistedElement_ || this.isFixedPosition_) {
          position = this.adjustPositionForHoistedElement_(position);
        }

        for (var prop in position) {
          if (position.hasOwnProperty(prop) && position[prop] !== '0') {
            position[prop] = "".concat(parseInt(position[prop], 10), "px");
          }
        }

        this.adapter_.setTransformOrigin("".concat(horizontalAlignment, " ").concat(verticalAlignment));
        this.adapter_.setPosition(position);
        this.adapter_.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + 'px' : ''); // Clear measures after positioning is complete.

        this.measures_ = null;
      }
      /**
       * Calculates the offsets for positioning the menu-surface when the menu-surface has been
       * hoisted to the body.
       * @param {!{
       *   top: (string|undefined),
       *   right: (string|undefined),
       *   bottom: (string|undefined),
       *   left: (string|undefined)
       * }} position
       * @return {!{
       *   top: (string|undefined),
       *   right: (string|undefined),
       *   bottom: (string|undefined),
       *   left: (string|undefined)
       * }} position
       * @private
       */

    }, {
      key: "adjustPositionForHoistedElement_",
      value: function adjustPositionForHoistedElement_(position) {
        var _this$measures_3 = this.measures_,
            windowScroll = _this$measures_3.windowScroll,
            viewportDistance = _this$measures_3.viewportDistance;

        for (var prop in position) {
          if (position.hasOwnProperty(prop)) {
            // Hoisted surfaces need to have the anchor elements location on the page added to the
            // position properties for proper alignment on the body.
            if (viewportDistance.hasOwnProperty(prop)) {
              position[prop] = parseInt(position[prop], 10) + viewportDistance[prop];
            } // Surfaces that are absolutely positioned need to have additional calculations for scroll
            // and bottom positioning.


            if (!this.isFixedPosition_) {
              if (prop === 'top') {
                position[prop] = parseInt(position[prop], 10) + windowScroll.y;
              } else if (prop === 'bottom') {
                position[prop] = parseInt(position[prop], 10) - windowScroll.y;
              } else if (prop === 'left') {
                position[prop] = parseInt(position[prop], 10) + windowScroll.x;
              } else if (prop === 'right') {
                position[prop] = parseInt(position[prop], 10) - windowScroll.x;
              }
            }
          }
        }

        return position;
      }
      /**
       * Open the menu surface.
       */

    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.adapter_.saveFocus();

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);
        }

        this.animationRequestId_ = requestAnimationFrame(function () {
          _this2.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

          _this2.dimensions_ = _this2.adapter_.getInnerDimensions();

          _this2.autoPosition_();

          if (_this2.quickOpen_) {
            _this2.adapter_.notifyOpen();
          } else {
            _this2.openAnimationEndTimerId_ = setTimeout(function () {
              _this2.openAnimationEndTimerId_ = 0;

              _this2.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_OPEN);

              _this2.adapter_.notifyOpen();
            }, numbers$3.TRANSITION_OPEN_DURATION);
          }
        });
        this.isOpen_ = true;
      }
      /**
       * Closes the menu surface.
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        if (!this.quickOpen_) {
          this.adapter_.addClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);
        }

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.OPEN);

          if (_this3.quickOpen_) {
            _this3.adapter_.notifyClose();
          } else {
            _this3.closeAnimationEndTimerId_ = setTimeout(function () {
              _this3.closeAnimationEndTimerId_ = 0;

              _this3.adapter_.removeClass(MDCMenuSurfaceFoundation.cssClasses.ANIMATING_CLOSED);

              _this3.adapter_.notifyClose();
            }, numbers$3.TRANSITION_CLOSE_DURATION);
          }
        });
        this.isOpen_ = false;
        this.maybeRestoreFocus_();
      }
      /**
       * The last focused element when the menu surface was opened should regain focus, if the user is
       * focused on or within the menu surface when it is closed.
       * @private
       */

    }, {
      key: "maybeRestoreFocus_",
      value: function maybeRestoreFocus_() {
        if (this.adapter_.isFocused() || this.adapter_.isElementInContainer(document.activeElement)) {
          this.adapter_.restoreFocus();
        }
      }
      /** @return {boolean} */

    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /**
       * isFinite that doesn't force conversion to number type.
       * Equivalent to Number.isFinite in ES2015, but is not included in IE11.
       * @param {number} num
       * @return {boolean}
       * @private
       */

    }, {
      key: "typeCheckisFinite_",
      value: function typeCheckisFinite_(num) {
        return typeof num === 'number' && isFinite(num);
      }
    }]);

    return MDCMenuSurfaceFoundation;
  }(MDCFoundation);

  var ELEMENTS_KEY_ALLOWED_IN$1 = ['input', 'button', 'textarea', 'select', 'a'];
  /**
   * @extends {MDCFoundation<!MDCMenuAdapter>}
   */

  var MDCMenuFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCMenuFoundation, _MDCFoundation);

    _createClass(MDCMenuFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get() {
        return cssClasses$c;
      }
      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$d;
      }
      /**
       * {@see MDCMenuAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCMenuAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCMenuAdapter} */
          {
            addClassToElementAtIndex: function addClassToElementAtIndex() {},
            removeClassFromElementAtIndex: function removeClassFromElementAtIndex() {},
            addAttributeToElementAtIndex: function addAttributeToElementAtIndex() {},
            removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex() {},
            elementContainsClass: function elementContainsClass() {},
            closeSurface: function closeSurface() {},
            getElementIndex: function getElementIndex() {},
            getParentElement: function getParentElement() {},
            getSelectedElementIndex: function getSelectedElementIndex() {},
            notifySelected: function notifySelected() {}
          }
        );
      }
      /** @param {!MDCMenuAdapter} adapter */

    }]);

    function MDCMenuFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCMenuFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCMenuFoundation).call(this, _extends(MDCMenuFoundation.defaultAdapter, adapter)));
      /** @type {number} */

      _this.closeAnimationEndTimerId_ = 0;
      return _this;
    }

    _createClass(MDCMenuFoundation, [{
      key: "destroy",
      value: function destroy() {
        if (this.closeAnimationEndTimerId_) {
          clearTimeout(this.closeAnimationEndTimerId_);
        }

        this.adapter_.closeSurface();
      }
      /**
       * Handler function for the keydown events.
       * @param {!Event} evt
       */

    }, {
      key: "handleKeydown",
      value: function handleKeydown(evt) {
        var key = evt.key,
            keyCode = evt.keyCode;
        var isSpace = key === 'Space' || keyCode === 32;
        var isEnter = key === 'Enter' || keyCode === 13;
        var isTab = key === 'Tab' || keyCode === 9;

        if (isSpace || isEnter) {
          this.handleAction_(evt);
        } else if (isTab) {
          this.adapter_.closeSurface();
        }
      }
      /**
       * Handler function for the click events.
       * @param {!Event} evt
       */

    }, {
      key: "handleClick",
      value: function handleClick(evt) {
        this.handleAction_(evt);
      }
      /**
       * Combined action handling for click/keypress events.
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleAction_",
      value: function handleAction_(evt) {
        var listItem = this.getListItem_(
        /** @type {HTMLElement} */
        evt.target);

        if (listItem) {
          this.handleSelection(listItem);
          this.preventDefaultEvent_(evt);
        }
      }
      /**
       * Handler for a selected list item.
       * @param {?HTMLElement} listItem
       */

    }, {
      key: "handleSelection",
      value: function handleSelection(listItem) {
        var _this2 = this;

        var index = this.adapter_.getElementIndex(listItem);

        if (index < 0) {
          return;
        }

        this.adapter_.notifySelected({
          index: index
        });
        this.adapter_.closeSurface(); // Wait for the menu to close before adding/removing classes that affect styles.

        this.closeAnimationEndTimerId_ = setTimeout(function () {
          var selectionGroup = _this2.getSelectionGroup_(listItem);

          if (selectionGroup !== null) {
            _this2.handleSelectionGroup_(
            /** @type {!HTMLElement} */
            selectionGroup, index);
          }
        }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
      }
      /**
       * Handles toggling the selected classes in a selection group when a
       * selection is made.
       * @param {!HTMLElement} selectionGroup
       * @param {number} index The selected index value
       * @private
       */

    }, {
      key: "handleSelectionGroup_",
      value: function handleSelectionGroup_(selectionGroup, index) {
        // De-select the previous selection in this group.
        var selectedIndex = this.adapter_.getSelectedElementIndex(selectionGroup);

        if (selectedIndex >= 0) {
          this.adapter_.removeAttributeFromElementAtIndex(selectedIndex, strings$d.ARIA_SELECTED_ATTR);
          this.adapter_.removeClassFromElementAtIndex(selectedIndex, cssClasses$c.MENU_SELECTED_LIST_ITEM);
        } // Select the new list item in this group.


        this.adapter_.addClassToElementAtIndex(index, cssClasses$c.MENU_SELECTED_LIST_ITEM);
        this.adapter_.addAttributeToElementAtIndex(index, strings$d.ARIA_SELECTED_ATTR, 'true');
      }
      /**
       * Returns the parent selection group of an element if one exists.
       * @param listItem
       * @return {?HTMLElement} parent selection group element or null.
       * @private
       */

    }, {
      key: "getSelectionGroup_",
      value: function getSelectionGroup_(listItem) {
        var parent = this.adapter_.getParentElement(listItem);
        var isGroup = this.adapter_.elementContainsClass(parent, cssClasses$c.MENU_SELECTION_GROUP); // Iterate through ancestors until we find the group or get to the list.

        while (!isGroup && !this.adapter_.elementContainsClass(parent, MDCListFoundation.cssClasses.ROOT)) {
          parent = this.adapter_.getParentElement(parent);
          isGroup = this.adapter_.elementContainsClass(parent, cssClasses$c.MENU_SELECTION_GROUP);
        }

        if (isGroup) {
          return parent;
        } else {
          return null;
        }
      }
      /**
       * Find the first ancestor with the mdc-list-item class.
       * @param {?HTMLElement} target
       * @return {?HTMLElement}
       * @private
       */

    }, {
      key: "getListItem_",
      value: function getListItem_(target) {
        var isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation.cssClasses.LIST_ITEM_CLASS);

        while (!isListItem) {
          target = this.adapter_.getParentElement(target);

          if (target) {
            isListItem = this.adapter_.elementContainsClass(target, MDCListFoundation.cssClasses.LIST_ITEM_CLASS);
          } else {
            // target has no parent element.
            return null;
          }
        }

        return target;
      }
      /**
       * Ensures that preventDefault is only called if the containing element doesn't
       * consume the event, and it will cause an unintended scroll.
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "preventDefaultEvent_",
      value: function preventDefaultEvent_(evt) {
        var target =
        /** @type {!HTMLElement} */
        evt.target;
        var tagName = "".concat(target.tagName).toLowerCase();

        if (ELEMENTS_KEY_ALLOWED_IN$1.indexOf(tagName) === -1) {
          evt.preventDefault();
        }
      }
    }]);

    return MDCMenuFoundation;
  }(MDCFoundation);

  //
  var script$G = {
    name: 'mdc-menu',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: [Boolean, Object],
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    provide: function provide() {
      return {
        mdcMenu: this
      };
    },
    watch: {// anchorCorner(nv) {
      //   this.foundation.setAnchorCorner(Number(nv))
      // },
      // anchorMargin(nv) {
      //   this.foundation.setAnchorMargin(nv)
      // }
    },
    mounted: function mounted() {
      var _this = this;

      this._previousFocus = undefined;
      this.foundation = new MDCMenuFoundation({
        addClassToElementAtIndex: function addClassToElementAtIndex(index, className) {
          var list = _this.items;
          list[index].classList.add(className);
        },
        removeClassFromElementAtIndex: function removeClassFromElementAtIndex(index, className) {
          var list = _this.items;
          list[index].classList.remove(className);
        },
        addAttributeToElementAtIndex: function addAttributeToElementAtIndex(index, attr, value) {
          var list = _this.items;
          list[index].setAttribute(attr, value);
        },
        removeAttributeFromElementAtIndex: function removeAttributeFromElementAtIndex(index, attr) {
          var list = _this.items;
          list[index].removeAttribute(attr);
        },
        elementContainsClass: function elementContainsClass(element, className) {
          return element.classList.contains(className);
        },
        closeSurface: function closeSurface() {
          _this.$emit('change', false);
        },
        getElementIndex: function getElementIndex(element) {
          return _this.items.indexOf(element);
        },
        getParentElement: function getParentElement(element) {
          return element.parentElement;
        },
        getSelectedElementIndex: function getSelectedElementIndex(selectionGroup) {
          var idx = _this.items.indexOf(selectionGroup.querySelector(".".concat(MDCMenuFoundation.cssClasses.MENU_SELECTED_LIST_ITEM)));

          return idx;
        },
        notifySelected: function notifySelected(evtData) {
          emitCustomEvent(_this.$el, MDCMenuFoundation.strings.SELECTED_EVENT, {
            index: evtData.index,
            item: _this.items[evtData.index]
          });

          _this.$emit('select', {
            index: evtData.index,
            item: _this.items[evtData.index]
          });
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.foundation.destroy();
    },
    computed: {
      items: function items() {
        return this.$refs.list.listElements;
      }
    },
    methods: {
      handleClick: function handleClick(evt) {
        this.foundation.handleClick(evt);
      },
      onChange: function onChange(item) {
        this.$emit('change', item);
      } // onOpen_(value) {
      //   if (value) {
      //     this.foundation.open(typeof value === 'object' ? value : void 0)
      //   } else {
      //     this.foundation.close()
      //   }
      // },
      // show(options) {
      //   this.foundation.open(options)
      // },
      // hide() {
      //   this.foundation.close()
      // },
      // isOpen() {
      //   return this.foundation ? this.foundation.isOpen() : false
      // }

    }
  };

  /* script */
  const __vue_script__$G = script$G;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$G.__file = "/ddata/extra/vma/components/menu/mdc-menu.vue";

  /* template */
  var __vue_render__$D = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "mdc-menu-surface",
      {
        ref: "root",
        attrs: { "quick-open": _vm.quickOpen, open: _vm.open },
        on: { change: _vm.onChange },
        nativeOn: {
          click: function($event) {
            return _vm.handleClick($event)
          }
        }
      },
      [_c("mdc-list", { ref: "list" }, [_vm._t("default")], 2)],
      1
    )
  };
  var __vue_staticRenderFns__$D = [];
  __vue_render__$D._withStripped = true;

    /* style */
    const __vue_inject_styles__$G = undefined;
    /* scoped */
    const __vue_scope_id__$G = undefined;
    /* module identifier */
    const __vue_module_identifier__$G = undefined;
    /* functional template */
    const __vue_is_functional_template__$G = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcMenu = normalizeComponent(
      { render: __vue_render__$D, staticRenderFns: __vue_staticRenderFns__$D },
      __vue_inject_styles__$G,
      __vue_script__$G,
      __vue_scope_id__$G,
      __vue_is_functional_template__$G,
      __vue_module_identifier__$G,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @type {string|undefined} */
  var storedTransformPropertyName_;
  /**
   * Returns the name of the correct transform property to use on the current browser.
   * @param {!Window} globalObj
   * @param {boolean=} forceRefresh
   * @return {string}
   */

  function getTransformPropertyName(globalObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : 'webkitTransform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  var script$H = {
    name: 'mdc-menu-surface',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: [Boolean, Object],
      'quick-open': Boolean,
      'anchor-corner': [String, Number],
      'anchor-margin': Object
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    provide: function provide() {
      return {
        mdcMenu: this
      };
    },
    watch: {
      open: 'onOpen_',
      quickOpen: function quickOpen(nv) {
        this.foundation.setQuickOpen(nv);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this._previousFocus = undefined;
      this.foundation = new MDCMenuSurfaceFoundation(_extends({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasAnchor: function hasAnchor() {
          return !!_this.anchorElement;
        },
        notifyClose: function notifyClose() {
          emitCustomEvent(_this.$el, MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});

          _this.$emit('change', false);
        },
        notifyOpen: function notifyOpen() {
          emitCustomEvent(_this.$el, MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});

          _this.$emit('change', true);
        },
        isElementInContainer: function isElementInContainer(el) {
          return _this.$el === el || _this.$el.contains(el);
        },
        isRtl: function isRtl() {
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        setTransformOrigin: function setTransformOrigin(origin) {
          _this.$el.style["".concat(getTransformPropertyName(window), "-origin")] = origin;
        }
      }, this.getFocusAdapterMethods(), this.getDimensionAdapterMethods()));

      if (this.$el.parentElement && this.$el.parentElement.classList.contains(MDCMenuSurfaceFoundation.cssClasses.ANCHOR)) {
        this.anchorElement = this.$el.parentElement;
      }

      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this._previousFocus = null;
      this.foundation.destroy();
    },
    methods: {
      handleBodyClick: function handleBodyClick(evt) {
        this.foundation.handleBodyClick(evt);
      },
      registerBodyClickListener: function registerBodyClickListener() {
        document.body.addEventListener('click', this.handleBodyClick);
      },
      deregisterBodyClickListener: function deregisterBodyClickListener() {
        document.body.removeEventListener('click', this.handleBodyClick);
      },
      handleKeydown: function handleKeydown(evt) {
        this.foundation.handleKeydown(evt);
      },
      getFocusAdapterMethods: function getFocusAdapterMethods() {
        var _this2 = this;

        return {
          isFocused: function isFocused() {
            return document.activeElement === _this2.$el;
          },
          saveFocus: function saveFocus() {
            _this2.previousFocus_ = document.activeElement;
          },
          restoreFocus: function restoreFocus() {
            if (_this2.$el.contains(document.activeElement)) {
              if (_this2.previousFocus_ && _this2.previousFocus_.focus) {
                _this2.previousFocus_.focus();
              }
            }
          },
          isFirstElementFocused: function isFirstElementFocused() {
            return _this2.firstFocusableElement_ && _this2.firstFocusableElement_ === document.activeElement;
          },
          isLastElementFocused: function isLastElementFocused() {
            return _this2.lastFocusableElement_ && _this2.lastFocusableElement_ === document.activeElement;
          },
          focusFirstElement: function focusFirstElement() {
            return _this2.firstFocusableElement_ && _this2.firstFocusableElement_.focus && _this2.firstFocusableElement_.focus();
          },
          focusLastElement: function focusLastElement() {
            return _this2.lastFocusableElement_ && _this2.lastFocusableElement_.focus && _this2.lastFocusableElement_.focus();
          }
        };
      },
      getDimensionAdapterMethods: function getDimensionAdapterMethods() {
        var _this3 = this;

        return {
          getInnerDimensions: function getInnerDimensions() {
            return {
              width: _this3.$el.offsetWidth,
              height: _this3.$el.offsetHeight
            };
          },
          getAnchorDimensions: function getAnchorDimensions() {
            return _this3.anchorElement && _this3.anchorElement.getBoundingClientRect();
          },
          getWindowDimensions: function getWindowDimensions() {
            return {
              width: window.innerWidth,
              height: window.innerHeight
            };
          },
          getBodyDimensions: function getBodyDimensions() {
            return {
              width: document.body.clientWidth,
              height: document.body.clientHeight
            };
          },
          getWindowScroll: function getWindowScroll() {
            return {
              x: window.pageXOffset,
              y: window.pageYOffset
            };
          },
          setPosition: function setPosition(position) {
            _this3.$el.style.left = 'left' in position ? position.left : null;
            _this3.$el.style.right = 'right' in position ? position.right : null;
            _this3.$el.style.top = 'top' in position ? position.top : null;
            _this3.$el.style.bottom = 'bottom' in position ? position.bottom : null;
          },
          setMaxHeight: function setMaxHeight(height) {
            _this3.$el.style.maxHeight = height;
          }
        };
      },
      onOpen_: function onOpen_(value) {
        if (value) {
          var focusableElements = this.$el.querySelectorAll(MDCMenuSurfaceFoundation.strings.FOCUSABLE_ELEMENTS);
          this.firstFocusableElement_ = focusableElements.length > 0 ? focusableElements[0] : null;
          this.lastFocusableElement_ = focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : null;
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      hoistMenuToBody: function hoistMenuToBody() {
        document.body.appendChild(this.$el.parentElement.removeChild(this.$el));
        this.setIsHoisted(true);
      },
      setIsHoisted: function setIsHoisted(isHoisted) {
        this.foundation.setIsHoisted(isHoisted);
      },
      setMenuSurfaceAnchorElement: function setMenuSurfaceAnchorElement(element) {
        this.anchorElement = element;
      },
      setFixedPosition: function setFixedPosition(isFixed) {
        if (isFixed) {
          this.$el.classList.add(cssClasses.FIXED);
        } else {
          this.$el.classList.remove(cssClasses.FIXED);
        }

        this.foundation.setFixedPosition(isFixed);
      },
      setAbsolutePosition: function setAbsolutePosition(x, y) {
        this.foundation.setAbsolutePosition(x, y);
        this.setIsHoisted(true);
      },
      setAnchorCorner: function setAnchorCorner(corner) {
        this.foundation.setAnchorCorner(corner);
      },
      setAnchorMargin: function setAnchorMargin(margin) {
        this.foundation.setAnchorMargin(margin);
      },
      show: function show(options) {
        this.foundation.open(options);
      },
      hide: function hide() {
        this.foundation.close();
      },
      isOpen: function isOpen() {
        return this.foundation ? this.foundation.isOpen() : false;
      }
    }
  };

  /* script */
  const __vue_script__$H = script$H;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$H.__file = "/ddata/extra/vma/components/menu/mdc-menu-surface.vue";

  /* template */
  var __vue_render__$E = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-menu mdc-menu-surface",
        class: _vm.classes,
        on: {
          keydown: _vm.handleKeydown,
          "MDCMenuSurface:opened": _vm.registerBodyClickListener,
          "MDCMenuSurface:closed": _vm.deregisterBodyClickListener
        }
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$E = [];
  __vue_render__$E._withStripped = true;

    /* style */
    const __vue_inject_styles__$H = undefined;
    /* scoped */
    const __vue_scope_id__$H = undefined;
    /* module identifier */
    const __vue_module_identifier__$H = undefined;
    /* functional template */
    const __vue_is_functional_template__$H = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcMenuSurface = normalizeComponent(
      { render: __vue_render__$E, staticRenderFns: __vue_staticRenderFns__$E },
      __vue_inject_styles__$H,
      __vue_script__$H,
      __vue_scope_id__$H,
      __vue_is_functional_template__$H,
      __vue_module_identifier__$H,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  //
  var script$I = {
    name: 'mdc-menu-item',
    props: {
      disabled: Boolean
    },
    inject: ['mdcMenu'],
    mounted: function mounted() {
      console.dir(this.mdcMenu);
      this.mdcMenu.items.push(this.$el);
    }
  };

  /* script */
  const __vue_script__$I = script$I;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$I.__file = "/ddata/extra/vma/components/menu/mdc-menu-item.vue";

  /* template */
  var __vue_render__$F = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "li",
      {
        staticClass: "mdc-menu-item mdc-list-item",
        attrs: {
          tabindex: _vm.disabled ? "-1" : "0",
          "aria-disabled": _vm.disabled,
          role: "menuitem"
        }
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$F = [];
  __vue_render__$F._withStripped = true;

    /* style */
    const __vue_inject_styles__$I = undefined;
    /* scoped */
    const __vue_scope_id__$I = undefined;
    /* module identifier */
    const __vue_module_identifier__$I = undefined;
    /* functional template */
    const __vue_is_functional_template__$I = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcMenuItem = normalizeComponent(
      { render: __vue_render__$F, staticRenderFns: __vue_staticRenderFns__$F },
      __vue_inject_styles__$I,
      __vue_script__$I,
      __vue_scope_id__$I,
      __vue_is_functional_template__$I,
      __vue_module_identifier__$I,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$J = {
    name: 'mdc-menu-divider'
  };

  /* script */
  const __vue_script__$J = script$J;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$J.__file = "/ddata/extra/vma/components/menu/mdc-menu-divider.vue";

  /* template */
  var __vue_render__$G = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("li", {
      staticClass: "mdc-menu-divider mdc-list-divider",
      attrs: { role: "separator" }
    })
  };
  var __vue_staticRenderFns__$G = [];
  __vue_render__$G._withStripped = true;

    /* style */
    const __vue_inject_styles__$J = undefined;
    /* scoped */
    const __vue_scope_id__$J = undefined;
    /* module identifier */
    const __vue_module_identifier__$J = undefined;
    /* functional template */
    const __vue_is_functional_template__$J = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcMenuDivider = normalizeComponent(
      { render: __vue_render__$G, staticRenderFns: __vue_staticRenderFns__$G },
      __vue_inject_styles__$J,
      __vue_script__$J,
      __vue_scope_id__$J,
      __vue_is_functional_template__$J,
      __vue_module_identifier__$J,
      undefined,
      undefined
    );

  //
  //
  //
  //
  var script$K = {
    name: 'mdc-menu-anchor'
  };

  /* script */
  const __vue_script__$K = script$K;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$K.__file = "/ddata/extra/vma/components/menu/mdc-menu-anchor.vue";

  /* template */
  var __vue_render__$H = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-menu-surface--anchor" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$H = [];
  __vue_render__$H._withStripped = true;

    /* style */
    const __vue_inject_styles__$K = undefined;
    /* scoped */
    const __vue_scope_id__$K = undefined;
    /* module identifier */
    const __vue_module_identifier__$K = undefined;
    /* functional template */
    const __vue_is_functional_template__$K = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcMenuAnchor = normalizeComponent(
      { render: __vue_render__$H, staticRenderFns: __vue_staticRenderFns__$H },
      __vue_inject_styles__$K,
      __vue_script__$K,
      __vue_scope_id__$K,
      __vue_is_functional_template__$K,
      __vue_module_identifier__$K,
      undefined,
      undefined
    );

  var VueMDCMenu = BasePlugin({
    mdcMenu: mdcMenu,
    mdcMenuSurface: mdcMenuSurface,
    mdcMenuItem: mdcMenuItem,
    mdcMenuDivider: mdcMenuDivider,
    mdcMenuAnchor: mdcMenuAnchor
  });

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Radio. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCRadioAdapter =
  /*#__PURE__*/
  function () {
    function MDCRadioAdapter() {
      _classCallCheck(this, MDCRadioAdapter);
    }

    _createClass(MDCRadioAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {boolean} disabled */

    }, {
      key: "setNativeControlDisabled",
      value: function setNativeControlDisabled(disabled) {}
    }]);

    return MDCRadioAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$f = {
    NATIVE_CONTROL_SELECTOR: '.mdc-radio__native-control'
  };
  /** @enum {string} */

  var cssClasses$e = {
    ROOT: 'mdc-radio',
    DISABLED: 'mdc-radio--disabled'
  };

  /**
   * @extends {MDCFoundation<!MDCRadioAdapter>}
   */

  var MDCRadioFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCRadioFoundation, _MDCFoundation);

    function MDCRadioFoundation() {
      _classCallCheck(this, MDCRadioFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCRadioFoundation).apply(this, arguments));
    }

    _createClass(MDCRadioFoundation, [{
      key: "setDisabled",

      /** @param {boolean} disabled */
      value: function setDisabled(disabled) {
        var DISABLED = MDCRadioFoundation.cssClasses.DISABLED;
        this.adapter_.setNativeControlDisabled(disabled);

        if (disabled) {
          this.adapter_.addClass(DISABLED);
        } else {
          this.adapter_.removeClass(DISABLED);
        }
      }
    }], [{
      key: "cssClasses",

      /** @return enum {cssClasses} */
      get: function get() {
        return cssClasses$e;
      }
      /** @return enum {strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$f;
      }
      /** @return {!MDCRadioAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCRadioAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            setNativeControlDisabled: function setNativeControlDisabled()
            /* disabled: boolean */
            {}
          }
        );
      }
    }]);

    return MDCRadioFoundation;
  }(MDCFoundation);

  //
  var script$L = {
    name: 'mdc-radio',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'picked',
      event: 'change'
    },
    props: {
      name: {
        type: String,
        required: true
      },
      value: String,
      picked: String,
      checked: Boolean,
      label: String,
      'align-end': Boolean,
      disabled: Boolean
    },
    data: function data() {
      return {
        classes: {},
        styles: {},
        formFieldClasses: {
          'mdc-form-field': this.label,
          'mdc-form-field--align-end': this.label && this.alignEnd
        }
      };
    },
    watch: {
      checked: 'setChecked',
      picked: 'onPicked',
      disabled: function disabled(value) {
        this.foundation.setDisabled(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      // add foundation
      this.foundation = new MDCRadioFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlDisabled: function setNativeControlDisabled(disabled) {
          return _this.$refs.control.disabled = disabled;
        }
      }); // add ripple

      this.ripple = new RippleBase(this, {
        isUnbounded: function isUnbounded() {
          return true;
        },
        // Radio buttons technically go "active" whenever there is *any* keyboard interaction. This is not the
        // UI we desire.
        isSurfaceActive: function isSurfaceActive() {
          return false;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$refs.control.addEventListener(evt, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$refs.control.removeEventListener(evt, handler, applyPassive());
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$refs.root.getBoundingClientRect();
        }
      });
      this.formField = new MDCFormFieldFoundation({
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$refs.label.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$refs.label.removeEventListener(type, handler);
        },
        activateInputRipple: function activateInputRipple() {
          _this.ripple && _this.ripple.activate();
        },
        deactivateInputRipple: function deactivateInputRipple() {
          _this.ripple && _this.ripple.deactivate();
        }
      });
      this.foundation.init();
      this.ripple.init();
      this.formField.init();
      this.foundation.setDisabled(this.disabled);
      this.$refs.control.value = this.value || this.label;
      this.setChecked(this.checked || this.picked == this.$refs.control.value); // refresh model

      this.checked && this.sync();
    },
    beforeDestroy: function beforeDestroy() {
      this.formField.destroy();
      this.ripple.destroy();
      this.foundation.destroy();
    },
    methods: {
      onPicked: function onPicked(nv) {
        this.setChecked(this.picked == this.$refs.control.value);
      },
      setChecked: function setChecked(checked) {
        this.$refs.control.checked = checked;
      },
      isChecked: function isChecked() {
        return this.$refs.control.checked;
      },
      sync: function sync(evt) {
        this.$emit('change', this.$refs.control.value);
      }
    }
  };

  /* script */
  const __vue_script__$L = script$L;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$L.__file = "/ddata/extra/vma/components/radio/mdc-radio.vue";

  /* template */
  var __vue_render__$I = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-radio-wrapper", class: _vm.formFieldClasses },
      [
        _c(
          "div",
          {
            ref: "root",
            staticClass: "mdc-radio",
            class: _vm.classes,
            style: _vm.styles
          },
          [
            _c("input", {
              ref: "control",
              staticClass: "mdc-radio__native-control",
              attrs: { id: _vm.vma_uid_, name: _vm.name, type: "radio" },
              on: { change: _vm.sync }
            }),
            _vm._v(" "),
            _vm._m(0)
          ]
        ),
        _vm._v(" "),
        _c(
          "label",
          { ref: "label", attrs: { for: _vm.vma_uid_ } },
          [_vm._t("default", [_vm._v(_vm._s(_vm.label))])],
          2
        )
      ]
    )
  };
  var __vue_staticRenderFns__$I = [
    function() {
      var _vm = this;
      var _h = _vm.$createElement;
      var _c = _vm._self._c || _h;
      return _c("div", { staticClass: "mdc-radio__background" }, [
        _c("div", { staticClass: "mdc-radio__outer-circle" }),
        _vm._v(" "),
        _c("div", { staticClass: "mdc-radio__inner-circle" })
      ])
    }
  ];
  __vue_render__$I._withStripped = true;

    /* style */
    const __vue_inject_styles__$L = undefined;
    /* scoped */
    const __vue_scope_id__$L = undefined;
    /* module identifier */
    const __vue_module_identifier__$L = undefined;
    /* functional template */
    const __vue_is_functional_template__$L = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcRadio = normalizeComponent(
      { render: __vue_render__$I, staticRenderFns: __vue_staticRenderFns__$I },
      __vue_inject_styles__$L,
      __vue_script__$L,
      __vue_scope_id__$L,
      __vue_is_functional_template__$L,
      __vue_module_identifier__$L,
      undefined,
      undefined
    );

  var VueMDCRadio = BasePlugin({
    mdcRadio: mdcRadio
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the select icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectIconAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectIconAdapter() {
      _classCallCheck(this, MDCSelectIconAdapter);
    }

    _createClass(MDCSelectIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}
      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content of the icon element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * Emits a custom event "MDCSelect:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);

    return MDCSelectIconAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$g = {
    ICON_EVENT: 'MDCSelect:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @extends {MDCFoundation<!MDCSelectIconAdapter>}
   * @final
   */

  var MDCSelectIconFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectIconFoundation, _MDCFoundation);

    _createClass(MDCSelectIconFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$g;
      }
      /**
       * {@see MDCSelectIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectIconAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectIconAdapter} */
          {
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }
      /**
       * @param {!MDCSelectIconAdapter} adapter
       */

    }]);

    function MDCSelectIconFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSelectIconFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectIconFoundation).call(this, _extends(MDCSelectIconFoundation.defaultAdapter, adapter)));
      /** @private {string?} */

      _this.savedTabIndex_ = null;
      /** @private {function(!Event): undefined} */

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };

      return _this;
    }

    _createClass(MDCSelectIconFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$g.ICON_ROLE);
        }
      }
      /** @param {string} label */

    }, {
      key: "setAriaLabel",
      value: function setAriaLabel(label) {
        this.adapter_.setAttr('aria-label', label);
      }
      /** @param {string} content */

    }, {
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);

    return MDCSelectIconFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCSelectIconFoundation>}
   * @final
   */

  var MDCSelectIcon =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSelectIcon, _MDCComponent);

    function MDCSelectIcon() {
      _classCallCheck(this, MDCSelectIcon);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectIcon).apply(this, arguments));
    }

    _createClass(MDCSelectIcon, [{
      key: "getDefaultFoundation",

      /**
       * @return {!MDCSelectIconFoundation}
       */
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCSelectIconFoundation(
        /** @type {!MDCSelectIconAdapter} */
        _extends({
          getAttr: function getAttr(attr) {
            return _this.root_.getAttribute(attr);
          },
          setAttr: function setAttr(attr, value) {
            return _this.root_.setAttribute(attr, value);
          },
          removeAttr: function removeAttr(attr) {
            return _this.root_.removeAttribute(attr);
          },
          setContent: function setContent(content) {
            _this.root_.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            return _this.root_.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            return _this.root_.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.emit(MDCSelectIconFoundation.strings.ICON_EVENT, {}
            /* evtData */
            , true
            /* shouldBubble */
            );
          }
        }));
      }
    }, {
      key: "foundation",

      /**
       * @return {!MDCSelectIconFoundation}
       */
      get: function get() {
        return this.foundation_;
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCSelectIcon}
       */
      value: function attachTo(root) {
        return new MDCSelectIcon(root);
      }
    }]);

    return MDCSelectIcon;
  }(MDCComponent);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Select Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Select helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSelectHelperTextAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectHelperTextAdapter() {
      _classCallCheck(this, MDCSelectHelperTextAdapter);
    }

    _createClass(MDCSelectHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);

    return MDCSelectHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$h = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };
  /** @enum {string} */

  var cssClasses$f = {
    HELPER_TEXT_PERSISTENT: 'mdc-select-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-select-helper-text--validation-msg'
  };

  /**
   * @extends {MDCFoundation<!MDCSelectHelperTextAdapter>}
   * @final
   */

  var MDCSelectHelperTextFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectHelperTextFoundation, _MDCFoundation);

    _createClass(MDCSelectHelperTextFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$f;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$h;
      }
      /**
       * {@see MDCSelectHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectHelperTextAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectHelperTextAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }
      /**
       * @param {!MDCSelectHelperTextAdapter} adapter
       */

    }]);

    function MDCSelectHelperTextFoundation(adapter) {
      _classCallCheck(this, MDCSelectHelperTextFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectHelperTextFoundation).call(this, _extends(MDCSelectHelperTextFoundation.defaultAdapter, adapter)));
    }
    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    _createClass(MDCSelectHelperTextFoundation, [{
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: "setPersistent",
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
        }
      }
      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: "setValidation",
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
        }
      }
      /** Makes the helper text visible to the screen reader. */

    }, {
      key: "showToScreenReader",
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$h.ARIA_HIDDEN);
      }
      /**
       * Sets the validity of the helper text based on the select validity.
       * @param {boolean} selectIsValid
       */

    }, {
      key: "setValidity",
      value: function setValidity(selectIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$f.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$f.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !selectIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$h.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$h.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }
      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: "hide_",
      value: function hide_() {
        this.adapter_.setAttr(strings$h.ARIA_HIDDEN, 'true');
      }
    }]);

    return MDCSelectHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCComponent<!MDCSelectHelperTextFoundation>}
   * @final
   */

  var MDCSelectHelperText =
  /*#__PURE__*/
  function (_MDCComponent) {
    _inherits(MDCSelectHelperText, _MDCComponent);

    function MDCSelectHelperText() {
      _classCallCheck(this, MDCSelectHelperText);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectHelperText).apply(this, arguments));
    }

    _createClass(MDCSelectHelperText, [{
      key: "getDefaultFoundation",

      /**
       * @return {!MDCSelectHelperTextFoundation}
       */
      value: function getDefaultFoundation() {
        var _this = this;

        return new MDCSelectHelperTextFoundation(
        /** @type {!MDCSelectHelperTextAdapter} */
        _extends({
          addClass: function addClass(className) {
            return _this.root_.classList.add(className);
          },
          removeClass: function removeClass(className) {
            return _this.root_.classList.remove(className);
          },
          hasClass: function hasClass(className) {
            return _this.root_.classList.contains(className);
          },
          setAttr: function setAttr(attr, value) {
            return _this.root_.setAttribute(attr, value);
          },
          removeAttr: function removeAttr(attr) {
            return _this.root_.removeAttribute(attr);
          },
          setContent: function setContent(content) {
            _this.root_.textContent = content;
          }
        }));
      }
    }, {
      key: "foundation",

      /**
       * @return {!MDCSelectHelperTextFoundation}
       */
      get: function get() {
        return this.foundation_;
      }
    }], [{
      key: "attachTo",

      /**
       * @param {!Element} root
       * @return {!MDCSelectHelperText}
       */
      value: function attachTo(root) {
        return new MDCSelectHelperText(root);
      }
    }]);

    return MDCSelectHelperText;
  }(MDCComponent);

  /**
   * Adapter for MDC Select. Provides an interface for managing
   * - classes
   * - dom
   * - event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */

  var MDCSelectAdapter =
  /*#__PURE__*/
  function () {
    function MDCSelectAdapter() {
      _classCallCheck(this, MDCSelectAdapter);
    }

    _createClass(MDCSelectAdapter, [{
      key: "addClass",

      /**
       * Adds class to root element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Activates the bottom line, showing a focused state.
       */

    }, {
      key: "activateBottomLine",
      value: function activateBottomLine() {}
      /**
       * Deactivates the bottom line.
       */

    }, {
      key: "deactivateBottomLine",
      value: function deactivateBottomLine() {}
      /**
       * Sets the value of the select.
       * @param {string} value
       */

    }, {
      key: "setValue",
      value: function setValue(value) {}
      /**
       * Returns the selected value of the select element.
       * @return {string}
       */

    }, {
      key: "getValue",
      value: function getValue() {}
      /**
       * Floats label determined based off of the shouldFloat argument.
       * @param {boolean} shouldFloat
       */

    }, {
      key: "floatLabel",
      value: function floatLabel(shouldFloat) {}
      /**
       * Returns width of label in pixels, if the label exists.
       * @return {number}
       */

    }, {
      key: "getLabelWidth",
      value: function getLabelWidth() {}
      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasOutline",
      value: function hasOutline() {}
      /**
       * Only implement if outline element exists.
       * @param {number} labelWidth
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(labelWidth) {}
      /**
       * Closes notch in outline element, if the outline exists.
       */

    }, {
      key: "closeOutline",
      value: function closeOutline() {}
      /**
       * Opens the menu.
       */

    }, {
      key: "openMenu",
      value: function openMenu() {}
      /**
       * Closes the menu.
       */

    }, {
      key: "closeMenu",
      value: function closeMenu() {}
      /**
       * Returns true if the menu is currently open.
       * @return {boolean}
       */

    }, {
      key: "isMenuOpen",
      value: function isMenuOpen() {}
      /**
       * Sets the selected index of the select to the index provided.
       * @param {number} index
       */

    }, {
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {}
      /**
       * Sets the select to disabled.
       * @param {boolean} isDisabled
       */

    }, {
      key: "setDisabled",
      value: function setDisabled(isDisabled) {}
      /**
       * Sets the line ripple transform origin center.
       * @param {number} normalizedX
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(normalizedX) {}
      /**
       * Emits a change event when an element is selected.
       * @param {string} value
       */

    }, {
      key: "notifyChange",
      value: function notifyChange(value) {}
      /**
       * Checks if the select is currently valid.
       * @return {boolean} isValid
       */

    }, {
      key: "checkValidity",
      value: function checkValidity() {}
      /**
       * Adds/Removes the invalid class.
       * @param {boolean} isValid
       */

    }, {
      key: "setValid",
      value: function setValid(isValid) {}
    }]);

    return MDCSelectAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$g = {
    DISABLED: 'mdc-select--disabled',
    ROOT: 'mdc-select',
    OUTLINED: 'mdc-select--outlined',
    FOCUSED: 'mdc-select--focused',
    SELECTED_ITEM_CLASS: 'mdc-list-item--selected',
    WITH_LEADING_ICON: 'mdc-select--with-leading-icon',
    INVALID: 'mdc-select--invalid',
    REQUIRED: 'mdc-select--required'
  };
  /** @enum {string} */

  var strings$i = {
    ARIA_CONTROLS: 'aria-controls',
    CHANGE_EVENT: 'MDCSelect:change',
    SELECTED_ITEM_SELECTOR: ".".concat(cssClasses$g.SELECTED_ITEM_CLASS),
    LEADING_ICON_SELECTOR: '.mdc-select__icon',
    SELECTED_TEXT_SELECTOR: '.mdc-select__selected-text',
    HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
    MENU_SELECTOR: '.mdc-select__menu',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple',
    LABEL_SELECTOR: '.mdc-floating-label',
    NATIVE_CONTROL_SELECTOR: '.mdc-select__native-control',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    ENHANCED_VALUE_ATTR: 'data-value',
    ARIA_SELECTED_ATTR: 'aria-selected'
  };
  /** @enum {number} */

  var numbers$4 = {
    LABEL_SCALE: 0.75
  };

  /**
   * @extends {MDCFoundation<!MDCSelectAdapter>}
   * @final
   */

  var MDCSelectFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSelectFoundation, _MDCFoundation);

    _createClass(MDCSelectFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$g;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$4;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$i;
      }
      /**
       * {@see MDCSelectAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCSelectAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSelectAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            hasClass: function hasClass() {
              return (
                /* className: string */
                false
              );
            },
            activateBottomLine: function activateBottomLine() {},
            deactivateBottomLine: function deactivateBottomLine() {},
            setValue: function setValue() {},
            getValue: function getValue() {},
            floatLabel: function floatLabel()
            /* value: boolean */
            {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {
              return false;
            },
            notchOutline: function notchOutline()
            /* labelWidth: number, */
            {},
            closeOutline: function closeOutline() {},
            openMenu: function openMenu() {},
            closeMenu: function closeMenu() {},
            isMenuOpen: function isMenuOpen() {},
            setSelectedIndex: function setSelectedIndex() {},
            setDisabled: function setDisabled() {},
            setRippleCenter: function setRippleCenter() {},
            notifyChange: function notifyChange() {},
            checkValidity: function checkValidity() {},
            setValid: function setValid() {}
          }
        );
      }
      /**
       * @param {!MDCSelectAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCSelectFoundation(adapter) {
      var _this;

      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
      /** @type {!FoundationMapType} */
      {};

      _classCallCheck(this, MDCSelectFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSelectFoundation).call(this, _extends(MDCSelectFoundation.defaultAdapter, adapter)));
      /** @type {!MDCSelectIconFoundation|undefined} */

      _this.leadingIcon_ = foundationMap.leadingIcon;
      /** @type {!MDCSelectHelperTextFoundation|undefined} */

      _this.helperText_ = foundationMap.helperText;
      return _this;
    }

    _createClass(MDCSelectFoundation, [{
      key: "setSelectedIndex",
      value: function setSelectedIndex(index) {
        this.adapter_.setSelectedIndex(index);
        this.adapter_.closeMenu();
        var didChange = true;
        this.handleChange(didChange);
      }
    }, {
      key: "setValue",
      value: function setValue(value) {
        this.adapter_.setValue(value);
        var didChange = true;
        this.handleChange(didChange);
      }
    }, {
      key: "getValue",
      value: function getValue() {
        return this.adapter_.getValue();
      }
    }, {
      key: "setDisabled",
      value: function setDisabled(isDisabled) {
        isDisabled ? this.adapter_.addClass(cssClasses$g.DISABLED) : this.adapter_.removeClass(cssClasses$g.DISABLED);
        this.adapter_.setDisabled(isDisabled);
        this.adapter_.closeMenu();

        if (this.leadingIcon_) {
          this.leadingIcon_.setDisabled(isDisabled);
        }
      }
      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: "setHelperTextContent",
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        var openNotch = this.getValue().length > 0;
        this.notchOutline(openNotch);
      }
      /**
       * Handles value changes, via change event or programmatic updates.
       */

    }, {
      key: "handleChange",
      value: function handleChange() {
        var didChange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var value = this.getValue();
        var optionHasValue = value.length > 0;
        var isRequired = this.adapter_.hasClass(cssClasses$g.REQUIRED);
        this.notchOutline(optionHasValue);

        if (!this.adapter_.hasClass(cssClasses$g.FOCUSED)) {
          this.adapter_.floatLabel(optionHasValue);
        }

        if (didChange) {
          this.adapter_.notifyChange(value);

          if (isRequired) {
            this.setValid(this.isValid());

            if (this.helperText_) {
              this.helperText_.setValidity(this.isValid());
            }
          }
        }
      }
      /**
       * Handles focus events from select element.
       */

    }, {
      key: "handleFocus",
      value: function handleFocus() {
        this.adapter_.addClass(cssClasses$g.FOCUSED);
        this.adapter_.floatLabel(true);
        this.notchOutline(true);
        this.adapter_.activateBottomLine();

        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }
      /**
       * Handles blur events from select element.
       */

    }, {
      key: "handleBlur",
      value: function handleBlur() {
        if (this.adapter_.isMenuOpen()) return;
        this.adapter_.removeClass(cssClasses$g.FOCUSED);
        this.handleChange(false);
        this.adapter_.deactivateBottomLine();
        var isRequired = this.adapter_.hasClass(cssClasses$g.REQUIRED);

        if (isRequired) {
          this.setValid(this.isValid());

          if (this.helperText_) {
            this.helperText_.setValidity(this.isValid());
          }
        }
      }
    }, {
      key: "handleClick",
      value: function handleClick(normalizedX) {
        if (this.adapter_.isMenuOpen()) return;
        this.adapter_.setRippleCenter(normalizedX);
        this.adapter_.openMenu();
      }
    }, {
      key: "handleKeydown",
      value: function handleKeydown(event) {
        if (this.adapter_.isMenuOpen()) return;
        var isEnter = event.key === 'Enter' || event.keyCode === 13;
        var isSpace = event.key === 'Space' || event.keyCode === 32;
        var arrowUp = event.key === 'ArrowUp' || event.keyCode === 38;
        var arrowDown = event.key === 'ArrowDown' || event.keyCode === 40;

        if (this.adapter_.hasClass(cssClasses$g.FOCUSED) && (isEnter || isSpace || arrowUp || arrowDown)) {
          this.adapter_.openMenu();
          event.preventDefault();
        }
      }
      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline()) {
          return;
        }

        var isFocused = this.adapter_.hasClass(cssClasses$g.FOCUSED);

        if (openNotch) {
          var labelScale = numbers$4.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          this.adapter_.notchOutline(labelWidth);
        } else if (!isFocused) {
          this.adapter_.closeOutline();
        }
      }
      /**
       * Sets the aria label of the leading icon.
       * @param {string} label
       */

    }, {
      key: "setLeadingIconAriaLabel",
      value: function setLeadingIconAriaLabel(label) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setAriaLabel(label);
        }
      }
      /**
       * Sets the text content of the leading icon.
       * @param {string} content
       */

    }, {
      key: "setLeadingIconContent",
      value: function setLeadingIconContent(content) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setContent(content);
        }
      }
    }, {
      key: "setValid",
      value: function setValid(isValid) {
        this.adapter_.setValid(isValid);
      }
    }, {
      key: "isValid",
      value: function isValid() {
        return this.adapter_.checkValidity();
      }
    }]);

    return MDCSelectFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Floating Label.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the floating label into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCFloatingLabelAdapter =
  /*#__PURE__*/
  function () {
    function MDCFloatingLabelAdapter() {
      _classCallCheck(this, MDCFloatingLabelAdapter);
    }

    _createClass(MDCFloatingLabelAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the label element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the label element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {}
      /**
       * Registers an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the root element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
    }]);

    return MDCFloatingLabelAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$h = {
    LABEL_FLOAT_ABOVE: 'mdc-floating-label--float-above',
    LABEL_SHAKE: 'mdc-floating-label--shake',
    ROOT: 'mdc-floating-label'
  };

  /**
   * @extends {MDCFoundation<!MDCFloatingLabelAdapter>}
   * @final
   */

  var MDCFloatingLabelFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCFloatingLabelFoundation, _MDCFoundation);

    _createClass(MDCFloatingLabelFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$h;
      }
      /**
       * {@see MDCFloatingLabelAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCFloatingLabelAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCFloatingLabelAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            getWidth: function getWidth() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {}
          }
        );
      }
      /**
       * @param {!MDCFloatingLabelAdapter} adapter
       */

    }]);

    function MDCFloatingLabelFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCFloatingLabelFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCFloatingLabelFoundation).call(this, _extends(MDCFloatingLabelFoundation.defaultAdapter, adapter)));
      /** @private {function(!Event): undefined} */

      _this.shakeAnimationEndHandler_ = function () {
        return _this.handleShakeAnimationEnd_();
      };

      return _this;
    }

    _createClass(MDCFloatingLabelFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterInteractionHandler('animationend', this.shakeAnimationEndHandler_);
      }
      /**
       * Returns the width of the label element.
       * @return {number}
       */

    }, {
      key: "getWidth",
      value: function getWidth() {
        return this.adapter_.getWidth();
      }
      /**
       * Styles the label to produce the label shake for errors.
       * @param {boolean} shouldShake adds shake class if true,
       * otherwise removes shake class.
       */

    }, {
      key: "shake",
      value: function shake(shouldShake) {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;

        if (shouldShake) {
          this.adapter_.addClass(LABEL_SHAKE);
        } else {
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }
      /**
       * Styles the label to float or dock.
       * @param {boolean} shouldFloat adds float class if true, otherwise remove
       * float and shake class to dock label.
       */

    }, {
      key: "float",
      value: function float(shouldFloat) {
        var _MDCFloatingLabelFoun = MDCFloatingLabelFoundation.cssClasses,
            LABEL_FLOAT_ABOVE = _MDCFloatingLabelFoun.LABEL_FLOAT_ABOVE,
            LABEL_SHAKE = _MDCFloatingLabelFoun.LABEL_SHAKE;

        if (shouldFloat) {
          this.adapter_.addClass(LABEL_FLOAT_ABOVE);
        } else {
          this.adapter_.removeClass(LABEL_FLOAT_ABOVE);
          this.adapter_.removeClass(LABEL_SHAKE);
        }
      }
      /**
       * Handles an interaction event on the root element.
       */

    }, {
      key: "handleShakeAnimationEnd_",
      value: function handleShakeAnimationEnd_() {
        var LABEL_SHAKE = MDCFloatingLabelFoundation.cssClasses.LABEL_SHAKE;
        this.adapter_.removeClass(LABEL_SHAKE);
      }
    }]);

    return MDCFloatingLabelFoundation;
  }(MDCFoundation);

  //
  var script$M = {
    name: 'mdc-select-label',
    data: function data() {
      return {
        labelClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCFloatingLabelFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.labelClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.labelClasses, className);
        },
        getWidth: function getWidth() {
          return _this.$el.offsetWidth;
        },
        registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$M = script$M;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$M.__file = "/ddata/extra/vma/components/select/mdc-select-label.vue";

  /* template */
  var __vue_render__$J = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "label",
      { staticClass: "mdc-floating-label", class: _vm.labelClasses },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$J = [];
  __vue_render__$J._withStripped = true;

    /* style */
    const __vue_inject_styles__$M = undefined;
    /* scoped */
    const __vue_scope_id__$M = undefined;
    /* module identifier */
    const __vue_module_identifier__$M = undefined;
    /* functional template */
    const __vue_is_functional_template__$M = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var SelectLabel = normalizeComponent(
      { render: __vue_render__$J, staticRenderFns: __vue_staticRenderFns__$J },
      __vue_inject_styles__$M,
      __vue_script__$M,
      __vue_scope_id__$M,
      __vue_is_functional_template__$M,
      __vue_module_identifier__$M,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC TextField Line Ripple.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the line ripple into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCLineRippleAdapter =
  /*#__PURE__*/
  function () {
    function MDCLineRippleAdapter() {
      _classCallCheck(this, MDCLineRippleAdapter);
    }

    _createClass(MDCLineRippleAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the line ripple element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the line ripple element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets the style property with propertyName to value on the root element.
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(propertyName, value) {}
      /**
       * Registers an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerEventHandler",
      value: function registerEventHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the line ripple element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterEventHandler",
      value: function deregisterEventHandler(evtType, handler) {}
    }]);

    return MDCLineRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$i = {
    LINE_RIPPLE_ACTIVE: 'mdc-line-ripple--active',
    LINE_RIPPLE_DEACTIVATING: 'mdc-line-ripple--deactivating'
  };

  /**
   * @extends {MDCFoundation<!MDCLineRippleAdapter>}
   * @final
   */

  var MDCLineRippleFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCLineRippleFoundation, _MDCFoundation);

    _createClass(MDCLineRippleFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$i;
      }
      /**
       * {@see MDCLineRippleAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCLineRippleAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCLineRippleAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setStyle: function setStyle() {},
            registerEventHandler: function registerEventHandler() {},
            deregisterEventHandler: function deregisterEventHandler() {}
          }
        );
      }
      /**
       * @param {!MDCLineRippleAdapter=} adapter
       */

    }]);

    function MDCLineRippleFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCLineRippleFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCLineRippleFoundation).call(this, _extends(MDCLineRippleFoundation.defaultAdapter, adapter)));
      /** @private {function(!Event): undefined} */

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd(evt);
      };

      return _this;
    }

    _createClass(MDCLineRippleFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerEventHandler('transitionend', this.transitionEndHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterEventHandler('transitionend', this.transitionEndHandler_);
      }
      /**
       * Activates the line ripple
       */

    }, {
      key: "activate",
      value: function activate() {
        this.adapter_.removeClass(cssClasses$i.LINE_RIPPLE_DEACTIVATING);
        this.adapter_.addClass(cssClasses$i.LINE_RIPPLE_ACTIVE);
      }
      /**
       * Sets the center of the ripple animation to the given X coordinate.
       * @param {number} xCoordinate
       */

    }, {
      key: "setRippleCenter",
      value: function setRippleCenter(xCoordinate) {
        this.adapter_.setStyle('transform-origin', "".concat(xCoordinate, "px center"));
      }
      /**
       * Deactivates the line ripple
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        this.adapter_.addClass(cssClasses$i.LINE_RIPPLE_DEACTIVATING);
      }
      /**
       * Handles a transition end event
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        // Wait for the line ripple to be either transparent or opaque
        // before emitting the animation end event
        var isDeactivating = this.adapter_.hasClass(cssClasses$i.LINE_RIPPLE_DEACTIVATING);

        if (evt.propertyName === 'opacity') {
          if (isDeactivating) {
            this.adapter_.removeClass(cssClasses$i.LINE_RIPPLE_ACTIVE);
            this.adapter_.removeClass(cssClasses$i.LINE_RIPPLE_DEACTIVATING);
          }
        }
      }
    }]);

    return MDCLineRippleFoundation;
  }(MDCFoundation);

  //
  var script$N = {
    name: 'mdc-select-line-ripple',
    data: function data() {
      return {
        lineClasses: {},
        lineStyles: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCLineRippleFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.lineClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.lineClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$el.classList.contains(className);
        },
        setStyle: function setStyle(name, value) {
          _this.$set(_this.lineStyles, name, value);
        },
        registerEventHandler: function registerEventHandler(evtType, handler) {
          _this.$el.addEventListener(evtType, handler);
        },
        deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
          _this.$el.removeEventListener(evtType, handler);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$N = script$N;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$N.__file = "/ddata/extra/vma/components/select/mdc-select-line-ripple.vue";

  /* template */
  var __vue_render__$K = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", {
      staticClass: "mdc-line-ripple",
      class: _vm.lineClasses,
      style: _vm.lineStyles
    })
  };
  var __vue_staticRenderFns__$K = [];
  __vue_render__$K._withStripped = true;

    /* style */
    const __vue_inject_styles__$N = undefined;
    /* scoped */
    const __vue_scope_id__$N = undefined;
    /* module identifier */
    const __vue_module_identifier__$N = undefined;
    /* functional template */
    const __vue_is_functional_template__$N = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var SelectLineRiple = normalizeComponent(
      { render: __vue_render__$K, staticRenderFns: __vue_staticRenderFns__$K },
      __vue_inject_styles__$N,
      __vue_script__$N,
      __vue_scope_id__$N,
      __vue_is_functional_template__$N,
      __vue_module_identifier__$N,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Notched Outline.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Notched Outline into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCNotchedOutlineAdapter =
  /*#__PURE__*/
  function () {
    function MDCNotchedOutlineAdapter() {
      _classCallCheck(this, MDCNotchedOutlineAdapter);
    }

    _createClass(MDCNotchedOutlineAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Sets the width style property of the notch element.
       * @param {number} width
       */

    }, {
      key: "setNotchWidthProperty",
      value: function setNotchWidthProperty(width) {}
      /**
       * Removes the width style property from the notch element.
       */

    }, {
      key: "removeNotchWidthProperty",
      value: function removeNotchWidthProperty() {}
    }]);

    return MDCNotchedOutlineAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$j = {
    NOTCH_ELEMENT_SELECTOR: '.mdc-notched-outline__notch'
  };
  /** @enum {number} */

  var numbers$5 = {
    // This should stay in sync with $mdc-notched-outline-padding * 2.
    NOTCH_ELEMENT_PADDING: 8
  };
  /** @enum {string} */

  var cssClasses$j = {
    OUTLINE_NOTCHED: 'mdc-notched-outline--notched',
    OUTLINE_UPGRADED: 'mdc-notched-outline--upgraded',
    NO_LABEL: 'mdc-notched-outline--no-label'
  };

  /**
   * @extends {MDCFoundation<!MDCNotchedOutlineAdapter>}
   * @final
   */

  var MDCNotchedOutlineFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCNotchedOutlineFoundation, _MDCFoundation);

    _createClass(MDCNotchedOutlineFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$j;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$j;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$5;
      }
      /**
       * {@see MDCNotchedOutlineAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCNotchedOutlineAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCNotchedOutlineAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            setNotchWidthProperty: function setNotchWidthProperty() {},
            removeNotchWidthProperty: function removeNotchWidthProperty() {}
          }
        );
      }
      /**
       * @param {!MDCNotchedOutlineAdapter} adapter
       */

    }]);

    function MDCNotchedOutlineFoundation(adapter) {
      _classCallCheck(this, MDCNotchedOutlineFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCNotchedOutlineFoundation).call(this, _extends(MDCNotchedOutlineFoundation.defaultAdapter, adapter)));
    }
    /**
     * Adds the outline notched selector and updates the notch width
     * calculated based off of notchWidth.
     * @param {number} notchWidth
     */


    _createClass(MDCNotchedOutlineFoundation, [{
      key: "notch",
      value: function notch(notchWidth) {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;

        if (notchWidth > 0) {
          notchWidth += numbers$5.NOTCH_ELEMENT_PADDING; // Add padding from left/right.
        }

        this.adapter_.setNotchWidthProperty(notchWidth);
        this.adapter_.addClass(OUTLINE_NOTCHED);
      }
      /**
       * Removes notched outline selector to close the notch in the outline.
       */

    }, {
      key: "closeNotch",
      value: function closeNotch() {
        var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation.cssClasses.OUTLINE_NOTCHED;
        this.adapter_.removeClass(OUTLINE_NOTCHED);
        this.adapter_.removeNotchWidthProperty();
      }
    }]);

    return MDCNotchedOutlineFoundation;
  }(MDCFoundation);

  //
  var script$O = {
    name: 'mdc-select-notched-outline',
    data: function data() {
      return {
        outlinedClasses: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCNotchedOutlineFoundation({
        getWidth: function getWidth() {
          return _this.$refs.outlined.offsetWidth;
        },
        getHeight: function getHeight() {
          return _this.$refs.outlined.offsetHeight;
        },
        addClass: function addClass(className) {
          _this.$set(_this.outlinedClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.outlinedClasses, className);
        },
        setOutlinePathAttr: function setOutlinePathAttr(value) {
          var path = _this.$refs.outlinedPath;
          path.setAttribute('d', value);
        },
        getIdleOutlineStyleValue: function getIdleOutlineStyleValue(propertyName) {
          return window.getComputedStyle(_this.$refs.outlinedIdle).getPropertyValue(propertyName);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$O = script$O;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$O.__file = "/ddata/extra/vma/components/select/mdc-select-notched-outline.vue";

  /* template */
  var __vue_render__$L = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", [
      _c(
        "div",
        {
          ref: "outlined",
          staticClass: "mdc-notched-outline",
          class: _vm.outlinedClasses
        },
        [
          _c("svg", [
            _c("path", {
              ref: "outlinedPath",
              staticClass: "mdc-notched-outline__path"
            })
          ])
        ]
      ),
      _vm._v(" "),
      _c("div", { ref: "outlinedIdle", staticClass: "mdc-notched-outline__idle" })
    ])
  };
  var __vue_staticRenderFns__$L = [];
  __vue_render__$L._withStripped = true;

    /* style */
    const __vue_inject_styles__$O = undefined;
    /* scoped */
    const __vue_scope_id__$O = undefined;
    /* module identifier */
    const __vue_module_identifier__$O = undefined;
    /* functional template */
    const __vue_is_functional_template__$O = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var SelectNotchedOutline = normalizeComponent(
      { render: __vue_render__$L, staticRenderFns: __vue_staticRenderFns__$L },
      __vue_inject_styles__$O,
      __vue_script__$O,
      __vue_scope_id__$O,
      __vue_is_functional_template__$O,
      __vue_module_identifier__$O,
      undefined,
      undefined
    );

  var script$P = {
    name: 'mdc-select',
    components: {
      SelectLabel: SelectLabel,
      SelectLineRiple: SelectLineRiple,
      SelectNotchedOutline: SelectNotchedOutline
    },
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: String,
      disabled: Boolean,
      label: String,
      outlined: Boolean,
      id: {
        type: String
      }
    },
    data: function data() {
      return {
        styles: {},
        classes: {}
      };
    },
    computed: {
      rootClasses: function rootClasses() {
        return _objectSpread({
          'mdc-select--box': !this.outlined,
          'mdc-select--outlined': this.outlined
        }, this.classes);
      },
      listeners: function listeners() {
        var _this = this;

        return _objectSpread({}, this.$listeners, {
          change: function change(event) {
            return _this.onChange(event);
          }
        });
      }
    },
    watch: {
      disabled: function disabled(value) {
        this.foundation && this.foundation.updateDisabledStyle(value);
      },
      value: 'refreshIndex'
    },
    mounted: function mounted() {
      var _this2 = this;

      this.foundation = new MDCSelectFoundation({
        addClass: function addClass(className) {
          return _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this2.$delete(_this2.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this2.$el.classList.contains(className);
        },
        activateBottomLine: function activateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.activate();
          }
        },
        deactivateBottomLine: function deactivateBottomLine() {
          if (_this2.$refs.line) {
            _this2.$refs.line.foundation.deactivate();
          }
        },
        getValue: function getValue() {
          return _this2.$refs.native_control.value;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this2.$el).getPropertyValue('direction') === 'rtl';
        },
        notchOutline: function notchOutline(labelWidth, isRtl) {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.notch(labelWidth, isRtl);
          }
        },
        closeOutline: function closeOutline() {
          if (_this2.$refs.outline) {
            _this2.$refs.outline.foundation.closeNotch();
          }
        },
        hasOutline: function hasOutline() {
          return !!_this2.$refs.outline;
        },
        floatLabel: function floatLabel(value) {
          if (_this2.$refs.label) {
            _this2.$refs.label.foundation.float(value);
          }
        },
        hasLabel: function hasLabel() {
          return !!_this2.$refs.label;
        },
        getLabelWidth: function getLabelWidth() {
          if (_this2.$refs.label) {
            return _this2.$refs.label.foundation.getWidth();
          }
        }
      });
      this.foundation.init();
      this.foundation.handleChange(); // initial sync with DOM

      this.refreshIndex();
      this.slotObserver = new MutationObserver(function () {
        return _this2.refreshIndex();
      });
      this.slotObserver.observe(this.$refs.native_control, {
        childList: true,
        subtree: true
      });
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.slotObserver.disconnect();
      var foundation = this.foundation;
      this.foundation = null;
      foundation.destroy();
      this.ripple && this.ripple.destroy();
    },
    methods: {
      refreshIndex: function refreshIndex() {
        var _this3 = this;

        var options = _toConsumableArray(this.$refs.native_control.querySelectorAll('option'));

        var idx = options.findIndex(function (_ref) {
          var value = _ref.value;
          return _this3.value === value;
        });

        if (this.$refs.native_control.selectedIndex !== idx) {
          this.$refs.native_control.selectedIndex = idx;
          this.foundation.handleChange();
        }
      },
      onChange: function onChange(event) {
        this.foundation.handleChange();
        this.$emit('change', event.target.value);
      }
    }
  };

  /* script */
  const __vue_script__$P = script$P;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$P.__file = "/ddata/extra/vma/components/select/mdc-select.vue";

  /* template */
  var __vue_render__$M = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-select",
        class: _vm.rootClasses,
        style: _vm.styles,
        attrs: { id: _vm.id }
      },
      [
        _c(
          "select",
          _vm._g(
            _vm._b(
              {
                ref: "native_control",
                staticClass: "mdc-select__native-control",
                attrs: { disabled: _vm.disabled }
              },
              "select",
              _vm.$attrs,
              false
            ),
            _vm.listeners
          ),
          [
            !!_vm.label
              ? _c("option", {
                  staticClass: "mdc-option",
                  attrs: { value: "", disabled: "", selected: "" }
                })
              : _vm._e(),
            _vm._v(" "),
            _vm._t("default")
          ],
          2
        ),
        _vm._v(" "),
        _vm.label
          ? _c("select-label", { ref: "label" }, [_vm._v(_vm._s(_vm.label))])
          : _vm._e(),
        _vm._v(" "),
        !_vm.outlined ? _c("select-line-riple", { ref: "line" }) : _vm._e(),
        _vm._v(" "),
        _vm.outlined ? _c("select-notched-outline", { ref: "outline" }) : _vm._e()
      ],
      1
    )
  };
  var __vue_staticRenderFns__$M = [];
  __vue_render__$M._withStripped = true;

    /* style */
    const __vue_inject_styles__$P = undefined;
    /* scoped */
    const __vue_scope_id__$P = undefined;
    /* module identifier */
    const __vue_module_identifier__$P = undefined;
    /* functional template */
    const __vue_is_functional_template__$P = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcSelect = normalizeComponent(
      { render: __vue_render__$M, staticRenderFns: __vue_staticRenderFns__$M },
      __vue_inject_styles__$P,
      __vue_script__$P,
      __vue_scope_id__$P,
      __vue_is_functional_template__$P,
      __vue_module_identifier__$P,
      undefined,
      undefined
    );

  var VueMDCSelect = BasePlugin({
    mdcSelect: mdcSelect
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$k = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };
  /** @enum {string} */

  var strings$k = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };
  /** @enum {number} */

  var numbers$6 = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter =
  /*#__PURE__*/
  function () {
    function MDCSliderAdapter() {
      _classCallCheck(this, MDCSliderAdapter);
    }

    _createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}
      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}
      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}
      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}
      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}
      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}
      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}
      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}
      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}
      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}
      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}
      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}
      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}
      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}
      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}
      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}
      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}
      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}
      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);

    return MDCSliderAdapter;
  }();

  /** @enum {string} */

  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };
  /** @enum {string} */

  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };
  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];
  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSliderFoundation, _MDCFoundation);

    _createClass(MDCSliderFoundation, null, [{
      key: "cssClasses",

      /** @return enum {cssClasses} */
      get: function get() {
        return cssClasses$k;
      }
      /** @return enum {strings} */

    }, {
      key: "strings",
      get: function get() {
        return strings$k;
      }
      /** @return enum {numbers} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$6;
      }
      /** @return {!MDCSliderAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSliderAdapter} */
          {
            hasClass: function hasClass() {
              return (
                /* className: string */

                /* boolean */
                false
              );
            },
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            getAttribute: function getAttribute() {
              return (
                /* name: string */

                /* string|null */
                null
              );
            },
            setAttribute: function setAttribute()
            /* name: string, value: string */
            {},
            removeAttribute: function removeAttribute()
            /* name: string */
            {},
            computeBoundingRect: function computeBoundingRect() {
              return (
                /* ClientRect */
                {
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0,
                  width: 0,
                  height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (
                /* number */
                0
              );
            },
            registerInteractionHandler: function registerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterInteractionHandler: function deregisterInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerBodyInteractionHandler: function registerBodyInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty()
            /* propertyName: string, value: string */
            {},
            setTrackStyleProperty: function setTrackStyleProperty()
            /* propertyName: string, value: string */
            {},
            setMarkerValue: function setMarkerValue()
            /* value: number */
            {},
            appendTrackMarkers: function appendTrackMarkers()
            /* numMarkers: number */
            {},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty()
            /* propertyName: string, value: string */
            {},
            isRTL: function isRTL() {
              return (
                /* boolean */
                false
              );
            }
          }
        );
      }
      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSliderFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSliderFoundation).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));
      /** @private {?ClientRect} */

      _this.rect_ = null; // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.

      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;

      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };

      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };

      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };

      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };

      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };

      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      return _this;
    }

    _createClass(MDCSliderFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses$k.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses$k.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout(); // At last step, provide a reasonable default value to discrete slider

        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "setupTrackMarker",
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step; // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value

          var indivisible = Math.ceil(numMarkers) !== numMarkers;

          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: "layout",
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }
      /** @return {number} */

    }, {
      key: "getValue",
      value: function getValue() {
        return this.value_;
      }
      /** @param {number} value */

    }, {
      key: "setValue",
      value: function setValue(value) {
        this.setValue_(value, false);
      }
      /** @return {number} */

    }, {
      key: "getMax",
      value: function getMax() {
        return this.max_;
      }
      /** @param {number} max */

    }, {
      key: "setMax",
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }

        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$k.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }
      /** @return {number} */

    }, {
      key: "getMin",
      value: function getMin() {
        return this.min_;
      }
      /** @param {number} min */

    }, {
      key: "setMin",
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }

        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings$k.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }
      /** @return {number} */

    }, {
      key: "getStep",
      value: function getStep() {
        return this.step_;
      }
      /** @param {number} step */

    }, {
      key: "setStep",
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }

        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }

        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }
      /** @return {boolean} */

    }, {
      key: "isDisabled",
      value: function isDisabled() {
        return this.disabled_;
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses$k.DISABLED, this.disabled_);

        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings$k.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings$k.ARIA_DISABLED);

          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }
      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleDown_",
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        }; // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)


        var upHandler = function upHandler() {
          _this4.handleUp_();

          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);

          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }
      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "handleMove_",
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }
      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: "handleUp_",
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }
      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: "getPageX_",
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }

        return evt.pageX;
      }
      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: "setValueFromEvt_",
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }
      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: "computeValueFromPageX_",
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;
        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;

        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        } // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].


        return min + pctComplete * (max - min);
      }
      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: "handleKeydown_",
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);

        if (isNaN(value)) {
          return;
        } // Prevent page from scrolling due to key presses that would normally scroll the page


        evt.preventDefault();
        this.adapter_.addClass(cssClasses$k.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }
      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: "getKeyId_",
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }

        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }

        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }

        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }

        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }

        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }
      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: "getValueForKeyId_",
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;
        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);

        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;

          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;

          case KEY_IDS.HOME:
            return this.min_;

          case KEY_IDS.END:
            return this.max_;

          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers$6.PAGE_FACTOR;

          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers$6.PAGE_FACTOR;

          default:
            return NaN;
        }
      }
    }, {
      key: "handleFocus_",
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }

        this.adapter_.addClass(cssClasses$k.FOCUS);
      }
    }, {
      key: "handleBlur_",
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses$k.FOCUS);
      }
      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: "setValue_",
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;
        var valueSetToBoundary = value === min || value === max;

        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }

        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }

        this.value_ = value;
        this.adapter_.setAttribute(strings$k.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();

          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }
      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: "quantize_",
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: "updateUIForCurrentValue_",
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;
        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;

        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);

            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };

          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, "translateX(".concat(translatePx, "px) translateX(-50%)"));

          _this5.adapter_.setTrackStyleProperty(transformProp, "scaleX(".concat(pctComplete, ")"));
        });
      }
      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: "setActive_",
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses$k.ACTIVE, this.active_);
      }
      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: "setInTransit_",
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses$k.IN_TRANSIT, this.inTransit_);
      }
      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: "toggleClass_",
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);

    return MDCSliderFoundation;
  }(MDCFoundation);

  //
  var script$Q = {
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: {
        type: [Number, String],
        default: 0
      },
      max: {
        type: [Number, String],
        default: 100
      },
      step: {
        type: [Number, String],
        default: 0
      },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: {
        type: Object,
        required: false
      }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },
    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this.$el.addEventListener(type, handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this.$el.removeEventListener(type, handler, applyPassive());
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.addEventListener(type, handler, applyPassive());
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this.$refs.thumbContainer.removeEventListener(type, handler, applyPassive());
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this.$emit('input', _this.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this.$emit('change', _this.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this.$set(_this.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this.$set(_this.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this.$set(_this.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });
      this.foundation.init();
      this.foundation.setDisabled(this.disabled);

      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }

      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));

      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      this.$root.$on('vma:layout', this.layout);

      if (this.layoutOn) {
        this.layoutOnEventSource = this.layoutOnSource || this.$root;
        this.layoutOnEventSource.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.$root.$off('vma:layout', this.layout);

      if (this.layoutOnEventSource) {
        this.layoutOnEventSource.$off(this.layoutOn, this.layout);
      }

      this.foundation.destroy();
    },
    methods: {
      layout: function layout() {
        var _this2 = this;

        this.$nextTick(function () {
          _this2.foundation && _this2.foundation.layout();
        });
      }
    }
  };

  /* script */
  const __vue_script__$Q = script$Q;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$Q.__file = "/ddata/extra/vma/components/slider/mdc-slider.vue";

  /* template */
  var __vue_render__$N = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-slider",
        class: _vm.classes,
        attrs: { tabindex: "0", role: "slider" }
      },
      [
        _c("div", { staticClass: "mdc-slider__track-container" }, [
          _c("div", { staticClass: "mdc-slider__track", style: _vm.trackStyles }),
          _vm._v(" "),
          _vm.hasMarkers
            ? _c(
                "div",
                { staticClass: "mdc-slider__track-marker-container" },
                _vm._l(_vm.numMarkers, function(markerNum) {
                  return _c("div", {
                    key: markerNum,
                    staticClass: "mdc-slider__track-marker",
                    style:
                      markerNum == _vm.numMarkers
                        ? _vm.lastTrackMarkersStyles
                        : {}
                  })
                }),
                0
              )
            : _vm._e()
        ]),
        _vm._v(" "),
        _c(
          "div",
          {
            ref: "thumbContainer",
            staticClass: "mdc-slider__thumb-container",
            style: _vm.thumbStyles
          },
          [
            _vm.isDiscrete
              ? _c("div", { staticClass: "mdc-slider__pin" }, [
                  _c("span", { staticClass: "mdc-slider__pin-value-marker" }, [
                    _vm._v(_vm._s(_vm.markerValue))
                  ])
                ])
              : _vm._e(),
            _vm._v(" "),
            _c(
              "svg",
              {
                staticClass: "mdc-slider__thumb",
                attrs: { width: "21", height: "21" }
              },
              [_c("circle", { attrs: { cx: "10.5", cy: "10.5", r: "7.875" } })]
            ),
            _vm._v(" "),
            _c("div", { staticClass: "mdc-slider__focus-ring" })
          ]
        )
      ]
    )
  };
  var __vue_staticRenderFns__$N = [];
  __vue_render__$N._withStripped = true;

    /* style */
    const __vue_inject_styles__$Q = undefined;
    /* scoped */
    const __vue_scope_id__$Q = undefined;
    /* module identifier */
    const __vue_module_identifier__$Q = undefined;
    /* functional template */
    const __vue_is_functional_template__$Q = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcSlider = normalizeComponent(
      { render: __vue_render__$N, staticRenderFns: __vue_staticRenderFns__$N },
      __vue_inject_styles__$Q,
      __vue_script__$Q,
      __vue_scope_id__$Q,
      __vue_is_functional_template__$Q,
      __vue_module_identifier__$Q,
      undefined,
      undefined
    );

  var VueMDCSlider = BasePlugin({
    mdcSlider: mdcSlider
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Snackbar. Provides an interface for managing:
   * - CSS classes
   * - Event handlers
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCSnackbarAdapter =
  /*#__PURE__*/
  function () {
    function MDCSnackbarAdapter() {
      _classCallCheck(this, MDCSnackbarAdapter);
    }

    _createClass(MDCSnackbarAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
    }, {
      key: "announce",
      value: function announce() {}
    }, {
      key: "notifyOpening",
      value: function notifyOpening() {}
    }, {
      key: "notifyOpened",
      value: function notifyOpened() {}
      /**
       * @param {string} reason
       */

    }, {
      key: "notifyClosing",
      value: function notifyClosing(reason) {}
      /**
       * @param {string} reason
       */

    }, {
      key: "notifyClosed",
      value: function notifyClosed(reason) {}
    }]);

    return MDCSnackbarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$l = {
    OPENING: 'mdc-snackbar--opening',
    OPEN: 'mdc-snackbar--open',
    CLOSING: 'mdc-snackbar--closing'
  };
  var strings$l = {
    SURFACE_SELECTOR: '.mdc-snackbar__surface',
    LABEL_SELECTOR: '.mdc-snackbar__label',
    ACTION_SELECTOR: '.mdc-snackbar__action',
    DISMISS_SELECTOR: '.mdc-snackbar__dismiss',
    OPENING_EVENT: 'MDCSnackbar:opening',
    OPENED_EVENT: 'MDCSnackbar:opened',
    CLOSING_EVENT: 'MDCSnackbar:closing',
    CLOSED_EVENT: 'MDCSnackbar:closed',
    REASON_ACTION: 'action',
    REASON_DISMISS: 'dismiss',
    ARIA_LIVE_LABEL_TEXT_ATTR: 'data-mdc-snackbar-label-text'
  };
  var numbers$7 = {
    MIN_AUTO_DISMISS_TIMEOUT_MS: 4000,
    MAX_AUTO_DISMISS_TIMEOUT_MS: 10000,
    DEFAULT_AUTO_DISMISS_TIMEOUT_MS: 5000,
    // These variables need to be kept in sync with the values in _variables.scss.
    SNACKBAR_ANIMATION_OPEN_TIME_MS: 150,
    SNACKBAR_ANIMATION_CLOSE_TIME_MS: 75,

    /**
     * Number of milliseconds to wait between temporarily clearing the label text
     * in the DOM and subsequently restoring it. This is necessary to force IE 11
     * to pick up the `aria-live` content change and announce it to the user.
     */
    ARIA_LIVE_DELAY_MS: 1000
  };

  var OPENING = cssClasses$l.OPENING,
      OPEN = cssClasses$l.OPEN,
      CLOSING = cssClasses$l.CLOSING;
  var REASON_ACTION = strings$l.REASON_ACTION,
      REASON_DISMISS = strings$l.REASON_DISMISS;

  var MDCSnackbarFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSnackbarFoundation, _MDCFoundation);

    _createClass(MDCSnackbarFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$l;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$l;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers$7;
      }
      /**
       * @return {!MDCSnackbarAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSnackbarAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            announce: function announce() {},
            notifyOpening: function notifyOpening() {},
            notifyOpened: function notifyOpened() {},
            notifyClosing: function notifyClosing()
            /* reason: string */
            {},
            notifyClosed: function notifyClosed()
            /* reason: string */
            {}
          }
        );
      }
      /**
       * @param {!MDCSnackbarAdapter=} adapter
       */

    }]);

    function MDCSnackbarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCSnackbarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCSnackbarFoundation).call(this, _extends(MDCSnackbarFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.isOpen_ = false;
      /** @private {number} */

      _this.animationFrame_ = 0;
      /** @private {number} */

      _this.animationTimer_ = 0;
      /** @private {number} */

      _this.autoDismissTimer_ = 0;
      /** @private {number} */

      _this.autoDismissTimeoutMs_ = numbers$7.DEFAULT_AUTO_DISMISS_TIMEOUT_MS;
      /** @private {boolean} */

      _this.closeOnEscape_ = true;
      return _this;
    }

    _createClass(MDCSnackbarFoundation, [{
      key: "destroy",
      value: function destroy() {
        this.clearAutoDismissTimer_();
        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = 0;
        this.adapter_.removeClass(OPENING);
        this.adapter_.removeClass(OPEN);
        this.adapter_.removeClass(CLOSING);
      }
    }, {
      key: "open",
      value: function open() {
        var _this2 = this;

        this.clearAutoDismissTimer_();
        this.isOpen_ = true;
        this.adapter_.notifyOpening();
        this.adapter_.removeClass(CLOSING);
        this.adapter_.addClass(OPENING);
        this.adapter_.announce(); // Wait a frame once display is no longer "none", to establish basis for animation

        this.runNextAnimationFrame_(function () {
          _this2.adapter_.addClass(OPEN);

          _this2.animationTimer_ = setTimeout(function () {
            _this2.handleAnimationTimerEnd_();

            _this2.adapter_.notifyOpened();

            _this2.autoDismissTimer_ = setTimeout(function () {
              _this2.close(REASON_DISMISS);
            }, _this2.getTimeoutMs());
          }, numbers$7.SNACKBAR_ANIMATION_OPEN_TIME_MS);
        });
      }
      /**
       * @param {string=} reason Why the snackbar was closed. Value will be passed to CLOSING_EVENT and CLOSED_EVENT via the
       *     `event.detail.reason` property. Standard values are REASON_ACTION and REASON_DISMISS, but custom
       *     client-specific values may also be used if desired.
       */

    }, {
      key: "close",
      value: function close() {
        var _this3 = this;

        var reason = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        if (!this.isOpen_) {
          // Avoid redundant close calls (and events), e.g. repeated interactions as the snackbar is animating closed
          return;
        }

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = 0;
        this.clearAutoDismissTimer_();
        this.isOpen_ = false;
        this.adapter_.notifyClosing(reason);
        this.adapter_.addClass(cssClasses$l.CLOSING);
        this.adapter_.removeClass(cssClasses$l.OPEN);
        this.adapter_.removeClass(cssClasses$l.OPENING);
        clearTimeout(this.animationTimer_);
        this.animationTimer_ = setTimeout(function () {
          _this3.handleAnimationTimerEnd_();

          _this3.adapter_.notifyClosed(reason);
        }, numbers$7.SNACKBAR_ANIMATION_CLOSE_TIME_MS);
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "isOpen",
      value: function isOpen() {
        return this.isOpen_;
      }
      /**
       * @return {number}
       */

    }, {
      key: "getTimeoutMs",
      value: function getTimeoutMs() {
        return this.autoDismissTimeoutMs_;
      }
      /**
       * @param {number} timeoutMs
       */

    }, {
      key: "setTimeoutMs",
      value: function setTimeoutMs(timeoutMs) {
        // Use shorter variable names to make the code more readable
        var minValue = numbers$7.MIN_AUTO_DISMISS_TIMEOUT_MS;
        var maxValue = numbers$7.MAX_AUTO_DISMISS_TIMEOUT_MS;

        if (timeoutMs <= maxValue && timeoutMs >= minValue) {
          this.autoDismissTimeoutMs_ = timeoutMs;
        } else {
          throw new Error("timeoutMs must be an integer in the range ".concat(minValue, "\u2013").concat(maxValue, ", but got '").concat(timeoutMs, "'"));
        }
      }
      /**
       * @return {boolean}
       */

    }, {
      key: "getCloseOnEscape",
      value: function getCloseOnEscape() {
        return this.closeOnEscape_;
      }
      /**
       * @param {boolean} closeOnEscape
       */

    }, {
      key: "setCloseOnEscape",
      value: function setCloseOnEscape(closeOnEscape) {
        this.closeOnEscape_ = closeOnEscape;
      }
      /**
       * @param {!KeyboardEvent} evt
       */

    }, {
      key: "handleKeyDown",
      value: function handleKeyDown(evt) {
        if (this.getCloseOnEscape() && (evt.key === 'Escape' || evt.keyCode === 27)) {
          this.close(REASON_DISMISS);
        }
      }
      /**
       * @param {!MouseEvent} evt
       */

    }, {
      key: "handleActionButtonClick",
      value: function handleActionButtonClick(evt) {
        this.close(REASON_ACTION);
      }
      /**
       * @param {!MouseEvent} evt
       */

    }, {
      key: "handleActionIconClick",
      value: function handleActionIconClick(evt) {
        this.close(REASON_DISMISS);
      }
      /** @private */

    }, {
      key: "clearAutoDismissTimer_",
      value: function clearAutoDismissTimer_() {
        clearTimeout(this.autoDismissTimer_);
        this.autoDismissTimer_ = 0;
      }
      /** @private */

    }, {
      key: "handleAnimationTimerEnd_",
      value: function handleAnimationTimerEnd_() {
        this.animationTimer_ = 0;
        this.adapter_.removeClass(cssClasses$l.OPENING);
        this.adapter_.removeClass(cssClasses$l.CLOSING);
      }
      /**
       * Runs the given logic on the next animation frame, using setTimeout to factor in Firefox reflow behavior.
       * @param {Function} callback
       * @private
       */

    }, {
      key: "runNextAnimationFrame_",
      value: function runNextAnimationFrame_(callback) {
        var _this4 = this;

        cancelAnimationFrame(this.animationFrame_);
        this.animationFrame_ = requestAnimationFrame(function () {
          _this4.animationFrame_ = 0;
          clearTimeout(_this4.animationTimer_);
          _this4.animationTimer_ = setTimeout(callback, 0);
        });
      }
    }]);

    return MDCSnackbarFoundation;
  }(MDCFoundation);

  //
  var script$R = {
    name: 'mdc-snackbar',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      open: Boolean,
      stacked: Boolean,
      leading: Boolean,
      labelText: String,
      actionText: String,
      timeoutMs: [String, Number],
      dismissAction: {
        type: [String, Boolean],
        default: true
      }
    },
    data: function data() {
      return {
        classes: {
          'mdc-snackbar--leading': this.leading,
          'mdc-snackbar--stacked': this.stacked
        },
        hidden: false,
        actionHidden: false,
        showLabelText: true
      };
    },
    watch: {
      open: 'onOpen_',
      timeoutMs: 'onTimeoutMs_'
    },
    mounted: function mounted() {
      var _this = this;

      window.addEventListener('keydown', this.handleKeydownEvent);
      this.foundation = new MDCSnackbarFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        announce: function announce() {
          return _this.announce(_this.$refs.labelEl);
        },
        notifyOpening: function notifyOpening() {
          return _this.$emit(MDCSnackbarFoundation.strings.OPENING_EVENT, {});
        },
        notifyOpened: function notifyOpened() {
          _this.$emit(MDCSnackbarFoundation.strings.OPENED_EVENT, {});

          _this.$emit('change', true);

          _this.$emit('show', {});
        },
        notifyClosing: function notifyClosing(reason) {
          return _this.$emit(MDCSnackbarFoundation.strings.CLOSING_EVENT, reason ? {
            reason: reason
          } : {});
        },
        notifyClosed: function notifyClosed(reason) {
          _this.$emit(MDCSnackbarFoundation.strings.CLOSED_EVENT, reason ? {
            reason: reason
          } : {});

          _this.$emit('change', false);

          _this.$emit('hide');
        }
      });
      this.foundation.init();

      if (this.timeoutMs !== void 0) {
        this.foundation.setTimeoutMs(this.timeoutMs);
      }
    },
    computed: {
      showDismissAction: function showDismissAction() {
        return typeof this.dismissAction === 'string' ? this.dismissAction != 'false' : this.dismissAction;
      }
    },
    beforeDestroy: function beforeDestroy() {
      window.removeEventListener('keydown', this.handleKeydownEvent);
      this.foundation.destroy();
    },
    methods: {
      onTimeoutMs_: function onTimeoutMs_(value) {
        if (value !== void 0) {
          this.foundation.setTimeoutMs(value);
        }
      },
      onOpen_: function onOpen_(value) {
        if (value) {
          this.foundation.open();
        } else {
          this.foundation.close();
        }
      },
      surfaceClickHandler: function surfaceClickHandler(evt) {
        if (this.isActionButton_(evt.target)) {
          this.foundation.handleActionButtonClick(evt);
        } else if (this.isActionIcon_(evt.target)) {
          this.foundation.handleActionIconClick(evt);
        }
      },
      handleKeydownEvent: function handleKeydownEvent(evt) {
        this.foundation.handleKeyDown(evt);
      },
      isActionButton_: function isActionButton_(target) {
        return Boolean(closest(target, MDCSnackbarFoundation.strings.ACTION_SELECTOR));
      },
      isActionIcon_: function isActionIcon_(target) {
        return Boolean(closest(target, MDCSnackbarFoundation.strings.DISMISS_SELECTOR));
      },
      announce: function announce(ariaEl) {
        var _this2 = this;

        var labelEl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ariaEl;
        var priority = ariaEl.getAttribute('aria-live');
        var text = this.labelText;

        if (!text) {
          return;
        } // Temporarily disable `aria-live` to prevent JAWS+Firefox from announcing the message twice.


        ariaEl.setAttribute('aria-live', 'off'); // Temporarily clear `textContent` to force a DOM mutation event that will be detected by screen readers.
        // `aria-live` elements are only announced when the element's `textContent` *changes*, so snackbars
        // sent to the browser in the initial HTML response won't be read unless we clear the element's `textContent` first.
        // Similarly, displaying the same snackbar message twice in a row doesn't trigger a DOM mutation event,
        // so screen readers won't announce the second message unless we first clear `textContent`.
        //
        // We have to clear the label text two different ways to make it work in all browsers and screen readers:
        //
        //   1. `textContent = ''` is required for IE11 + JAWS
        //   2. `innerHTML = '&nbsp;'` is required for Chrome + JAWS and NVDA
        //
        // All other browser/screen reader combinations support both methods.
        //
        // The wrapper `<span>` visually hides the space character so that it doesn't cause jank when added/removed.
        // N.B.: Setting `position: absolute`, `opacity: 0`, or `height: 0` prevents Chrome from detecting the DOM change.
        //
        // This technique has been tested in:
        //
        //   * JAWS 2019:
        //       - Chrome 70
        //       - Firefox 60 (ESR)
        //       - IE 11
        //   * NVDA 2018:
        //       - Chrome 70
        //       - Firefox 60 (ESR)
        //       - IE 11
        //   * ChromeVox 53

        this.showLabelText = false; // Prevent visual jank by temporarily displaying the label text in the ::before pseudo-element.
        // CSS generated content is normally announced by screen readers
        // (except in IE 11; see https://tink.uk/accessibility-support-for-css-generated-content/);
        // however, `aria-live` is turned off, so this DOM update will be ignored by screen readers.

        labelEl.setAttribute(MDCSnackbarFoundation.strings.ARIA_LIVE_LABEL_TEXT_ATTR, this.labelText);
        setTimeout(function () {
          // Allow screen readers to announce changes to the DOM again.
          ariaEl.setAttribute('aria-live', priority); // Remove the message from the ::before pseudo-element.

          labelEl.removeAttribute(MDCSnackbarFoundation.strings.ARIA_LIVE_LABEL_TEXT_ATTR); // Restore the original label text, which will be announced by screen readers.

          _this2.showLabelText = true;
        }, MDCSnackbarFoundation.numbers.ARIA_LIVE_DELAY_MS);
      }
    }
  };

  /* script */
  const __vue_script__$R = script$R;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$R.__file = "/ddata/extra/vma/components/snackbar/mdc-snackbar.vue";

  /* template */
  var __vue_render__$O = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { ref: "root", staticClass: "mdc-snackbar", class: _vm.classes },
      [
        _c(
          "div",
          {
            staticClass: "mdc-snackbar__surface",
            on: { click: _vm.surfaceClickHandler }
          },
          [
            _c(
              "div",
              {
                ref: "labelEl",
                staticClass: "mdc-snackbar__label",
                attrs: { role: "status", "aria-live": "polite" }
              },
              [
                _vm.showLabelText
                  ? [_vm._v("\n        " + _vm._s(_vm.labelText) + "\n      ")]
                  : _c(
                      "span",
                      {
                        staticStyle: {
                          display: "inline-block",
                          width: "0",
                          height: "1px"
                        }
                      },
                      [_vm._v(" ")]
                    )
              ],
              2
            ),
            _vm._v(" "),
            _c("div", { staticClass: "mdc-snackbar__actions" }, [
              _c(
                "button",
                _vm._g(
                  {
                    ref: "actionEl",
                    staticClass: "mdc-button mdc-snackbar__action",
                    attrs: { type: "button" }
                  },
                  _vm.$listeners
                ),
                [_vm._v("\n        " + _vm._s(_vm.actionText) + "\n      ")]
              ),
              _vm._v(" "),
              _vm.showDismissAction
                ? _c(
                    "button",
                    {
                      staticClass:
                        "mdc-icon-button mdc-snackbar__dismiss material-icons",
                      attrs: { title: "Dismiss" }
                    },
                    [_vm._v("\n        close\n      ")]
                  )
                : _vm._e()
            ])
          ]
        )
      ]
    )
  };
  var __vue_staticRenderFns__$O = [];
  __vue_render__$O._withStripped = true;

    /* style */
    const __vue_inject_styles__$R = undefined;
    /* scoped */
    const __vue_scope_id__$R = undefined;
    /* module identifier */
    const __vue_module_identifier__$R = undefined;
    /* functional template */
    const __vue_is_functional_template__$R = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcSnackbar = normalizeComponent(
      { render: __vue_render__$O, staticRenderFns: __vue_staticRenderFns__$O },
      __vue_inject_styles__$R,
      __vue_script__$R,
      __vue_scope_id__$R,
      __vue_is_functional_template__$R,
      __vue_module_identifier__$R,
      undefined,
      undefined
    );

  var VueMDCSnackbar = BasePlugin({
    mdcSnackbar: mdcSnackbar
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Switch. Provides an interface for managing
   * - classes
   * - dom
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCSwitchAdapter =
  /*#__PURE__*/
  function () {
    function MDCSwitchAdapter() {
      _classCallCheck(this, MDCSwitchAdapter);
    }

    _createClass(MDCSwitchAdapter, [{
      key: "addClass",

      /** @param {string} className */
      value: function addClass(className) {}
      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /** @param {boolean} checked */

    }, {
      key: "setNativeControlChecked",
      value: function setNativeControlChecked(checked) {}
      /** @param {boolean} disabled */

    }, {
      key: "setNativeControlDisabled",
      value: function setNativeControlDisabled(disabled) {}
    }]);

    return MDCSwitchAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$m = {
    CHECKED: 'mdc-switch--checked',
    DISABLED: 'mdc-switch--disabled'
  };
  /** @enum {string} */

  var strings$m = {
    NATIVE_CONTROL_SELECTOR: '.mdc-switch__native-control',
    RIPPLE_SURFACE_SELECTOR: '.mdc-switch__thumb-underlay'
  };

  /**
   * @extends {MDCFoundation<!MDCSwitchAdapter>}
   */

  var MDCSwitchFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCSwitchFoundation, _MDCFoundation);

    _createClass(MDCSwitchFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$m;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$m;
      }
      /** @return {!MDCSwitchAdapter} */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCSwitchAdapter} */
          {
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            setNativeControlChecked: function setNativeControlChecked()
            /* checked: boolean */
            {},
            setNativeControlDisabled: function setNativeControlDisabled()
            /* disabled: boolean */
            {}
          }
        );
      }
    }]);

    function MDCSwitchFoundation(adapter) {
      _classCallCheck(this, MDCSwitchFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSwitchFoundation).call(this, _extends(MDCSwitchFoundation.defaultAdapter, adapter)));
    }
    /** @param {boolean} checked */


    _createClass(MDCSwitchFoundation, [{
      key: "setChecked",
      value: function setChecked(checked) {
        this.adapter_.setNativeControlChecked(checked);
        this.updateCheckedStyling_(checked);
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        this.adapter_.setNativeControlDisabled(disabled);

        if (disabled) {
          this.adapter_.addClass(cssClasses$m.DISABLED);
        } else {
          this.adapter_.removeClass(cssClasses$m.DISABLED);
        }
      }
      /**
       * Handles the change event for the switch native control.
       * @param {!Event} evt
       */

    }, {
      key: "handleChange",
      value: function handleChange(evt) {
        this.updateCheckedStyling_(evt.target.checked);
      }
      /**
       * Updates the styling of the switch based on its checked state.
       * @param {boolean} checked
       * @private
       */

    }, {
      key: "updateCheckedStyling_",
      value: function updateCheckedStyling_(checked) {
        if (checked) {
          this.adapter_.addClass(cssClasses$m.CHECKED);
        } else {
          this.adapter_.removeClass(cssClasses$m.CHECKED);
        }
      }
    }]);

    return MDCSwitchFoundation;
  }(MDCFoundation);

  //
  var script$S = {
    name: 'mdc-switch',
    mixins: [DispatchFocusMixin, VMAUniqueIdMixin],
    model: {
      prop: 'checked',
      event: 'change'
    },
    props: {
      checked: Boolean,
      disabled: Boolean,
      value: String,
      label: String,
      alignEnd: Boolean,
      name: String
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    computed: {
      hasLabel: function hasLabel() {
        return this.label || this.$slots.default;
      }
    },
    watch: {
      checked: function checked(value) {
        this.foundation && this.foundation.setChecked(value);
      },
      disabled: function disabled(value) {
        this.foundation && this.foundation.setDisabled(value);
      }
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSwitchFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        setNativeControlChecked: function setNativeControlChecked(checked) {
          return _this.$refs.control.checked = checked;
        },
        setNativeControlDisabled: function setNativeControlDisabled(disabled) {
          return _this.$refs.control.disabled = disabled;
        }
      });
      this.foundation.init();
      this.foundation.setChecked(this.checked);
      this.foundation.setDisabled(this.disabled);
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.ripple && this.ripple.destroy();
    },
    methods: {
      onChanged: function onChanged(event) {
        this.foundation && this.foundation.handleChange(event);
        this.$emit('change', event.target.checked);
      }
    }
  };

  /* script */
  const __vue_script__$S = script$S;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$S.__file = "/ddata/extra/vma/components/switch/mdc-switch.vue";

  /* template */
  var __vue_render__$P = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-switch-wrapper",
        class: {
          "mdc-form-field": _vm.hasLabel,
          "mdc-form-field--align-end": _vm.hasLabel && _vm.alignEnd
        }
      },
      [
        _c(
          "div",
          {
            staticClass: "mdc-switch",
            class: _vm.classes,
            attrs: { styles: _vm.styles }
          },
          [
            _c("div", { staticClass: "mdc-switch__track" }),
            _vm._v(" "),
            _c("div", { staticClass: "mdc-switch__thumb-underlay" }, [
              _c("div", { staticClass: "mdc-switch__thumb" }, [
                _c("input", {
                  ref: "control",
                  staticClass: "mdc-switch__native-control",
                  attrs: {
                    name: _vm.name,
                    id: _vm.vma_uid_,
                    type: "checkbox",
                    role: "switch"
                  },
                  domProps: { value: _vm.value },
                  on: { change: _vm.onChanged }
                })
              ])
            ])
          ]
        ),
        _vm._v(" "),
        _vm.hasLabel
          ? _c(
              "label",
              { staticClass: "mdc-switch-label", attrs: { for: _vm.vma_uid_ } },
              [_vm._t("default", [_vm._v(_vm._s(_vm.label))])],
              2
            )
          : _vm._e()
      ]
    )
  };
  var __vue_staticRenderFns__$P = [];
  __vue_render__$P._withStripped = true;

    /* style */
    const __vue_inject_styles__$S = undefined;
    /* scoped */
    const __vue_scope_id__$S = undefined;
    /* module identifier */
    const __vue_module_identifier__$S = undefined;
    /* functional template */
    const __vue_is_functional_template__$S = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcSwitch = normalizeComponent(
      { render: __vue_render__$P, staticRenderFns: __vue_staticRenderFns__$P },
      __vue_inject_styles__$S,
      __vue_script__$S,
      __vue_scope_id__$S,
      __vue_is_functional_template__$S,
      __vue_module_identifier__$S,
      undefined,
      undefined
    );

  var VueMDCSwitch = BasePlugin({
    mdcSwitch: mdcSwitch
  });

  /**
   * Adapter for MDC Tab.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Tab  into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTabAdapter =
  /*#__PURE__*/
  function () {
    function MDCTabAdapter() {
      _classCallCheck(this, MDCTabAdapter);
    }

    _createClass(MDCTabAdapter, [{
      key: "addClass",

      /**
       * Adds the given className to the root element.
       * @param {string} className The className to add
       */
      value: function addClass(className) {}
      /**
       * Removes the given className from the root element.
       * @param {string} className The className to remove
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns whether the root element has the given className.
       * @param {string} className The className to remove
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets the given attrName of the root element to the given value.
       * @param {string} attr The attribute name to set
       * @param {string} value The value so give the attribute
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Activates the indicator element.
       * @param {!ClientRect=} previousIndicatorClientRect The client rect of the previously activated indicator
       */

    }, {
      key: "activateIndicator",
      value: function activateIndicator(previousIndicatorClientRect) {}
      /** Deactivates the indicator. */

    }, {
      key: "deactivateIndicator",
      value: function deactivateIndicator() {}
      /**
       * Emits the MDCTab:interacted event for use by parent components
       */

    }, {
      key: "notifyInteracted",
      value: function notifyInteracted() {}
      /**
       * Returns the offsetLeft value of the root element.
       * @return {number}
       */

    }, {
      key: "getOffsetLeft",
      value: function getOffsetLeft() {}
      /**
       * Returns the offsetWidth value of the root element.
       * @return {number}
       */

    }, {
      key: "getOffsetWidth",
      value: function getOffsetWidth() {}
      /**
       * Returns the offsetLeft of the content element.
       * @return {number}
       */

    }, {
      key: "getContentOffsetLeft",
      value: function getContentOffsetLeft() {}
      /**
       * Returns the offsetWidth of the content element.
       * @return {number}
       */

    }, {
      key: "getContentOffsetWidth",
      value: function getContentOffsetWidth() {}
      /**
       * Applies focus to the root element
       */

    }, {
      key: "focus",
      value: function focus() {}
    }]);

    return MDCTabAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$n = {
    ACTIVE: 'mdc-tab--active'
  };
  /** @enum {string} */

  var strings$n = {
    ARIA_SELECTED: 'aria-selected',
    RIPPLE_SELECTOR: '.mdc-tab__ripple',
    CONTENT_SELECTOR: '.mdc-tab__content',
    TAB_INDICATOR_SELECTOR: '.mdc-tab-indicator',
    TABINDEX: 'tabIndex',
    INTERACTED_EVENT: 'MDCTab:interacted'
  };

  /**
   * @extends {MDCFoundation<!MDCTabAdapter>}
   * @final
   */

  var MDCTabFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabFoundation, _MDCFoundation);

    _createClass(MDCTabFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$n;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$n;
      }
      /**
       * @see MDCTabAdapter for typing information
       * @return {!MDCTabAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTabAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            activateIndicator: function activateIndicator() {},
            deactivateIndicator: function deactivateIndicator() {},
            notifyInteracted: function notifyInteracted() {},
            getOffsetLeft: function getOffsetLeft() {},
            getOffsetWidth: function getOffsetWidth() {},
            getContentOffsetLeft: function getContentOffsetLeft() {},
            getContentOffsetWidth: function getContentOffsetWidth() {},
            focus: function focus() {}
          }
        );
      }
      /** @param {!MDCTabAdapter} adapter */

    }]);

    function MDCTabFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTabFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTabFoundation).call(this, _extends(MDCTabFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.focusOnActivate_ = true;
      return _this;
    }
    /**
     * Handles the "click" event
     */


    _createClass(MDCTabFoundation, [{
      key: "handleClick",
      value: function handleClick() {
        // It's up to the parent component to keep track of the active Tab and
        // ensure we don't activate a Tab that's already active.
        this.adapter_.notifyInteracted();
      }
      /**
       * Returns the Tab's active state
       * @return {boolean}
       */

    }, {
      key: "isActive",
      value: function isActive() {
        return this.adapter_.hasClass(cssClasses$n.ACTIVE);
      }
      /**
       * Sets whether the tab should focus itself when activated
       * @param {boolean} focusOnActivate
       */

    }, {
      key: "setFocusOnActivate",
      value: function setFocusOnActivate(focusOnActivate) {
        this.focusOnActivate_ = focusOnActivate;
      }
      /**
       * Activates the Tab
       * @param {!ClientRect=} previousIndicatorClientRect
       */

    }, {
      key: "activate",
      value: function activate(previousIndicatorClientRect) {
        this.adapter_.addClass(cssClasses$n.ACTIVE);
        this.adapter_.setAttr(strings$n.ARIA_SELECTED, 'true');
        this.adapter_.setAttr(strings$n.TABINDEX, '0');
        this.adapter_.activateIndicator(previousIndicatorClientRect);

        if (this.focusOnActivate_) {
          this.adapter_.focus();
        }
      }
      /**
       * Deactivates the Tab
       */

    }, {
      key: "deactivate",
      value: function deactivate() {
        // Early exit
        if (!this.isActive()) {
          return;
        }

        this.adapter_.removeClass(cssClasses$n.ACTIVE);
        this.adapter_.setAttr(strings$n.ARIA_SELECTED, 'false');
        this.adapter_.setAttr(strings$n.TABINDEX, '-1');
        this.adapter_.deactivateIndicator();
      }
      /**
       * Returns the dimensions of the Tab
       * @return {!MDCTabDimensions}
       */

    }, {
      key: "computeDimensions",
      value: function computeDimensions() {
        var rootWidth = this.adapter_.getOffsetWidth();
        var rootLeft = this.adapter_.getOffsetLeft();
        var contentWidth = this.adapter_.getContentOffsetWidth();
        var contentLeft = this.adapter_.getContentOffsetLeft();
        return {
          rootLeft: rootLeft,
          rootRight: rootLeft + rootWidth,
          contentLeft: rootLeft + contentLeft,
          contentRight: rootLeft + contentLeft + contentWidth
        };
      }
    }]);

    return MDCTabFoundation;
  }(MDCFoundation);

  //
  var script$T = {
    name: 'mdc-tab',
    mixins: [CustomLinkMixin, DispatchEventMixin],
    props: {
      active: Boolean,
      icon: [String, Array, Object],
      stacked: Boolean,
      minWidth: Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-tab--stacked': this.stacked,
          'mdc-tab--min-width': this.minWidth
        },
        styles: {}
      };
    },
    inject: ['mdcTabBar'],
    computed: {
      hasIcon: function hasIcon() {
        if (this.icon || this.$slots.icon) {
          return this.icon ? extractIconProp(this.icon) : {};
        }

        return false;
      },
      hasText: function hasText() {
        return !!this.$slots.default;
      }
    },
    watch: {
      active: function active(value) {}
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabFoundation({
        setAttr: function setAttr(attr, value) {
          return _this.$el.setAttribute(attr, value);
        },
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        activateIndicator: function activateIndicator(previousIndicatorClientRect) {
          _this.$refs.tabIndicator.activate(previousIndicatorClientRect);
        },
        deactivateIndicator: function deactivateIndicator() {
          _this.$refs.tabIndicator.deactivate();
        },
        notifyInteracted: function notifyInteracted() {
          return emitCustomEvent(_this.$el, MDCTabFoundation.strings.INTERACTED_EVENT, {
            tab: _this
          }, true
          /* bubble */
          );
        },
        getOffsetLeft: function getOffsetLeft() {
          return _this.$el.offsetLeft;
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        getContentOffsetLeft: function getContentOffsetLeft() {
          return _this.$refs.content.offsetLeft;
        },
        getContentOffsetWidth: function getContentOffsetWidth() {
          return _this.$refs.content.offsetWidth;
        },
        focus: function focus() {
          return _this.$el.focus();
        }
      });
      this.foundation.init(); // console.log('tab mounted')

      this.mdcTabBar.tabList.push(this); // this.setActive(this.active)
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    methods: {
      activate: function activate(computeIndicatorClientRect) {
        this.foundation.activate(computeIndicatorClientRect);
      },
      deactivate: function deactivate() {
        this.foundation.deactivate();
      },
      handleClick: function handleClick(evt) {
        this.foundation.handleClick(evt);
      },
      isActive: function isActive() {
        return this.foundation.isActive();
      },
      setActive: function setActive(isActive) {
        if (isActive) {
          this.$set(this.classes, 'mdc-tab--active', true), this.$refs.tabIndicator.activate();
        }
      },
      computeIndicatorClientRect: function computeIndicatorClientRect() {
        return this.$refs.tabIndicator.computeContentClientRect();
      },
      computeDimensions: function computeDimensions() {
        return this.foundation.computeDimensions();
      },
      focus: function focus() {
        this.$el.focus();
      }
    }
  };

  /* script */
  const __vue_script__$T = script$T;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$T.__file = "/ddata/extra/vma/components/tabs/mdc-tab.vue";

  /* template */
  var __vue_render__$Q = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-link",
      {
        staticClass: "mdc-tab",
        class: _vm.classes,
        style: _vm.styles,
        attrs: {
          link: _vm.link,
          role: "tab",
          "aria-selected": "false",
          tabindex: "-1"
        },
        on: { click: _vm.handleClick }
      },
      [
        _c("span", { ref: "content", staticClass: "mdc-tab__content" }, [
          !!_vm.hasIcon
            ? _c(
                "i",
                {
                  ref: "icon",
                  staticClass: "mdc-tab__icon",
                  class: _vm.hasIcon.classes,
                  attrs: { tabindex: "0", "aria-hidden": "true" }
                },
                [_vm._t("icon", [_vm._v(_vm._s(_vm.hasIcon.content))])],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.hasText
            ? _c(
                "span",
                { staticClass: "mdc-tab__text-label" },
                [_vm._t("default")],
                2
              )
            : _vm._e()
        ]),
        _vm._v(" "),
        _c("mdc-tab-indicator", { ref: "tabIndicator" }),
        _vm._v(" "),
        _c("mdc-tab-ripple")
      ],
      1
    )
  };
  var __vue_staticRenderFns__$Q = [];
  __vue_render__$Q._withStripped = true;

    /* style */
    const __vue_inject_styles__$T = undefined;
    /* scoped */
    const __vue_scope_id__$T = undefined;
    /* module identifier */
    const __vue_module_identifier__$T = undefined;
    /* functional template */
    const __vue_is_functional_template__$T = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTab = normalizeComponent(
      { render: __vue_render__$Q, staticRenderFns: __vue_staticRenderFns__$Q },
      __vue_inject_styles__$T,
      __vue_script__$T,
      __vue_scope_id__$T,
      __vue_is_functional_template__$T,
      __vue_module_identifier__$T,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$o = {
    TAB_ACTIVATED_EVENT: 'MDCTabBar:activated',
    TAB_SCROLLER_SELECTOR: '.mdc-tab-scroller',
    TAB_SELECTOR: '.mdc-tab',
    ARROW_LEFT_KEY: 'ArrowLeft',
    ARROW_RIGHT_KEY: 'ArrowRight',
    END_KEY: 'End',
    HOME_KEY: 'Home',
    ENTER_KEY: 'Enter',
    SPACE_KEY: 'Space'
  };
  /** @enum {number} */

  var numbers$8 = {
    EXTRA_SCROLL_AMOUNT: 20,
    ARROW_LEFT_KEYCODE: 37,
    ARROW_RIGHT_KEYCODE: 39,
    END_KEYCODE: 35,
    HOME_KEYCODE: 36,
    ENTER_KEYCODE: 13,
    SPACE_KEYCODE: 32
  };

  /* eslint-enable no-unused-vars */

  /**
   * Adapter for MDC Tab Bar.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Tab Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTabBarAdapter =
  /*#__PURE__*/
  function () {
    function MDCTabBarAdapter() {
      _classCallCheck(this, MDCTabBarAdapter);
    }

    _createClass(MDCTabBarAdapter, [{
      key: "scrollTo",

      /**
       * Scrolls to the given position
       * @param {number} scrollX The position to scroll to
       */
      value: function scrollTo(scrollX) {}
      /**
       * Increments the current scroll position by the given amount
       * @param {number} scrollXIncrement The amount to increment scroll
       */

    }, {
      key: "incrementScroll",
      value: function incrementScroll(scrollXIncrement) {}
      /**
       * Returns the current scroll position
       * @return {number}
       */

    }, {
      key: "getScrollPosition",
      value: function getScrollPosition() {}
      /**
       * Returns the width of the scroll content
       * @return {number}
       */

    }, {
      key: "getScrollContentWidth",
      value: function getScrollContentWidth() {}
      /**
       * Returns the root element's offsetWidth
       * @return {number}
       */

    }, {
      key: "getOffsetWidth",
      value: function getOffsetWidth() {}
      /**
       * Returns if the Tab Bar language direction is RTL
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
      /**
       * Sets the tab at the given index to be activated
       * @param {number} index The index of the tab to activate
       */

    }, {
      key: "setActiveTab",
      value: function setActiveTab(index) {}
      /**
       * Activates the tab at the given index with the given client rect
       * @param {number} index The index of the tab to activate
       * @param {!ClientRect} clientRect The client rect of the previously active Tab Indicator
       */

    }, {
      key: "activateTabAtIndex",
      value: function activateTabAtIndex(index, clientRect) {}
      /**
       * Deactivates the tab at the given index
       * @param {number} index The index of the tab to deactivate
       */

    }, {
      key: "deactivateTabAtIndex",
      value: function deactivateTabAtIndex(index) {}
      /**
       * Focuses the tab at the given index
       * @param {number} index The index of the tab to focus
       */

    }, {
      key: "focusTabAtIndex",
      value: function focusTabAtIndex(index) {}
      /**
       * Returns the client rect of the tab's indicator
       * @param {number} index The index of the tab
       * @return {!ClientRect}
       */

    }, {
      key: "getTabIndicatorClientRectAtIndex",
      value: function getTabIndicatorClientRectAtIndex(index) {}
      /**
       * Returns the tab dimensions of the tab at the given index
       * @param {number} index The index of the tab
       * @return {!MDCTabDimensions}
       */

    }, {
      key: "getTabDimensionsAtIndex",
      value: function getTabDimensionsAtIndex(index) {}
      /**
       * Returns the length of the tab list
       * @return {number}
       */

    }, {
      key: "getTabListLength",
      value: function getTabListLength() {}
      /**
       * Returns the index of the previously active tab
       * @return {number}
       */

    }, {
      key: "getPreviousActiveTabIndex",
      value: function getPreviousActiveTabIndex() {}
      /**
       * Returns the index of the focused tab
       * @return {number}
       */

    }, {
      key: "getFocusedTabIndex",
      value: function getFocusedTabIndex() {}
      /**
       * Returns the index of the given tab
       * @param {string} id The ID of the tab whose index to determine
       * @return {number}
       */

    }, {
      key: "getIndexOfTabById",
      value: function getIndexOfTabById(id) {}
      /**
       * Emits the MDCTabBar:activated event
       * @param {number} index The index of the activated tab
       */

    }, {
      key: "notifyTabActivated",
      value: function notifyTabActivated(index) {}
    }]);

    return MDCTabBarAdapter;
  }();

  /* eslint-enable no-unused-vars */

  /**
   * @type {Set<string>}
   */

  var ACCEPTABLE_KEYS = new Set(); // IE11 has no support for new Set with iterable so we need to initialize this by hand

  ACCEPTABLE_KEYS.add(strings$o.ARROW_LEFT_KEY);
  ACCEPTABLE_KEYS.add(strings$o.ARROW_RIGHT_KEY);
  ACCEPTABLE_KEYS.add(strings$o.END_KEY);
  ACCEPTABLE_KEYS.add(strings$o.HOME_KEY);
  ACCEPTABLE_KEYS.add(strings$o.ENTER_KEY);
  ACCEPTABLE_KEYS.add(strings$o.SPACE_KEY);
  /**
   * @type {Map<number, string>}
   */

  var KEYCODE_MAP = new Map(); // IE11 has no support for new Map with iterable so we need to initialize this by hand

  KEYCODE_MAP.set(numbers$8.ARROW_LEFT_KEYCODE, strings$o.ARROW_LEFT_KEY);
  KEYCODE_MAP.set(numbers$8.ARROW_RIGHT_KEYCODE, strings$o.ARROW_RIGHT_KEY);
  KEYCODE_MAP.set(numbers$8.END_KEYCODE, strings$o.END_KEY);
  KEYCODE_MAP.set(numbers$8.HOME_KEYCODE, strings$o.HOME_KEY);
  KEYCODE_MAP.set(numbers$8.ENTER_KEYCODE, strings$o.ENTER_KEY);
  KEYCODE_MAP.set(numbers$8.SPACE_KEYCODE, strings$o.SPACE_KEY);
  /**
   * @extends {MDCFoundation<!MDCTabBarAdapter>}
   * @final
   */

  var MDCTabBarFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabBarFoundation, _MDCFoundation);

    _createClass(MDCTabBarFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$o;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$8;
      }
      /**
       * @see MDCTabBarAdapter for typing information
       * @return {!MDCTabBarAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTabBarAdapter} */
          {
            scrollTo: function scrollTo() {},
            incrementScroll: function incrementScroll() {},
            getScrollPosition: function getScrollPosition() {},
            getScrollContentWidth: function getScrollContentWidth() {},
            getOffsetWidth: function getOffsetWidth() {},
            isRTL: function isRTL() {},
            setActiveTab: function setActiveTab() {},
            activateTabAtIndex: function activateTabAtIndex() {},
            deactivateTabAtIndex: function deactivateTabAtIndex() {},
            focusTabAtIndex: function focusTabAtIndex() {},
            getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex() {},
            getTabDimensionsAtIndex: function getTabDimensionsAtIndex() {},
            getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {},
            getFocusedTabIndex: function getFocusedTabIndex() {},
            getIndexOfTabById: function getIndexOfTabById() {},
            getTabListLength: function getTabListLength() {},
            notifyTabActivated: function notifyTabActivated() {}
          }
        );
      }
      /**
       * @param {!MDCTabBarAdapter} adapter
       * */

    }]);

    function MDCTabBarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTabBarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTabBarFoundation).call(this, _extends(MDCTabBarFoundation.defaultAdapter, adapter)));
      /** @private {boolean} */

      _this.useAutomaticActivation_ = false;
      return _this;
    }
    /**
     * Switches between automatic and manual activation modes.
     * See https://www.w3.org/TR/wai-aria-practices/#tabpanel for examples.
     * @param {boolean} useAutomaticActivation
     */


    _createClass(MDCTabBarFoundation, [{
      key: "setUseAutomaticActivation",
      value: function setUseAutomaticActivation(useAutomaticActivation) {
        this.useAutomaticActivation_ = useAutomaticActivation;
      }
      /**
       * Activates the tab at the given index
       * @param {number} index
       */

    }, {
      key: "activateTab",
      value: function activateTab(index) {
        var previousActiveIndex = this.adapter_.getPreviousActiveTabIndex();

        if (!this.indexIsInRange_(index) || index === previousActiveIndex) {
          return;
        }

        this.adapter_.deactivateTabAtIndex(previousActiveIndex);
        this.adapter_.activateTabAtIndex(index, this.adapter_.getTabIndicatorClientRectAtIndex(previousActiveIndex));
        this.scrollIntoView(index);
        this.adapter_.notifyTabActivated(index);
      }
      /**
       * Handles the keydown event
       * @param {!Event} evt
       */

    }, {
      key: "handleKeyDown",
      value: function handleKeyDown(evt) {
        // Get the key from the event
        var key = this.getKeyFromEvent_(evt); // Early exit if the event key isn't one of the keyboard navigation keys

        if (key === undefined) {
          return;
        } // Prevent default behavior for movement keys, but not for activation keys, since :active is used to apply ripple


        if (!this.isActivationKey_(key)) {
          evt.preventDefault();
        }

        if (this.useAutomaticActivation_) {
          if (this.isActivationKey_(key)) {
            return;
          }

          var index = this.determineTargetFromKey_(this.adapter_.getPreviousActiveTabIndex(), key);
          this.adapter_.setActiveTab(index);
          this.scrollIntoView(index);
        } else {
          var focusedTabIndex = this.adapter_.getFocusedTabIndex();

          if (this.isActivationKey_(key)) {
            this.adapter_.setActiveTab(focusedTabIndex);
          } else {
            var _index = this.determineTargetFromKey_(focusedTabIndex, key);

            this.adapter_.focusTabAtIndex(_index);
            this.scrollIntoView(_index);
          }
        }
      }
      /**
       * Handles the MDCTab:interacted event
       * @param {!Event} evt
       */

    }, {
      key: "handleTabInteraction",
      value: function handleTabInteraction(evt) {
        this.adapter_.setActiveTab(this.adapter_.getIndexOfTabById(evt.detail.tabId));
      }
      /**
       * Scrolls the tab at the given index into view
       * @param {number} index The tab index to make visible
       */

    }, {
      key: "scrollIntoView",
      value: function scrollIntoView(index) {
        // Early exit if the index is out of range
        if (!this.indexIsInRange_(index)) {
          return;
        } // Always scroll to 0 if scrolling to the 0th index


        if (index === 0) {
          return this.adapter_.scrollTo(0);
        } // Always scroll to the max value if scrolling to the Nth index
        // MDCTabScroller.scrollTo() will never scroll past the max possible value


        if (index === this.adapter_.getTabListLength() - 1) {
          return this.adapter_.scrollTo(this.adapter_.getScrollContentWidth());
        }

        if (this.isRTL_()) {
          return this.scrollIntoViewRTL_(index);
        }

        this.scrollIntoView_(index);
      }
      /**
       * Private method for determining the index of the destination tab based on what key was pressed
       * @param {number} origin The original index from which to determine the destination
       * @param {string} key The name of the key
       * @return {number}
       * @private
       */

    }, {
      key: "determineTargetFromKey_",
      value: function determineTargetFromKey_(origin, key) {
        var isRTL = this.isRTL_();
        var maxIndex = this.adapter_.getTabListLength() - 1;
        var shouldGoToEnd = key === strings$o.END_KEY;
        var shouldDecrement = key === strings$o.ARROW_LEFT_KEY && !isRTL || key === strings$o.ARROW_RIGHT_KEY && isRTL;
        var shouldIncrement = key === strings$o.ARROW_RIGHT_KEY && !isRTL || key === strings$o.ARROW_LEFT_KEY && isRTL;
        var index = origin;

        if (shouldGoToEnd) {
          index = maxIndex;
        } else if (shouldDecrement) {
          index -= 1;
        } else if (shouldIncrement) {
          index += 1;
        } else {
          index = 0;
        }

        if (index < 0) {
          index = maxIndex;
        } else if (index > maxIndex) {
          index = 0;
        }

        return index;
      }
      /**
       * Calculates the scroll increment that will make the tab at the given index visible
       * @param {number} index The index of the tab
       * @param {number} nextIndex The index of the next tab
       * @param {number} scrollPosition The current scroll position
       * @param {number} barWidth The width of the Tab Bar
       * @return {number}
       * @private
       */

    }, {
      key: "calculateScrollIncrement_",
      value: function calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = nextTabDimensions.contentLeft - scrollPosition - barWidth;
        var relativeContentRight = nextTabDimensions.contentRight - scrollPosition;
        var leftIncrement = relativeContentRight - numbers$8.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft + numbers$8.EXTRA_SCROLL_AMOUNT;

        if (nextIndex < index) {
          return Math.min(leftIncrement, 0);
        }

        return Math.max(rightIncrement, 0);
      }
      /**
       * Calculates the scroll increment that will make the tab at the given index visible in RTL
       * @param {number} index The index of the tab
       * @param {number} nextIndex The index of the next tab
       * @param {number} scrollPosition The current scroll position
       * @param {number} barWidth The width of the Tab Bar
       * @param {number} scrollContentWidth The width of the scroll content
       * @return {number}
       * @private
       */

    }, {
      key: "calculateScrollIncrementRTL_",
      value: function calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollContentWidth) {
        var nextTabDimensions = this.adapter_.getTabDimensionsAtIndex(nextIndex);
        var relativeContentLeft = scrollContentWidth - nextTabDimensions.contentLeft - scrollPosition;
        var relativeContentRight = scrollContentWidth - nextTabDimensions.contentRight - scrollPosition - barWidth;
        var leftIncrement = relativeContentRight + numbers$8.EXTRA_SCROLL_AMOUNT;
        var rightIncrement = relativeContentLeft - numbers$8.EXTRA_SCROLL_AMOUNT;

        if (nextIndex > index) {
          return Math.max(leftIncrement, 0);
        }

        return Math.min(rightIncrement, 0);
      }
      /**
       * Determines the index of the adjacent tab closest to either edge of the Tab Bar
       * @param {number} index The index of the tab
       * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
       * @param {number} scrollPosition The current scroll position
       * @param {number} barWidth The width of the tab bar
       * @return {number}
       * @private
       */

    }, {
      key: "findAdjacentTabIndexClosestToEdge_",
      value: function findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth) {
        /**
         * Tabs are laid out in the Tab Scroller like this:
         *
         *    Scroll Position
         *    +---+
         *    |   |   Bar Width
         *    |   +-----------------------------------+
         *    |   |                                   |
         *    |   V                                   V
         *    |   +-----------------------------------+
         *    V   |             Tab Scroller          |
         *    +------------+--------------+-------------------+
         *    |    Tab     |      Tab     |        Tab        |
         *    +------------+--------------+-------------------+
         *        |                                   |
         *        +-----------------------------------+
         *
         * To determine the next adjacent index, we look at the Tab root left and
         * Tab root right, both relative to the scroll position. If the Tab root
         * left is less than 0, then we know it's out of view to the left. If the
         * Tab root right minus the bar width is greater than 0, we know the Tab is
         * out of view to the right. From there, we either increment or decrement
         * the index.
         */
        var relativeRootLeft = tabDimensions.rootLeft - scrollPosition;
        var relativeRootRight = tabDimensions.rootRight - scrollPosition - barWidth;
        var relativeRootDelta = relativeRootLeft + relativeRootRight;
        var leftEdgeIsCloser = relativeRootLeft < 0 || relativeRootDelta < 0;
        var rightEdgeIsCloser = relativeRootRight > 0 || relativeRootDelta > 0;

        if (leftEdgeIsCloser) {
          return index - 1;
        }

        if (rightEdgeIsCloser) {
          return index + 1;
        }

        return -1;
      }
      /**
       * Determines the index of the adjacent tab closest to either edge of the Tab Bar in RTL
       * @param {number} index The index of the tab
       * @param {!MDCTabDimensions} tabDimensions The dimensions of the tab
       * @param {number} scrollPosition The current scroll position
       * @param {number} barWidth The width of the tab bar
       * @param {number} scrollContentWidth The width of the scroller content
       * @return {number}
       * @private
       */

    }, {
      key: "findAdjacentTabIndexClosestToEdgeRTL_",
      value: function findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollContentWidth) {
        var rootLeft = scrollContentWidth - tabDimensions.rootLeft - barWidth - scrollPosition;
        var rootRight = scrollContentWidth - tabDimensions.rootRight - scrollPosition;
        var rootDelta = rootLeft + rootRight;
        var leftEdgeIsCloser = rootLeft > 0 || rootDelta > 0;
        var rightEdgeIsCloser = rootRight < 0 || rootDelta < 0;

        if (leftEdgeIsCloser) {
          return index + 1;
        }

        if (rightEdgeIsCloser) {
          return index - 1;
        }

        return -1;
      }
      /**
       * Returns the key associated with a keydown event
       * @param {!Event} evt The keydown event
       * @return {string}
       * @private
       */

    }, {
      key: "getKeyFromEvent_",
      value: function getKeyFromEvent_(evt) {
        if (ACCEPTABLE_KEYS.has(evt.key)) {
          return evt.key;
        }

        return KEYCODE_MAP.get(evt.keyCode);
      }
    }, {
      key: "isActivationKey_",
      value: function isActivationKey_(key) {
        return key === strings$o.SPACE_KEY || key === strings$o.ENTER_KEY;
      }
      /**
       * Returns whether a given index is inclusively between the ends
       * @param {number} index The index to test
       * @private
       */

    }, {
      key: "indexIsInRange_",
      value: function indexIsInRange_(index) {
        return index >= 0 && index < this.adapter_.getTabListLength();
      }
      /**
       * Returns the view's RTL property
       * @return {boolean}
       * @private
       */

    }, {
      key: "isRTL_",
      value: function isRTL_() {
        return this.adapter_.isRTL();
      }
      /**
       * Scrolls the tab at the given index into view for left-to-right useragents
       * @param {number} index The index of the tab to scroll into view
       * @private
       */

    }, {
      key: "scrollIntoView_",
      value: function scrollIntoView_(index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var nextIndex = this.findAdjacentTabIndexClosestToEdge_(index, tabDimensions, scrollPosition, barWidth);

        if (!this.indexIsInRange_(nextIndex)) {
          return;
        }

        var scrollIncrement = this.calculateScrollIncrement_(index, nextIndex, scrollPosition, barWidth);
        this.adapter_.incrementScroll(scrollIncrement);
      }
      /**
       * Scrolls the tab at the given index into view in RTL
       * @param {number} index The tab index to make visible
       * @private
       */

    }, {
      key: "scrollIntoViewRTL_",
      value: function scrollIntoViewRTL_(index) {
        var scrollPosition = this.adapter_.getScrollPosition();
        var barWidth = this.adapter_.getOffsetWidth();
        var tabDimensions = this.adapter_.getTabDimensionsAtIndex(index);
        var scrollWidth = this.adapter_.getScrollContentWidth();
        var nextIndex = this.findAdjacentTabIndexClosestToEdgeRTL_(index, tabDimensions, scrollPosition, barWidth, scrollWidth);

        if (!this.indexIsInRange_(nextIndex)) {
          return;
        }

        var scrollIncrement = this.calculateScrollIncrementRTL_(index, nextIndex, scrollPosition, barWidth, scrollWidth);
        this.adapter_.incrementScroll(scrollIncrement);
      }
    }]);

    return MDCTabBarFoundation;
  }(MDCFoundation);

  var script$U = {
    name: 'mdc-tab-bar',
    data: function data() {
      return {
        classes: {},
        indicatorStyles: {},
        tabList: []
      };
    },
    props: {
      activeTabIndex: [Number, String]
    },
    provide: function provide() {
      return {
        mdcTabBar: this
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabBarFoundation({
        scrollTo: function scrollTo(scrollX) {
          return _this.$refs.scroller.scrollTo(scrollX);
        },
        incrementScroll: function incrementScroll(scrollXIncrement) {
          return _this.$refs.scroller.incrementScroll(scrollXIncrement);
        },
        getScrollPosition: function getScrollPosition() {
          return _this.$refs.scroller.getScrollPosition();
        },
        getScrollContentWidth: function getScrollContentWidth() {
          return _this.$refs.scroller.getScrollContentWidth();
        },
        getOffsetWidth: function getOffsetWidth() {
          return _this.$el.offsetWidth;
        },
        isRTL: function isRTL() {
          return window.getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        setActiveTab: function setActiveTab(index) {
          _this.foundation.activateTab(index);
        },
        activateTabAtIndex: function activateTabAtIndex(index, clientRect) {
          _this.tabList[index].activate(clientRect);
        },
        deactivateTabAtIndex: function deactivateTabAtIndex(index) {
          _this.tabList[index] && _this.tabList[index].deactivate();
        },
        focusTabAtIndex: function focusTabAtIndex(index) {
          return _this.tabList[index].focus();
        },
        getTabIndicatorClientRectAtIndex: function getTabIndicatorClientRectAtIndex(index) {
          return _this.tabList[index] && _this.tabList[index].computeIndicatorClientRect();
        },
        getTabDimensionsAtIndex: function getTabDimensionsAtIndex(index) {
          return _this.tabList[index].computeDimensions();
        },
        getPreviousActiveTabIndex: function getPreviousActiveTabIndex() {
          for (var i = 0; i < _this.tabList.length; i++) {
            if (_this.tabList[i].isActive()) {
              return i;
            }
          }

          return -1;
        },
        getFocusedTabIndex: function getFocusedTabIndex() {
          var tabElements = _this.getTabElements_();

          var activeElement = document.activeElement;
          return tabElements.indexOf(activeElement);
        },
        getIndexOfTab: function getIndexOfTab(tabToFind) {
          return _this.tabList.indexOf(tabToFind);
        },
        getTabListLength: function getTabListLength() {
          return _this.tabList.length;
        },
        notifyTabActivated: function notifyTabActivated(index) {
          emitCustomEvent(_this.$el, MDCTabBarFoundation.strings.TAB_ACTIVATED_EVENT, {
            index: index
          }, true);

          _this.$emit('change', index);
        }
      });
      this.foundation.init(); // ensure active tab

      this.foundation.activateTab(this.activeTabIndex || 0);
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    computed: {
      listeners: function listeners() {
        var _this2 = this;

        return _objectSpread({}, this.$listeners, {
          'MDCTab:interacted': function MDCTabInteracted(event) {
            return _this2.handleInteraction(event);
          }
        });
      }
    },
    methods: {
      handleInteraction: function handleInteraction(evt) {
        this.foundation.handleTabInteraction(evt);
      }
    }
  };

  /* script */
  const __vue_script__$U = script$U;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$U.__file = "/ddata/extra/vma/components/tabs/mdc-tab-bar.vue";

  /* template */
  var __vue_render__$R = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      _vm._g(
        {
          staticClass: "mdc-tab-bar",
          class: _vm.classes,
          attrs: { role: "tablist" }
        },
        _vm.listeners
      ),
      [_c("mdc-tab-scroller", { ref: "scroller" }, [_vm._t("default")], 2)],
      1
    )
  };
  var __vue_staticRenderFns__$R = [];
  __vue_render__$R._withStripped = true;

    /* style */
    const __vue_inject_styles__$U = undefined;
    /* scoped */
    const __vue_scope_id__$U = undefined;
    /* module identifier */
    const __vue_module_identifier__$U = undefined;
    /* functional template */
    const __vue_is_functional_template__$U = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTabBar = normalizeComponent(
      { render: __vue_render__$R, staticRenderFns: __vue_staticRenderFns__$R },
      __vue_inject_styles__$U,
      __vue_script__$U,
      __vue_scope_id__$U,
      __vue_is_functional_template__$U,
      __vue_module_identifier__$U,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$o = {
    ANIMATING: 'mdc-tab-scroller--animating',
    SCROLL_TEST: 'mdc-tab-scroller__test',
    SCROLL_AREA_SCROLL: 'mdc-tab-scroller__scroll-area--scroll'
  };
  /** @enum {string} */

  var strings$p = {
    AREA_SELECTOR: '.mdc-tab-scroller__scroll-area',
    CONTENT_SELECTOR: '.mdc-tab-scroller__scroll-content'
  };

  /**
   * Adapter for MDC Tab Scroller.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Tab  into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTabScrollerAdapter =
  /*#__PURE__*/
  function () {
    function MDCTabScrollerAdapter() {
      _classCallCheck(this, MDCTabScrollerAdapter);
    }

    _createClass(MDCTabScrollerAdapter, [{
      key: "addClass",

      /**
       * Adds the given className to the root element.
       * @param {string} className The className to add
       */
      value: function addClass(className) {}
      /**
       * Removes the given className from the root element.
       * @param {string} className The className to remove
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Adds the given className to the scroll area element.
       * @param {string} className The className to add
       */

    }, {
      key: "addScrollAreaClass",
      value: function addScrollAreaClass(className) {}
      /**
       * Returns whether the event target matches given className.
       * @param {EventTarget} evtTarget The event target
       * @param {string} selector The selector to check
       * @return {boolean}
       */

    }, {
      key: "eventTargetMatchesSelector",
      value: function eventTargetMatchesSelector(evtTarget, selector) {}
      /**
       * Sets a style property of the area element to the passed value.
       * @param {string} propName The style property name to set
       * @param {string} value The style property value
       */

    }, {
      key: "setScrollAreaStyleProperty",
      value: function setScrollAreaStyleProperty(propName, value) {}
      /**
       * Sets a style property of the content element to the passed value.
       * @param {string} propName The style property name to set
       * @param {string} value The style property value
       */

    }, {
      key: "setScrollContentStyleProperty",
      value: function setScrollContentStyleProperty(propName, value) {}
      /**
       * Returns the scroll content element's computed style value of the given css property `propertyName`.
       * We achieve this via `getComputedStyle(...).getPropertyValue(propertyName)`.
       * @param {string} propertyName
       * @return {string}
       */

    }, {
      key: "getScrollContentStyleValue",
      value: function getScrollContentStyleValue(propertyName) {}
      /**
       * Sets the scrollLeft value of the scroll area element to the passed value.
       * @param {number} scrollLeft The new scrollLeft value
       */

    }, {
      key: "setScrollAreaScrollLeft",
      value: function setScrollAreaScrollLeft(scrollLeft) {}
      /**
       * Returns the scrollLeft value of the scroll area element.
       * @return {number}
       */

    }, {
      key: "getScrollAreaScrollLeft",
      value: function getScrollAreaScrollLeft() {}
      /**
       * Returns the offsetWidth of the scroll content element.
       * @return {number}
       */

    }, {
      key: "getScrollContentOffsetWidth",
      value: function getScrollContentOffsetWidth() {}
      /**
       * Returns the offsetWitdth of the scroll area element.
       * @return {number}
       */

    }, {
      key: "getScrollAreaOffsetWidth",
      value: function getScrollAreaOffsetWidth() {}
      /**
       * Returns the bounding client rect of the scroll area element.
       * @return {!ClientRect}
       */

    }, {
      key: "computeScrollAreaClientRect",
      value: function computeScrollAreaClientRect() {}
      /**
       * Returns the bounding client rect of the scroll content element.
       * @return {!ClientRect}
       */

    }, {
      key: "computeScrollContentClientRect",
      value: function computeScrollContentClientRect() {}
      /**
       * Returns the height of the browser's horizontal scrollbars (in px).
       * @return {number}
       */

    }, {
      key: "computeHorizontalScrollbarHeight",
      value: function computeHorizontalScrollbarHeight() {}
    }]);

    return MDCTabScrollerAdapter;
  }();

  /* eslint-enable no-unused-vars */

  /**
   * @abstract
   */

  var MDCTabScrollerRTL =
  /*#__PURE__*/
  function () {
    /** @param {!MDCTabScrollerAdapter} adapter */
    function MDCTabScrollerRTL(adapter) {
      _classCallCheck(this, MDCTabScrollerRTL);

      /** @private */
      this.adapter_ = adapter;
    }
    /**
     * @param {number} translateX The current translateX position
     * @return {number}
     * @abstract
     */


    _createClass(MDCTabScrollerRTL, [{
      key: "getScrollPositionRTL",
      value: function getScrollPositionRTL(translateX) {}
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       * @abstract
       */

    }, {
      key: "scrollToRTL",
      value: function scrollToRTL(scrollX) {}
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       * @abstract
       */

    }, {
      key: "incrementScrollRTL",
      value: function incrementScrollRTL(scrollX) {}
      /**
       * @param {number} scrollX The current scrollX position
       * @param {number} translateX The current translateX position
       * @return {number}
       * @abstract
       */

    }, {
      key: "getAnimatingScrollPosition",
      value: function getAnimatingScrollPosition(scrollX, translateX) {}
    }]);

    return MDCTabScrollerRTL;
  }();

  /* eslint-enable no-unused-vars */

  /**
   * @extends {MDCTabScrollerRTL}
   * @final
   */

  var MDCTabScrollerRTLDefault =
  /*#__PURE__*/
  function (_MDCTabScrollerRTL) {
    _inherits(MDCTabScrollerRTLDefault, _MDCTabScrollerRTL);

    function MDCTabScrollerRTLDefault() {
      _classCallCheck(this, MDCTabScrollerRTLDefault);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTabScrollerRTLDefault).apply(this, arguments));
    }

    _createClass(MDCTabScrollerRTLDefault, [{
      key: "getScrollPositionRTL",

      /**
       * @return {number}
       */
      value: function getScrollPositionRTL() {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();

        var _this$calculateScroll = this.calculateScrollEdges_(),
            right = _this$calculateScroll.right; // Scroll values on most browsers are ints instead of floats so we round


        return Math.round(right - currentScrollLeft);
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "scrollToRTL",
      value: function scrollToRTL(scrollX) {
        var edges = this.calculateScrollEdges_();
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(edges.right - scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "incrementScrollRTL",
      value: function incrementScrollRTL(scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {number}
       */

    }, {
      key: "getAnimatingScrollPosition",
      value: function getAnimatingScrollPosition(scrollX) {
        return scrollX;
      }
      /**
       * @return {!MDCTabScrollerHorizontalEdges}
       * @private
       */

    }, {
      key: "calculateScrollEdges_",
      value: function calculateScrollEdges_() {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return (
          /** @type {!MDCTabScrollerHorizontalEdges} */
          {
            left: 0,
            right: contentWidth - rootWidth
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {number}
       * @private
       */

    }, {
      key: "clampScrollValue_",
      value: function clampScrollValue_(scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
      }
    }]);

    return MDCTabScrollerRTLDefault;
  }(MDCTabScrollerRTL);

  /* eslint-enable no-unused-vars */

  /**
   * @extends {MDCTabScrollerRTL}
   * @final
   */

  var MDCTabScrollerRTLNegative =
  /*#__PURE__*/
  function (_MDCTabScrollerRTL) {
    _inherits(MDCTabScrollerRTLNegative, _MDCTabScrollerRTL);

    function MDCTabScrollerRTLNegative() {
      _classCallCheck(this, MDCTabScrollerRTLNegative);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTabScrollerRTLNegative).apply(this, arguments));
    }

    _createClass(MDCTabScrollerRTLNegative, [{
      key: "getScrollPositionRTL",

      /**
       * @param {number} translateX The current translateX position
       * @return {number}
       */
      value: function getScrollPositionRTL(translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return Math.round(translateX - currentScrollLeft);
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "scrollToRTL",
      value: function scrollToRTL(scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(-scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "incrementScrollRTL",
      value: function incrementScrollRTL(scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft - scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: clampedScrollLeft - currentScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @param {number} translateX
       * @return {number}
       */

    }, {
      key: "getAnimatingScrollPosition",
      value: function getAnimatingScrollPosition(scrollX, translateX) {
        return scrollX - translateX;
      }
      /**
       * @return {!MDCTabScrollerHorizontalEdges}
       * @private
       */

    }, {
      key: "calculateScrollEdges_",
      value: function calculateScrollEdges_() {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return (
          /** @type {!MDCTabScrollerHorizontalEdges} */
          {
            left: rootWidth - contentWidth,
            right: 0
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {number}
       * @private
       */

    }, {
      key: "clampScrollValue_",
      value: function clampScrollValue_(scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.max(Math.min(edges.right, scrollX), edges.left);
      }
    }]);

    return MDCTabScrollerRTLNegative;
  }(MDCTabScrollerRTL);

  /* eslint-enable no-unused-vars */

  /**
   * @extends {MDCTabScrollerRTL}
   * @final
   */

  var MDCTabScrollerRTLReverse =
  /*#__PURE__*/
  function (_MDCTabScrollerRTL) {
    _inherits(MDCTabScrollerRTLReverse, _MDCTabScrollerRTL);

    function MDCTabScrollerRTLReverse() {
      _classCallCheck(this, MDCTabScrollerRTLReverse);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTabScrollerRTLReverse).apply(this, arguments));
    }

    _createClass(MDCTabScrollerRTLReverse, [{
      key: "getScrollPositionRTL",

      /**
       * @param {number} translateX
       * @return {number}
       */
      value: function getScrollPositionRTL(translateX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // Scroll values on most browsers are ints instead of floats so we round

        return Math.round(currentScrollLeft - translateX);
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "scrollToRTL",
      value: function scrollToRTL(scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {!MDCTabScrollerAnimation}
       */

    }, {
      key: "incrementScrollRTL",
      value: function incrementScrollRTL(scrollX) {
        var currentScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        var clampedScrollLeft = this.clampScrollValue_(currentScrollLeft + scrollX);
        return (
          /** @type {!MDCTabScrollerAnimation} */
          {
            finalScrollPosition: clampedScrollLeft,
            scrollDelta: currentScrollLeft - clampedScrollLeft
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {number}
       */

    }, {
      key: "getAnimatingScrollPosition",
      value: function getAnimatingScrollPosition(scrollX, translateX) {
        return scrollX + translateX;
      }
      /**
       * @return {!MDCTabScrollerHorizontalEdges}
       * @private
       */

    }, {
      key: "calculateScrollEdges_",
      value: function calculateScrollEdges_() {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return (
          /** @type {!MDCTabScrollerHorizontalEdges} */
          {
            left: contentWidth - rootWidth,
            right: 0
          }
        );
      }
      /**
       * @param {number} scrollX
       * @return {number}
       * @private
       */

    }, {
      key: "clampScrollValue_",
      value: function clampScrollValue_(scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.right, scrollX), edges.left);
      }
    }]);

    return MDCTabScrollerRTLReverse;
  }(MDCTabScrollerRTL);

  /**
   * @extends {MDCFoundation<!MDCTabScrollerAdapter>}
   * @final
   */

  var MDCTabScrollerFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabScrollerFoundation, _MDCFoundation);

    _createClass(MDCTabScrollerFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$o;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$p;
      }
      /**
       * @see MDCTabScrollerAdapter for typing information
       * @return {!MDCTabScrollerAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTabScrollerAdapter} */
          {
            eventTargetMatchesSelector: function eventTargetMatchesSelector() {},
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            addScrollAreaClass: function addScrollAreaClass() {},
            setScrollAreaStyleProperty: function setScrollAreaStyleProperty() {},
            setScrollContentStyleProperty: function setScrollContentStyleProperty() {},
            getScrollContentStyleValue: function getScrollContentStyleValue() {},
            setScrollAreaScrollLeft: function setScrollAreaScrollLeft() {},
            getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {},
            getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {},
            getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {},
            computeScrollAreaClientRect: function computeScrollAreaClientRect() {},
            computeScrollContentClientRect: function computeScrollContentClientRect() {},
            computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight() {}
          }
        );
      }
      /** @param {!MDCTabScrollerAdapter} adapter */

    }]);

    function MDCTabScrollerFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTabScrollerFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTabScrollerFoundation).call(this, _extends(MDCTabScrollerFoundation.defaultAdapter, adapter)));
      /**
       * This boolean controls whether we should handle the transitionend and interaction events during the animation.
       * @private {boolean}
       */

      _this.isAnimating_ = false;
      /**
       * The MDCTabScrollerRTL instance varies per browser and allows us to encapsulate the peculiar browser behavior
       * of RTL scrolling in it's own class.
       * @private {?MDCTabScrollerRTL}
       */

      _this.rtlScrollerInstance_;
      return _this;
    }

    _createClass(MDCTabScrollerFoundation, [{
      key: "init",
      value: function init() {
        // Compute horizontal scrollbar height on scroller with overflow initially hidden, then update overflow to scroll
        // and immediately adjust bottom margin to avoid the scrollbar initially appearing before JS runs.
        var horizontalScrollbarHeight = this.adapter_.computeHorizontalScrollbarHeight();
        this.adapter_.setScrollAreaStyleProperty('margin-bottom', -horizontalScrollbarHeight + 'px');
        this.adapter_.addScrollAreaClass(MDCTabScrollerFoundation.cssClasses.SCROLL_AREA_SCROLL);
      }
      /**
       * Computes the current visual scroll position
       * @return {number}
       */

    }, {
      key: "getScrollPosition",
      value: function getScrollPosition() {
        if (this.isRTL_()) {
          return this.computeCurrentScrollPositionRTL_();
        }

        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();
        return scrollLeft - currentTranslateX;
      }
      /**
       * Handles interaction events that occur during transition
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction() {
        // Early exit if we aren't animating
        if (!this.isAnimating_) {
          return;
        } // Prevent other event listeners from handling this event


        this.stopScrollAnimation_();
      }
      /**
       * Handles the transitionend event
       * @param {!Event} evt
       */

    }, {
      key: "handleTransitionEnd",
      value: function handleTransitionEnd(evt) {
        // Early exit if we aren't animating or the event was triggered by a different element.
        if (!this.isAnimating_ || !this.adapter_.eventTargetMatchesSelector(evt.target, MDCTabScrollerFoundation.strings.CONTENT_SELECTOR)) {
          return;
        }

        this.isAnimating_ = false;
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
      }
      /**
       * Increment the scroll value by the scrollXIncrement
       * @param {number} scrollXIncrement The value by which to increment the scroll position
       */

    }, {
      key: "incrementScroll",
      value: function incrementScroll(scrollXIncrement) {
        // Early exit for non-operational increment values
        if (scrollXIncrement === 0) {
          return;
        }

        if (this.isRTL_()) {
          return this.incrementScrollRTL_(scrollXIncrement);
        }

        this.incrementScroll_(scrollXIncrement);
      }
      /**
       * Scrolls to the given scrollX value
       * @param {number} scrollX
       */

    }, {
      key: "scrollTo",
      value: function scrollTo(scrollX) {
        if (this.isRTL_()) {
          return this.scrollToRTL_(scrollX);
        }

        this.scrollTo_(scrollX);
      }
      /**
       * Returns the appropriate version of the MDCTabScrollerRTL
       * @return {!MDCTabScrollerRTL}
       */

    }, {
      key: "getRTLScroller",
      value: function getRTLScroller() {
        if (!this.rtlScrollerInstance_) {
          this.rtlScrollerInstance_ = this.rtlScrollerFactory_();
        }

        return this.rtlScrollerInstance_;
      }
      /**
       * Returns the translateX value from a CSS matrix transform function string
       * @return {number}
       * @private
       */

    }, {
      key: "calculateCurrentTranslateX_",
      value: function calculateCurrentTranslateX_() {
        var transformValue = this.adapter_.getScrollContentStyleValue('transform'); // Early exit if no transform is present

        if (transformValue === 'none') {
          return 0;
        } // The transform value comes back as a matrix transformation in the form
        // of `matrix(a, b, c, d, tx, ty)`. We only care about tx (translateX) so
        // we're going to grab all the parenthesized values, strip out tx, and
        // parse it.


        var results = /\((.+)\)/.exec(transformValue)[1];
        var parts = results.split(',');
        return parseFloat(parts[4]);
      }
      /**
       * Calculates a safe scroll value that is > 0 and < the max scroll value
       * @param {number} scrollX The distance to scroll
       * @return {number}
       * @private
       */

    }, {
      key: "clampScrollValue_",
      value: function clampScrollValue_(scrollX) {
        var edges = this.calculateScrollEdges_();
        return Math.min(Math.max(edges.left, scrollX), edges.right);
      }
      /**
       * @return {number}
       * @private
       */

    }, {
      key: "computeCurrentScrollPositionRTL_",
      value: function computeCurrentScrollPositionRTL_() {
        var translateX = this.calculateCurrentTranslateX_();
        return this.getRTLScroller().getScrollPositionRTL(translateX);
      }
      /**
       * @return {!MDCTabScrollerHorizontalEdges}
       * @private
       */

    }, {
      key: "calculateScrollEdges_",
      value: function calculateScrollEdges_() {
        var contentWidth = this.adapter_.getScrollContentOffsetWidth();
        var rootWidth = this.adapter_.getScrollAreaOffsetWidth();
        return (
          /** @type {!MDCTabScrollerHorizontalEdges} */
          {
            left: 0,
            right: contentWidth - rootWidth
          }
        );
      }
      /**
       * Internal scroll method
       * @param {number} scrollX The new scroll position
       * @private
       */

    }, {
      key: "scrollTo_",
      value: function scrollTo_(scrollX) {
        var currentScrollX = this.getScrollPosition();
        var safeScrollX = this.clampScrollValue_(scrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        this.animate_(
        /** @type {!MDCTabScrollerAnimation} */
        {
          finalScrollPosition: safeScrollX,
          scrollDelta: scrollDelta
        });
      }
      /**
       * Internal RTL scroll method
       * @param {number} scrollX The new scroll position
       * @private
       */

    }, {
      key: "scrollToRTL_",
      value: function scrollToRTL_(scrollX) {
        var animation = this.getRTLScroller().scrollToRTL(scrollX);
        this.animate_(animation);
      }
      /**
       * Internal increment scroll method
       * @param {number} scrollX The new scroll position increment
       * @private
       */

    }, {
      key: "incrementScroll_",
      value: function incrementScroll_(scrollX) {
        var currentScrollX = this.getScrollPosition();
        var targetScrollX = scrollX + currentScrollX;
        var safeScrollX = this.clampScrollValue_(targetScrollX);
        var scrollDelta = safeScrollX - currentScrollX;
        this.animate_(
        /** @type {!MDCTabScrollerAnimation} */
        {
          finalScrollPosition: safeScrollX,
          scrollDelta: scrollDelta
        });
      }
      /**
       * Internal incremenet scroll RTL method
       * @param {number} scrollX The new scroll position RTL increment
       * @private
       */

    }, {
      key: "incrementScrollRTL_",
      value: function incrementScrollRTL_(scrollX) {
        var animation = this.getRTLScroller().incrementScrollRTL(scrollX);
        this.animate_(animation);
      }
      /**
       * Animates the tab scrolling
       * @param {!MDCTabScrollerAnimation} animation The animation to apply
       * @private
       */

    }, {
      key: "animate_",
      value: function animate_(animation) {
        var _this2 = this;

        // Early exit if translateX is 0, which means there's no animation to perform
        if (animation.scrollDelta === 0) {
          return;
        }

        this.stopScrollAnimation_(); // This animation uses the FLIP approach.
        // Read more here: https://aerotwist.com/blog/flip-your-animations/

        this.adapter_.setScrollAreaScrollLeft(animation.finalScrollPosition);
        this.adapter_.setScrollContentStyleProperty('transform', "translateX(".concat(animation.scrollDelta, "px)")); // Force repaint

        this.adapter_.computeScrollAreaClientRect();
        requestAnimationFrame(function () {
          _this2.adapter_.addClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);

          _this2.adapter_.setScrollContentStyleProperty('transform', 'none');
        });
        this.isAnimating_ = true;
      }
      /**
       * Stops scroll animation
       * @private
       */

    }, {
      key: "stopScrollAnimation_",
      value: function stopScrollAnimation_() {
        this.isAnimating_ = false;
        var currentScrollPosition = this.getAnimatingScrollPosition_();
        this.adapter_.removeClass(MDCTabScrollerFoundation.cssClasses.ANIMATING);
        this.adapter_.setScrollContentStyleProperty('transform', 'translateX(0px)');
        this.adapter_.setScrollAreaScrollLeft(currentScrollPosition);
      }
      /**
       * Gets the current scroll position during animation
       * @return {number}
       * @private
       */

    }, {
      key: "getAnimatingScrollPosition_",
      value: function getAnimatingScrollPosition_() {
        var currentTranslateX = this.calculateCurrentTranslateX_();
        var scrollLeft = this.adapter_.getScrollAreaScrollLeft();

        if (this.isRTL_()) {
          return this.getRTLScroller().getAnimatingScrollPosition(scrollLeft, currentTranslateX);
        }

        return scrollLeft - currentTranslateX;
      }
      /**
       * Determines the RTL Scroller to use
       * @return {!MDCTabScrollerRTL}
       * @private
       */

    }, {
      key: "rtlScrollerFactory_",
      value: function rtlScrollerFactory_() {
        // Browsers have three different implementations of scrollLeft in RTL mode,
        // dependent on the browser. The behavior is based off the max LTR
        // scrollleft value and 0.
        //
        // * Default scrolling in RTL *
        //    - Left-most value: 0
        //    - Right-most value: Max LTR scrollLeft value
        //
        // * Negative scrolling in RTL *
        //    - Left-most value: Negated max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // * Reverse scrolling in RTL *
        //    - Left-most value: Max LTR scrollLeft value
        //    - Right-most value: 0
        //
        // We use those principles below to determine which RTL scrollLeft
        // behavior is implemented in the current browser.
        var initialScrollLeft = this.adapter_.getScrollAreaScrollLeft();
        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft - 1);
        var newScrollLeft = this.adapter_.getScrollAreaScrollLeft(); // If the newScrollLeft value is negative,then we know that the browser has
        // implemented negative RTL scrolling, since all other implementations have
        // only positive values.

        if (newScrollLeft < 0) {
          // Undo the scrollLeft test check
          this.adapter_.setScrollAreaScrollLeft(initialScrollLeft);
          return new MDCTabScrollerRTLNegative(this.adapter_);
        }

        var rootClientRect = this.adapter_.computeScrollAreaClientRect();
        var contentClientRect = this.adapter_.computeScrollContentClientRect();
        var rightEdgeDelta = Math.round(contentClientRect.right - rootClientRect.right); // Undo the scrollLeft test check

        this.adapter_.setScrollAreaScrollLeft(initialScrollLeft); // By calculating the clientRect of the root element and the clientRect of
        // the content element, we can determine how much the scroll value changed
        // when we performed the scrollLeft subtraction above.

        if (rightEdgeDelta === newScrollLeft) {
          return new MDCTabScrollerRTLReverse(this.adapter_);
        }

        return new MDCTabScrollerRTLDefault(this.adapter_);
      }
      /**
       * @return {boolean}
       * @private
       */

    }, {
      key: "isRTL_",
      value: function isRTL_() {
        return this.adapter_.getScrollContentStyleValue('direction') === 'rtl';
      }
    }]);

    return MDCTabScrollerFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  /**
   * Stores result from computeHorizontalScrollbarHeight to avoid redundant processing.
   * @private {number|undefined}
   */

  var horizontalScrollbarHeight_;
  /**
   * Computes the height of browser-rendered horizontal scrollbars using a self-created test element.
   * May return 0 (e.g. on OS X browsers under default configuration).
   * @param {!Document} documentObj
   * @param {boolean=} shouldCacheResult
   * @return {number}
   */

  function computeHorizontalScrollbarHeight(documentObj) {
    var shouldCacheResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

    if (shouldCacheResult && typeof horizontalScrollbarHeight_ !== 'undefined') {
      return horizontalScrollbarHeight_;
    }

    var el = documentObj.createElement('div');
    el.classList.add(cssClasses$o.SCROLL_TEST);
    documentObj.body.appendChild(el);
    var horizontalScrollbarHeight = el.offsetHeight - el.clientHeight;
    documentObj.body.removeChild(el);

    if (shouldCacheResult) {
      horizontalScrollbarHeight_ = horizontalScrollbarHeight;
    }

    return horizontalScrollbarHeight;
  }
  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */


  function getMatchesProperty$1(HTMLElementPrototype) {
    return ['msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  //
  var script$V = {
    name: 'mdc-tab-scroller',
    data: function data() {
      return {
        classes: {},
        areaClasses: {},
        areaStyles: {},
        contentStyles: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCTabScrollerFoundation({
        eventTargetMatchesSelector: function eventTargetMatchesSelector(evtTarget, selector) {
          var MATCHES = getMatchesProperty$1(HTMLElement.prototype);
          return evtTarget[MATCHES](selector);
        },
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        addScrollAreaClass: function addScrollAreaClass(className) {
          return _this.$set(_this.areaClasses, className, true);
        },
        setScrollAreaStyleProperty: function setScrollAreaStyleProperty(prop, value) {
          return _this.$set(_this.areaStyles, prop, value);
        },
        setScrollContentStyleProperty: function setScrollContentStyleProperty(prop, value) {
          return _this.$set(_this.contentStyles, prop, value);
        },
        getScrollContentStyleValue: function getScrollContentStyleValue(propName) {
          return window.getComputedStyle(_this.$refs.content).getPropertyValue(propName);
        },
        setScrollAreaScrollLeft: function setScrollAreaScrollLeft(scrollX) {
          return _this.$refs.area.scrollLeft = scrollX;
        },
        getScrollAreaScrollLeft: function getScrollAreaScrollLeft() {
          return _this.$refs.area.scrollLeft;
        },
        getScrollContentOffsetWidth: function getScrollContentOffsetWidth() {
          return _this.$refs.content.offsetWidth;
        },
        getScrollAreaOffsetWidth: function getScrollAreaOffsetWidth() {
          return _this.$refs.area.offsetWidth;
        },
        computeScrollAreaClientRect: function computeScrollAreaClientRect() {
          return _this.$refs.area.getBoundingClientRect();
        },
        computeScrollContentClientRect: function computeScrollContentClientRect() {
          return _this.$refs.content.getBoundingClientRect();
        },
        computeHorizontalScrollbarHeight: function computeHorizontalScrollbarHeight$$1() {
          return computeHorizontalScrollbarHeight(document);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    methods: {
      handleTransitionEnd: function handleTransitionEnd(evt) {
        this.foundation.handleTransitionEnd(evt);
      },
      handleInteraction: function handleInteraction(evt) {
        this.foundation.handleInteraction(evt);
      },
      getScrollPosition: function getScrollPosition() {
        return this.foundation.getScrollPosition();
      },
      getScrollContentWidth: function getScrollContentWidth() {
        return this.$refs.content.offsetWidth;
      },
      incrementScroll: function incrementScroll(scrollXIncrement) {
        this.foundation.incrementScroll(scrollXIncrement);
      },
      scrollTo: function scrollTo(scrollX) {
        this.foundation.scrollTo(scrollX);
      }
    }
  };

  /* script */
  const __vue_script__$V = script$V;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$V.__file = "/ddata/extra/vma/components/tabs/mdc-tab-scroller.vue";

  /* template */
  var __vue_render__$S = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("div", { staticClass: "mdc-tab-scroller", class: _vm.classes }, [
      _c(
        "div",
        {
          ref: "area",
          staticClass: "mdc-tab-scroller__scroll-area",
          class: _vm.areaClasses,
          style: _vm.areaStyles,
          on: {
            mousedown: _vm.handleInteraction,
            wheel: _vm.handleInteraction,
            pointerdown: _vm.handleInteraction,
            touchstart: _vm.handleInteraction,
            keydown: _vm.handleInteraction
          }
        },
        [
          _c(
            "div",
            {
              ref: "content",
              staticClass: "mdc-tab-scroller__scroll-content",
              style: _vm.contentStyles,
              on: { transitionend: _vm.handleTransitionEnd }
            },
            [_vm._t("default")],
            2
          )
        ]
      )
    ])
  };
  var __vue_staticRenderFns__$S = [];
  __vue_render__$S._withStripped = true;

    /* style */
    const __vue_inject_styles__$V = undefined;
    /* scoped */
    const __vue_scope_id__$V = undefined;
    /* module identifier */
    const __vue_module_identifier__$V = undefined;
    /* functional template */
    const __vue_is_functional_template__$V = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTabScroller = normalizeComponent(
      { render: __vue_render__$S, staticRenderFns: __vue_staticRenderFns__$S },
      __vue_inject_styles__$V,
      __vue_script__$V,
      __vue_scope_id__$V,
      __vue_is_functional_template__$V,
      __vue_module_identifier__$V,
      undefined,
      undefined
    );

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Tab Indicator.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Tab Indicator into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTabIndicatorAdapter =
  /*#__PURE__*/
  function () {
    function MDCTabIndicatorAdapter() {
      _classCallCheck(this, MDCTabIndicatorAdapter);
    }

    _createClass(MDCTabIndicatorAdapter, [{
      key: "addClass",

      /**
       * Adds the given className to the root element.
       * @param {string} className The className to add
       */
      value: function addClass(className) {}
      /**
       * Removes the given className from the root element.
       * @param {string} className The className to remove
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns the client rect of the content element.
       * @return {!ClientRect}
       */

    }, {
      key: "computeContentClientRect",
      value: function computeContentClientRect() {}
      /**
       * Sets a style property of the content element to the passed value
       * @param {string} propName The style property name to set
       * @param {string} value The style property value
       */

    }, {
      key: "setContentStyleProperty",
      value: function setContentStyleProperty(propName, value) {}
    }]);

    return MDCTabIndicatorAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$p = {
    ACTIVE: 'mdc-tab-indicator--active',
    FADE: 'mdc-tab-indicator--fade',
    NO_TRANSITION: 'mdc-tab-indicator--no-transition'
  };
  /** @enum {string} */

  var strings$q = {
    CONTENT_SELECTOR: '.mdc-tab-indicator__content'
  };

  /**
   * @extends {MDCFoundation<!MDCTabIndicatorAdapter>}
   * @abstract
   */

  var MDCTabIndicatorFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTabIndicatorFoundation, _MDCFoundation);

    _createClass(MDCTabIndicatorFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$p;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$q;
      }
      /**
       * @see MDCTabIndicatorAdapter for typing information
       * @return {!MDCTabIndicatorAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTabIndicatorAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            computeContentClientRect: function computeContentClientRect() {},
            setContentStyleProperty: function setContentStyleProperty() {}
          }
        );
      }
      /** @param {!MDCTabIndicatorAdapter} adapter */

    }]);

    function MDCTabIndicatorFoundation(adapter) {
      _classCallCheck(this, MDCTabIndicatorFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTabIndicatorFoundation).call(this, _extends(MDCTabIndicatorFoundation.defaultAdapter, adapter)));
    }
    /** @return {!ClientRect} */


    _createClass(MDCTabIndicatorFoundation, [{
      key: "computeContentClientRect",
      value: function computeContentClientRect() {
        return this.adapter_.computeContentClientRect();
      }
      /**
       * Activates the indicator
       * @param {!ClientRect=} previousIndicatorClientRect
       * @abstract
       */

    }, {
      key: "activate",
      value: function activate(previousIndicatorClientRect) {} // eslint-disable-line no-unused-vars

      /** @abstract */

    }, {
      key: "deactivate",
      value: function deactivate() {}
    }]);

    return MDCTabIndicatorFoundation;
  }(MDCFoundation);

  /**
   * @extends {MDCTabIndicatorFoundation}
   * @final
   */

  var MDCSlidingTabIndicatorFoundation =
  /*#__PURE__*/
  function (_MDCTabIndicatorFound) {
    _inherits(MDCSlidingTabIndicatorFoundation, _MDCTabIndicatorFound);

    function MDCSlidingTabIndicatorFoundation() {
      _classCallCheck(this, MDCSlidingTabIndicatorFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCSlidingTabIndicatorFoundation).apply(this, arguments));
    }

    _createClass(MDCSlidingTabIndicatorFoundation, [{
      key: "activate",

      /** @param {!ClientRect=} previousIndicatorClientRect */
      value: function activate(previousIndicatorClientRect) {
        // Early exit if no indicator is present to handle cases where an indicator
        // may be activated without a prior indicator state
        if (!previousIndicatorClientRect) {
          this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
          return;
        } // This animation uses the FLIP approach. You can read more about it at the link below:
        // https://aerotwist.com/blog/flip-your-animations/
        // Calculate the dimensions based on the dimensions of the previous indicator


        var currentClientRect = this.computeContentClientRect();
        var widthDelta = previousIndicatorClientRect.width / currentClientRect.width;
        var xPosition = previousIndicatorClientRect.left - currentClientRect.left;
        this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.setContentStyleProperty('transform', "translateX(".concat(xPosition, "px) scaleX(").concat(widthDelta, ")")); // Force repaint before updating classes and transform to ensure the transform properly takes effect

        this.computeContentClientRect();
        this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.NO_TRANSITION);
        this.adapter_.addClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
        this.adapter_.setContentStyleProperty('transform', '');
      }
    }, {
      key: "deactivate",
      value: function deactivate() {
        this.adapter_.removeClass(MDCTabIndicatorFoundation.cssClasses.ACTIVE);
      }
    }]);

    return MDCSlidingTabIndicatorFoundation;
  }(MDCTabIndicatorFoundation);

  //
  var script$W = {
    name: 'mdc-tab-indicator',
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCSlidingTabIndicatorFoundation({
        addClass: function addClass(className) {
          return _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          return _this.$delete(_this.classes, className);
        },
        computeContentClientRect: function computeContentClientRect() {
          return _this.$refs.content.getBoundingClientRect();
        },
        setContentStyleProperty: function setContentStyleProperty(prop, value) {
          _this.$set(_this.styles, prop, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    },
    methods: {
      activate: function activate(previousIndicatorClientRect) {
        this.foundation.activate(previousIndicatorClientRect);
      },
      deactivate: function deactivate() {
        this.foundation.deactivate();
      },
      computeContentClientRect: function computeContentClientRect() {
        return this.foundation.computeContentClientRect();
      }
    }
  };

  /* script */
  const __vue_script__$W = script$W;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$W.__file = "/ddata/extra/vma/components/tabs/mdc-tab-indicator.vue";

  /* template */
  var __vue_render__$T = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", { staticClass: "mdc-tab-indicator", class: _vm.classes }, [
      _c("span", {
        ref: "content",
        staticClass:
          "mdc-tab-indicator__content mdc-tab-indicator__content--underline",
        style: _vm.styles
      })
    ])
  };
  var __vue_staticRenderFns__$T = [];
  __vue_render__$T._withStripped = true;

    /* style */
    const __vue_inject_styles__$W = undefined;
    /* scoped */
    const __vue_scope_id__$W = undefined;
    /* module identifier */
    const __vue_module_identifier__$W = undefined;
    /* functional template */
    const __vue_is_functional_template__$W = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTabIndicator = normalizeComponent(
      { render: __vue_render__$T, staticRenderFns: __vue_staticRenderFns__$T },
      __vue_inject_styles__$W,
      __vue_script__$W,
      __vue_scope_id__$W,
      __vue_is_functional_template__$W,
      __vue_module_identifier__$W,
      undefined,
      undefined
    );

  //
  var script$X = {
    name: 'mdc-tab-ripple',
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple.destroy();
    }
  };

  /* script */
  const __vue_script__$X = script$X;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$X.__file = "/ddata/extra/vma/components/tabs/mdc-tab-ripple.vue";

  /* template */
  var __vue_render__$U = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("span", {
      staticClass: "mdc-tab__ripple",
      class: _vm.classes,
      style: _vm.styles
    })
  };
  var __vue_staticRenderFns__$U = [];
  __vue_render__$U._withStripped = true;

    /* style */
    const __vue_inject_styles__$X = undefined;
    /* scoped */
    const __vue_scope_id__$X = undefined;
    /* module identifier */
    const __vue_module_identifier__$X = undefined;
    /* functional template */
    const __vue_is_functional_template__$X = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTabRipple = normalizeComponent(
      { render: __vue_render__$U, staticRenderFns: __vue_staticRenderFns__$U },
      __vue_inject_styles__$X,
      __vue_script__$X,
      __vue_scope_id__$X,
      __vue_is_functional_template__$X,
      __vue_module_identifier__$X,
      undefined,
      undefined
    );

  var VueMDCTabs = BasePlugin({
    mdcTab: mdcTab,
    mdcTabBar: mdcTabBar,
    mdcTabScroller: mdcTabScroller,
    mdcTabIndicator: mdcTabIndicator,
    mdcTabRipple: mdcTabRipple
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Helper Text.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the TextField helper text into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldHelperTextAdapter =
  /*#__PURE__*/
  function () {
    function MDCTextFieldHelperTextAdapter() {
      _classCallCheck(this, MDCTextFieldHelperTextAdapter);
    }

    _createClass(MDCTextFieldHelperTextAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the helper text element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the helper text element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns whether or not the helper text element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets an attribute with a given value on the helper text element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the helper text element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content for the helper text element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
    }]);

    return MDCTextFieldHelperTextAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$r = {
    ARIA_HIDDEN: 'aria-hidden',
    ROLE: 'role'
  };
  /** @enum {string} */

  var cssClasses$q = {
    HELPER_TEXT_PERSISTENT: 'mdc-text-field-helper-text--persistent',
    HELPER_TEXT_VALIDATION_MSG: 'mdc-text-field-helper-text--validation-msg'
  };

  /**
   * @extends {MDCFoundation<!MDCTextFieldHelperTextAdapter>}
   * @final
   */

  var MDCTextFieldHelperTextFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTextFieldHelperTextFoundation, _MDCFoundation);

    _createClass(MDCTextFieldHelperTextFoundation, null, [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$q;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$r;
      }
      /**
       * {@see MDCTextFieldHelperTextAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldHelperTextAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTextFieldHelperTextAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {}
          }
        );
      }
      /**
       * @param {!MDCTextFieldHelperTextAdapter} adapter
       */

    }]);

    function MDCTextFieldHelperTextFoundation(adapter) {
      _classCallCheck(this, MDCTextFieldHelperTextFoundation);

      return _possibleConstructorReturn(this, _getPrototypeOf(MDCTextFieldHelperTextFoundation).call(this, _extends(MDCTextFieldHelperTextFoundation.defaultAdapter, adapter)));
    }
    /**
     * Sets the content of the helper text field.
     * @param {string} content
     */


    _createClass(MDCTextFieldHelperTextFoundation, [{
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /** @param {boolean} isPersistent Sets the persistency of the helper text. */

    }, {
      key: "setPersistent",
      value: function setPersistent(isPersistent) {
        if (isPersistent) {
          this.adapter_.addClass(cssClasses$q.HELPER_TEXT_PERSISTENT);
        } else {
          this.adapter_.removeClass(cssClasses$q.HELPER_TEXT_PERSISTENT);
        }
      }
      /**
       * @param {boolean} isValidation True to make the helper text act as an
       *   error validation message.
       */

    }, {
      key: "setValidation",
      value: function setValidation(isValidation) {
        if (isValidation) {
          this.adapter_.addClass(cssClasses$q.HELPER_TEXT_VALIDATION_MSG);
        } else {
          this.adapter_.removeClass(cssClasses$q.HELPER_TEXT_VALIDATION_MSG);
        }
      }
      /** Makes the helper text visible to the screen reader. */

    }, {
      key: "showToScreenReader",
      value: function showToScreenReader() {
        this.adapter_.removeAttr(strings$r.ARIA_HIDDEN);
      }
      /**
       * Sets the validity of the helper text based on the input validity.
       * @param {boolean} inputIsValid
       */

    }, {
      key: "setValidity",
      value: function setValidity(inputIsValid) {
        var helperTextIsPersistent = this.adapter_.hasClass(cssClasses$q.HELPER_TEXT_PERSISTENT);
        var helperTextIsValidationMsg = this.adapter_.hasClass(cssClasses$q.HELPER_TEXT_VALIDATION_MSG);
        var validationMsgNeedsDisplay = helperTextIsValidationMsg && !inputIsValid;

        if (validationMsgNeedsDisplay) {
          this.adapter_.setAttr(strings$r.ROLE, 'alert');
        } else {
          this.adapter_.removeAttr(strings$r.ROLE);
        }

        if (!helperTextIsPersistent && !validationMsgNeedsDisplay) {
          this.hide_();
        }
      }
      /**
       * Hides the help text from screen readers.
       * @private
       */

    }, {
      key: "hide_",
      value: function hide_() {
        this.adapter_.setAttr(strings$r.ARIA_HIDDEN, 'true');
      }
    }]);

    return MDCTextFieldHelperTextFoundation;
  }(MDCFoundation);

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Text Field Icon.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the text field icon into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTextFieldIconAdapter =
  /*#__PURE__*/
  function () {
    function MDCTextFieldIconAdapter() {
      _classCallCheck(this, MDCTextFieldIconAdapter);
    }

    _createClass(MDCTextFieldIconAdapter, [{
      key: "getAttr",

      /**
       * Gets the value of an attribute on the icon element.
       * @param {string} attr
       * @return {string}
       */
      value: function getAttr(attr) {}
      /**
       * Sets an attribute on the icon element.
       * @param {string} attr
       * @param {string} value
       */

    }, {
      key: "setAttr",
      value: function setAttr(attr, value) {}
      /**
       * Removes an attribute from the icon element.
       * @param {string} attr
       */

    }, {
      key: "removeAttr",
      value: function removeAttr(attr) {}
      /**
       * Sets the text content of the icon element.
       * @param {string} content
       */

    }, {
      key: "setContent",
      value: function setContent(content) {}
      /**
       * Registers an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the icon element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}
      /**
       * Emits a custom event "MDCTextField:icon" denoting a user has clicked the icon.
       */

    }, {
      key: "notifyIconAction",
      value: function notifyIconAction() {}
    }]);

    return MDCTextFieldIconAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$s = {
    ICON_EVENT: 'MDCTextField:icon',
    ICON_ROLE: 'button'
  };

  /**
   * @extends {MDCFoundation<!MDCTextFieldIconAdapter>}
   * @final
   */

  var MDCTextFieldIconFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTextFieldIconFoundation, _MDCFoundation);

    _createClass(MDCTextFieldIconFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$s;
      }
      /**
       * {@see MDCTextFieldIconAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldIconAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTextFieldIconAdapter} */
          {
            getAttr: function getAttr() {},
            setAttr: function setAttr() {},
            removeAttr: function removeAttr() {},
            setContent: function setContent() {},
            registerInteractionHandler: function registerInteractionHandler() {},
            deregisterInteractionHandler: function deregisterInteractionHandler() {},
            notifyIconAction: function notifyIconAction() {}
          }
        );
      }
      /**
       * @param {!MDCTextFieldIconAdapter} adapter
       */

    }]);

    function MDCTextFieldIconFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTextFieldIconFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTextFieldIconFoundation).call(this, _extends(MDCTextFieldIconFoundation.defaultAdapter, adapter)));
      /** @private {string?} */

      _this.savedTabIndex_ = null;
      /** @private {function(!Event): undefined} */

      _this.interactionHandler_ = function (evt) {
        return _this.handleInteraction(evt);
      };

      return _this;
    }

    _createClass(MDCTextFieldIconFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        this.savedTabIndex_ = this.adapter_.getAttr('tabindex');
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerInteractionHandler(evtType, _this2.interactionHandler_);
        });
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterInteractionHandler(evtType, _this3.interactionHandler_);
        });
      }
      /** @param {boolean} disabled */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        if (!this.savedTabIndex_) {
          return;
        }

        if (disabled) {
          this.adapter_.setAttr('tabindex', '-1');
          this.adapter_.removeAttr('role');
        } else {
          this.adapter_.setAttr('tabindex', this.savedTabIndex_);
          this.adapter_.setAttr('role', strings$s.ICON_ROLE);
        }
      }
      /** @param {string} label */

    }, {
      key: "setAriaLabel",
      value: function setAriaLabel(label) {
        this.adapter_.setAttr('aria-label', label);
      }
      /** @param {string} content */

    }, {
      key: "setContent",
      value: function setContent(content) {
        this.adapter_.setContent(content);
      }
      /**
       * Handles an interaction event
       * @param {!Event} evt
       */

    }, {
      key: "handleInteraction",
      value: function handleInteraction(evt) {
        if (evt.type === 'click' || evt.key === 'Enter' || evt.keyCode === 13) {
          this.adapter_.notifyIconAction();
        }
      }
    }]);

    return MDCTextFieldIconFoundation;
  }(MDCFoundation);

  /**
   * Adapter for MDC Text Field.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Text Field into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */

  var MDCTextFieldAdapter =
  /*#__PURE__*/
  function () {
    function MDCTextFieldAdapter() {
      _classCallCheck(this, MDCTextFieldAdapter);
    }

    _createClass(MDCTextFieldAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root element contains the given class name.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerTextFieldInteractionHandler",
      value: function registerTextFieldInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterTextFieldInteractionHandler",
      value: function deregisterTextFieldInteractionHandler(type, handler) {}
      /**
       * Registers an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInputInteractionHandler",
      value: function registerInputInteractionHandler(evtType, handler) {}
      /**
       * Deregisters an event listener on the native input element for a given event.
       * @param {string} evtType
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInputInteractionHandler",
      value: function deregisterInputInteractionHandler(evtType, handler) {}
      /**
       * Registers a validation attribute change listener on the input element.
       * Handler accepts list of attribute names.
       * @param {function(!Array<string>): undefined} handler
       * @return {!MutationObserver}
       */

    }, {
      key: "registerValidationAttributeChangeHandler",
      value: function registerValidationAttributeChangeHandler(handler) {}
      /**
       * Disconnects a validation attribute observer on the input element.
       * @param {!MutationObserver} observer
       */

    }, {
      key: "deregisterValidationAttributeChangeHandler",
      value: function deregisterValidationAttributeChangeHandler(observer) {}
      /**
       * Returns an object representing the native text input element, with a
       * similar API shape. The object returned should include the value, disabled
       * and badInput properties, as well as the checkValidity() function. We never
       * alter the value within our code, however we do update the disabled
       * property, so if you choose to duck-type the return value for this method
       * in your implementation it's important to keep this in mind. Also note that
       * this method can return null, which the foundation will handle gracefully.
       * @return {?Element|?NativeInputType}
       */

    }, {
      key: "getNativeInput",
      value: function getNativeInput() {}
      /**
       * Returns true if the textfield is focused.
       * We achieve this via `document.activeElement === this.root_`.
       * @return {boolean}
       */

    }, {
      key: "isFocused",
      value: function isFocused() {}
      /**
       * Activates the line ripple.
       */

    }, {
      key: "activateLineRipple",
      value: function activateLineRipple() {}
      /**
       * Deactivates the line ripple.
       */

    }, {
      key: "deactivateLineRipple",
      value: function deactivateLineRipple() {}
      /**
       * Sets the transform origin of the line ripple.
       * @param {number} normalizedX
       */

    }, {
      key: "setLineRippleTransformOrigin",
      value: function setLineRippleTransformOrigin(normalizedX) {}
      /**
       * Only implement if label exists.
       * Shakes label if shouldShake is true.
       * @param {boolean} shouldShake
       */

    }, {
      key: "shakeLabel",
      value: function shakeLabel(shouldShake) {}
      /**
       * Only implement if label exists.
       * Floats the label above the input element if shouldFloat is true.
       * @param {boolean} shouldFloat
       */

    }, {
      key: "floatLabel",
      value: function floatLabel(shouldFloat) {}
      /**
       * Returns true if label element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasLabel",
      value: function hasLabel() {}
      /**
       * Only implement if label exists.
       * Returns width of label in pixels.
       * @return {number}
       */

    }, {
      key: "getLabelWidth",
      value: function getLabelWidth() {}
      /**
       * Returns true if outline element exists, false if it doesn't.
       * @return {boolean}
       */

    }, {
      key: "hasOutline",
      value: function hasOutline() {}
      /**
       * Only implement if outline element exists.
       * @param {number} labelWidth
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(labelWidth) {}
      /**
       * Only implement if outline element exists.
       * Closes notch in outline element.
       */

    }, {
      key: "closeOutline",
      value: function closeOutline() {}
    }]);

    return MDCTextFieldAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var strings$t = {
    ARIA_CONTROLS: 'aria-controls',
    INPUT_SELECTOR: '.mdc-text-field__input',
    LABEL_SELECTOR: '.mdc-floating-label',
    ICON_SELECTOR: '.mdc-text-field__icon',
    OUTLINE_SELECTOR: '.mdc-notched-outline',
    LINE_RIPPLE_SELECTOR: '.mdc-line-ripple'
  };
  /** @enum {string} */

  var cssClasses$r = {
    ROOT: 'mdc-text-field',
    DISABLED: 'mdc-text-field--disabled',
    DENSE: 'mdc-text-field--dense',
    FOCUSED: 'mdc-text-field--focused',
    INVALID: 'mdc-text-field--invalid',
    TEXTAREA: 'mdc-text-field--textarea',
    OUTLINED: 'mdc-text-field--outlined',
    WITH_LEADING_ICON: 'mdc-text-field--with-leading-icon'
  };
  /** @enum {number} */

  var numbers$9 = {
    LABEL_SCALE: 0.75,
    DENSE_LABEL_SCALE: 0.923
  }; // whitelist based off of https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5/Constraint_validation
  // under section: `Validation-related attributes`

  var VALIDATION_ATTR_WHITELIST = ['pattern', 'min', 'max', 'required', 'step', 'minlength', 'maxlength']; // Label should always float for these types as they show some UI even if value is empty.

  var ALWAYS_FLOAT_TYPES = ['color', 'date', 'datetime-local', 'month', 'range', 'time', 'week'];

  /**
   * @extends {MDCFoundation<!MDCTextFieldAdapter>}
   * @final
   */

  var MDCTextFieldFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTextFieldFoundation, _MDCFoundation);

    _createClass(MDCTextFieldFoundation, [{
      key: "shouldShake",

      /** @return {boolean} */
      get: function get() {
        return !this.isValid() && !this.isFocused_ && !!this.getValue();
      }
      /**
       * @return {boolean}
       * @private
       */

    }, {
      key: "shouldAlwaysFloat_",
      get: function get() {
        var type = this.getNativeInput_().type;
        return ALWAYS_FLOAT_TYPES.indexOf(type) >= 0;
      }
      /** @return {boolean} */

    }, {
      key: "shouldFloat",
      get: function get() {
        return this.shouldAlwaysFloat_ || this.isFocused_ || !!this.getValue() || this.isBadInput_();
      }
      /**
       * {@see MDCTextFieldAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTextFieldAdapter}
       */

    }], [{
      key: "cssClasses",

      /** @return enum {string} */
      get: function get() {
        return cssClasses$r;
      }
      /** @return enum {string} */

    }, {
      key: "strings",
      get: function get() {
        return strings$t;
      }
      /** @return enum {string} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$9;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTextFieldAdapter} */
          {
            addClass: function addClass() {},
            removeClass: function removeClass() {},
            hasClass: function hasClass() {},
            registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler() {},
            deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler() {},
            registerInputInteractionHandler: function registerInputInteractionHandler() {},
            deregisterInputInteractionHandler: function deregisterInputInteractionHandler() {},
            registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler() {},
            deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler() {},
            getNativeInput: function getNativeInput() {},
            isFocused: function isFocused() {},
            activateLineRipple: function activateLineRipple() {},
            deactivateLineRipple: function deactivateLineRipple() {},
            setLineRippleTransformOrigin: function setLineRippleTransformOrigin() {},
            shakeLabel: function shakeLabel() {},
            floatLabel: function floatLabel() {},
            hasLabel: function hasLabel() {},
            getLabelWidth: function getLabelWidth() {},
            hasOutline: function hasOutline() {},
            notchOutline: function notchOutline() {},
            closeOutline: function closeOutline() {}
          }
        );
      }
      /**
       * @param {!MDCTextFieldAdapter} adapter
       * @param {!FoundationMapType=} foundationMap Map from subcomponent names to their subfoundations.
       */

    }]);

    function MDCTextFieldFoundation(adapter) {
      var _this;

      var foundationMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] :
      /** @type {!FoundationMapType} */
      {};

      _classCallCheck(this, MDCTextFieldFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTextFieldFoundation).call(this, _extends(MDCTextFieldFoundation.defaultAdapter, adapter)));
      /** @type {!MDCTextFieldHelperTextFoundation|undefined} */

      _this.helperText_ = foundationMap.helperText;
      /** @type {!MDCTextFieldIconFoundation|undefined} */

      _this.leadingIcon_ = foundationMap.leadingIcon;
      /** @type {!MDCTextFieldIconFoundation|undefined} */

      _this.trailingIcon_ = foundationMap.trailingIcon;
      /** @private {boolean} */

      _this.isFocused_ = false;
      /** @private {boolean} */

      _this.receivedUserInput_ = false;
      /** @private {boolean} */

      _this.useCustomValidityChecking_ = false;
      /** @private {boolean} */

      _this.isValid_ = true;
      /** @private {boolean} */

      _this.useNativeValidation_ = true;
      /** @private {function(): undefined} */

      _this.inputFocusHandler_ = function () {
        return _this.activateFocus();
      };
      /** @private {function(): undefined} */


      _this.inputBlurHandler_ = function () {
        return _this.deactivateFocus();
      };
      /** @private {function(): undefined} */


      _this.inputInputHandler_ = function () {
        return _this.autoCompleteFocus();
      };
      /** @private {function(!Event): undefined} */


      _this.setPointerXOffset_ = function (evt) {
        return _this.setTransformOrigin(evt);
      };
      /** @private {function(!Event): undefined} */


      _this.textFieldInteractionHandler_ = function () {
        return _this.handleTextFieldInteraction();
      };
      /** @private {function(!Array): undefined} */


      _this.validationAttributeChangeHandler_ = function (attributesList) {
        return _this.handleValidationAttributeChange(attributesList);
      };
      /** @private {!MutationObserver} */


      _this.validationObserver_;
      return _this;
    }

    _createClass(MDCTextFieldFoundation, [{
      key: "init",
      value: function init() {
        var _this2 = this;

        if (this.adapter_.isFocused()) {
          this.inputFocusHandler_();
        } else if (this.adapter_.hasLabel() && this.shouldFloat) {
          this.notchOutline(true);
          this.adapter_.floatLabel(true);
        }

        this.adapter_.registerInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.registerInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.registerInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this2.adapter_.registerInputInteractionHandler(evtType, _this2.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this2.adapter_.registerTextFieldInteractionHandler(evtType, _this2.textFieldInteractionHandler_);
        });
        this.validationObserver_ = this.adapter_.registerValidationAttributeChangeHandler(this.validationAttributeChangeHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        var _this3 = this;

        this.adapter_.deregisterInputInteractionHandler('focus', this.inputFocusHandler_);
        this.adapter_.deregisterInputInteractionHandler('blur', this.inputBlurHandler_);
        this.adapter_.deregisterInputInteractionHandler('input', this.inputInputHandler_);
        ['mousedown', 'touchstart'].forEach(function (evtType) {
          _this3.adapter_.deregisterInputInteractionHandler(evtType, _this3.setPointerXOffset_);
        });
        ['click', 'keydown'].forEach(function (evtType) {
          _this3.adapter_.deregisterTextFieldInteractionHandler(evtType, _this3.textFieldInteractionHandler_);
        });
        this.adapter_.deregisterValidationAttributeChangeHandler(this.validationObserver_);
      }
      /**
       * Handles user interactions with the Text Field.
       */

    }, {
      key: "handleTextFieldInteraction",
      value: function handleTextFieldInteraction() {
        if (this.adapter_.getNativeInput().disabled) {
          return;
        }

        this.receivedUserInput_ = true;
      }
      /**
       * Handles validation attribute changes
       * @param {!Array<string>} attributesList
       */

    }, {
      key: "handleValidationAttributeChange",
      value: function handleValidationAttributeChange(attributesList) {
        var _this4 = this;

        attributesList.some(function (attributeName) {
          if (VALIDATION_ATTR_WHITELIST.indexOf(attributeName) > -1) {
            _this4.styleValidity_(true);

            return true;
          }
        });
      }
      /**
       * Opens/closes the notched outline.
       * @param {boolean} openNotch
       */

    }, {
      key: "notchOutline",
      value: function notchOutline(openNotch) {
        if (!this.adapter_.hasOutline()) {
          return;
        }

        if (openNotch) {
          var isDense = this.adapter_.hasClass(cssClasses$r.DENSE);
          var labelScale = isDense ? numbers$9.DENSE_LABEL_SCALE : numbers$9.LABEL_SCALE;
          var labelWidth = this.adapter_.getLabelWidth() * labelScale;
          this.adapter_.notchOutline(labelWidth);
        } else {
          this.adapter_.closeOutline();
        }
      }
      /**
       * Activates the text field focus state.
       */

    }, {
      key: "activateFocus",
      value: function activateFocus() {
        this.isFocused_ = true;
        this.styleFocused_(this.isFocused_);
        this.adapter_.activateLineRipple();

        if (this.adapter_.hasLabel()) {
          this.notchOutline(this.shouldFloat);
          this.adapter_.floatLabel(this.shouldFloat);
          this.adapter_.shakeLabel(this.shouldShake);
        }

        if (this.helperText_) {
          this.helperText_.showToScreenReader();
        }
      }
      /**
       * Sets the line ripple's transform origin, so that the line ripple activate
       * animation will animate out from the user's click location.
       * @param {!Event} evt
       */

    }, {
      key: "setTransformOrigin",
      value: function setTransformOrigin(evt) {
        var targetEvent;

        if (evt.touches) {
          targetEvent = evt.touches[0];
        } else {
          targetEvent = evt;
        }

        var targetClientRect = targetEvent.target.getBoundingClientRect();
        var normalizedX = targetEvent.clientX - targetClientRect.left;
        this.adapter_.setLineRippleTransformOrigin(normalizedX);
      }
      /**
       * Activates the Text Field's focus state in cases when the input value
       * changes without user input (e.g. programatically).
       */

    }, {
      key: "autoCompleteFocus",
      value: function autoCompleteFocus() {
        if (!this.receivedUserInput_) {
          this.activateFocus();
        }
      }
      /**
       * Deactivates the Text Field's focus state.
       */

    }, {
      key: "deactivateFocus",
      value: function deactivateFocus() {
        this.isFocused_ = false;
        this.adapter_.deactivateLineRipple();
        var isValid = this.isValid();
        this.styleValidity_(isValid);
        this.styleFocused_(this.isFocused_);

        if (this.adapter_.hasLabel()) {
          this.notchOutline(this.shouldFloat);
          this.adapter_.floatLabel(this.shouldFloat);
          this.adapter_.shakeLabel(this.shouldShake);
        }

        if (!this.shouldFloat) {
          this.receivedUserInput_ = false;
        }
      }
      /**
       * @return {string} The value of the input Element.
       */

    }, {
      key: "getValue",
      value: function getValue() {
        return this.getNativeInput_().value;
      }
      /**
       * @param {string} value The value to set on the input Element.
       */

    }, {
      key: "setValue",
      value: function setValue(value) {
        // Prevent Safari from moving the caret to the end of the input when the value has not changed.
        if (this.getValue() !== value) {
          this.getNativeInput_().value = value;
        }

        var isValid = this.isValid();
        this.styleValidity_(isValid);

        if (this.adapter_.hasLabel()) {
          this.notchOutline(this.shouldFloat);
          this.adapter_.floatLabel(this.shouldFloat);
          this.adapter_.shakeLabel(this.shouldShake);
        }
      }
      /**
       * @return {boolean} If a custom validity is set, returns that value.
       *     Otherwise, returns the result of native validity checks.
       */

    }, {
      key: "isValid",
      value: function isValid() {
        return this.useNativeValidation_ ? this.isNativeInputValid_() : this.isValid_;
      }
      /**
       * @param {boolean} isValid Sets the validity state of the Text Field.
       */

    }, {
      key: "setValid",
      value: function setValid(isValid) {
        this.isValid_ = isValid;
        this.styleValidity_(isValid);
        var shouldShake = !isValid && !this.isFocused_;

        if (this.adapter_.hasLabel()) {
          this.adapter_.shakeLabel(shouldShake);
        }
      }
      /**
       * Enables or disables the use of native validation. Use this for custom validation.
       * @param {boolean} useNativeValidation Set this to false to ignore native input validation.
       */

    }, {
      key: "setUseNativeValidation",
      value: function setUseNativeValidation(useNativeValidation) {
        this.useNativeValidation_ = useNativeValidation;
      }
      /**
       * @return {boolean} True if the Text Field is disabled.
       */

    }, {
      key: "isDisabled",
      value: function isDisabled() {
        return this.getNativeInput_().disabled;
      }
      /**
       * @param {boolean} disabled Sets the text-field disabled or enabled.
       */

    }, {
      key: "setDisabled",
      value: function setDisabled(disabled) {
        this.getNativeInput_().disabled = disabled;
        this.styleDisabled_(disabled);
      }
      /**
       * @param {string} content Sets the content of the helper text.
       */

    }, {
      key: "setHelperTextContent",
      value: function setHelperTextContent(content) {
        if (this.helperText_) {
          this.helperText_.setContent(content);
        }
      }
      /**
       * Sets the aria label of the leading icon.
       * @param {string} label
       */

    }, {
      key: "setLeadingIconAriaLabel",
      value: function setLeadingIconAriaLabel(label) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setAriaLabel(label);
        }
      }
      /**
       * Sets the text content of the leading icon.
       * @param {string} content
       */

    }, {
      key: "setLeadingIconContent",
      value: function setLeadingIconContent(content) {
        if (this.leadingIcon_) {
          this.leadingIcon_.setContent(content);
        }
      }
      /**
       * Sets the aria label of the trailing icon.
       * @param {string} label
       */

    }, {
      key: "setTrailingIconAriaLabel",
      value: function setTrailingIconAriaLabel(label) {
        if (this.trailingIcon_) {
          this.trailingIcon_.setAriaLabel(label);
        }
      }
      /**
       * Sets the text content of the trailing icon.
       * @param {string} content
       */

    }, {
      key: "setTrailingIconContent",
      value: function setTrailingIconContent(content) {
        if (this.trailingIcon_) {
          this.trailingIcon_.setContent(content);
        }
      }
      /**
       * @return {boolean} True if the Text Field input fails in converting the
       *     user-supplied value.
       * @private
       */

    }, {
      key: "isBadInput_",
      value: function isBadInput_() {
        return this.getNativeInput_().validity.badInput;
      }
      /**
       * @return {boolean} The result of native validity checking
       *     (ValidityState.valid).
       */

    }, {
      key: "isNativeInputValid_",
      value: function isNativeInputValid_() {
        return this.getNativeInput_().validity.valid;
      }
      /**
       * Styles the component based on the validity state.
       * @param {boolean} isValid
       * @private
       */

    }, {
      key: "styleValidity_",
      value: function styleValidity_(isValid) {
        var INVALID = MDCTextFieldFoundation.cssClasses.INVALID;

        if (isValid) {
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.addClass(INVALID);
        }

        if (this.helperText_) {
          this.helperText_.setValidity(isValid);
        }
      }
      /**
       * Styles the component based on the focused state.
       * @param {boolean} isFocused
       * @private
       */

    }, {
      key: "styleFocused_",
      value: function styleFocused_(isFocused) {
        var FOCUSED = MDCTextFieldFoundation.cssClasses.FOCUSED;

        if (isFocused) {
          this.adapter_.addClass(FOCUSED);
        } else {
          this.adapter_.removeClass(FOCUSED);
        }
      }
      /**
       * Styles the component based on the disabled state.
       * @param {boolean} isDisabled
       * @private
       */

    }, {
      key: "styleDisabled_",
      value: function styleDisabled_(isDisabled) {
        var _MDCTextFieldFoundati = MDCTextFieldFoundation.cssClasses,
            DISABLED = _MDCTextFieldFoundati.DISABLED,
            INVALID = _MDCTextFieldFoundati.INVALID;

        if (isDisabled) {
          this.adapter_.addClass(DISABLED);
          this.adapter_.removeClass(INVALID);
        } else {
          this.adapter_.removeClass(DISABLED);
        }

        if (this.leadingIcon_) {
          this.leadingIcon_.setDisabled(isDisabled);
        }

        if (this.trailingIcon_) {
          this.trailingIcon_.setDisabled(isDisabled);
        }
      }
      /**
       * @return {!Element|!NativeInputType} The native text input from the
       * host environment, or a dummy if none exists.
       * @private
       */

    }, {
      key: "getNativeInput_",
      value: function getNativeInput_() {
        return this.adapter_.getNativeInput() ||
        /** @type {!NativeInputType} */
        {
          value: '',
          disabled: false,
          validity: {
            badInput: false,
            valid: true
          }
        };
      }
    }]);

    return MDCTextFieldFoundation;
  }(MDCFoundation);

  var script$Y = {
    name: 'mdc-textfield',
    mixins: [CustomElementMixin, DispatchFocusMixin, VMAUniqueIdMixin],
    inheritAttrs: false,
    model: {
      prop: 'value',
      event: 'model'
    },
    props: {
      value: [String, Number],
      type: {
        type: String,
        default: 'text',
        validator: function validator(value) {
          return ['text', 'email', 'search', 'password', 'tel', 'url', 'number'].indexOf(value) !== -1;
        }
      },
      dense: Boolean,
      label: String,
      helptext: String,
      helptextPersistent: Boolean,
      helptextValidation: Boolean,
      outline: Boolean,
      disabled: Boolean,
      required: Boolean,
      valid: {
        type: Boolean,
        default: undefined
      },
      fullwidth: Boolean,
      multiline: Boolean,
      leadingIcon: [String, Array, Object],
      trailingNonInteractive: Boolean,
      leadingNonInteractive: Boolean,
      trailingIcon: [String, Array, Object],
      size: {
        type: [Number, String],
        default: 20
      },
      minlength: {
        type: [Number, String],
        default: undefined
      },
      maxlength: {
        type: [Number, String],
        default: undefined
      },
      rows: {
        type: [Number, String],
        default: 8
      },
      cols: {
        type: [Number, String],
        default: 40
      },
      id: {
        type: String
      }
    },
    data: function data() {
      return {
        text: this.value,
        rootClasses: {
          'mdc-textfield': true,
          'mdc-text-field': true,
          'mdc-text-field--upgraded': true,
          'mdc-text-field--disabled': this.disabled,
          'mdc-text-field--dense': this.dense,
          'mdc-text-field--fullwidth': this.fullwidth,
          'mdc-text-field--textarea': this.multiline,
          'mdc-text-field--outlined': !this.fullwidth && this.outline
        },
        inputClasses: {
          'mdc-text-field__input': true
        },
        labelClasses: {
          'mdc-floating-label': true
        },
        lineRippleClasses: {
          'mdc-line-ripple': true
        },
        lineRippleStyles: {},
        helpClasses: {
          'mdc-text-field-helper-text': true,
          'mdc-text-field-helper-text--persistent': this.helptextPersistent,
          'mdc-text-field-helper-text--validation-msg': this.helptextValidation
        },
        outlineClasses: {},
        notchStyles: {}
      };
    },
    computed: {
      leadingTabindex: function leadingTabindex() {
        if (!this.leadingNonInteractive) {
          return '0';
        }
      },
      leadingRole: function leadingRole() {
        if (!this.leadingNonInteractive) {
          return 'button';
        }
      },
      trailingTabindex: function trailingTabindex() {
        if (!this.trailingNonInteractive) {
          return '0';
        }
      },
      trailingRole: function trailingRole() {
        if (!this.trailingNonInteractive) {
          return 'button';
        }
      },
      inputPlaceHolder: function inputPlaceHolder() {
        return this.fullwidth ? this.label : undefined;
      },
      inputAriaControls: function inputAriaControls() {
        return this.help ? 'help-' + this.vma_uid_ : undefined;
      },
      hasLabel: function hasLabel() {
        return !this.fullwidth && !this.outline && this.label;
      },
      hasOutlineLabel: function hasOutlineLabel() {
        return this.hasOutline && this.label;
      },
      hasOutline: function hasOutline() {
        return !this.fullwidth && this.outline;
      },
      hasLineRipple: function hasLineRipple() {
        return !this.hasOutline && !this.multiline;
      },
      hasLeadingIcon: function hasLeadingIcon() {
        if (this.leadingIcon || this.$slots['leading-icon']) {
          return this.leadingIcon ? extractIconProp(this.leadingIcon) : {};
        }

        return false;
      },
      hasTrailingIcon: function hasTrailingIcon() {
        if (this.trailingIcon || this.$slots['trailing-icon']) {
          return this.trailingIcon ? extractIconProp(this.trailingIcon) : {};
        }

        return false;
      },
      labelClassesUpgraded: function labelClassesUpgraded() {
        return _extends(this.labelClasses, {
          'mdc-floating-label--float-above': this.value
        });
      }
    },
    watch: {
      disabled: function disabled() {
        this.foundation && this.foundation.setDisabled(this.disabled);
      },
      required: function required() {
        this.$refs.input && (this.$refs.input.required = this.required);
      },
      valid: function valid() {
        if (typeof this.valid !== 'undefined') {
          this.foundation && this.foundation.setValid(this.valid);
        }
      },
      dense: function dense() {
        this.$set(this.rootClasses, 'mdc-text-field--dense', this.dense);
      },
      helptextPersistent: function helptextPersistent() {
        this.helperTextFoundation && this.helperTextFoundation.setPersistent(this.helptextPersistent);
      },
      helptextValidation: function helptextValidation() {
        this.helperTextFoundation && this.helperTextFoundation.setValidation(this.helptextValidation);
      },
      value: function value(_value) {
        if (this.foundation) {
          if (_value !== this.foundation.getValue()) {
            this.foundation.setValue(_value);
          }
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.$refs.lineRipple) {
        this.lineRippleFoundation = new MDCLineRippleFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.lineRippleClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.lineRippleClasses, className);
          },
          hasClass: function hasClass(className) {
            _this.$refs.lineRipple.classList.contains(className);
          },
          setStyle: function setStyle(name, value) {
            _this.$set(_this.lineRippleStyles, name, value);
          },
          registerEventHandler: function registerEventHandler(evtType, handler) {
            _this.$refs.lineRipple.addEventListener(evtType, handler);
          },
          deregisterEventHandler: function deregisterEventHandler(evtType, handler) {
            _this.$refs.lineRipple.removeEventListener(evtType, handler);
          }
        });
        this.lineRippleFoundation.init();
      }

      if (this.$refs.help) {
        this.helperTextFoundation = new MDCTextFieldHelperTextFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.helpClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.helpClasses, className);
          },
          hasClass: function hasClass(className) {
            return _this.$refs.help.classList.contains(className);
          },
          setAttr: function setAttr(name, value) {
            _this.$refs.help.setAttribute(name, value);
          },
          removeAttr: function removeAttr(name) {
            _this.$refs.help.removeAttribute(name);
          },
          setContent: function setContent()
          /*content*/
          {// help text get's updated from {{helptext}}
            // this.$refs.help.textContent = content;
          }
        });
        this.helperTextFoundation.init();
      }

      if (this.hasLeadingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-leading-icon', true);
        this.leadingIconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.leadingIcon.setAttribute(attr, value);
          },
          getAttr: function getAttr(attr) {
            return _this.$refs.leadingIcon.getAttribute(attr);
          },
          removeAttr: function removeAttr(attr) {
            return _this.$refs.leadingIcon.removeAttribute(attr);
          },
          setContent: function setContent()
          /*content*/
          {// icon text get's updated from {{{{ hasTrailingIcon.content }}}}
            // this.$refs.icon.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.leadingIcon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.leadingIcon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('leadingicon-action');
          }
        });
        this.leadingIconFoundation.init();
      }

      if (this.hasTrailingIcon) {
        this.$set(this.rootClasses, 'mdc-text-field--with-trailing-icon', true);
        this.trailingIconFoundation = new MDCTextFieldIconFoundation({
          setAttr: function setAttr(attr, value) {
            return _this.$refs.trailingIcon.setAttribute(attr, value);
          },
          getAttr: function getAttr(attr) {
            return _this.$refs.trailingIcon.getAttribute(attr);
          },
          removeAttr: function removeAttr(attr) {
            return _this.$refs.trailingIcon.removeAttribute(attr);
          },
          setContent: function setContent()
          /*content*/
          {// icon text get's updated from {{{{ hasTrailingIcon.content }}}}
            // this.$refs.icon.textContent = content;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            _this.$refs.trailingIcon.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            _this.$refs.trailingIcon.removeEventListener(evtType, handler);
          },
          notifyIconAction: function notifyIconAction() {
            return _this.$emit('trainlingicon-action');
          }
        });
        this.trailingIconFoundation.init();
      }

      if (this.$refs.label || this.$refs['label-outline']) {
        var label = this.$refs.label || this.$refs['label-outline'];
        this.labelFoundation = new MDCFloatingLabelFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.labelClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.labelClasses, className);
          },
          getWidth: function getWidth() {
            return label.offsetWidth;
          },
          registerInteractionHandler: function registerInteractionHandler(evtType, handler) {
            label.addEventListener(evtType, handler);
          },
          deregisterInteractionHandler: function deregisterInteractionHandler(evtType, handler) {
            label.removeEventListener(evtType, handler);
          }
        });
        this.labelFoundation.init();
      }

      if (this.$refs.outline) {
        this.outlineFoundation = new MDCNotchedOutlineFoundation({
          addClass: function addClass(className) {
            _this.$set(_this.outlineClasses, className, true);
          },
          removeClass: function removeClass(className) {
            _this.$delete(_this.outlineClasses, className);
          },
          setNotchWidthProperty: function setNotchWidthProperty(width) {
            return _this.$set(_this.notchStyles, 'width', width > 0 ? width + 'px' : '0');
          }
        });
        this.outlineFoundation.init();
      }

      this.foundation = new MDCTextFieldFoundation(_extends({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          _this.$refs.root.classList.contains(className);
        },
        registerTextFieldInteractionHandler: function registerTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.addEventListener(evtType, handler);
        },
        deregisterTextFieldInteractionHandler: function deregisterTextFieldInteractionHandler(evtType, handler) {
          _this.$refs.root.removeEventListener(evtType, handler);
        },
        isFocused: function isFocused() {
          return document.activeElement === _this.$refs.input;
        },
        isRtl: function isRtl() {
          return window.getComputedStyle(_this.$refs.root).getPropertyValue('direction') === 'rtl';
        },
        registerValidationAttributeChangeHandler: function registerValidationAttributeChangeHandler(handler) {
          var getAttributesList = function getAttributesList(mutationsList) {
            return mutationsList.map(function (mutation) {
              return mutation.attributeName;
            });
          };

          var observer = new MutationObserver(function (mutationsList) {
            return handler(getAttributesList(mutationsList));
          });
          var targetNode = _this.$refs.input;
          var config = {
            attributes: true
          };
          observer.observe(targetNode, config);
          return observer;
        },
        deregisterValidationAttributeChangeHandler: function deregisterValidationAttributeChangeHandler(observer) {
          observer.disconnect();
        }
      }, this.getInputAdapterMethods(), this.getLabelAdapterMethods(), this.getLineRippleAdapterMethods(), this.getOutlineAdapterMethods()), {
        helperText: this.helperTextFoundation,
        leadingIcon: this.leadingIconFoundation,
        trailingIcon: this.trailingFoundation
      });
      this.foundation.init();
      this.foundation.setValue(this.value);
      this.foundation.setDisabled(this.disabled);
      this.$refs.input && (this.$refs.input.required = this.required);

      if (typeof this.valid !== 'undefined') {
        this.foundation.setValid(this.valid);
      }

      if (this.textbox) {
        this.ripple = new RippleBase(this);
        this.ripple.init();
      }
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.lineRippleFoundation && this.lineRippleFoundation.destroy();
      this.helperTextFoundation && this.helperTextFoundation.destroy();
      this.leadingIconFoundation && this.leadingIconFoundation.destroy();
      this.trailingIconFoundation && this.trailingIconFoundation.destroy();
      this.labelFoundation && this.labelFoundation.destroy();
      this.outlineFoundation && this.outlineFoundation.destroy();
      this.ripple && this.ripple.destroy();
    },
    methods: {
      getInputAdapterMethods: function getInputAdapterMethods() {
        var _this2 = this;

        return {
          registerInputInteractionHandler: function registerInputInteractionHandler(evtType, handler) {
            _this2.$refs.input.addEventListener(evtType, handler, applyPassive());
          },
          deregisterInputInteractionHandler: function deregisterInputInteractionHandler(evtType, handler) {
            _this2.$refs.input.removeEventListener(evtType, handler, applyPassive());
          },
          getNativeInput: function getNativeInput() {
            return _this2.$refs.input;
          }
        };
      },
      getLabelAdapterMethods: function getLabelAdapterMethods() {
        var _this3 = this;

        return {
          shakeLabel: function shakeLabel(shouldShake) {
            _this3.labelFoundation.shake(shouldShake);
          },
          floatLabel: function floatLabel(shouldFloat) {
            _this3.labelFoundation.float(shouldFloat);
          },
          hasLabel: function hasLabel() {
            return !!_this3.$refs.label || !!_this3.$refs['label-outline'];
          },
          getLabelWidth: function getLabelWidth() {
            return _this3.labelFoundation.getWidth();
          }
        };
      },
      getLineRippleAdapterMethods: function getLineRippleAdapterMethods() {
        var _this4 = this;

        return {
          deactivateLineRipple: function deactivateLineRipple() {
            if (_this4.lineRippleFoundation) {
              _this4.lineRippleFoundation.deactivate();
            }
          },
          activateLineRipple: function activateLineRipple() {
            if (_this4.lineRippleFoundation) {
              _this4.lineRippleFoundation.activate();
            }
          },
          setLineRippleTransformOrigin: function setLineRippleTransformOrigin(normalizedX) {
            if (_this4.lineRippleFoundation) {
              _this4.lineRippleFoundation.setRippleCenter(normalizedX);
            }
          }
        };
      },
      getOutlineAdapterMethods: function getOutlineAdapterMethods() {
        var _this5 = this;

        return {
          hasOutline: function hasOutline() {
            return !!_this5.hasOutline;
          },
          notchOutline: function notchOutline(notchWidth, isRtl) {
            return _this5.outlineFoundation.notch(notchWidth, isRtl);
          },
          closeOutline: function closeOutline() {
            return _this5.outlineFoundation.closeNotch();
          }
        };
      },
      updateValue: function updateValue(value) {
        this.$emit('model', value);
      },
      focus: function focus() {
        this.$refs.input && this.$refs.input.focus();
      },
      blur: function blur() {
        this.$refs.input && this.$refs.input.blur();
      }
    }
  };

  /* script */
  const __vue_script__$Y = script$Y;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$Y.__file = "/ddata/extra/vma/components/textfield/mdc-textfield.vue";

  /* template */
  var __vue_render__$V = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      {
        staticClass: "mdc-textfield-wrapper",
        style: { width: _vm.fullwidth ? "100%" : undefined },
        attrs: { id: _vm.id }
      },
      [
        _c("div", { ref: "root", class: _vm.rootClasses }, [
          !!_vm.hasLeadingIcon
            ? _c(
                "i",
                {
                  ref: "leadingIcon",
                  staticClass: "mdc-text-field__icon",
                  class: _vm.hasLeadingIcon.classes,
                  attrs: { tabindex: _vm.leadingTabindex, role: _vm.leadingRole }
                },
                [
                  _vm._t("leading-icon", [
                    _vm._v(_vm._s(_vm.hasLeadingIcon.content))
                  ])
                ],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.multiline
            ? _c(
                "textarea",
                _vm._g(
                  _vm._b(
                    {
                      ref: "input",
                      class: _vm.inputClasses,
                      attrs: {
                        id: _vm.vma_uid_,
                        minlength: _vm.minlength,
                        maxlength: _vm.maxlength,
                        placeholder: _vm.inputPlaceHolder,
                        "aria-label": _vm.inputPlaceHolder,
                        "aria-controls": _vm.inputAriaControls,
                        rows: _vm.rows,
                        cols: _vm.cols
                      },
                      on: {
                        input: function($event) {
                          _vm.updateValue($event.target.value);
                        }
                      }
                    },
                    "textarea",
                    _vm.$attrs,
                    false
                  ),
                  _vm.$listeners
                )
              )
            : _c(
                "input",
                _vm._g(
                  _vm._b(
                    {
                      ref: "input",
                      class: _vm.inputClasses,
                      attrs: {
                        id: _vm.vma_uid_,
                        type: _vm.type,
                        minlength: _vm.minlength,
                        maxlength: _vm.maxlength,
                        placeholder: _vm.inputPlaceHolder,
                        "aria-label": _vm.inputPlaceHolder,
                        "aria-controls": _vm.inputAriaControls
                      },
                      on: {
                        input: function($event) {
                          _vm.updateValue($event.target.value);
                        }
                      }
                    },
                    "input",
                    _vm.$attrs,
                    false
                  ),
                  _vm.$listeners
                )
              ),
          _vm._v(" "),
          _vm.hasLabel
            ? _c(
                "label",
                {
                  ref: "label",
                  class: _vm.labelClassesUpgraded,
                  attrs: { for: _vm.vma_uid_ }
                },
                [_vm._v("\n      " + _vm._s(_vm.label) + "\n    ")]
              )
            : _vm._e(),
          _vm._v(" "),
          !!_vm.hasTrailingIcon
            ? _c(
                "i",
                {
                  ref: "trailingIcon",
                  staticClass: "mdc-text-field__icon",
                  class: _vm.hasTrailingIcon.classes,
                  attrs: {
                    tabindex: _vm.trailingTabindex,
                    role: _vm.trailingRole
                  }
                },
                [
                  _vm._t("trailing-icon", [
                    _vm._v(_vm._s(_vm.hasTrailingIcon.content))
                  ])
                ],
                2
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.hasOutline
            ? _c(
                "div",
                {
                  ref: "outline",
                  staticClass: "mdc-notched-outline",
                  class: _vm.outlineClasses
                },
                [
                  _c("div", { staticClass: "mdc-notched-outline__leading" }),
                  _vm._v(" "),
                  _c(
                    "div",
                    {
                      staticClass: "mdc-notched-outline__notch",
                      style: _vm.notchStyles
                    },
                    [
                      _vm.hasOutlineLabel
                        ? _c(
                            "label",
                            {
                              ref: "label-outline",
                              class: _vm.labelClassesUpgraded,
                              attrs: { for: _vm.vma_uid_ }
                            },
                            [
                              _vm._v(
                                "\n          " + _vm._s(_vm.label) + "\n        "
                              )
                            ]
                          )
                        : _vm._e(),
                      _vm._v(" "),
                      _c("label", { staticClass: "mdc-floating-label" })
                    ]
                  ),
                  _vm._v(" "),
                  _c("div", { staticClass: "mdc-notched-outline__trailing" })
                ]
              )
            : _vm._e(),
          _vm._v(" "),
          _vm.hasLineRipple
            ? _c("div", {
                ref: "lineRipple",
                class: _vm.lineRippleClasses,
                style: _vm.lineRippleStyles
              })
            : _vm._e()
        ]),
        _vm._v(" "),
        _vm.helptext
          ? _c(
              "p",
              {
                ref: "help",
                class: _vm.helpClasses,
                attrs: { id: "help-" + _vm.vma_uid_, "aria-hidden": "true" }
              },
              [_vm._v("\n    " + _vm._s(_vm.helptext) + "\n  ")]
            )
          : _vm._e()
      ]
    )
  };
  var __vue_staticRenderFns__$V = [];
  __vue_render__$V._withStripped = true;

    /* style */
    const __vue_inject_styles__$Y = undefined;
    /* scoped */
    const __vue_scope_id__$Y = undefined;
    /* module identifier */
    const __vue_module_identifier__$Y = undefined;
    /* functional template */
    const __vue_is_functional_template__$Y = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTextField = normalizeComponent(
      { render: __vue_render__$V, staticRenderFns: __vue_staticRenderFns__$V },
      __vue_inject_styles__$Y,
      __vue_script__$Y,
      __vue_scope_id__$Y,
      __vue_is_functional_template__$Y,
      __vue_module_identifier__$Y,
      undefined,
      undefined
    );

  var VueMDCTextfield = BasePlugin({
    mdcTextField: mdcTextField
  });

  //
  var THEME_COLORS = ['primary', 'secondary', 'background', 'primary-light', 'secondary-light', 'secondary-dark', 'primary-dark'];
  var THEME_STYLES = ['text-primary', 'text-secondary', 'text-hint', 'text-icon', 'text-disabled'];
  var script$Z = {
    name: 'mdc-theme',
    components: {
      CustomElement: CustomElement
    },
    props: {
      tag: {
        type: String,
        default: 'div'
      },
      color: String,
      background: String
    },
    computed: {
      classes: function classes() {
        var classes = {};

        if (this.color && THEME_COLORS.indexOf(this.color) !== -1) {
          classes["mdc-theme--".concat(this.color)] = true;
        }

        if (this.background && THEME_COLORS.indexOf(this.background) !== -1) {
          classes["mdc-theme--".concat(this.background, "-bg")] = true;

          if (this.color && THEME_STYLES.indexOf(this.color) !== -1) {
            classes["mdc-theme--".concat(this.color, "-on-").concat(this.background)] = true;
          }
        }

        return classes;
      }
    }
  };

  /* script */
  const __vue_script__$Z = script$Z;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$Z.__file = "/ddata/extra/vma/components/theme/mdc-theme.vue";

  /* template */
  var __vue_render__$W = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "custom-element",
      { staticClass: "mdc-theme", class: _vm.classes, attrs: { tag: _vm.tag } },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$W = [];
  __vue_render__$W._withStripped = true;

    /* style */
    const __vue_inject_styles__$Z = undefined;
    /* scoped */
    const __vue_scope_id__$Z = undefined;
    /* module identifier */
    const __vue_module_identifier__$Z = undefined;
    /* functional template */
    const __vue_is_functional_template__$Z = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTheme = normalizeComponent(
      { render: __vue_render__$W, staticRenderFns: __vue_staticRenderFns__$W },
      __vue_inject_styles__$Z,
      __vue_script__$Z,
      __vue_scope_id__$Z,
      __vue_is_functional_template__$Z,
      __vue_module_identifier__$Z,
      undefined,
      undefined
    );

  var VueMDCTheme = BasePlugin({
    mdcTheme: mdcTheme
  });

  /**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */
  var cssClasses$s = {
    FIXED: 'mdc-toolbar--fixed',
    FIXED_LASTROW: 'mdc-toolbar--fixed-lastrow-only',
    FIXED_AT_LAST_ROW: 'mdc-toolbar--fixed-at-last-row',
    TOOLBAR_ROW_FLEXIBLE: 'mdc-toolbar--flexible',
    FLEXIBLE_DEFAULT_BEHAVIOR: 'mdc-toolbar--flexible-default-behavior',
    FLEXIBLE_MAX: 'mdc-toolbar--flexible-space-maximized',
    FLEXIBLE_MIN: 'mdc-toolbar--flexible-space-minimized'
  };
  var strings$u = {
    TITLE_SELECTOR: '.mdc-toolbar__title',
    ICON_SELECTOR: '.mdc-toolbar__icon',
    FIRST_ROW_SELECTOR: '.mdc-toolbar__row:first-child',
    CHANGE_EVENT: 'MDCToolbar:change'
  };
  var numbers$a = {
    MAX_TITLE_SIZE: 2.125,
    MIN_TITLE_SIZE: 1.25,
    TOOLBAR_ROW_HEIGHT: 64,
    TOOLBAR_ROW_MOBILE_HEIGHT: 56,
    TOOLBAR_MOBILE_BREAKPOINT: 600
  };

  var MDCToolbarFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCToolbarFoundation, _MDCFoundation);

    _createClass(MDCToolbarFoundation, null, [{
      key: "cssClasses",
      get: function get() {
        return cssClasses$s;
      }
    }, {
      key: "strings",
      get: function get() {
        return strings$u;
      }
    }, {
      key: "numbers",
      get: function get() {
        return numbers$a;
      }
    }, {
      key: "defaultAdapter",
      get: function get() {
        return {
          hasClass: function hasClass() {
            return (
              /* className: string */

              /* boolean */
              false
            );
          },
          addClass: function addClass()
          /* className: string */
          {},
          removeClass: function removeClass()
          /* className: string */
          {},
          registerScrollHandler: function registerScrollHandler()
          /* handler: EventListener */
          {},
          deregisterScrollHandler: function deregisterScrollHandler()
          /* handler: EventListener */
          {},
          registerResizeHandler: function registerResizeHandler()
          /* handler: EventListener */
          {},
          deregisterResizeHandler: function deregisterResizeHandler()
          /* handler: EventListener */
          {},
          getViewportWidth: function getViewportWidth() {
            return (
              /* number */
              0
            );
          },
          getViewportScrollY: function getViewportScrollY() {
            return (
              /* number */
              0
            );
          },
          getOffsetHeight: function getOffsetHeight() {
            return (
              /* number */
              0
            );
          },
          getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
            return (
              /* number */
              0
            );
          },
          notifyChange: function notifyChange()
          /* evtData: {flexibleExpansionRatio: number} */
          {},
          setStyle: function setStyle()
          /* property: string, value: string */
          {},
          setStyleForTitleElement: function setStyleForTitleElement()
          /* property: string, value: string */
          {},
          setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement()
          /* property: string, value: string */
          {},
          setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement()
          /* property: string, value: string */
          {}
        };
      }
    }]);

    function MDCToolbarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCToolbarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCToolbarFoundation).call(this, _extends(MDCToolbarFoundation.defaultAdapter, adapter)));

      _this.resizeHandler_ = function () {
        return _this.checkRowHeight_();
      };

      _this.scrollHandler_ = function () {
        return _this.updateToolbarStyles_();
      };

      _this.checkRowHeightFrame_ = 0;
      _this.scrollFrame_ = 0;
      _this.executedLastChange_ = false;
      _this.calculations_ = {
        toolbarRowHeight: 0,
        // Calculated Height ratio. We use ratio to calculate corresponding heights in resize event.
        toolbarRatio: 0,
        // The ratio of toolbar height to row height
        flexibleExpansionRatio: 0,
        // The ratio of flexible space height to row height
        maxTranslateYRatio: 0,
        // The ratio of max toolbar move up distance to row height
        scrollThresholdRatio: 0,
        // The ratio of max scrollTop that we should listen to to row height
        // Derived Heights based on the above key ratios.
        toolbarHeight: 0,
        flexibleExpansionHeight: 0,
        // Flexible row minus toolbar height (derived)
        maxTranslateYDistance: 0,
        // When toolbar only fix last row (derived)
        scrollThreshold: 0
      }; // Toolbar fixed behavior
      // If toolbar is fixed

      _this.fixed_ = false; // If fixed is targeted only at the last row

      _this.fixedLastrow_ = false; // Toolbar flexible behavior
      // If the first row is flexible

      _this.hasFlexibleRow_ = false; // If use the default behavior

      _this.useFlexDefaultBehavior_ = false;
      return _this;
    }

    _createClass(MDCToolbarFoundation, [{
      key: "init",
      value: function init() {
        this.fixed_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED);
        this.fixedLastrow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FIXED_LASTROW) & this.fixed_;
        this.hasFlexibleRow_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.TOOLBAR_ROW_FLEXIBLE);

        if (this.hasFlexibleRow_) {
          this.useFlexDefaultBehavior_ = this.adapter_.hasClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_DEFAULT_BEHAVIOR);
        }

        this.initKeyRatio_();
        this.setKeyHeights_();
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }, {
      key: "updateAdjustElementStyles",
      value: function updateAdjustElementStyles() {
        if (this.fixed_) {
          this.adapter_.setStyleForFixedAdjustElement('margin-top', "".concat(this.calculations_.toolbarHeight, "px"));
        }
      }
    }, {
      key: "getFlexibleExpansionRatio_",
      value: function getFlexibleExpansionRatio_(scrollTop) {
        // To prevent division by zero when there is no flexibleExpansionHeight
        var delta = 0.0001;
        return Math.max(0, 1 - scrollTop / (this.calculations_.flexibleExpansionHeight + delta));
      }
    }, {
      key: "checkRowHeight_",
      value: function checkRowHeight_() {
        var _this2 = this;

        cancelAnimationFrame(this.checkRowHeightFrame_);
        this.checkRowHeightFrame_ = requestAnimationFrame(function () {
          return _this2.setKeyHeights_();
        });
      }
    }, {
      key: "setKeyHeights_",
      value: function setKeyHeights_() {
        var newToolbarRowHeight = this.getRowHeight_();

        if (newToolbarRowHeight !== this.calculations_.toolbarRowHeight) {
          this.calculations_.toolbarRowHeight = newToolbarRowHeight;
          this.calculations_.toolbarHeight = this.calculations_.toolbarRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.flexibleExpansionHeight = this.calculations_.flexibleExpansionRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.maxTranslateYDistance = this.calculations_.maxTranslateYRatio * this.calculations_.toolbarRowHeight;
          this.calculations_.scrollThreshold = this.calculations_.scrollThresholdRatio * this.calculations_.toolbarRowHeight;
          this.updateAdjustElementStyles();
          this.updateToolbarStyles_();
        }
      }
    }, {
      key: "updateToolbarStyles_",
      value: function updateToolbarStyles_() {
        var _this3 = this;

        cancelAnimationFrame(this.scrollFrame_);
        this.scrollFrame_ = requestAnimationFrame(function () {
          var scrollTop = _this3.adapter_.getViewportScrollY();

          var hasScrolledOutOfThreshold = _this3.scrolledOutOfThreshold_(scrollTop);

          if (hasScrolledOutOfThreshold && _this3.executedLastChange_) {
            return;
          }

          var flexibleExpansionRatio = _this3.getFlexibleExpansionRatio_(scrollTop);

          _this3.updateToolbarFlexibleState_(flexibleExpansionRatio);

          if (_this3.fixedLastrow_) {
            _this3.updateToolbarFixedState_(scrollTop);
          }

          if (_this3.hasFlexibleRow_) {
            _this3.updateFlexibleRowElementStyles_(flexibleExpansionRatio);
          }

          _this3.executedLastChange_ = hasScrolledOutOfThreshold;

          _this3.adapter_.notifyChange({
            flexibleExpansionRatio: flexibleExpansionRatio
          });
        });
      }
    }, {
      key: "scrolledOutOfThreshold_",
      value: function scrolledOutOfThreshold_(scrollTop) {
        return scrollTop > this.calculations_.scrollThreshold;
      }
    }, {
      key: "initKeyRatio_",
      value: function initKeyRatio_() {
        var toolbarRowHeight = this.getRowHeight_();
        var firstRowMaxRatio = this.adapter_.getFirstRowElementOffsetHeight() / toolbarRowHeight;
        this.calculations_.toolbarRatio = this.adapter_.getOffsetHeight() / toolbarRowHeight;
        this.calculations_.flexibleExpansionRatio = firstRowMaxRatio - 1;
        this.calculations_.maxTranslateYRatio = this.fixedLastrow_ ? this.calculations_.toolbarRatio - firstRowMaxRatio : 0;
        this.calculations_.scrollThresholdRatio = (this.fixedLastrow_ ? this.calculations_.toolbarRatio : firstRowMaxRatio) - 1;
      }
    }, {
      key: "getRowHeight_",
      value: function getRowHeight_() {
        var breakpoint = MDCToolbarFoundation.numbers.TOOLBAR_MOBILE_BREAKPOINT;
        return this.adapter_.getViewportWidth() < breakpoint ? MDCToolbarFoundation.numbers.TOOLBAR_ROW_MOBILE_HEIGHT : MDCToolbarFoundation.numbers.TOOLBAR_ROW_HEIGHT;
      }
    }, {
      key: "updateToolbarFlexibleState_",
      value: function updateToolbarFlexibleState_(flexibleExpansionRatio) {
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);

        if (flexibleExpansionRatio === 1) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MAX);
        } else if (flexibleExpansionRatio === 0) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FLEXIBLE_MIN);
        }
      }
    }, {
      key: "updateToolbarFixedState_",
      value: function updateToolbarFixedState_(scrollTop) {
        var translateDistance = Math.max(0, Math.min(scrollTop - this.calculations_.flexibleExpansionHeight, this.calculations_.maxTranslateYDistance));
        this.adapter_.setStyle('transform', "translateY(".concat(-translateDistance, "px)"));

        if (translateDistance === this.calculations_.maxTranslateYDistance) {
          this.adapter_.addClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        } else {
          this.adapter_.removeClass(MDCToolbarFoundation.cssClasses.FIXED_AT_LAST_ROW);
        }
      }
    }, {
      key: "updateFlexibleRowElementStyles_",
      value: function updateFlexibleRowElementStyles_(flexibleExpansionRatio) {
        if (this.fixed_) {
          var height = this.calculations_.flexibleExpansionHeight * flexibleExpansionRatio;
          this.adapter_.setStyleForFlexibleRowElement('height', "".concat(height + this.calculations_.toolbarRowHeight, "px"));
        }

        if (this.useFlexDefaultBehavior_) {
          this.updateElementStylesDefaultBehavior_(flexibleExpansionRatio);
        }
      }
    }, {
      key: "updateElementStylesDefaultBehavior_",
      value: function updateElementStylesDefaultBehavior_(flexibleExpansionRatio) {
        var maxTitleSize = MDCToolbarFoundation.numbers.MAX_TITLE_SIZE;
        var minTitleSize = MDCToolbarFoundation.numbers.MIN_TITLE_SIZE;
        var currentTitleSize = (maxTitleSize - minTitleSize) * flexibleExpansionRatio + minTitleSize;
        this.adapter_.setStyleForTitleElement('font-size', "".concat(currentTitleSize, "rem"));
      }
    }]);

    return MDCToolbarFoundation;
  }(MDCFoundation);

  //
  var script$_ = {
    name: 'mdc-toolbar',
    props: {
      fixed: Boolean,
      waterfall: Boolean,
      'fixed-lastrow': Boolean,
      flexible: Boolean,
      'flexible-default': {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        rootClasses: {
          'mdc-toolbar': true,
          'mdc-toolbar--fixed': this.fixed || this.waterfall || this.fixedLastrow,
          'mdc-toolbar--waterfall': this.waterfall,
          'mdc-toolbar--fixed-lastrow-only': this.fixedLastrow,
          'mdc-toolbar--flexible': this.flexible,
          'mdc-toolbar--flexible-default-behavior': this.flexible && this.flexibleDefault
        },
        rootStyles: {},
        adjustStyles: {// to avoid top margin collapse with :after el
          // 0.1 px should be rounded to 0px
          // TODO: find a better trick
          // height: '0.1px'
        },
        foundation: null
      };
    },
    mounted: function mounted() {
      var _this = this;

      this.foundation = new MDCToolbarFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        getViewportWidth: function getViewportWidth() {
          return window.innerWidth;
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getOffsetHeight: function getOffsetHeight() {
          return _this.$refs.root.offsetHeight;
        },
        getFirstRowElementOffsetHeight: function getFirstRowElementOffsetHeight() {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);

          return el ? el.offsetHeight : undefined;
        },
        notifyChange: function notifyChange(evtData) {
          _this.$emit('change', evtData);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        setStyleForTitleElement: function setStyleForTitleElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.TITLE_SELECTOR);

          if (el) el.style.setProperty(property, value);
        },
        setStyleForFlexibleRowElement: function setStyleForFlexibleRowElement(property, value) {
          var el = _this.$refs.root.querySelector(MDCToolbarFoundation.strings.FIRST_ROW_SELECTOR);

          if (el) el.style.setProperty(property, value);
        },
        setStyleForFixedAdjustElement: function setStyleForFixedAdjustElement(property, value) {
          _this.$set(_this.adjustStyles, property, value);
        }
      });
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$_ = script$_;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$_.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar.vue";

  /* template */
  var __vue_render__$X = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c("header", { staticClass: "mdc-toolbar-wrapper" }, [
      _c(
        "div",
        { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles },
        [_vm._t("default")],
        2
      ),
      _vm._v(" "),
      _vm.fixed || _vm.waterfall || _vm.fixedLastrow
        ? _c("div", {
            ref: "fixed-adjust",
            staticClass: "mdc-toolbar-fixed-adjust",
            style: _vm.adjustStyles
          })
        : _vm._e()
    ])
  };
  var __vue_staticRenderFns__$X = [];
  __vue_render__$X._withStripped = true;

    /* style */
    const __vue_inject_styles__$_ = undefined;
    /* scoped */
    const __vue_scope_id__$_ = undefined;
    /* module identifier */
    const __vue_module_identifier__$_ = undefined;
    /* functional template */
    const __vue_is_functional_template__$_ = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbar = normalizeComponent(
      { render: __vue_render__$X, staticRenderFns: __vue_staticRenderFns__$X },
      __vue_inject_styles__$_,
      __vue_script__$_,
      __vue_scope_id__$_,
      __vue_is_functional_template__$_,
      __vue_module_identifier__$_,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  var script$10 = {
    name: 'mdc-toolbar-row'
  };

  /* script */
  const __vue_script__$10 = script$10;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$10.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar-row.vue";

  /* template */
  var __vue_render__$Y = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "div",
      { staticClass: "mdc-toolbar-row mdc-toolbar__row" },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$Y = [];
  __vue_render__$Y._withStripped = true;

    /* style */
    const __vue_inject_styles__$10 = undefined;
    /* scoped */
    const __vue_scope_id__$10 = undefined;
    /* module identifier */
    const __vue_module_identifier__$10 = undefined;
    /* functional template */
    const __vue_is_functional_template__$10 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbarRow = normalizeComponent(
      { render: __vue_render__$Y, staticRenderFns: __vue_staticRenderFns__$Y },
      __vue_inject_styles__$10,
      __vue_script__$10,
      __vue_scope_id__$10,
      __vue_is_functional_template__$10,
      __vue_module_identifier__$10,
      undefined,
      undefined
    );

  //
  //
  //
  //
  //
  //
  //
  //
  var script$11 = {
    name: 'mdc-toolbar-section',
    props: {
      'align-start': Boolean,
      'align-end': Boolean,
      'shrink-to-fit': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-toolbar__section--align-start': this.alignStart,
          'mdc-toolbar__section--align-end': this.alignEnd,
          'mdc-toolbar__section--shrink-to-fit': this.shrinkToFit
        }
      };
    }
  };

  /* script */
  const __vue_script__$11 = script$11;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$11.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar-section.vue";

  /* template */
  var __vue_render__$Z = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "section",
      {
        staticClass: "mdc-toolbar-section mdc-toolbar__section",
        class: _vm.classes
      },
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$Z = [];
  __vue_render__$Z._withStripped = true;

    /* style */
    const __vue_inject_styles__$11 = undefined;
    /* scoped */
    const __vue_scope_id__$11 = undefined;
    /* module identifier */
    const __vue_module_identifier__$11 = undefined;
    /* functional template */
    const __vue_is_functional_template__$11 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbarSection = normalizeComponent(
      { render: __vue_render__$Z, staticRenderFns: __vue_staticRenderFns__$Z },
      __vue_inject_styles__$11,
      __vue_script__$11,
      __vue_scope_id__$11,
      __vue_is_functional_template__$11,
      __vue_module_identifier__$11,
      undefined,
      undefined
    );

  //
  var script$12 = {
    name: 'mdc-toolbar-menu-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: {
        type: String,
        default: 'menu'
      }
    }
  };

  /* script */
  const __vue_script__$12 = script$12;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$12.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar-menu-icon.vue";

  /* template */
  var __vue_render__$_ = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "a",
      _vm._g(
        {
          staticClass: "mdc-toolbar-menu-icon mdc-toolbar__menu-icon",
          class: { "material-icons": !!_vm.icon }
        },
        _vm.listeners
      ),
      [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
      2
    )
  };
  var __vue_staticRenderFns__$_ = [];
  __vue_render__$_._withStripped = true;

    /* style */
    const __vue_inject_styles__$12 = undefined;
    /* scoped */
    const __vue_scope_id__$12 = undefined;
    /* module identifier */
    const __vue_module_identifier__$12 = undefined;
    /* functional template */
    const __vue_is_functional_template__$12 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbarMenuIcon = normalizeComponent(
      { render: __vue_render__$_, staticRenderFns: __vue_staticRenderFns__$_ },
      __vue_inject_styles__$12,
      __vue_script__$12,
      __vue_scope_id__$12,
      __vue_is_functional_template__$12,
      __vue_module_identifier__$12,
      undefined,
      undefined
    );

  //
  var script$13 = {
    name: 'mdc-toolbar-title',
    mixins: [DispatchEventMixin]
  };

  /* script */
  const __vue_script__$13 = script$13;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$13.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar-title.vue";

  /* template */
  var __vue_render__$10 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "a",
      _vm._g(
        { staticClass: "mdc-toolbar-title mdc-toolbar__title" },
        _vm.listeners
      ),
      [_vm._t("default")],
      2
    )
  };
  var __vue_staticRenderFns__$10 = [];
  __vue_render__$10._withStripped = true;

    /* style */
    const __vue_inject_styles__$13 = undefined;
    /* scoped */
    const __vue_scope_id__$13 = undefined;
    /* module identifier */
    const __vue_module_identifier__$13 = undefined;
    /* functional template */
    const __vue_is_functional_template__$13 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbarTitle = normalizeComponent(
      { render: __vue_render__$10, staticRenderFns: __vue_staticRenderFns__$10 },
      __vue_inject_styles__$13,
      __vue_script__$13,
      __vue_scope_id__$13,
      __vue_is_functional_template__$13,
      __vue_module_identifier__$13,
      undefined,
      undefined
    );

  //
  var script$14 = {
    name: 'mdc-toolbar-icon',
    mixins: [DispatchEventMixin],
    props: {
      icon: String
    }
  };

  /* script */
  const __vue_script__$14 = script$14;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$14.__file = "/ddata/extra/vma/components/toolbar/mdc-toolbar-icon.vue";

  /* template */
  var __vue_render__$11 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "a",
      _vm._g(
        {
          staticClass: "mdc-toolbar-icon mdc-toolbar__icon",
          class: { "material-icons": !!_vm.icon }
        },
        _vm.listeners
      ),
      [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
      2
    )
  };
  var __vue_staticRenderFns__$11 = [];
  __vue_render__$11._withStripped = true;

    /* style */
    const __vue_inject_styles__$14 = undefined;
    /* scoped */
    const __vue_scope_id__$14 = undefined;
    /* module identifier */
    const __vue_module_identifier__$14 = undefined;
    /* functional template */
    const __vue_is_functional_template__$14 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcToolbarIcon = normalizeComponent(
      { render: __vue_render__$11, staticRenderFns: __vue_staticRenderFns__$11 },
      __vue_inject_styles__$14,
      __vue_script__$14,
      __vue_scope_id__$14,
      __vue_is_functional_template__$14,
      __vue_module_identifier__$14,
      undefined,
      undefined
    );

  var VueMDCToolbar = BasePlugin({
    mdcToolbar: mdcToolbar,
    mdcToolbarRow: mdcToolbarRow,
    mdcToolbarSection: mdcToolbarSection,
    mdcToolbarMenuIcon: mdcToolbarMenuIcon,
    mdcToolbarTitle: mdcToolbarTitle,
    mdcToolbarIcon: mdcToolbarIcon
  });

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Top App Bar
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Top App Bar into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCTopAppBarAdapter =
  /*#__PURE__*/
  function () {
    function MDCTopAppBarAdapter() {
      _classCallCheck(this, MDCTopAppBarAdapter);
    }

    _createClass(MDCTopAppBarAdapter, [{
      key: "addClass",

      /**
       * Adds a class to the root Element.
       * @param {string} className
       */
      value: function addClass(className) {}
      /**
       * Removes a class from the root Element.
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}
      /**
       * Returns true if the root Element contains the given class.
       * @param {string} className
       * @return {boolean}
       */

    }, {
      key: "hasClass",
      value: function hasClass(className) {}
      /**
       * Sets the specified inline style property on the root Element to the given value.
       * @param {string} property
       * @param {string} value
       */

    }, {
      key: "setStyle",
      value: function setStyle(property, value) {}
      /**
       * Gets the height of the top app bar.
       * @return {number}
       */

    }, {
      key: "getTopAppBarHeight",
      value: function getTopAppBarHeight() {}
      /**
       * Registers an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerNavigationIconInteractionHandler",
      value: function registerNavigationIconInteractionHandler(type, handler) {}
      /**
       * Deregisters an event handler on the navigation icon element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterNavigationIconInteractionHandler",
      value: function deregisterNavigationIconInteractionHandler(type, handler) {}
      /**
       * Emits an event when the navigation icon is clicked.
       */

    }, {
      key: "notifyNavigationIconClicked",
      value: function notifyNavigationIconClicked() {}
      /** @param {function(!Event)} handler */

    }, {
      key: "registerScrollHandler",
      value: function registerScrollHandler(handler) {}
      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterScrollHandler",
      value: function deregisterScrollHandler(handler) {}
      /** @param {function(!Event)} handler */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}
      /** @param {function(!Event)} handler */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}
      /** @return {number} */

    }, {
      key: "getViewportScrollY",
      value: function getViewportScrollY() {}
      /** @return {number} */

    }, {
      key: "getTotalActionItems",
      value: function getTotalActionItems() {}
    }]);

    return MDCTopAppBarAdapter;
  }();

  /**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   */

  /** @enum {string} */
  var cssClasses$t = {
    FIXED_CLASS: 'mdc-top-app-bar--fixed',
    FIXED_SCROLLED_CLASS: 'mdc-top-app-bar--fixed-scrolled',
    SHORT_CLASS: 'mdc-top-app-bar--short',
    SHORT_HAS_ACTION_ITEM_CLASS: 'mdc-top-app-bar--short-has-action-item',
    SHORT_COLLAPSED_CLASS: 'mdc-top-app-bar--short-collapsed'
  };
  /** @enum {number} */

  var numbers$b = {
    DEBOUNCE_THROTTLE_RESIZE_TIME_MS: 100,
    MAX_TOP_APP_BAR_HEIGHT: 128
  };
  /** @enum {string} */

  var strings$v = {
    ACTION_ITEM_SELECTOR: '.mdc-top-app-bar__action-item',
    NAVIGATION_EVENT: 'MDCTopAppBar:nav',
    NAVIGATION_ICON_SELECTOR: '.mdc-top-app-bar__navigation-icon',
    ROOT_SELECTOR: '.mdc-top-app-bar',
    TITLE_SELECTOR: '.mdc-top-app-bar__title'
  };

  /**
   * @extends {MDCFoundation<!MDCTopAppBarAdapter>}
   */

  var MDCTopAppBarBaseFoundation =
  /*#__PURE__*/
  function (_MDCFoundation) {
    _inherits(MDCTopAppBarBaseFoundation, _MDCFoundation);

    _createClass(MDCTopAppBarBaseFoundation, null, [{
      key: "strings",

      /** @return enum {string} */
      get: function get() {
        return strings$v;
      }
      /** @return enum {string} */

    }, {
      key: "cssClasses",
      get: function get() {
        return cssClasses$t;
      }
      /** @return enum {number} */

    }, {
      key: "numbers",
      get: function get() {
        return numbers$b;
      }
      /**
       * {@see MDCTopAppBarAdapter} for typing information on parameters and return
       * types.
       * @return {!MDCTopAppBarAdapter}
       */

    }, {
      key: "defaultAdapter",
      get: function get() {
        return (
          /** @type {!MDCTopAppBarAdapter} */
          {
            hasClass: function hasClass()
            /* className: string */
            {},
            addClass: function addClass()
            /* className: string */
            {},
            removeClass: function removeClass()
            /* className: string */
            {},
            setStyle: function setStyle()
            /* property: string, value: string */
            {},
            getTopAppBarHeight: function getTopAppBarHeight() {},
            registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler()
            /* type: string, handler: EventListener */
            {},
            notifyNavigationIconClicked: function notifyNavigationIconClicked() {},
            registerScrollHandler: function registerScrollHandler()
            /* handler: EventListener */
            {},
            deregisterScrollHandler: function deregisterScrollHandler()
            /* handler: EventListener */
            {},
            registerResizeHandler: function registerResizeHandler()
            /* handler: EventListener */
            {},
            deregisterResizeHandler: function deregisterResizeHandler()
            /* handler: EventListener */
            {},
            getViewportScrollY: function getViewportScrollY() {
              return (
                /* number */
                0
              );
            },
            getTotalActionItems: function getTotalActionItems() {
              return (
                /* number */
                0
              );
            }
          }
        );
      }
      /**
       * @param {!MDCTopAppBarAdapter} adapter
       */

    }]);

    function MDCTopAppBarBaseFoundation(
    /** @type {!MDCTopAppBarAdapter} */
    adapter) {
      var _this;

      _classCallCheck(this, MDCTopAppBarBaseFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTopAppBarBaseFoundation).call(this, _extends(MDCTopAppBarBaseFoundation.defaultAdapter, adapter)));

      _this.navClickHandler_ = function () {
        return _this.adapter_.notifyNavigationIconClicked();
      };

      _this.scrollHandler_ = function () {};

      return _this;
    }

    _createClass(MDCTopAppBarBaseFoundation, [{
      key: "init",
      value: function init() {
        this.adapter_.registerNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        this.adapter_.deregisterNavigationIconInteractionHandler('click', this.navClickHandler_);
      }
    }, {
      key: "initScrollHandler",
      value: function initScrollHandler() {
        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: "destroyScrollHandler",
      value: function destroyScrollHandler() {
        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
    }]);

    return MDCTopAppBarBaseFoundation;
  }(MDCFoundation);

  var INITIAL_VALUE = 0;
  /**
   * @extends {MDCTopAppBarBaseFoundation<!MDCTopAppBarFoundation>}
   * @final
   */

  var MDCTopAppBarFoundation =
  /*#__PURE__*/
  function (_MDCTopAppBarBaseFoun) {
    _inherits(MDCTopAppBarFoundation, _MDCTopAppBarBaseFoun);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCTopAppBarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCTopAppBarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCTopAppBarFoundation).call(this, adapter));
      /**
       * Used for diffs of current scroll position vs previous scroll position
       * @private {number}
       */

      _this.lastScrollPosition_ = _this.adapter_.getViewportScrollY();
      /**
       * Used to verify when the top app bar is completely showing or completely hidden
       * @private {number}
       */

      _this.topAppBarHeight_ = _this.adapter_.getTopAppBarHeight();
      /**
       * wasDocked_ is used to indicate if the top app bar was docked in the previous
       * scroll handler iteration.
       * @private {boolean}
       */

      _this.wasDocked_ = true;
      /**
       * isDockedShowing_ is used to indicate if the top app bar is docked in the fully
       * shown position.
       * @private {boolean}
       */

      _this.isDockedShowing_ = true;
      /**
       * Variable for current scroll position of the top app bar
       * @private {number}
       */

      _this.currentAppBarOffsetTop_ = 0;
      /**
       * Used to prevent the top app bar from being scrolled out of view during resize events
       * @private {boolean} */

      _this.isCurrentlyBeingResized_ = false;
      /**
       * The timeout that's used to throttle the resize events
       * @private {number}
       */

      _this.resizeThrottleId_ = INITIAL_VALUE;
      /**
       * The timeout that's used to debounce toggling the isCurrentlyBeingResized_ variable after a resize
       * @private {number}
       */

      _this.resizeDebounceId_ = INITIAL_VALUE;

      _this.scrollHandler_ = function () {
        return _this.topAppBarScrollHandler_();
      };

      _this.resizeHandler_ = function () {
        return _this.topAppBarResizeHandler_();
      };

      return _this;
    }

    _createClass(MDCTopAppBarFoundation, [{
      key: "init",
      value: function init() {
        _get(_getPrototypeOf(MDCTopAppBarFoundation.prototype), "init", this).call(this);

        this.adapter_.registerScrollHandler(this.scrollHandler_);
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(MDCTopAppBarFoundation.prototype), "destroy", this).call(this);

        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
        this.adapter_.setStyle('top', '');
      }
      /**
       * Function to determine if the DOM needs to update.
       * @return {boolean}
       * @private
       */

    }, {
      key: "checkForUpdate_",
      value: function checkForUpdate_() {
        var offscreenBoundaryTop = -this.topAppBarHeight_;
        var hasAnyPixelsOffscreen = this.currentAppBarOffsetTop_ < 0;
        var hasAnyPixelsOnscreen = this.currentAppBarOffsetTop_ > offscreenBoundaryTop;
        var partiallyShowing = hasAnyPixelsOffscreen && hasAnyPixelsOnscreen; // If it's partially showing, it can't be docked.

        if (partiallyShowing) {
          this.wasDocked_ = false;
        } else {
          // Not previously docked and not partially showing, it's now docked.
          if (!this.wasDocked_) {
            this.wasDocked_ = true;
            return true;
          } else if (this.isDockedShowing_ !== hasAnyPixelsOnscreen) {
            this.isDockedShowing_ = hasAnyPixelsOnscreen;
            return true;
          }
        }

        return partiallyShowing;
      }
      /**
       * Function to move the top app bar if needed.
       * @private
       */

    }, {
      key: "moveTopAppBar_",
      value: function moveTopAppBar_() {
        if (this.checkForUpdate_()) {
          // Once the top app bar is fully hidden we use the max potential top app bar height as our offset
          // so the top app bar doesn't show if the window resizes and the new height > the old height.
          var offset = this.currentAppBarOffsetTop_;

          if (Math.abs(offset) >= this.topAppBarHeight_) {
            offset = -numbers$b.MAX_TOP_APP_BAR_HEIGHT;
          }

          this.adapter_.setStyle('top', offset + 'px');
        }
      }
      /**
       * Scroll handler for the default scroll behavior of the top app bar.
       * @private
       */

    }, {
      key: "topAppBarScrollHandler_",
      value: function topAppBarScrollHandler_() {
        var currentScrollPosition = Math.max(this.adapter_.getViewportScrollY(), 0);
        var diff = currentScrollPosition - this.lastScrollPosition_;
        this.lastScrollPosition_ = currentScrollPosition; // If the window is being resized the lastScrollPosition_ needs to be updated but the
        // current scroll of the top app bar should stay in the same position.

        if (!this.isCurrentlyBeingResized_) {
          this.currentAppBarOffsetTop_ -= diff;

          if (this.currentAppBarOffsetTop_ > 0) {
            this.currentAppBarOffsetTop_ = 0;
          } else if (Math.abs(this.currentAppBarOffsetTop_) > this.topAppBarHeight_) {
            this.currentAppBarOffsetTop_ = -this.topAppBarHeight_;
          }

          this.moveTopAppBar_();
        }
      }
      /**
       * Top app bar resize handler that throttle/debounce functions that execute updates.
       * @private
       */

    }, {
      key: "topAppBarResizeHandler_",
      value: function topAppBarResizeHandler_() {
        var _this2 = this;

        // Throttle resize events 10 p/s
        if (!this.resizeThrottleId_) {
          this.resizeThrottleId_ = setTimeout(function () {
            _this2.resizeThrottleId_ = INITIAL_VALUE;

            _this2.throttledResizeHandler_();
          }, numbers$b.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
        }

        this.isCurrentlyBeingResized_ = true;

        if (this.resizeDebounceId_) {
          clearTimeout(this.resizeDebounceId_);
        }

        this.resizeDebounceId_ = setTimeout(function () {
          _this2.topAppBarScrollHandler_();

          _this2.isCurrentlyBeingResized_ = false;
          _this2.resizeDebounceId_ = INITIAL_VALUE;
        }, numbers$b.DEBOUNCE_THROTTLE_RESIZE_TIME_MS);
      }
      /**
       * Throttled function that updates the top app bar scrolled values if the
       * top app bar height changes.
       * @private
       */

    }, {
      key: "throttledResizeHandler_",
      value: function throttledResizeHandler_() {
        var currentHeight = this.adapter_.getTopAppBarHeight();

        if (this.topAppBarHeight_ !== currentHeight) {
          this.wasDocked_ = false; // Since the top app bar has a different height depending on the screen width, this
          // will ensure that the top app bar remains in the correct location if
          // completely hidden and a resize makes the top app bar a different height.

          this.currentAppBarOffsetTop_ -= this.topAppBarHeight_ - currentHeight;
          this.topAppBarHeight_ = currentHeight;
        }

        this.topAppBarScrollHandler_();
      }
    }]);

    return MDCTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  /**
   * @extends {MDCTopAppBarBaseFoundation<!MDCShortTopAppBarFoundation>}
   * @final
   */

  var MDCShortTopAppBarFoundation =
  /*#__PURE__*/
  function (_MDCTopAppBarBaseFoun) {
    _inherits(MDCShortTopAppBarFoundation, _MDCTopAppBarBaseFoun);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCShortTopAppBarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCShortTopAppBarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCShortTopAppBarFoundation).call(this, adapter)); // State variable for the current top app bar state

      _this.isCollapsed = false;

      _this.scrollHandler_ = function () {
        return _this.shortAppBarScrollHandler_();
      };

      return _this;
    }

    _createClass(MDCShortTopAppBarFoundation, [{
      key: "init",
      value: function init() {
        _get(_getPrototypeOf(MDCShortTopAppBarFoundation.prototype), "init", this).call(this);

        var isAlwaysCollapsed = this.adapter_.hasClass(cssClasses$t.SHORT_COLLAPSED_CLASS);

        if (this.adapter_.getTotalActionItems() > 0) {
          this.adapter_.addClass(cssClasses$t.SHORT_HAS_ACTION_ITEM_CLASS);
        }

        if (!isAlwaysCollapsed) {
          this.adapter_.registerScrollHandler(this.scrollHandler_);
          this.shortAppBarScrollHandler_();
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(MDCShortTopAppBarFoundation.prototype), "destroy", this).call(this);

        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
      /**
       * Scroll handler for applying/removing the collapsed modifier class
       * on the short top app bar.
       * @private
       */

    }, {
      key: "shortAppBarScrollHandler_",
      value: function shortAppBarScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.isCollapsed) {
            this.adapter_.removeClass(cssClasses$t.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = false;
          }
        } else {
          if (!this.isCollapsed) {
            this.adapter_.addClass(cssClasses$t.SHORT_COLLAPSED_CLASS);
            this.isCollapsed = true;
          }
        }
      }
    }]);

    return MDCShortTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  /**
   * @extends {MDCTopAppBarFoundation<!MDCFixedTopAppBarFoundation>}
   * @final
   */

  var MDCFixedTopAppBarFoundation =
  /*#__PURE__*/
  function (_MDCTopAppBarFoundati) {
    _inherits(MDCFixedTopAppBarFoundation, _MDCTopAppBarFoundati);

    /**
     * @param {!MDCTopAppBarAdapter} adapter
     */
    function MDCFixedTopAppBarFoundation(adapter) {
      var _this;

      _classCallCheck(this, MDCFixedTopAppBarFoundation);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(MDCFixedTopAppBarFoundation).call(this, adapter));
      /** State variable for the previous scroll iteration top app bar state */

      _this.wasScrolled_ = false;

      _this.scrollHandler_ = function () {
        return _this.fixedScrollHandler_();
      };

      return _this;
    }

    _createClass(MDCFixedTopAppBarFoundation, [{
      key: "init",
      value: function init() {
        _get(_getPrototypeOf(MDCFixedTopAppBarFoundation.prototype), "init", this).call(this);

        this.adapter_.registerScrollHandler(this.scrollHandler_);
      }
    }, {
      key: "destroy",
      value: function destroy() {
        _get(_getPrototypeOf(MDCFixedTopAppBarFoundation.prototype), "destroy", this).call(this);

        this.adapter_.deregisterScrollHandler(this.scrollHandler_);
      }
      /**
       * Scroll handler for applying/removing the modifier class
       * on the fixed top app bar.
       */

    }, {
      key: "fixedScrollHandler_",
      value: function fixedScrollHandler_() {
        var currentScroll = this.adapter_.getViewportScrollY();

        if (currentScroll <= 0) {
          if (this.wasScrolled_) {
            this.adapter_.removeClass(cssClasses$t.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = false;
          }
        } else {
          if (!this.wasScrolled_) {
            this.adapter_.addClass(cssClasses$t.FIXED_SCROLLED_CLASS);
            this.wasScrolled_ = true;
          }
        }
      }
    }]);

    return MDCFixedTopAppBarFoundation;
  }(MDCTopAppBarBaseFoundation);

  var script$15 = {
    name: 'mdc-top-app-bar',
    mixins: [DispatchEventMixin],
    props: {
      short: Boolean,
      shortCollapsed: Boolean,
      prominent: Boolean,
      fixed: Boolean,
      title: String,
      icon: {
        type: [String, Boolean],
        default: 'menu'
      },
      iconClasses: Object,
      dense: Boolean
    },
    data: function data() {
      return {
        rootStyles: {
          top: '0'
        },
        rootClasses: {
          'mdc-top-app-bar': true,
          'mdc-top-app-bar--dense': this.dense,
          'mdc-top-app-bar--short': this.short,
          'mdc-top-app-bar--short-collapsed': this.shortCollapsed,
          'mdc-top-app-bar--prominent': this.prominent,
          'mdc-top-app-bar--fixed': this.fixed
        },
        foundation: null
      };
    },
    computed: {
      haveNavigationIcon: function haveNavigationIcon() {
        return !!this.icon || this.iconClasses;
      },
      naviconClasses: function naviconClasses() {
        return _objectSpread({
          'mdc-top-app-bar__navigation-icon': true,
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    },
    mounted: function mounted() {
      var _this = this;

      var adapter = {
        addClass: function addClass(className) {
          _this.$set(_this.rootClasses, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.rootClasses, className);
        },
        hasClass: function hasClass(className) {
          return _this.$refs.root.classList.contains(className);
        },
        setStyle: function setStyle(property, value) {
          _this.$set(_this.rootStyles, property, value);
        },
        getTopAppBarHeight: function getTopAppBarHeight() {
          return _this.$el.clientHeight;
        },
        registerNavigationIconInteractionHandler: function registerNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.addEventListener(type, handler);
          }
        },
        deregisterNavigationIconInteractionHandler: function deregisterNavigationIconInteractionHandler(type, handler) {
          if (_this.$refs.navigationIcon) {
            _this.$refs.navigationIcon.removeEventListener(type, handler);
          }
        },
        notifyNavigationIconClicked: function notifyNavigationIconClicked() {
          _this.$emit('nav');
        },
        registerScrollHandler: function registerScrollHandler(handler) {
          window.addEventListener('scroll', handler);
        },
        deregisterScrollHandler: function deregisterScrollHandler(handler) {
          window.removeEventListener('scroll', handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        getViewportScrollY: function getViewportScrollY() {
          return window.pageYOffset;
        },
        getTotalActionItems: function getTotalActionItems() {
          return _this.$refs.root.querySelectorAll(MDCTopAppBarFoundation.strings.ACTION_ITEM_SELECTOR).length;
        }
      };
      this.foundation = this.short ? new MDCShortTopAppBarFoundation(adapter) : this.fixed ? new MDCFixedTopAppBarFoundation(adapter) : new MDCTopAppBarFoundation(adapter);
      this.foundation.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation.destroy();
    }
  };

  /* script */
  const __vue_script__$15 = script$15;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$15.__file = "/ddata/extra/vma/components/top-app-bar/mdc-top-app-bar.vue";

  /* template */
  var __vue_render__$12 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "header",
      _vm._g(
        { ref: "root", class: _vm.rootClasses, style: _vm.rootStyles },
        _vm.$listeners
      ),
      [
        _c("div", { staticClass: "mdc-top-app-bar__row" }, [
          _c(
            "section",
            {
              staticClass:
                "mdc-top-app-bar__section mdc-top-app-bar__section--align-start"
            },
            [
              _vm.haveNavigationIcon
                ? _c(
                    "button",
                    _vm._g(
                      { ref: "navigationIcon", class: _vm.naviconClasses },
                      _vm.listeners
                    ),
                    [_vm._v("\n        " + _vm._s(_vm.icon) + "\n      ")]
                  )
                : _vm._e(),
              _vm._v(" "),
              !!_vm.title
                ? _c("span", { staticClass: "mdc-top-app-bar__title" }, [
                    _vm._v(_vm._s(_vm.title))
                  ])
                : _vm._e()
            ]
          ),
          _vm._v(" "),
          _vm.$slots.default
            ? _c(
                "section",
                {
                  staticClass:
                    "mdc-top-app-bar__section mdc-top-app-bar__section--align-end"
                },
                [_vm._t("default")],
                2
              )
            : _vm._e()
        ]),
        _vm._v(" "),
        _vm._t("tabs")
      ],
      2
    )
  };
  var __vue_staticRenderFns__$12 = [];
  __vue_render__$12._withStripped = true;

    /* style */
    const __vue_inject_styles__$15 = undefined;
    /* scoped */
    const __vue_scope_id__$15 = undefined;
    /* module identifier */
    const __vue_module_identifier__$15 = undefined;
    /* functional template */
    const __vue_is_functional_template__$15 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTopAppBar = normalizeComponent(
      { render: __vue_render__$12, staticRenderFns: __vue_staticRenderFns__$12 },
      __vue_inject_styles__$15,
      __vue_script__$15,
      __vue_scope_id__$15,
      __vue_is_functional_template__$15,
      __vue_module_identifier__$15,
      undefined,
      undefined
    );

  var script$16 = {
    name: 'mdc-top-app-bar-action',
    mixins: [DispatchEventMixin, RippleMixin],
    props: {
      icon: String,
      iconClasses: Object
    },
    computed: {
      actioniconClasses: function actioniconClasses() {
        return _objectSpread({
          'material-icons': !!this.icon
        }, this.iconClasses);
      }
    }
  };

  /* script */
  const __vue_script__$16 = script$16;
  // For security concerns, we use only base name in production mode. See https://github.com/vuejs/rollup-plugin-vue/issues/258
  script$16.__file = "/ddata/extra/vma/components/top-app-bar/mdc-top-app-bar-action.vue";

  /* template */
  var __vue_render__$13 = function() {
    var _vm = this;
    var _h = _vm.$createElement;
    var _c = _vm._self._c || _h;
    return _c(
      "a",
      _vm._g(
        {
          staticClass:
            "mdc-top-app-bar-action mdc-top-app-bar--action mdc-top-app-bar__action-item",
          class: _vm.actioniconClasses,
          attrs: { href: "#" }
        },
        _vm.listeners
      ),
      [_vm._t("default", [_vm._v(_vm._s(_vm.icon))])],
      2
    )
  };
  var __vue_staticRenderFns__$13 = [];
  __vue_render__$13._withStripped = true;

    /* style */
    const __vue_inject_styles__$16 = undefined;
    /* scoped */
    const __vue_scope_id__$16 = undefined;
    /* module identifier */
    const __vue_module_identifier__$16 = undefined;
    /* functional template */
    const __vue_is_functional_template__$16 = false;
    /* style inject */
    
    /* style inject SSR */
    

    
    var mdcTopAppBarAction = normalizeComponent(
      { render: __vue_render__$13, staticRenderFns: __vue_staticRenderFns__$13 },
      __vue_inject_styles__$16,
      __vue_script__$16,
      __vue_scope_id__$16,
      __vue_is_functional_template__$16,
      __vue_module_identifier__$16,
      undefined,
      undefined
    );

  var VueMDCTopAppBar = BasePlugin({
    mdcTopAppBar: mdcTopAppBar,
    mdcTopAppBarAction: mdcTopAppBarAction
  });

  var typos = ['headline1', 'headline2', 'headline3', 'headline4', 'headline5', 'headline6', 'subtitle1', 'subtitle2', 'body1', 'body2', 'caption', 'button', 'overline'];
  var mdcTypoMixin = function mdcTypoMixin(name) {
    return {
      render: function render(createElement) {
        var _class;

        return createElement(this.tag, {
          class: (_class = {
            'mdc-typo': true
          }, _defineProperty(_class, name, true), _defineProperty(_class, "mdc-typography--".concat(this.typo), true), _class),
          attrs: this.$attrs,
          on: this.$listeners
        }, this.$slots.default);
      }
    };
  };
  function mdcTypoPropMixin(defaultTag, defaultTypo, validTypos) {
    return {
      props: {
        tag: {
          type: String,
          default: defaultTag
        },
        typo: {
          type: String,
          default: defaultTypo,
          validator: function validator(value) {
            return validTypos.indexOf(value) !== -1;
          }
        }
      }
    };
  }
  var mdcTextSection = {
    name: 'mdc-text-section',
    props: {
      tag: {
        type: String,
        default: 'section'
      }
    },
    render: function render(createElement) {
      return createElement(this.tag, {
        class: {
          'mdc-typography': true,
          'mdc-text-section': true
        },
        attrs: this.$attrs,
        on: this.$listeners
      }, this.$slots.default);
    }
  };
  var mdcText = {
    name: 'mdc-text',
    mixins: [mdcTypoMixin('mdc-text'), mdcTypoPropMixin('p', 'body1', typos)]
  };
  var mdcDisplay = {
    name: 'mdc-display',
    mixins: [mdcTypoMixin('mdc-display'), mdcTypoPropMixin('h1', 'headline4', ['headline4', 'headline3', 'headline2', 'headline1'])]
  };
  var mdcHeadline = {
    name: 'mdc-headline',
    mixins: [mdcTypoMixin('mdc-headline'), mdcTypoPropMixin('h2', 'headline5', ['headline5'])]
  };
  var mdcTitle = {
    name: 'mdc-title',
    mixins: [mdcTypoMixin('mdc-title'), mdcTypoPropMixin('h3', 'headline6', ['headline6'])]
  };
  var mdcSubHeading = {
    name: 'mdc-subheading',
    mixins: [mdcTypoMixin('mdc-subheading'), mdcTypoPropMixin('h4', 'subtitle2', ['subtitle1', 'subtitle2'])]
  };
  var mdcBody = {
    name: 'mdc-body',
    mixins: [mdcTypoMixin('mdc-body'), mdcTypoPropMixin('p', 'body1', ['body1', 'body2'])]
  };
  var mdcCaption = {
    name: 'mdc-caption',
    mixins: [mdcTypoMixin('mdc-caption'), mdcTypoPropMixin('span', 'caption', ['caption'])]
  };

  var VueMDCTypography = BasePlugin({
    mdcTextSection: mdcTextSection,
    mdcText: mdcText,
    mdcBody: mdcBody,
    mdcCaption: mdcCaption,
    mdcDisplay: mdcDisplay,
    mdcHeadline: mdcHeadline,
    mdcSubHeading: mdcSubHeading,
    mdcTitle: mdcTitle
  });

  //
  var plugin = {
    version: '0.19.0-beta',
    install: function install(vm) {
      vm.use(VueMDCButton);
      vm.use(VueMDCCard);
      vm.use(VueMDCCheckbox);
      vm.use(VueMDCChipSet);
      vm.use(VueMDCElevation);
      vm.use(VueMDCDialog);
      vm.use(VueMDCDrawer);
      vm.use(VueMDCElevation);
      vm.use(VueMDCFab);
      vm.use(VueMDCGridList);
      vm.use(VueMDCIcon);
      vm.use(VueMDCIconButton);
      vm.use(VueMDCIconToggle);
      vm.use(VueMDCLayoutApp);
      vm.use(VueMDCLayoutGrid);
      vm.use(VueMDCLinearProgress);
      vm.use(VueMDCList);
      vm.use(VueMDCMenu);
      vm.use(VueMDCRadio);
      vm.use(VueMDCRipple);
      vm.use(VueMDCSelect);
      vm.use(VueMDCSlider);
      vm.use(VueMDCSnackbar);
      vm.use(VueMDCSwitch);
      vm.use(VueMDCTabs);
      vm.use(VueMDCTextfield);
      vm.use(VueMDCTheme);
      vm.use(VueMDCToolbar);
      vm.use(VueMDCTopAppBar);
      vm.use(VueMDCTypography);
    }
  };

  autoInit(plugin);

  return plugin;

}));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnVlLW1kYy1hZGFwdGVyLmpzIiwic291cmNlcyI6WyIuLi9jb21wb25lbnRzL2Jhc2UvYXBwbHktcGFzc2l2ZS5qcyIsIi4uL2NvbXBvbmVudHMvYmFzZS9hdXRvLWluaXQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvYmFzZS1wbHVnaW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWVsZW1lbnQuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWxpbmsuanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWV2ZW50LmpzIiwiLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1idXR0b24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvY3VzdG9tLWljb24uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZXZlbnQtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvZGlzcGF0Y2gtZm9jdXMtbWl4aW4uanMiLCIuLi9jb21wb25lbnRzL2Jhc2UvdW5pcXVlaWQtbWl4aW4uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9jb21wb25lbnQuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUtYmFzZS5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL21kYy1yaXBwbGUudnVlIiwiLi4vbm9kZV9tb2R1bGVzL3Z1ZS1ydW50aW1lLWhlbHBlcnMvbm9ybWFsaXplLWNvbXBvbmVudC5qcyIsIi4uL2NvbXBvbmVudHMvcmlwcGxlL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9idXR0b24vbWRjLWJ1dHRvbi1iYXNlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvYnV0dG9uL21kYy1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9idXR0b24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1tZWRpYS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL2NhcmQvbWRjLWNhcmQtc3VidGl0bGUudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLXRleHQudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9tZGMtY2FyZC1hY3Rpb24taWNvbnMudnVlIiwiLi4vY29tcG9uZW50cy9jYXJkL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvY2FyZC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoZWNrYm94L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hlY2tib3gvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9mb3JtLWZpZWxkL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L21kYy1jaGVja2JveC52dWUiLCIuLi9jb21wb25lbnRzL2NoZWNrYm94L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2NoaXBzL2NoaXAvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL2NoaXBzL21kYy1jaGlwLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvY2hpcHMvY2hpcC1zZXQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9jaGlwcy9tZGMtY2hpcC1zZXQudnVlIiwiLi4vY29tcG9uZW50cy9jaGlwcy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RpYWxvZy9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RpYWxvZy9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL3h0ZW5kL2ltbXV0YWJsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZGlhbG9nL25vZGVfbW9kdWxlcy9mb2N1cy10cmFwL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kaWFsb2cvdXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZG9tL3BvbnlmaWxsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2RpYWxvZy9tZGMtZGlhbG9nLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZGlhbG9nL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL2Rpc21pc3NpYmxlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9tb2RhbC9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saXN0L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpc3QvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saXN0L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpc3QvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWl0ZW0udnVlIiwiLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZHJhd2VyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9lbGV2YXRpb24vbWRjLWVsZXZhdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL2VsZXZhdGlvbi9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZmFiL21kYy1mYWIudnVlIiwiLi4vY29tcG9uZW50cy9mYWIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2dyaWQtbGlzdC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2dyaWQtbGlzdC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9ncmlkLWxpc3QvbWRjLWdyaWQtbGlzdC52dWUiLCIuLi9jb21wb25lbnRzL2dyaWQtbGlzdC9tZGMtZ3JpZC10aWxlLnZ1ZSIsIi4uL2NvbXBvbmVudHMvZ3JpZC1saXN0L2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9pY29uL21kYy1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvaWNvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi1idXR0b24vYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi1idXR0b24vY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLWJ1dHRvbi9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9pY29uLWJ1dHRvbi9tZGMtaWNvbi1idXR0b24udnVlIiwiLi4vY29tcG9uZW50cy9pY29uLWJ1dHRvbi9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi10b2dnbGUvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvaWNvbi10b2dnbGUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9pY29uLXRvZ2dsZS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9pY29uLXRvZ2dsZS9tZGMtaWNvbi10b2dnbGUudnVlIiwiLi4vY29tcG9uZW50cy9pY29uLXRvZ2dsZS9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvbGF5b3V0LWFwcC9tZGMtbGF5b3V0LWFwcC52dWUiLCIuLi9jb21wb25lbnRzL2xheW91dC1hcHAvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2xheW91dC1ncmlkL21kYy1sYXlvdXQtZ3JpZC52dWUiLCIuLi9jb21wb25lbnRzL2xheW91dC1ncmlkL21kYy1sYXlvdXQtY2VsbC52dWUiLCIuLi9jb21wb25lbnRzL2xheW91dC1ncmlkL21kYy1sYXlvdXQtaW5uZXItZ3JpZC52dWUiLCIuLi9jb21wb25lbnRzL2xheW91dC1ncmlkL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvbGluZWFyLXByb2dyZXNzL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlIiwiLi4vY29tcG9uZW50cy9saW5lYXItcHJvZ3Jlc3MvaW5kZXguanMiLCIuLi9jb21wb25lbnRzL2xpc3QvbWRjLWxpc3QudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWl0ZW0udnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLnZ1ZSIsIi4uL2NvbXBvbmVudHMvbGlzdC9tZGMtbGlzdC1ncm91cC1oZWFkZXIudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L21kYy1saXN0LWdyb3VwLWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9saXN0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51L2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9tZW51LXN1cmZhY2UvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS1zdXJmYWNlL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbWVudS1zdXJmYWNlL2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvbWVudS9tZGMtbWVudS52dWUiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL21lbnUtc3VyZmFjZS91dGlsLmpzIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LXN1cmZhY2UudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWl0ZW0udnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWRpdmlkZXIudnVlIiwiLi4vY29tcG9uZW50cy9tZW51L21kYy1tZW51LWFuY2hvci52dWUiLCIuLi9jb21wb25lbnRzL21lbnUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JhZGlvL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmFkaW8vZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvcmFkaW8vbWRjLXJhZGlvLnZ1ZSIsIi4uL2NvbXBvbmVudHMvcmFkaW8vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9pY29uL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9pY29uL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2ljb24vZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2ljb24vaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NlbGVjdC9oZWxwZXItdGV4dC9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvaGVscGVyLXRleHQvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvaGVscGVyLXRleHQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2hlbHBlci10ZXh0L2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zZWxlY3QvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2VsZWN0L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZmxvYXRpbmctbGFiZWwvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvc2VsZWN0L21kYy1zZWxlY3QtbGFiZWwudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9saW5lLXJpcHBsZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2xpbmUtcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9tZGMtc2VsZWN0LWxpbmUtcmlwcGxlLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvbm90Y2hlZC1vdXRsaW5lL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC1ub3RjaGVkLW91dGxpbmUudnVlIiwiLi4vY29tcG9uZW50cy9zZWxlY3QvbWRjLXNlbGVjdC52dWUiLCIuLi9jb21wb25lbnRzL3NlbGVjdC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3NsaWRlci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zbGlkZXIvbWRjLXNsaWRlci52dWUiLCIuLi9jb21wb25lbnRzL3NsaWRlci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc25hY2tiYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbmFja2Jhci9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zbmFja2Jhci9tZGMtc25hY2tiYXIudnVlIiwiLi4vY29tcG9uZW50cy9zbmFja2Jhci9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc3dpdGNoL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3N3aXRjaC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3N3aXRjaC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy9zd2l0Y2gvbWRjLXN3aXRjaC52dWUiLCIuLi9jb21wb25lbnRzL3N3aXRjaC9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90YWJzL21kYy10YWIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWJhci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3RhYnMvbWRjLXRhYi1iYXIudnVlIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL3J0bC1zY3JvbGxlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLXNjcm9sbGVyL3J0bC1kZWZhdWx0LXNjcm9sbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLW5lZ2F0aXZlLXNjcm9sbGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvcnRsLXJldmVyc2Utc2Nyb2xsZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RhYi1zY3JvbGxlci9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvdXRpbC5qcyIsIi4uL2NvbXBvbmVudHMvdGFicy9tZGMtdGFiLXNjcm9sbGVyLnZ1ZSIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9hZGFwdGVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGFiLWluZGljYXRvci9mb3VuZGF0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90YWItaW5kaWNhdG9yL3NsaWRpbmctZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdGFicy9tZGMtdGFiLWluZGljYXRvci52dWUiLCIuLi9jb21wb25lbnRzL3RhYnMvbWRjLXRhYi1yaXBwbGUudnVlIiwiLi4vY29tcG9uZW50cy90YWJzL2luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90ZXh0ZmllbGQvaGVscGVyLXRleHQvYWRhcHRlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2ljb24vZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdGV4dGZpZWxkL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9jb25zdGFudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RleHRmaWVsZC9mb3VuZGF0aW9uLmpzIiwiLi4vY29tcG9uZW50cy90ZXh0ZmllbGQvbWRjLXRleHRmaWVsZC52dWUiLCIuLi9jb21wb25lbnRzL3RleHRmaWVsZC9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvdGhlbWUvbWRjLXRoZW1lLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdGhlbWUvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3Rvb2xiYXIvY29uc3RhbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC90b29sYmFyL2ZvdW5kYXRpb24uanMiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXIudnVlIiwiLi4vY29tcG9uZW50cy90b29sYmFyL21kYy10b29sYmFyLXJvdy52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItc2VjdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItbWVudS1pY29uLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9vbGJhci9tZGMtdG9vbGJhci10aXRsZS52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvbWRjLXRvb2xiYXItaWNvbi52dWUiLCIuLi9jb21wb25lbnRzL3Rvb2xiYXIvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2FkYXB0ZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2NvbnN0YW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc3RhbmRhcmQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvdG9wLWFwcC1iYXIvZml4ZWQvZm91bmRhdGlvbi5qcyIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLnZ1ZSIsIi4uL2NvbXBvbmVudHMvdG9wLWFwcC1iYXIvbWRjLXRvcC1hcHAtYmFyLWFjdGlvbi52dWUiLCIuLi9jb21wb25lbnRzL3RvcC1hcHAtYmFyL2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L21kYy10eXBvZ3JhcGh5LmpzIiwiLi4vY29tcG9uZW50cy90eXBvZ3JhcGh5L2luZGV4LmpzIiwiLi4vY29tcG9uZW50cy9pbmRleC5qcyIsIi4uL2NvbXBvbmVudHMvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsibGV0IHN1cHBvcnRzUGFzc2l2ZV9cblxuLyoqXG4gKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuICogQHBhcmFtIHshV2luZG93PX0gZ2xvYmFsT2JqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBmb3JjZVJlZnJlc2hcbiAqIEByZXR1cm4ge2Jvb2xlYW58e3Bhc3NpdmU6IGJvb2xlYW59fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxPYmouZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIHtcbiAgICAgICAgZ2V0IHBhc3NpdmUoKSB7XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSB7IHBhc3NpdmU6IHRydWUgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vZW1wdHlcbiAgICB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWRcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfXG59XG4iLCJleHBvcnQgZnVuY3Rpb24gYXV0b0luaXQocGx1Z2luKSB7XG4gIC8vIEF1dG8taW5zdGFsbFxuICBsZXQgX1Z1ZSA9IG51bGxcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgX1Z1ZSA9IHdpbmRvdy5WdWVcbiAgfSBlbHNlIGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8qZ2xvYmFsIGdsb2JhbCovXG4gICAgX1Z1ZSA9IGdsb2JhbC5WdWVcbiAgfVxuICBpZiAoX1Z1ZSkge1xuICAgIF9WdWUudXNlKHBsdWdpbilcbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIEJhc2VQbHVnaW4oY29tcG9uZW50cykge1xuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogdm0gPT4ge1xuICAgICAgZm9yIChsZXQga2V5IGluIGNvbXBvbmVudHMpIHtcbiAgICAgICAgbGV0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNba2V5XVxuICAgICAgICB2bS5jb21wb25lbnQoY29tcG9uZW50Lm5hbWUsIGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUVsZW1lbnQgPSB7XG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHJlbmRlcihjcmVhdGVFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICBjb250ZXh0LnByb3BzLmlzIHx8IGNvbnRleHQucHJvcHMudGFnIHx8ICdkaXYnLFxuICAgICAgY29udGV4dC5kYXRhLFxuICAgICAgY29udGV4dC5jaGlsZHJlblxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tRWxlbWVudE1peGluID0ge1xuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tRWxlbWVudFxuICB9XG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tTGluayA9IHtcbiAgbmFtZTogJ2N1c3RvbS1saW5rJyxcbiAgZnVuY3Rpb25hbDogdHJ1ZSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnYScgfSxcbiAgICBsaW5rOiBPYmplY3RcbiAgfSxcbiAgcmVuZGVyKGgsIGNvbnRleHQpIHtcbiAgICBsZXQgZWxlbWVudFxuICAgIGxldCBkYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgY29udGV4dC5kYXRhKVxuXG4gICAgaWYgKGNvbnRleHQucHJvcHMubGluayAmJiBjb250ZXh0LnBhcmVudC4kcm91dGVyKSB7XG4gICAgICAvLyByb3V0ZXItbGluayBjYXNlXG4gICAgICBlbGVtZW50ID0gY29udGV4dC5wYXJlbnQuJHJvb3QuJG9wdGlvbnMuY29tcG9uZW50c1sncm91dGVyLWxpbmsnXVxuICAgICAgZGF0YS5wcm9wcyA9IE9iamVjdC5hc3NpZ24oeyB0YWc6IGNvbnRleHQucHJvcHMudGFnIH0sIGNvbnRleHQucHJvcHMubGluaylcbiAgICAgIGlmIChkYXRhLm9uLmNsaWNrKSB7XG4gICAgICAgIGRhdGEubmF0aXZlT24gPSB7IGNsaWNrOiBkYXRhLm9uLmNsaWNrIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxlbWVudCBmYWxsYmFja1xuICAgICAgZWxlbWVudCA9IGNvbnRleHQucHJvcHMudGFnXG4gICAgfVxuXG4gICAgcmV0dXJuIGgoZWxlbWVudCwgZGF0YSwgY29udGV4dC5jaGlsZHJlbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgQ3VzdG9tTGlua01peGluID0ge1xuICBwcm9wczoge1xuICAgIHRvOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIGV4YWN0OiBCb29sZWFuLFxuICAgIGFwcGVuZDogQm9vbGVhbixcbiAgICByZXBsYWNlOiBCb29sZWFuLFxuICAgIGFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gICAgZXhhY3RBY3RpdmVDbGFzczogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluaygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMudG8gJiYge1xuICAgICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICAgIGV4YWN0OiB0aGlzLmV4YWN0LFxuICAgICAgICAgIGFwcGVuZDogdGhpcy5hcHBlbmQsXG4gICAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICAgIGFjdGl2ZUNsYXNzOiB0aGlzLmFjdGl2ZUNsYXNzLFxuICAgICAgICAgIGV4YWN0QWN0aXZlQ2xhc3M6IHRoaXMuZXhhY3RBY3RpdmVDbGFzc1xuICAgICAgICB9XG4gICAgICApXG4gICAgfVxuICB9LFxuICBjb21wb25lbnRzOiB7XG4gICAgQ3VzdG9tTGlua1xuICB9XG59XG4iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudChlbCwgZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgbGV0IGV2dFxuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpXG4gIH1cbiAgZWwuZGlzcGF0Y2hFdmVudChldnQpXG59XG4iLCJleHBvcnQgY29uc3QgQ3VzdG9tQnV0dG9uID0ge1xuICBuYW1lOiAnY3VzdG9tLWJ1dHRvbicsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgbGluazogT2JqZWN0XG4gIH0sXG4gIHJlbmRlcihoLCBjb250ZXh0KSB7XG4gICAgbGV0IGVsZW1lbnRcbiAgICBsZXQgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbnRleHQuZGF0YSlcblxuICAgIGlmIChjb250ZXh0LnByb3BzLmxpbmsgJiYgY29udGV4dC5wYXJlbnQuJHJvdXRlcikge1xuICAgICAgLy8gcm91dGVyLWxpbmsgY2FzZVxuICAgICAgZWxlbWVudCA9IGNvbnRleHQucGFyZW50LiRyb290LiRvcHRpb25zLmNvbXBvbmVudHNbJ3JvdXRlci1saW5rJ11cbiAgICAgIGRhdGEucHJvcHMgPSBPYmplY3QuYXNzaWduKHsgdGFnOiBjb250ZXh0LnByb3BzLnRhZyB9LCBjb250ZXh0LnByb3BzLmxpbmspXG4gICAgICBkYXRhLmF0dHJzLnJvbGUgPSAnYnV0dG9uJ1xuICAgICAgaWYgKGRhdGEub24uY2xpY2spIHtcbiAgICAgICAgZGF0YS5uYXRpdmVPbiA9IHsgY2xpY2s6IGRhdGEub24uY2xpY2sgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hdHRycyAmJiBkYXRhLmF0dHJzLmhyZWYpIHtcbiAgICAgIC8vIGhyZWYgY2FzZVxuICAgICAgZWxlbWVudCA9ICdhJ1xuICAgICAgZGF0YS5hdHRycy5yb2xlID0gJ2J1dHRvbidcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYnV0dG9uIGZhbGxiYWNrXG4gICAgICBlbGVtZW50ID0gJ2J1dHRvbidcbiAgICB9XG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21CdXR0b25NaXhpbiA9IHtcbiAgcHJvcHM6IHtcbiAgICBocmVmOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmdcbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaW5rKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgdGhpcy50byAmJiB7XG4gICAgICAgICAgdG86IHRoaXMudG8sXG4gICAgICAgICAgZXhhY3Q6IHRoaXMuZXhhY3QsXG4gICAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgICByZXBsYWNlOiB0aGlzLnJlcGxhY2UsXG4gICAgICAgICAgYWN0aXZlQ2xhc3M6IHRoaXMuYWN0aXZlQ2xhc3MsXG4gICAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzXG4gICAgICAgIH1cbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIGNvbXBvbmVudHM6IHtcbiAgICBDdXN0b21CdXR0b25cbiAgfVxufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RJY29uUHJvcChpY29uUHJvcCkge1xuICBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtYXRlcmlhbC1pY29ucyc6IHRydWUgfSxcbiAgICAgIGNvbnRlbnQ6IGljb25Qcm9wXG4gICAgfVxuICB9IGVsc2UgaWYgKGljb25Qcm9wIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogaWNvblByb3AucmVkdWNlKFxuICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW3ZhbHVlXTogdHJ1ZSB9KSxcbiAgICAgICAge31cbiAgICAgIClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGljb25Qcm9wID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiBpY29uUHJvcC5jbGFzc05hbWVcbiAgICAgICAgLnNwbGl0KCcgJylcbiAgICAgICAgLnJlZHVjZShcbiAgICAgICAgICAocmVzdWx0LCB2YWx1ZSkgPT4gT2JqZWN0LmFzc2lnbihyZXN1bHQsIHsgW3ZhbHVlXTogdHJ1ZSB9KSxcbiAgICAgICAgICB7fVxuICAgICAgICApLFxuICAgICAgY29udGVudDogaWNvblByb3AudGV4dENvbnRlbnRcbiAgICB9XG4gIH1cbn1cbiIsImV4cG9ydCBjb25zdCBEaXNwYXRjaEV2ZW50TWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgZXZlbnQ6IFN0cmluZyxcbiAgICAnZXZlbnQtdGFyZ2V0JzogT2JqZWN0LFxuICAgICdldmVudC1hcmdzJzogQXJyYXlcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGRpc3BhdGNoRXZlbnQoZXZ0KSB7XG4gICAgICBldnQgJiYgdGhpcy4kZW1pdChldnQudHlwZSwgZXZ0KVxuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdFxuICAgICAgICBsZXQgYXJncyA9IHRoaXMuZXZlbnRBcmdzIHx8IFtdXG4gICAgICAgIHRhcmdldC4kZW1pdCh0aGlzLmV2ZW50LCAuLi5hcmdzKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsaXN0ZW5lcnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi50aGlzLiRsaXN0ZW5lcnMsXG4gICAgICAgIGNsaWNrOiBlID0+IHRoaXMuZGlzcGF0Y2hFdmVudChlKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBoYXNGb2N1czogZmFsc2UgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAoKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSBmYWxzZVxuICAgIH0sXG4gICAgb25Gb2N1c0V2ZW50KCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBvbkJsdXJFdmVudCgpIHtcbiAgICAgIC8vIGRpc3BhdGNoIGFzeW5jIHRvIGxldCB0aW1lIHRvIG90aGVyIGZvY3VzIGV2ZW50IHRvIHByb3BhZ2F0ZVxuICAgICAgLy8gYWxzbyBmaWx0dXIgYmx1ciBpZiBtb3VzZWRvd25cbiAgICAgIHRoaXMuX2FjdGl2ZSB8fCBzZXRUaW1lb3V0KCgpID0+IHRoaXMuZGlzcGF0Y2hGb2N1c0V2ZW50KCksIDApXG4gICAgfSxcbiAgICBkaXNwYXRjaEZvY3VzRXZlbnQoKSB7XG4gICAgICBsZXQgaGFzRm9jdXMgPVxuICAgICAgICB0aGlzLiRlbCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fFxuICAgICAgICB0aGlzLiRlbC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KVxuICAgICAgaWYgKGhhc0ZvY3VzICE9IHRoaXMuaGFzRm9jdXMpIHtcbiAgICAgICAgdGhpcy4kZW1pdChoYXNGb2N1cyA/ICdmb2N1cycgOiAnYmx1cicpXG4gICAgICAgIHRoaXMuaGFzRm9jdXMgPSBoYXNGb2N1c1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLm9uRm9jdXNFdmVudClcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMub25CbHVyRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5vbk1vdXNlRG93bilcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5vbk1vdXNlVXApXG4gIH1cbn1cbiIsImNvbnN0IHNjb3BlID1cbiAgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTWF0aC5mbG9vcigweDEwMDAwMDAwKSkudG9TdHJpbmcoKSArICctJ1xuXG5leHBvcnQgY29uc3QgVk1BVW5pcXVlSWRNaXhpbiA9IHtcbiAgYmVmb3JlQ3JlYXRlKCkge1xuICAgIHRoaXMudm1hX3VpZF8gPSBzY29wZSArIHRoaXMuX3VpZFxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICovXG5jbGFzcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bXtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBldmVyeVxuICAgIC8vIENTUyBjbGFzcyB0aGUgZm91bmRhdGlvbiBjbGFzcyBuZWVkcyBhcyBhIHByb3BlcnR5LiBlLmcuIHtBQ1RJVkU6ICdtZGMtY29tcG9uZW50LS1hY3RpdmUnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gc2VtYW50aWMgc3RyaW5ncyBhcyBjb25zdGFudHMuIGUuZy4ge0FSSUFfUk9MRTogJ3RhYmxpc3QnfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW17bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gc2hvdWxkIGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZXR1cm4gYW4gb2JqZWN0IHdoaWNoIGV4cG9ydHMgYWxsXG4gICAgLy8gb2YgaXRzIHNlbWFudGljIG51bWJlcnMgYXMgY29uc3RhbnRzLiBlLmcuIHtBTklNQVRJT05fREVMQVlfTVM6IDM1MH1cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKiogQHJldHVybiB7IU9iamVjdH0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIG1heSBjaG9vc2UgdG8gaW1wbGVtZW50IHRoaXMgZ2V0dGVyIGluIG9yZGVyIHRvIHByb3ZpZGUgYSBjb252ZW5pZW50XG4gICAgLy8gd2F5IG9mIHZpZXdpbmcgdGhlIG5lY2Vzc2FyeSBtZXRob2RzIG9mIGFuIGFkYXB0ZXIuIEluIHRoZSBmdXR1cmUsIHRoaXMgY291bGQgYWxzbyBiZSB1c2VkIGZvciBhZGFwdGVyXG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICByZXR1cm4ge307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlciA9IHt9KSB7XG4gICAgLyoqIEBwcm90ZWN0ZWQgeyFBfSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGluaXRpYWxpemF0aW9uIHJvdXRpbmVzIChyZWdpc3RlcmluZyBldmVudHMsIGV0Yy4pXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gZGUtaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKGRlLXJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQHRlbXBsYXRlIEZcbiAqL1xuY2xhc3MgTURDQ29tcG9uZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0NvbXBvbmVudH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgLy8gU3ViY2xhc3NlcyB3aGljaCBleHRlbmQgTURDQmFzZSBzaG91bGQgcHJvdmlkZSBhbiBhdHRhY2hUbygpIG1ldGhvZCB0aGF0IHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZFxuICAgIC8vIHJldHVybnMgYW4gaW5zdGFudGlhdGVkIGNvbXBvbmVudCB3aXRoIGl0cyByb290IHNldCB0byB0aGF0IGVsZW1lbnQuIEFsc28gbm90ZSB0aGF0IGluIHRoZSBjYXNlcyBvZlxuICAgIC8vIHN1YmNsYXNzZXMsIGFuIGV4cGxpY2l0IGZvdW5kYXRpb24gY2xhc3Mgd2lsbCBub3QgaGF2ZSB0byBiZSBwYXNzZWQgaW47IGl0IHdpbGwgc2ltcGx5IGJlIGluaXRpYWxpemVkXG4gICAgLy8gZnJvbSBnZXREZWZhdWx0Rm91bmRhdGlvbigpLlxuICAgIHJldHVybiBuZXcgTURDQ29tcG9uZW50KHJvb3QsIG5ldyBNRENGb3VuZGF0aW9uKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHBhcmFtIHtGPX0gZm91bmRhdGlvblxuICAgKiBAcGFyYW0gey4uLj99IGFyZ3NcbiAgICovXG4gIGNvbnN0cnVjdG9yKHJvb3QsIGZvdW5kYXRpb24gPSB1bmRlZmluZWQsIC4uLmFyZ3MpIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG4gICAgdGhpcy5yb290XyA9IHJvb3Q7XG4gICAgdGhpcy5pbml0aWFsaXplKC4uLmFyZ3MpO1xuICAgIC8vIE5vdGUgdGhhdCB3ZSBpbml0aWFsaXplIGZvdW5kYXRpb24gaGVyZSBhbmQgbm90IHdpdGhpbiB0aGUgY29uc3RydWN0b3IncyBkZWZhdWx0IHBhcmFtIHNvIHRoYXRcbiAgICAvLyB0aGlzLnJvb3RfIGlzIGRlZmluZWQgYW5kIGNhbiBiZSB1c2VkIHdpdGhpbiB0aGUgZm91bmRhdGlvbiBjbGFzcy5cbiAgICAvKiogQHByb3RlY3RlZCB7IUZ9ICovXG4gICAgdGhpcy5mb3VuZGF0aW9uXyA9IGZvdW5kYXRpb24gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSA6IGZvdW5kYXRpb247XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5pbml0KCk7XG4gICAgdGhpcy5pbml0aWFsU3luY1dpdGhET00oKTtcbiAgfVxuXG4gIGluaXRpYWxpemUoLyogLi4uYXJncyAqLykge1xuICAgIC8vIFN1YmNsYXNzZXMgY2FuIG92ZXJyaWRlIHRoaXMgdG8gZG8gYW55IGFkZGl0aW9uYWwgc2V0dXAgd29yayB0aGF0IHdvdWxkIGJlIGNvbnNpZGVyZWQgcGFydCBvZiBhXG4gICAgLy8gXCJjb25zdHJ1Y3RvclwiLiBFc3NlbnRpYWxseSwgaXQgaXMgYSBob29rIGludG8gdGhlIHBhcmVudCBjb25zdHJ1Y3RvciBiZWZvcmUgdGhlIGZvdW5kYXRpb24gaXNcbiAgICAvLyBpbml0aWFsaXplZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGJlc2lkZXMgcm9vdCBhbmQgZm91bmRhdGlvbiB3aWxsIGJlIHBhc3NlZCBpbiBoZXJlLlxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFGfSBmb3VuZGF0aW9uXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICAvLyBTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCBmb3VuZGF0aW9uIGNsYXNzIGZvciB0aGVcbiAgICAvLyBjb21wb25lbnQuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJjbGFzc2VzIG11c3Qgb3ZlcnJpZGUgZ2V0RGVmYXVsdEZvdW5kYXRpb24gdG8gcmV0dXJuIGEgcHJvcGVybHkgY29uZmlndXJlZCAnICtcbiAgICAgICdmb3VuZGF0aW9uIGNsYXNzJyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhleSBuZWVkIHRvIHBlcmZvcm0gd29yayB0byBzeW5jaHJvbml6ZSB3aXRoIGEgaG9zdCBET01cbiAgICAvLyBvYmplY3QuIEFuIGV4YW1wbGUgb2YgdGhpcyB3b3VsZCBiZSBhIGZvcm0gY29udHJvbCB3cmFwcGVyIHRoYXQgbmVlZHMgdG8gc3luY2hyb25pemUgaXRzIGludGVybmFsIHN0YXRlXG4gICAgLy8gdG8gc29tZSBwcm9wZXJ0eSBvciBhdHRyaWJ1dGUgb2YgdGhlIGhvc3QgRE9NLiBQbGVhc2Ugbm90ZTogdGhpcyBpcyAqbm90KiB0aGUgcGxhY2UgdG8gcGVyZm9ybSBET01cbiAgICAvLyByZWFkcy93cml0ZXMgdGhhdCB3b3VsZCBjYXVzZSBsYXlvdXQgLyBwYWludCwgYXMgdGhpcyBpcyBjYWxsZWQgc3luY2hyb25vdXNseSBmcm9tIHdpdGhpbiB0aGUgY29uc3RydWN0b3IuXG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbWF5IGltcGxlbWVudCB0aGlzIG1ldGhvZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMgLyBkZXJlZ2lzdGVyIGFueSBsaXN0ZW5lcnMgdGhleSBoYXZlXG4gICAgLy8gYXR0YWNoZWQuIEFuIGV4YW1wbGUgb2YgdGhpcyBtaWdodCBiZSBkZXJlZ2lzdGVyaW5nIGEgcmVzaXplIGV2ZW50IGZyb20gdGhlIHdpbmRvdyBvYmplY3QuXG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogV3JhcHBlciBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBjb21wb25lbnQncyByb290IGVsZW1lbnQuIFRoaXMgaXMgbW9zdCB1c2VmdWwgd2hlblxuICAgKiBsaXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBsaXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIHVubGlzdGVuaW5nIGZvciBjdXN0b20gZXZlbnRzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgdW5saXN0ZW4oZXZ0VHlwZSwgaGFuZGxlcikge1xuICAgIHRoaXMucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaXJlcyBhIGNyb3NzLWJyb3dzZXItY29tcGF0aWJsZSBjdXN0b20gZXZlbnQgZnJvbSB0aGUgY29tcG9uZW50IHJvb3Qgb2YgdGhlIGdpdmVuIHR5cGUsXG4gICAqIHdpdGggdGhlIGdpdmVuIGRhdGEuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gZXZ0RGF0YVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRCdWJibGVcbiAgICovXG4gIGVtaXQoZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgICBsZXQgZXZ0O1xuICAgIGlmICh0eXBlb2YgQ3VzdG9tRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgICAgYnViYmxlczogc2hvdWxkQnViYmxlLFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICAgICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLnJvb3RfLmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDb21wb25lbnQ7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufCFFdmVudExpc3RlbmVyT3B0aW9uc31cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGlzU3VwcG9ydGVkO1xuICAgICAgfX0pO1xuICAgIH0gY2F0Y2ggKGUpIHsgfVxuXG4gICAgc3VwcG9ydHNQYXNzaXZlXyA9IGlzU3VwcG9ydGVkO1xuICB9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZV9cbiAgICA/IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJPcHRpb25zfSAqLyAoe3Bhc3NpdmU6IHRydWV9KVxuICAgIDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnRQcm90b3R5cGUpIHtcbiAgLyoqXG4gICAqIE9yZGVyIGlzIGltcG9ydGFudCBiZWNhdXNlIHdlIHJldHVybiB0aGUgZmlyc3QgZXhpc3RpbmcgbWV0aG9kIHdlIGZpbmQuXG4gICAqIERvIG5vdCBjaGFuZ2UgdGhlIG9yZGVyIG9mIHRoZSBpdGVtcyBpbiB0aGUgYmVsb3cgYXJyYXkuXG4gICAqL1xuICBjb25zdCBtYXRjaGVzTWV0aG9kcyA9IFsnbWF0Y2hlcycsICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InXTtcbiAgbGV0IG1ldGhvZCA9ICdtYXRjaGVzJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVzTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG1hdGNoZXNNZXRob2QgPSBtYXRjaGVzTWV0aG9kc1tpXTtcbiAgICBpZiAobWF0Y2hlc01ldGhvZCBpbiBIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICAgICAgbWV0aG9kID0gbWF0Y2hlc01ldGhvZDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZXRob2Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHshRXZlbnR9IGV2XG4gKiBAcGFyYW0ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19IHBhZ2VPZmZzZXRcbiAqIEBwYXJhbSB7IUNsaWVudFJlY3R9IGNsaWVudFJlY3RcbiAqIEByZXR1cm4ge3t4OiBudW1iZXIsIHk6IG51bWJlcn19XG4gKi9cbmZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhldiwgcGFnZU9mZnNldCwgY2xpZW50UmVjdCkge1xuICBjb25zdCB7eCwgeX0gPSBwYWdlT2Zmc2V0O1xuICBjb25zdCBkb2N1bWVudFggPSB4ICsgY2xpZW50UmVjdC5sZWZ0O1xuICBjb25zdCBkb2N1bWVudFkgPSB5ICsgY2xpZW50UmVjdC50b3A7XG5cbiAgbGV0IG5vcm1hbGl6ZWRYO1xuICBsZXQgbm9ybWFsaXplZFk7XG4gIC8vIERldGVybWluZSB0b3VjaCBwb2ludCByZWxhdGl2ZSB0byB0aGUgcmlwcGxlIGNvbnRhaW5lci5cbiAgaWYgKGV2LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIGV2ID0gLyoqIEB0eXBlIHshVG91Y2hFdmVudH0gKi8gKGV2KTtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgZXYgPSAvKiogQHR5cGUgeyFNb3VzZUV2ZW50fSAqLyAoZXYpO1xuICAgIG5vcm1hbGl6ZWRYID0gZXYucGFnZVggLSBkb2N1bWVudFg7XG4gICAgbm9ybWFsaXplZFkgPSBldi5wYWdlWSAtIGRvY3VtZW50WTtcbiAgfVxuXG4gIHJldHVybiB7eDogbm9ybWFsaXplZFgsIHk6IG5vcm1hbGl6ZWRZfTtcbn1cblxuZXhwb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgYXBwbHlQYXNzaXZlLCBnZXRNYXRjaGVzUHJvcGVydHksIGdldE5vcm1hbGl6ZWRFdmVudENvb3Jkc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge2dldE5vcm1hbGl6ZWRFdmVudENvb3Jkc30gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogKCFFdmVudHx1bmRlZmluZWQpLFxuICogICBpc1Byb2dyYW1tYXRpYzogKGJvb2xlYW58dW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IEFjdGl2YXRpb25TdGF0ZVR5cGU7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZGVhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBmb2N1czogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBibHVyOiAoc3RyaW5nfHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lckluZm9UeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQpLFxuICogICBkZWFjdGl2YXRlOiBmdW5jdGlvbighRXZlbnQ9KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHg6IG51bWJlcixcbiAqICAgeTogbnVtYmVyXG4gKiB9fVxuICovXG5sZXQgUG9pbnRUeXBlO1xuXG4vLyBBY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIHRoZSByb290IGVsZW1lbnQgb2YgZWFjaCBpbnN0YW5jZSBmb3IgYWN0aXZhdGlvblxuY29uc3QgQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hzdGFydCcsICdwb2ludGVyZG93bicsICdtb3VzZWRvd24nLCAna2V5ZG93biddO1xuXG4vLyBEZWFjdGl2YXRpb24gZXZlbnRzIHJlZ2lzdGVyZWQgb24gZG9jdW1lbnRFbGVtZW50IHdoZW4gYSBwb2ludGVyLXJlbGF0ZWQgZG93biBldmVudCBvY2N1cnNcbmNvbnN0IFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTID0gWyd0b3VjaGVuZCcsICdwb2ludGVydXAnLCAnbW91c2V1cCcsICdjb250ZXh0bWVudSddO1xuXG4vLyBUcmFja3MgYWN0aXZhdGlvbnMgdGhhdCBoYXZlIG9jY3VycmVkIG9uIHRoZSBjdXJyZW50IGZyYW1lLCB0byBhdm9pZCBzaW11bHRhbmVvdXMgbmVzdGVkIGFjdGl2YXRpb25zXG4vKiogQHR5cGUgeyFBcnJheTwhRXZlbnRUYXJnZXQ+fSAqL1xubGV0IGFjdGl2YXRlZFRhcmdldHMgPSBbXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmlwcGxlQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYnJvd3NlclN1cHBvcnRzQ3NzVmFyczogKCkgPT4gLyogYm9vbGVhbiAtIGNhY2hlZCAqLyB7fSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKC8qIHRhcmdldDogIUV2ZW50VGFyZ2V0ICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YXJOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gLyogQ2xpZW50UmVjdCAqLyB7fSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+IC8qIHt4OiBudW1iZXIsIHk6IG51bWJlcn0gKi8ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1JpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUNsaWVudFJlY3R9ICovXG4gICAgdGhpcy5mcmFtZV8gPSAvKiogQHR5cGUgeyFDbGllbnRSZWN0fSAqLyAoe3dpZHRoOiAwLCBoZWlnaHQ6IDB9KTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5tYXhSYWRpdXNfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KX0gKi9cbiAgICB0aGlzLmFjdGl2YXRlSGFuZGxlcl8gPSAoZSkgPT4gdGhpcy5hY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudD0pfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5kZWFjdGl2YXRlXygpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQ9KX0gKi9cbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzKCk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudD0pfSAqL1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyKCk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7e2xlZnQ6IG51bWJlciwgdG9wOm51bWJlcn19ICovXG4gICAgdGhpcy51bmJvdW5kZWRDb29yZHNfID0ge1xuICAgICAgbGVmdDogMCxcbiAgICAgIHRvcDogMCxcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ1NjYWxlXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSB0cnVlO1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9O1xuXG4gICAgLyoqIEBwcml2YXRlIHshRXZlbnR8dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfO1xuICB9XG5cbiAgLyoqXG4gICAqIFdlIGNvbXB1dGUgdGhpcyBwcm9wZXJ0eSBzbyB0aGF0IHdlIGFyZSBub3QgcXVlcnlpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWVudFxuICAgKiB1bnRpbCB0aGUgcG9pbnQgaW4gdGltZSB3aGVyZSB0aGUgZm91bmRhdGlvbiByZXF1ZXN0cyBpdC4gVGhpcyBwcmV2ZW50cyBzY2VuYXJpb3Mgd2hlcmVcbiAgICogY2xpZW50LXNpZGUgZmVhdHVyZS1kZXRlY3Rpb24gbWF5IGhhcHBlbiB0b28gZWFybHksIHN1Y2ggYXMgd2hlbiBjb21wb25lbnRzIGFyZSByZW5kZXJlZCBvbiB0aGUgc2VydmVyXG4gICAqIGFuZCB0aGVuIGluaXRpYWxpemVkIGF0IG1vdW50IHRpbWUgb24gdGhlIGNsaWVudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN1cHBvcnRzUHJlc3NSaXBwbGVfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQWN0aXZhdGlvblN0YXRlVHlwZX1cbiAgICovXG4gIGRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpc0FjdGl2YXRlZDogZmFsc2UsXG4gICAgICBoYXNEZWFjdGl2YXRpb25VWFJ1bjogZmFsc2UsXG4gICAgICB3YXNBY3RpdmF0ZWRCeVBvaW50ZXI6IGZhbHNlLFxuICAgICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IGZhbHNlLFxuICAgICAgYWN0aXZhdGlvbkV2ZW50OiB1bmRlZmluZWQsXG4gICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgaW5pdCgpIHtcbiAgICBjb25zdCBzdXBwb3J0c1ByZXNzUmlwcGxlID0gdGhpcy5zdXBwb3J0c1ByZXNzUmlwcGxlXygpO1xuXG4gICAgdGhpcy5yZWdpc3RlclJvb3RIYW5kbGVyc18oc3VwcG9ydHNQcmVzc1JpcHBsZSk7XG5cbiAgICBpZiAoc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgICAgY29uc3Qge1JPT1QsIFVOQk9VTkRFRH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFJPT1QpO1xuICAgICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICAgIC8vIFVuYm91bmRlZCByaXBwbGVzIG5lZWQgbGF5b3V0IGxvZ2ljIGFwcGxpZWQgaW1tZWRpYXRlbHkgdG8gc2V0IGNvb3JkaW5hdGVzIGZvciBib3RoIHNoYWRlIGFuZCByaXBwbGVcbiAgICAgICAgICB0aGlzLmxheW91dEludGVybmFsXygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuc3VwcG9ydHNQcmVzc1JpcHBsZV8oKSkge1xuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkdfQUNUSVZBVElPTik7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IDA7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHtST09ULCBVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgICB0aGlzLnJlbW92ZUNzc1ZhcnNfKCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzdXBwb3J0c1ByZXNzUmlwcGxlIFBhc3NlZCBmcm9tIGluaXQgdG8gc2F2ZSBhIHJlZHVuZGFudCBmdW5jdGlvbiBjYWxsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oc3VwcG9ydHNQcmVzc1JpcHBsZSkge1xuICAgIGlmIChzdXBwb3J0c1ByZXNzUmlwcGxlKSB7XG4gICAgICBBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKSB7XG4gICAgaWYgKGUudHlwZSA9PT0gJ2tleWRvd24nKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCkge1xuICAgIEFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIFBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZW1vdmVDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7c3RyaW5nc30gPSBNRENSaXBwbGVGb3VuZGF0aW9uO1xuICAgIE9iamVjdC5rZXlzKHN0cmluZ3MpLmZvckVhY2goKGspID0+IHtcbiAgICAgIGlmIChrLmluZGV4T2YoJ1ZBUl8nKSA9PT0gMCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKHN0cmluZ3Nba10sIG51bGwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50PX0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWN0aXZhdGVfKGUpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VEaXNhYmxlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aXZhdGlvblN0YXRlID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBdm9pZCByZWFjdGluZyB0byBmb2xsb3ctb24gZXZlbnRzIGZpcmVkIGJ5IHRvdWNoIGRldmljZSBhZnRlciBhbiBhbHJlYWR5LXByb2Nlc3NlZCB1c2VyIGludGVyYWN0aW9uXG4gICAgY29uc3QgcHJldmlvdXNBY3RpdmF0aW9uRXZlbnQgPSB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XztcbiAgICBjb25zdCBpc1NhbWVJbnRlcmFjdGlvbiA9IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ICYmIGUgIT09IHVuZGVmaW5lZCAmJiBwcmV2aW91c0FjdGl2YXRpb25FdmVudC50eXBlICE9PSBlLnR5cGU7XG4gICAgaWYgKGlzU2FtZUludGVyYWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkID0gdHJ1ZTtcbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMgPSBlID09PSB1bmRlZmluZWQ7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogZSAhPT0gdW5kZWZpbmVkICYmIChcbiAgICAgIGUudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZS50eXBlID09PSAndG91Y2hzdGFydCcgfHwgZS50eXBlID09PSAncG9pbnRlcmRvd24nXG4gICAgKTtcblxuICAgIGNvbnN0IGhhc0FjdGl2YXRlZENoaWxkID0gZSAhPT0gdW5kZWZpbmVkICYmIGFjdGl2YXRlZFRhcmdldHMubGVuZ3RoID4gMCAmJiBhY3RpdmF0ZWRUYXJnZXRzLnNvbWUoXG4gICAgICAodGFyZ2V0KSA9PiB0aGlzLmFkYXB0ZXJfLmNvbnRhaW5zRXZlbnRUYXJnZXQodGFyZ2V0KSk7XG4gICAgaWYgKGhhc0FjdGl2YXRlZENoaWxkKSB7XG4gICAgICAvLyBJbW1lZGlhdGVseSByZXNldCBhY3RpdmF0aW9uIHN0YXRlLCB3aGlsZSBwcmVzZXJ2aW5nIGxvZ2ljIHRoYXQgcHJldmVudHMgdG91Y2ggZm9sbG93LW9uIGV2ZW50c1xuICAgICAgdGhpcy5yZXNldEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUgPSB0aGlzLmNoZWNrRWxlbWVudE1hZGVBY3RpdmVfKGUpO1xuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIFJlc2V0IGFycmF5IG9uIG5leHQgZnJhbWUgYWZ0ZXIgdGhlIGN1cnJlbnQgZXZlbnQgaGFzIGhhZCBhIGNoYW5jZSB0byBidWJibGUgdG8gcHJldmVudCBhbmNlc3RvciByaXBwbGVzXG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlICYmIGUgIT09IHVuZGVmaW5lZCAmJiAoZS5rZXkgPT09ICcgJyB8fCBlLmtleUNvZGUgPT09IDMyKSkge1xuICAgICAgICAvLyBJZiBzcGFjZSB3YXMgcHJlc3NlZCwgdHJ5IGFnYWluIHdpdGhpbiBhbiByQUYgY2FsbCB0byBkZXRlY3QgOmFjdGl2ZSwgYmVjYXVzZSBkaWZmZXJlbnQgVUFzIHJlcG9ydFxuICAgICAgICAvLyBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluIGV2ZW50IGhhbmRsaW5nIGNvZGU6XG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjM1OTcxXG4gICAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgICAvLyBXZSB0cnkgZmlyc3Qgb3V0c2lkZSByQUYgdG8gc3VwcG9ydCBFZGdlLCB3aGljaCBkb2VzIG5vdCBleGhpYml0IHRoaXMgcHJvYmxlbSwgYnV0IHdpbGwgY3Jhc2ggaWYgYSBDU1NcbiAgICAgICAgLy8gdmFyaWFibGUgaXMgc2V0IHdpdGhpbiBhIHJBRiBjYWxsYmFjayBmb3IgYSBzdWJtaXQgYnV0dG9uIGludGVyYWN0aW9uICgjMjI0MSkuXG4gICAgICAgIGFjdGl2YXRpb25TdGF0ZS53YXNFbGVtZW50TWFkZUFjdGl2ZSA9IHRoaXMuY2hlY2tFbGVtZW50TWFkZUFjdGl2ZV8oZSk7XG4gICAgICAgIGlmIChhY3RpdmF0aW9uU3RhdGUud2FzRWxlbWVudE1hZGVBY3RpdmUpIHtcbiAgICAgICAgICB0aGlzLmFuaW1hdGVBY3RpdmF0aW9uXygpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgIC8vIFJlc2V0IGFjdGl2YXRpb24gc3RhdGUgaW1tZWRpYXRlbHkgaWYgZWxlbWVudCB3YXMgbm90IG1hZGUgYWN0aXZlLlxuICAgICAgICB0aGlzLmFjdGl2YXRpb25TdGF0ZV8gPSB0aGlzLmRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnQ9fSBlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjaGVja0VsZW1lbnRNYWRlQWN0aXZlXyhlKSB7XG4gICAgcmV0dXJuIChlICE9PSB1bmRlZmluZWQgJiYgZS50eXBlID09PSAna2V5ZG93bicpID8gdGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VBY3RpdmUoKSA6IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnQ9fSBldmVudCBPcHRpb25hbCBldmVudCBjb250YWluaW5nIHBvc2l0aW9uIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgYWN0aXZhdGUoZXZlbnQpIHtcbiAgICB0aGlzLmFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYW5pbWF0ZUFjdGl2YXRpb25fKCkge1xuICAgIGNvbnN0IHtWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCBWQVJfRkdfVFJBTlNMQVRFX0VORH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTiwgRkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0RFQUNUSVZBVElPTl9USU1FT1VUX01TfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycztcblxuICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG5cbiAgICBsZXQgdHJhbnNsYXRlU3RhcnQgPSAnJztcbiAgICBsZXQgdHJhbnNsYXRlRW5kID0gJyc7XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSkge1xuICAgICAgY29uc3Qge3N0YXJ0UG9pbnQsIGVuZFBvaW50fSA9IHRoaXMuZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpO1xuICAgICAgdHJhbnNsYXRlU3RhcnQgPSBgJHtzdGFydFBvaW50Lnh9cHgsICR7c3RhcnRQb2ludC55fXB4YDtcbiAgICAgIHRyYW5zbGF0ZUVuZCA9IGAke2VuZFBvaW50Lnh9cHgsICR7ZW5kUG9pbnQueX1weGA7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX1NUQVJULCB0cmFuc2xhdGVTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfVFJBTlNMQVRFX0VORCwgdHJhbnNsYXRlRW5kKTtcbiAgICAvLyBDYW5jZWwgYW55IG9uZ29pbmcgYWN0aXZhdGlvbi9kZWFjdGl2YXRpb24gYW5pbWF0aW9uc1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFjdGl2YXRpb25UaW1lcl8pO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyk7XG4gICAgdGhpcy5ybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG5cbiAgICAvLyBGb3JjZSBsYXlvdXQgaW4gb3JkZXIgdG8gcmUtdHJpZ2dlciB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmFjdGl2YXRpb25UaW1lckNhbGxiYWNrXygpLCBERUFDVElWQVRJT05fVElNRU9VVF9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybiB7e3N0YXJ0UG9pbnQ6IFBvaW50VHlwZSwgZW5kUG9pbnQ6IFBvaW50VHlwZX19XG4gICAqL1xuICBnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfKCkge1xuICAgIGNvbnN0IHthY3RpdmF0aW9uRXZlbnQsIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcn0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG5cbiAgICBsZXQgc3RhcnRQb2ludDtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyKSB7XG4gICAgICBzdGFydFBvaW50ID0gZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzKFxuICAgICAgICAvKiogQHR5cGUgeyFFdmVudH0gKi8gKGFjdGl2YXRpb25FdmVudCksXG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93UGFnZU9mZnNldCgpLCB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQb2ludCA9IHtcbiAgICAgICAgeDogdGhpcy5mcmFtZV8ud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmZyYW1lXy5oZWlnaHQgLyAyLFxuICAgICAgfTtcbiAgICB9XG4gICAgLy8gQ2VudGVyIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgc3RhcnQgcG9pbnQuXG4gICAgc3RhcnRQb2ludCA9IHtcbiAgICAgIHg6IHN0YXJ0UG9pbnQueCAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgICAgeTogc3RhcnRQb2ludC55IC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgfTtcblxuICAgIGNvbnN0IGVuZFBvaW50ID0ge1xuICAgICAgeDogKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6ICh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICByZXR1cm4ge3N0YXJ0UG9pbnQsIGVuZFBvaW50fTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJvdGggd2hlbiBhIHBvaW50aW5nIGRldmljZSBpcyByZWxlYXNlZCwgYW5kIHdoZW4gdGhlIGFjdGl2YXRpb24gYW5pbWF0aW9uIGVuZHMuXG4gICAgLy8gVGhlIGRlYWN0aXZhdGlvbiBhbmltYXRpb24gc2hvdWxkIG9ubHkgcnVuIGFmdGVyIGJvdGggb2YgdGhvc2Ugb2NjdXIuXG4gICAgY29uc3Qge0ZHX0RFQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge2hhc0RlYWN0aXZhdGlvblVYUnVuLCBpc0FjdGl2YXRlZH0gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV87XG4gICAgY29uc3QgYWN0aXZhdGlvbkhhc0VuZGVkID0gaGFzRGVhY3RpdmF0aW9uVVhSdW4gfHwgIWlzQWN0aXZhdGVkO1xuXG4gICAgaWYgKGFjdGl2YXRpb25IYXNFbmRlZCAmJiB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8pIHtcbiAgICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB0aGlzLmZnRGVhY3RpdmF0aW9uUmVtb3ZhbFRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKEZHX0RFQUNUSVZBVElPTik7XG4gICAgICB9LCBudW1iZXJzLkZHX0RFQUNUSVZBVElPTl9NUyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpIHtcbiAgICBjb25zdCB7RkdfQUNUSVZBVElPTn0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgfVxuXG4gIHJlc2V0QWN0aXZhdGlvblN0YXRlXygpIHtcbiAgICB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXy5hY3RpdmF0aW9uRXZlbnQ7XG4gICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIC8vIFRvdWNoIGRldmljZXMgbWF5IGZpcmUgYWRkaXRpb25hbCBldmVudHMgZm9yIHRoZSBzYW1lIGludGVyYWN0aW9uIHdpdGhpbiBhIHNob3J0IHRpbWUuXG4gICAgLy8gU3RvcmUgdGhlIHByZXZpb3VzIGV2ZW50IHVudGlsIGl0J3Mgc2FmZSB0byBhc3N1bWUgdGhhdCBzdWJzZXF1ZW50IGV2ZW50cyBhcmUgZm9yIG5ldyBpbnRlcmFjdGlvbnMuXG4gICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyA9IHVuZGVmaW5lZCwgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlRBUF9ERUxBWV9NUyk7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlYWN0aXZhdGVfKCkge1xuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovIChPYmplY3QuYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpKTtcblxuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB0aGlzLmFuaW1hdGVEZWFjdGl2YXRpb25fKHN0YXRlKSk7XG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oc3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmRlYWN0aXZhdGVfKCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQWN0aXZhdGlvblN0YXRlVHlwZX0gb3B0aW9uc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYW5pbWF0ZURlYWN0aXZhdGlvbl8oe3dhc0FjdGl2YXRlZEJ5UG9pbnRlciwgd2FzRWxlbWVudE1hZGVBY3RpdmV9KSB7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlciB8fCB3YXNFbGVtZW50TWFkZUFjdGl2ZSkge1xuICAgICAgdGhpcy5ydW5EZWFjdGl2YXRpb25VWExvZ2ljSWZSZWFkeV8oKTtcbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgbGF5b3V0SW50ZXJuYWxfKCkge1xuICAgIHRoaXMuZnJhbWVfID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gICAgY29uc3QgbWF4RGltID0gTWF0aC5tYXgodGhpcy5mcmFtZV8uaGVpZ2h0LCB0aGlzLmZyYW1lXy53aWR0aCk7XG5cbiAgICAvLyBTdXJmYWNlIGRpYW1ldGVyIGlzIHRyZWF0ZWQgZGlmZmVyZW50bHkgZm9yIHVuYm91bmRlZCB2cy4gYm91bmRlZCByaXBwbGVzLlxuICAgIC8vIFVuYm91bmRlZCByaXBwbGUgZGlhbWV0ZXIgaXMgY2FsY3VsYXRlZCBzbWFsbGVyIHNpbmNlIHRoZSBzdXJmYWNlIGlzIGV4cGVjdGVkIHRvIGFscmVhZHkgYmUgcGFkZGVkIGFwcHJvcHJpYXRlbHlcbiAgICAvLyB0byBleHRlbmQgdGhlIGhpdGJveCwgYW5kIHRoZSByaXBwbGUgaXMgZXhwZWN0ZWQgdG8gbWVldCB0aGUgZWRnZXMgb2YgdGhlIHBhZGRlZCBoaXRib3ggKHdoaWNoIGlzIHR5cGljYWxseVxuICAgIC8vIHNxdWFyZSkuIEJvdW5kZWQgcmlwcGxlcywgb24gdGhlIG90aGVyIGhhbmQsIGFyZSBmdWxseSBleHBlY3RlZCB0byBleHBhbmQgYmV5b25kIHRoZSBzdXJmYWNlJ3MgbG9uZ2VzdCBkaWFtZXRlclxuICAgIC8vIChjYWxjdWxhdGVkIGJhc2VkIG9uIHRoZSBkaWFnb25hbCBwbHVzIGEgY29uc3RhbnQgcGFkZGluZyksIGFuZCBhcmUgY2xpcHBlZCBhdCB0aGUgc3VyZmFjZSdzIGJvcmRlciB2aWFcbiAgICAvLyBgb3ZlcmZsb3c6IGhpZGRlbmAuXG4gICAgY29uc3QgZ2V0Qm91bmRlZFJhZGl1cyA9ICgpID0+IHtcbiAgICAgIGNvbnN0IGh5cG90ZW51c2UgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5mcmFtZV8ud2lkdGgsIDIpICsgTWF0aC5wb3codGhpcy5mcmFtZV8uaGVpZ2h0LCAyKSk7XG4gICAgICByZXR1cm4gaHlwb3RlbnVzZSArIE1EQ1JpcHBsZUZvdW5kYXRpb24ubnVtYmVycy5QQURESU5HO1xuICAgIH07XG5cbiAgICB0aGlzLm1heFJhZGl1c18gPSB0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkgPyBtYXhEaW0gOiBnZXRCb3VuZGVkUmFkaXVzKCk7XG5cbiAgICAvLyBSaXBwbGUgaXMgc2l6ZWQgYXMgYSBmcmFjdGlvbiBvZiB0aGUgbGFyZ2VzdCBkaW1lbnNpb24gb2YgdGhlIHN1cmZhY2UsIHRoZW4gc2NhbGVzIHVwIHVzaW5nIGEgQ1NTIHNjYWxlIHRyYW5zZm9ybVxuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gTWF0aC5mbG9vcihtYXhEaW0gKiBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuSU5JVElBTF9PUklHSU5fU0NBTEUpO1xuICAgIHRoaXMuZmdTY2FsZV8gPSB0aGlzLm1heFJhZGl1c18gLyB0aGlzLmluaXRpYWxTaXplXztcblxuICAgIHRoaXMudXBkYXRlTGF5b3V0Q3NzVmFyc18oKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICB1cGRhdGVMYXlvdXRDc3NWYXJzXygpIHtcbiAgICBjb25zdCB7XG4gICAgICBWQVJfRkdfU0laRSwgVkFSX0xFRlQsIFZBUl9UT1AsIFZBUl9GR19TQ0FMRSxcbiAgICB9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5zdHJpbmdzO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfRkdfU0laRSwgYCR7dGhpcy5pbml0aWFsU2l6ZV99cHhgKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TQ0FMRSwgdGhpcy5mZ1NjYWxlXyk7XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1VuYm91bmRlZCgpKSB7XG4gICAgICB0aGlzLnVuYm91bmRlZENvb3Jkc18gPSB7XG4gICAgICAgIGxlZnQ6IE1hdGgucm91bmQoKHRoaXMuZnJhbWVfLndpZHRoIC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICAgIHRvcDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSksXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9MRUZULCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18ubGVmdH1weGApO1xuICAgICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZShWQVJfVE9QLCBgJHt0aGlzLnVuYm91bmRlZENvb3Jkc18udG9wfXB4YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gdW5ib3VuZGVkICovXG4gIHNldFVuYm91bmRlZCh1bmJvdW5kZWQpIHtcbiAgICBjb25zdCB7VU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAodW5ib3VuZGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKFVOQk9VTkRFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVGb2N1cygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT5cbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpKTtcbiAgfVxuXG4gIGhhbmRsZUJsdXIoKSB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgTURDUmlwcGxlQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1JpcHBsZUZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBAZXh0ZW5kcyBNRENDb21wb25lbnQ8IU1EQ1JpcHBsZUZvdW5kYXRpb24+XG4gKi9cbmNsYXNzIE1EQ1JpcHBsZSBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKiBAcGFyYW0gey4uLj99IGFyZ3MgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVuYm91bmRlZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge3tpc1VuYm91bmRlZDogKGJvb2xlYW58dW5kZWZpbmVkKX09fSBvcHRpb25zXG4gICAqIEByZXR1cm4geyFNRENSaXBwbGV9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCwge2lzVW5ib3VuZGVkID0gdW5kZWZpbmVkfSA9IHt9KSB7XG4gICAgY29uc3QgcmlwcGxlID0gbmV3IE1EQ1JpcHBsZShyb290KTtcbiAgICAvLyBPbmx5IG92ZXJyaWRlIHVuYm91bmRlZCBiZWhhdmlvciBpZiBvcHRpb24gaXMgZXhwbGljaXRseSBzcGVjaWZpZWRcbiAgICBpZiAoaXNVbmJvdW5kZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmlwcGxlLnVuYm91bmRlZCA9IC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi8gKGlzVW5ib3VuZGVkKTtcbiAgICB9XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFSaXBwbGVDYXBhYmxlU3VyZmFjZX0gaW5zdGFuY2VcbiAgICogQHJldHVybiB7IU1EQ1JpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWRhcHRlcihpbnN0YW5jZSkge1xuICAgIGNvbnN0IE1BVENIRVMgPSB1dGlsLmdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IHV0aWwuc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KSxcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiBpbnN0YW5jZS51bmJvdW5kZWQsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGluc3RhbmNlLnJvb3RfW01BVENIRVNdKCc6YWN0aXZlJyksXG4gICAgICBpc1N1cmZhY2VEaXNhYmxlZDogKCkgPT4gaW5zdGFuY2UuZGlzYWJsZWQsXG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4gaW5zdGFuY2Uucm9vdF8uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IGluc3RhbmNlLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICh0YXJnZXQpID0+IGluc3RhbmNlLnJvb3RfLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGluc3RhbmNlLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgaW5zdGFuY2Uucm9vdF8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PlxuICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIHV0aWwuYXBwbHlQYXNzaXZlKCkpLFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpLFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IChoYW5kbGVyKSA9PiB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlciksXG4gICAgICB1cGRhdGVDc3NWYXJpYWJsZTogKHZhck5hbWUsIHZhbHVlKSA9PiBpbnN0YW5jZS5yb290Xy5zdHlsZS5zZXRQcm9wZXJ0eSh2YXJOYW1lLCB2YWx1ZSksXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiBpbnN0YW5jZS5yb290Xy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGdldFdpbmRvd1BhZ2VPZmZzZXQ6ICgpID0+ICh7eDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXR9KSxcbiAgICB9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCB1bmJvdW5kZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5ib3VuZGVkXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IHVuYm91bmRlZCAqL1xuICBzZXQgdW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIHRoaXMudW5ib3VuZGVkXyA9IEJvb2xlYW4odW5ib3VuZGVkKTtcbiAgICB0aGlzLnNldFVuYm91bmRlZF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zdXJlIENvbXBpbGVyIHRocm93cyBhbiBhY2Nlc3MgY29udHJvbCBlcnJvciB3aGVuIGRpcmVjdGx5IGFjY2Vzc2luZyBhXG4gICAqIHByb3RlY3RlZCBvciBwcml2YXRlIHByb3BlcnR5IGluc2lkZSBhIGdldHRlci9zZXR0ZXIsIGxpa2UgdW5ib3VuZGVkIGFib3ZlLlxuICAgKiBCeSBhY2Nlc3NpbmcgdGhlIHByb3RlY3RlZCBwcm9wZXJ0eSBpbnNpZGUgYSBtZXRob2QsIHdlIHNvbHZlIHRoYXQgcHJvYmxlbS5cbiAgICogVGhhdCdzIHdoeSB0aGlzIGZ1bmN0aW9uIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFVuYm91bmRlZF8oKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRVbmJvdW5kZWQodGhpcy51bmJvdW5kZWRfKTtcbiAgfVxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbl8uYWN0aXZhdGUoKTtcbiAgfVxuXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5kZWFjdGl2YXRlKCk7XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5sYXlvdXQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDUmlwcGxlRm91bmRhdGlvbn1cbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBnZXREZWZhdWx0Rm91bmRhdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IE1EQ1JpcHBsZUZvdW5kYXRpb24oTURDUmlwcGxlLmNyZWF0ZUFkYXB0ZXIodGhpcykpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy51bmJvdW5kZWQgPSAnbWRjUmlwcGxlSXNVbmJvdW5kZWQnIGluIHRoaXMucm9vdF8uZGF0YXNldDtcbiAgfVxufVxuXG4vKipcbiAqIFNlZSBNYXRlcmlhbCBEZXNpZ24gc3BlYyBmb3IgbW9yZSBkZXRhaWxzIG9uIHdoZW4gdG8gdXNlIHJpcHBsZXMuXG4gKiBodHRwczovL21hdGVyaWFsLmlvL2d1aWRlbGluZXMvbW90aW9uL2Nob3Jlb2dyYXBoeS5odG1sI2Nob3Jlb2dyYXBoeS1jcmVhdGlvblxuICogQHJlY29yZFxuICovXG5jbGFzcyBSaXBwbGVDYXBhYmxlU3VyZmFjZSB7fVxuXG4vKiogQHByb3RlY3RlZCB7IUVsZW1lbnR9ICovXG5SaXBwbGVDYXBhYmxlU3VyZmFjZS5wcm90b3R5cGUucm9vdF87XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBibGVlZHMgb3V0IG9mIHRoZSBib3VuZHMgb2YgdGhlIGVsZW1lbnQuXG4gKiBAdHlwZSB7Ym9vbGVhbnx1bmRlZmluZWR9XG4gKi9cblJpcHBsZUNhcGFibGVTdXJmYWNlLnByb3RvdHlwZS51bmJvdW5kZWQ7XG5cbi8qKlxuICogV2hldGhlciBvciBub3QgdGhlIHJpcHBsZSBpcyBhdHRhY2hlZCB0byBhIGRpc2FibGVkIGNvbXBvbmVudC5cbiAqIEB0eXBlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuUmlwcGxlQ2FwYWJsZVN1cmZhY2UucHJvdG90eXBlLmRpc2FibGVkO1xuXG5leHBvcnQge01EQ1JpcHBsZSwgTURDUmlwcGxlRm91bmRhdGlvbiwgUmlwcGxlQ2FwYWJsZVN1cmZhY2UsIHV0aWx9O1xuIiwiaW1wb3J0IHsgTURDUmlwcGxlRm91bmRhdGlvbiB9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvaW5kZXgnXG5pbXBvcnQge1xuICBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyxcbiAgZ2V0TWF0Y2hlc1Byb3BlcnR5LFxuICBhcHBseVBhc3NpdmVcbn0gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS91dGlsJ1xuXG5leHBvcnQgY2xhc3MgUmlwcGxlQmFzZSBleHRlbmRzIE1EQ1JpcHBsZUZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IE1BVENIRVMoKSB7XG4gICAgLyogZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4gICAgcmV0dXJuIChcbiAgICAgIFJpcHBsZUJhc2UuX21hdGNoZXMgfHxcbiAgICAgIChSaXBwbGVCYXNlLl9tYXRjaGVzID0gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSkpXG4gICAgKVxuICB9XG5cbiAgc3RhdGljIGlzU3VyZmFjZUFjdGl2ZShyZWYpIHtcbiAgICByZXR1cm4gcmVmW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICB9XG5cbiAgY29uc3RydWN0b3Iodm0sIG9wdGlvbnMpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBicm93c2VyU3VwcG9ydHNDc3NWYXJzOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc3VwcG9ydHNDc3NWYXJpYWJsZXMod2luZG93KVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdm0uJGVsW1JpcHBsZUJhc2UuTUFUQ0hFU10oJzphY3RpdmUnKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNTdXJmYWNlRGlzYWJsZWQ6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB2bS5kaXNhYmxlZFxuICAgICAgICAgIH0sXG4gICAgICAgICAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2bS4kc2V0KHZtLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdm0uJGRlbGV0ZSh2bS5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjb250YWluc0V2ZW50VGFyZ2V0OiB0YXJnZXQgPT4gdm0uJGVsLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIHZtLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB2bS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgZXZ0VHlwZSxcbiAgICAgICAgICAgICAgaGFuZGxlcixcbiAgICAgICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgICAgICksXG4gICAgICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT5cbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgICBldnRUeXBlLFxuICAgICAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgICAgICBhcHBseVBhc3NpdmUoKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdm0uJHNldCh2bS5zdHlsZXMsIHZhck5hbWUsIHZhbHVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHZtLiRlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUmlwcGxlTWl4aW4gPSB7XG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1lbGVtZW50IFxuICAgIDp0YWc9XCJ0YWdcIiBcbiAgICA6Y2xhc3Nlcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZXM9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1yaXBwbGVcIj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1lbGVtZW50PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4vbWRjLXJpcHBsZS1iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmlwcGxlJyxcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBSaXBwbGVNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgdGFnOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQoY29tcGlsZWRUZW1wbGF0ZSwgaW5qZWN0U3R5bGUsIGRlZmF1bHRFeHBvcnQsIHNjb3BlSWQsIGlzRnVuY3Rpb25hbFRlbXBsYXRlLCBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovLCBpc1NoYWRvd01vZGUsIGNyZWF0ZUluamVjdG9yLCBjcmVhdGVJbmplY3RvclNTUiwgY3JlYXRlSW5qZWN0b3JTaGFkb3cpIHtcbiAgICBpZiAodHlwZW9mIGlzU2hhZG93TW9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjcmVhdGVJbmplY3RvclNTUiA9IGNyZWF0ZUluamVjdG9yO1xuICAgICAgICBjcmVhdGVJbmplY3RvciA9IGlzU2hhZG93TW9kZTtcbiAgICAgICAgaXNTaGFkb3dNb2RlID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgICBjb25zdCBvcHRpb25zID0gdHlwZW9mIGRlZmF1bHRFeHBvcnQgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0RXhwb3J0Lm9wdGlvbnMgOiBkZWZhdWx0RXhwb3J0O1xuICAgIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgICBpZiAoY29tcGlsZWRUZW1wbGF0ZSAmJiBjb21waWxlZFRlbXBsYXRlLnJlbmRlcikge1xuICAgICAgICBvcHRpb25zLnJlbmRlciA9IGNvbXBpbGVkVGVtcGxhdGUucmVuZGVyO1xuICAgICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWU7XG4gICAgICAgIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgICAgICAgaWYgKGlzRnVuY3Rpb25hbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNjb3BlZElkXG4gICAgaWYgKHNjb3BlSWQpIHtcbiAgICAgICAgb3B0aW9ucy5fc2NvcGVJZCA9IHNjb3BlSWQ7XG4gICAgfVxuICAgIGxldCBob29rO1xuICAgIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7XG4gICAgICAgIC8vIHNlcnZlciBidWlsZFxuICAgICAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgICAgICAgIGNvbnRleHQgPVxuICAgICAgICAgICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICAgICAgICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpOyAvLyBmdW5jdGlvbmFsXG4gICAgICAgICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgICAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfXztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICAgICAgICBpZiAoaW5qZWN0U3R5bGUpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RTdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yU1NSKGNvbnRleHQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJlbmNlXG4gICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Ll9yZWdpc3RlcmVkQ29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gdXNlZCBieSBzc3IgaW4gY2FzZSBjb21wb25lbnQgaXMgY2FjaGVkIGFuZCBiZWZvcmVDcmVhdGVcbiAgICAgICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICAgICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbmplY3RTdHlsZSkge1xuICAgICAgICBob29rID0gaXNTaGFkb3dNb2RlXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpbmplY3RTdHlsZS5jYWxsKHRoaXMsIGNyZWF0ZUluamVjdG9yU2hhZG93KHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGluamVjdFN0eWxlLmNhbGwodGhpcywgY3JlYXRlSW5qZWN0b3IoY29udGV4dCkpO1xuICAgICAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGhvb2spIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICAgICAgICBjb25zdCBvcmlnaW5hbFJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgICAgICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24oaCwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIGhvb2suY2FsbChjb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGU7XG4gICAgICAgICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKSA6IFtob29rXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEV4cG9ydDtcbn1cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JpcHBsZSBmcm9tICcuL21kYy1yaXBwbGUudnVlJ1xuXG5leHBvcnQgKiBmcm9tICcuL21kYy1yaXBwbGUtYmFzZS5qcydcblxuZXhwb3J0IHsgbWRjUmlwcGxlIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1JpcHBsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1idXR0b25cbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIDpocmVmPVwiaHJlZlwiXG4gICAgOmxpbms9XCJsaW5rXCJcbiAgICA6ZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiXG4gID5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1idXR0b25fX2xhYmVsXCI+IDxzbG90IC8+IDwvc3Bhbj5cbiAgPC9jdXN0b20tYnV0dG9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlTWl4aW4gfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24tYmFzZScsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4sIFJpcHBsZU1peGluXSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjxzY3JpcHQ+XG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1idXR0b24nLFxuICBleHRlbmRzOiBtZGNCdXR0b25CYXNlLFxuICBwcm9wczoge1xuICAgIHJhaXNlZDogQm9vbGVhbixcbiAgICB1bmVsZXZhdGVkOiBCb29sZWFuLFxuICAgIG91dGxpbmVkOiBCb29sZWFuLFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1idXR0b24nOiB0cnVlLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tcmFpc2VkJzogdGhpcy5yYWlzZWQsXG4gICAgICAgICdtZGMtYnV0dG9uLS11bmVsZXZhdGVkJzogdGhpcy51bmVsZXZhdGVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tb3V0bGluZWQnOiB0aGlzLm91dGxpbmVkLFxuICAgICAgICAnbWRjLWJ1dHRvbi0tZGVuc2UnOiB0aGlzLmRlbnNlXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIHJhaXNlZCgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtYnV0dG9uLS1yYWlzZWQnLCB0aGlzLnJhaXNlZClcbiAgICB9LFxuICAgIHVuZWxldmF0ZWQoKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWRjLWJ1dHRvbi0tdW5lbGV2YXRlZCcsIHRoaXMudW5lbGV2YXRlZClcbiAgICB9LFxuICAgIG91dGxpbmVkKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLW91dGxpbmVkJywgdGhpcy5vdXRsaW5lZClcbiAgICB9LFxuICAgIGRlbnNlKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1idXR0b24tLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQnV0dG9uIGZyb20gJy4vbWRjLWJ1dHRvbi52dWUnXG5pbXBvcnQgbWRjQnV0dG9uQmFzZSBmcm9tICcuL21kYy1idXR0b24tYmFzZS52dWUnXG5cbmV4cG9ydCB7IG1kY0J1dHRvbkJhc2UsIG1kY0J1dHRvbiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNCdXR0b25cbn0pXG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkLS1vdXRsaW5lZCc6IG91dGxpbmVkfVwiXG4gICAgY2xhc3M9XCJtZGMtY2FyZFwiPlxuICAgIDxzbG90Lz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQnLFxuICBwcm9wczoge1xuICAgIG91dGxpbmVkOiBCb29sZWFuXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayBcclxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxyXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgOmxpbms9XCJsaW5rXCIgXHJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXByaW1hcnktYWN0aW9uIG1kYy1jYXJkX19wcmltYXJ5LWFjdGlvblwiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3QgLz5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZS9pbmRleCdcclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1wcmltYXJ5LWFjdGlvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW4sIFJpcHBsZU1peGluXSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge30sXHJcbiAgICAgIHN0eWxlczoge31cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8c2VjdGlvbiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXHJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICBjbGFzcz1cIm1kYy1jYXJkLW1lZGlhIG1kYy1jYXJkX19tZWRpYVwiPlxyXG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiIFxuICAgICAgY2xhc3M9XCJtZGMtY2FyZF9fbWVkaWEtY29udGVudFwiPlxyXG4gICAgICA8c2xvdC8+XHJcbiAgICA8L2Rpdj5cclxuICA8L3NlY3Rpb24+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy1jYXJkLW1lZGlhJyxcclxuICBwcm9wczoge1xyXG4gICAgc3JjOiBTdHJpbmcsXHJcbiAgICBzcXVhcmU6IEJvb2xlYW5cclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICBzdHlsZXMoKSB7XHJcbiAgICAgIHZhciBzdHlsZXMgPSB7XHJcbiAgICAgICAgYmFja2dyb3VuZEltYWdlOiBgdXJsKCR7dGhpcy5zcmN9KWBcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHN0eWxlc1xyXG4gICAgfSxcclxuICAgIGNsYXNzZXMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnNxdWFyZSA/ICdtZGMtY2FyZF9fbWVkaWEtLXNxdWFyZScgOiAnbWRjLWNhcmRfX21lZGlhLS0xNi05J1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHRlbXBsYXRlPlxuICA8c2VjdGlvbiBjbGFzcz1cIm1kYy1jYXJkLWhlYWRlciBtZGMtY2FyZF9fcHJpbWFyeVwiPlxuICAgIDxzbG90PlxuICAgICAgPGgxIFxuICAgICAgICB2LWlmPVwidGl0bGVcIlxuICAgICAgICA6Y2xhc3M9XCJ7J21kYy1jYXJkX190aXRsZS0tbGFyZ2UnOiBsYXJnZVRpdGxlfVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3RpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgdGl0bGUgfX1cbiAgICAgIDwvaDE+XG4gICAgICA8aDIgXG4gICAgICAgIHYtaWY9XCJzdWJ0aXRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNhcmRfX3N1YnRpdGxlXCJcbiAgICAgID5cbiAgICAgICAge3sgc3VidGl0bGUgfX0gXG4gICAgICA8L2gyPlxuICAgIDwvc2xvdD5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jYXJkLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICBzdWJ0aXRsZTogU3RyaW5nLFxuICAgICdsYXJnZS10aXRsZSc6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdHJ1ZSB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aDEgXG4gICAgOmNsYXNzPVwieydtZGMtY2FyZF9fdGl0bGUtLWxhcmdlJzogbGFyZ2V9XCJcbiAgICBjbGFzcz1cIm1kYy1jYXJkLXRpdGxlIG1kYy1jYXJkX190aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10aXRsZScsXG4gIHByb3BzOiB7XG4gICAgbGFyZ2U6IEJvb2xlYW5cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMiBjbGFzcz1cIm1kYy1jYXJkLXN1YnRpdGxlIG1kYy1jYXJkX19zdWJ0aXRsZVwiPlxuICAgIDxzbG90Lz5cbiAgPC9oMj5cbjwvdGVtcGxhdGU+XG5cblxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWNhcmQtc3VidGl0bGUnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gY2xhc3M9XCJtZGMtY2FyZC10ZXh0IG1kYy1jYXJkX19zdXBwb3J0aW5nLXRleHRcIj5cbiAgICA8c2xvdC8+XG4gIDwvc2VjdGlvbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2FyZC10ZXh0J1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNlY3Rpb24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxyXG4gICAgY2xhc3M9XCJtZGMtY2FyZC1hY3Rpb25zIG1kYy1jYXJkX19hY3Rpb25zXCI+XHJcbiAgICA8c2xvdC8+XHJcbiAgPC9zZWN0aW9uPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb25zJyxcclxuICBwcm9wczoge1xyXG4gICAgZnVsbEJsZWVkOiBCb29sZWFuXHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgY2xhc3NlcygpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbnMtLWZ1bGwtYmxlZWQnOiB0aGlzLmZ1bGxCbGVlZFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPGRpdiBjbGFzcz1cIm1kYy1jYXJkLWFjdGlvbi1idXR0b25zIG1kYy1jYXJkX19hY3Rpb24tYnV0dG9uc1wiPlxyXG4gICAgPHNsb3QvPlxyXG4gIDwvZGl2PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24tYnV0dG9ucydcclxufVxyXG48L3NjcmlwdD5cclxuIiwiPHNjcmlwdD5cclxuaW1wb3J0IHsgbWRjQnV0dG9uQmFzZSB9IGZyb20gJy4uL2J1dHRvbidcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWJ1dHRvbicsXHJcbiAgZXh0ZW5kczogbWRjQnV0dG9uQmFzZSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtYnV0dG9uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWNhcmRfX2FjdGlvbic6IHRydWUsXHJcbiAgICAgICAgJ21kYy1jYXJkLWFjdGlvbi1idXR0b24nOiB0cnVlXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcbn1cclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cclxuICA8ZGl2IGNsYXNzPVwibWRjLWNhcmQtYWN0aW9uLWljb25zIG1kYy1jYXJkX19hY3Rpb24taWNvbnNcIj5cclxuICAgIDxzbG90Lz5cclxuICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQ+XHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWNhcmQtYWN0aW9uLWljb25zJ1xyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCI8dGVtcGxhdGU+XHJcbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxyXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxyXG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cclxuICA8L3NwYW4+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xyXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtY2FyZC1hY3Rpb24taWNvbicsXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgaWNvbjogU3RyaW5nXHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2xhc3Nlczoge1xyXG4gICAgICAgICdtZGMtY2FyZC1hY3Rpb24taWNvbic6IHRydWUsXHJcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXHJcbiAgICAgICAgJ21kYy1jYXJkX19hY3Rpb24nOiB0cnVlLFxyXG4gICAgICAgICdtZGMtY2FyZF9fYWN0aW9uLS1pY29uJzogdHJ1ZSxcclxuICAgICAgICAnbWRjLWljb24tdG9nZ2xlJzogdHJ1ZVxyXG4gICAgICB9LFxyXG4gICAgICBzdHlsZXM6IHt9XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgaWNvbigpIHtcclxuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21hdGVyaWFsLWljb25zJywgISF0aGlzLmljb24pXHJcbiAgICB9XHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzLCB7XHJcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlXHJcbiAgICB9KVxyXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXHJcbiAgfSxcclxuICBiZWZvcmVEZXN0cm95KCkge1xyXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXHJcbiAgfVxyXG59XHJcbjwvc2NyaXB0PlxyXG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0NhcmQgZnJvbSAnLi9tZGMtY2FyZC52dWUnXHJcbmltcG9ydCBtZGNDYXJkUHJpbWFyeUFjdGlvbiBmcm9tICcuL21kYy1jYXJkLXByaW1hcnktYWN0aW9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRNZWRpYSBmcm9tICcuL21kYy1jYXJkLW1lZGlhLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRIZWFkZXIgZnJvbSAnLi9tZGMtY2FyZC1oZWFkZXIudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRpdGxlIGZyb20gJy4vbWRjLWNhcmQtdGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFN1YnRpdGxlIGZyb20gJy4vbWRjLWNhcmQtc3VidGl0bGUudnVlJ1xyXG5pbXBvcnQgbWRjQ2FyZFRleHQgZnJvbSAnLi9tZGMtY2FyZC10ZXh0LnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25zIGZyb20gJy4vbWRjLWNhcmQtYWN0aW9ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uQnV0dG9ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1idXR0b25zLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25CdXR0b24gZnJvbSAnLi9tZGMtY2FyZC1hY3Rpb24tYnV0dG9uLnZ1ZSdcclxuaW1wb3J0IG1kY0NhcmRBY3Rpb25JY29ucyBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29ucy52dWUnXHJcbmltcG9ydCBtZGNDYXJkQWN0aW9uSWNvbiBmcm9tICcuL21kYy1jYXJkLWFjdGlvbi1pY29uLnZ1ZSdcclxuXHJcbmV4cG9ydCB7XHJcbiAgbWRjQ2FyZCxcclxuICBtZGNDYXJkUHJpbWFyeUFjdGlvbixcclxuICBtZGNDYXJkTWVkaWEsXHJcbiAgbWRjQ2FyZEhlYWRlcixcclxuICBtZGNDYXJkVGl0bGUsXHJcbiAgbWRjQ2FyZFN1YnRpdGxlLFxyXG4gIG1kY0NhcmRUZXh0LFxyXG4gIG1kY0NhcmRBY3Rpb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b25zLFxyXG4gIG1kY0NhcmRBY3Rpb25CdXR0b24sXHJcbiAgbWRjQ2FyZEFjdGlvbkljb25zLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29uXHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0NhcmQsXHJcbiAgbWRjQ2FyZFByaW1hcnlBY3Rpb24sXHJcbiAgbWRjQ2FyZE1lZGlhLFxyXG4gIG1kY0NhcmRIZWFkZXIsXHJcbiAgbWRjQ2FyZFRpdGxlLFxyXG4gIG1kY0NhcmRTdWJ0aXRsZSxcclxuICBtZGNDYXJkVGV4dCxcclxuICBtZGNDYXJkQWN0aW9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9ucyxcclxuICBtZGNDYXJkQWN0aW9uQnV0dG9uLFxyXG4gIG1kY0NhcmRBY3Rpb25JY29ucyxcclxuICBtZGNDYXJkQWN0aW9uSWNvblxyXG59KVxyXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDUmlwcGxlfSBmcm9tICdAbWF0ZXJpYWwvcmlwcGxlL2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBjaGVja2VkOiBib29sZWFuLFxuICogICBpbmRldGVybWluYXRlOiBib29sZWFuLFxuICogICBkaXNhYmxlZDogYm9vbGVhbixcbiAqICAgdmFsdWU6ID9zdHJpbmdcbiAqIH19XG4gKi9cbmxldCBNRENTZWxlY3Rpb25Db250cm9sU3RhdGU7XG5cbi8qKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3Rpb25Db250cm9sIHtcbiAgLyoqIEByZXR1cm4gez9NRENSaXBwbGV9ICovXG4gIGdldCByaXBwbGUoKSB7fVxufVxuXG5leHBvcnQge01EQ1NlbGVjdGlvbkNvbnRyb2xTdGF0ZSwgTURDU2VsZWN0aW9uQ29udHJvbH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgQ2hlY2tib3guIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94QWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYW4gYXR0cmlidXRlIHdpdGggYSBnaXZlbiB2YWx1ZSBvbiB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXROYXRpdmVDb250cm9sQXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyKGF0dHIpIHt9XG5cbiAgZm9yY2VMYXlvdXQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0F0dGFjaGVkVG9ET00oKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0luZGV0ZXJtaW5hdGUoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NoZWNrZWQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNOYXRpdmVDb250cm9sKCkge31cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQoZGlzYWJsZWQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoZWNrYm94QWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBST09UID0gJ21kYy1jaGVja2JveCc7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgVVBHUkFERUQ6ICdtZGMtY2hlY2tib3gtLXVwZ3JhZGVkJyxcbiAgQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tY2hlY2tlZCcsXG4gIElOREVURVJNSU5BVEU6ICdtZGMtY2hlY2tib3gtLWluZGV0ZXJtaW5hdGUnLFxuICBESVNBQkxFRDogJ21kYy1jaGVja2JveC0tZGlzYWJsZWQnLFxuICBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLXVuY2hlY2tlZC1jaGVja2VkJyxcbiAgQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS11bmNoZWNrZWQtaW5kZXRlcm1pbmF0ZScsXG4gIEFOSU1fQ0hFQ0tFRF9VTkNIRUNLRUQ6ICdtZGMtY2hlY2tib3gtLWFuaW0tY2hlY2tlZC11bmNoZWNrZWQnLFxuICBBTklNX0NIRUNLRURfSU5ERVRFUk1JTkFURTogJ21kYy1jaGVja2JveC0tYW5pbS1jaGVja2VkLWluZGV0ZXJtaW5hdGUnLFxuICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRDogJ21kYy1jaGVja2JveC0tYW5pbS1pbmRldGVybWluYXRlLWNoZWNrZWQnLFxuICBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEOiAnbWRjLWNoZWNrYm94LS1hbmltLWluZGV0ZXJtaW5hdGUtdW5jaGVja2VkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6IGAuJHtST09UfV9fbmF0aXZlLWNvbnRyb2xgLFxuICBUUkFOU0lUSU9OX1NUQVRFX0lOSVQ6ICdpbml0JyxcbiAgVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEOiAnY2hlY2tlZCcsXG4gIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOiAndW5jaGVja2VkJyxcbiAgVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFOiAnaW5kZXRlcm1pbmF0ZScsXG4gIEFSSUFfQ0hFQ0tFRF9BVFRSOiAnYXJpYS1jaGVja2VkJyxcbiAgQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUU6ICdtaXhlZCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIEFOSU1fRU5EX0xBVENIX01TOiAyNTAsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDU2VsZWN0aW9uQ29udHJvbFN0YXRlfSBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0aW9uLWNvbnRyb2wvaW5kZXgnO1xuaW1wb3J0IE1EQ0NoZWNrYm94QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ0NoZWNrYm94QWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0NoZWNrYm94Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0NoZWNrYm94QWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDQ2hlY2tib3hBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xBdHRyOiAoLyogYXR0cjogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZU5hdGl2ZUNvbnRyb2xBdHRyOiAoLyogYXR0cjogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB7fSxcbiAgICAgIGlzQXR0YWNoZWRUb0RPTTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzSW5kZXRlcm1pbmF0ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzQ2hlY2tlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGhhc05hdGl2ZUNvbnRyb2w6ICgpID0+IC8qIGJvb2xlYW4gKi8ge30sXG4gICAgICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQ6ICgvKiBkaXNhYmxlZDogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGVja2JveEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMuY3VycmVudENoZWNrU3RhdGVfID0gc3RyaW5ncy5UUkFOU0lUSU9OX1NUQVRFX0lOSVQ7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSAnJztcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbUVuZExhdGNoVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmVuYWJsZUFuaW1hdGlvbkVuZEhhbmRsZXJfID0gZmFsc2U7XG4gIH1cblxuICAvKiogQG92ZXJyaWRlICovXG4gIGluaXQoKSB7XG4gICAgdGhpcy5jdXJyZW50Q2hlY2tTdGF0ZV8gPSB0aGlzLmRldGVybWluZUNoZWNrU3RhdGVfKCk7XG4gICAgdGhpcy51cGRhdGVBcmlhQ2hlY2tlZF8oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuVVBHUkFERUQpO1xuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBkZXN0cm95KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1FbmRMYXRjaFRpbWVyXyk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0TmF0aXZlQ29udHJvbERpc2FibGVkKGRpc2FibGVkKTtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5ESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGFuaW1hdGlvbmVuZCBldmVudCBmb3IgdGhlIGNoZWNrYm94XG4gICAqL1xuICBoYW5kbGVBbmltYXRpb25FbmQoKSB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZUFuaW1hdGlvbkVuZEhhbmRsZXJfKSByZXR1cm47XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8pO1xuXG4gICAgdGhpcy5hbmltRW5kTGF0Y2hUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICAgIHRoaXMuZW5hYmxlQW5pbWF0aW9uRW5kSGFuZGxlcl8gPSBmYWxzZTtcbiAgICB9LCBudW1iZXJzLkFOSU1fRU5EX0xBVENIX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBjaGVja2JveFxuICAgKi9cbiAgaGFuZGxlQ2hhbmdlKCkge1xuICAgIHRoaXMudHJhbnNpdGlvbkNoZWNrU3RhdGVfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgdHJhbnNpdGlvbkNoZWNrU3RhdGVfKCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNOYXRpdmVDb250cm9sKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgb2xkU3RhdGUgPSB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXztcbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuZGV0ZXJtaW5lQ2hlY2tTdGF0ZV8oKTtcblxuICAgIGlmIChvbGRTdGF0ZSA9PT0gbmV3U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZUFyaWFDaGVja2VkXygpO1xuXG4gICAgLy8gQ2hlY2sgdG8gZW5zdXJlIHRoYXQgdGhlcmUgaXNuJ3QgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGFuaW1hdGlvbiBjbGFzcywgaW4gY2FzZSBmb3IgZXhhbXBsZVxuICAgIC8vIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGUgY2hlY2tib3ggYmVmb3JlIHRoZSBhbmltYXRpb24gd2FzIGZpbmlzaGVkLlxuICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbUVuZExhdGNoVGltZXJfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZm9yY2VMYXlvdXQoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5jdXJyZW50QW5pbWF0aW9uQ2xhc3NfKTtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18gPSB0aGlzLmdldFRyYW5zaXRpb25BbmltYXRpb25DbGFzc18ob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB0aGlzLmN1cnJlbnRDaGVja1N0YXRlXyA9IG5ld1N0YXRlO1xuXG4gICAgLy8gQ2hlY2sgZm9yIHBhcmVudE5vZGUgc28gdGhhdCBhbmltYXRpb25zIGFyZSBvbmx5IHJ1biB3aGVuIHRoZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgLy8gdG8gdGhlIERPTS5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0F0dGFjaGVkVG9ET00oKSAmJiB0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyh0aGlzLmN1cnJlbnRBbmltYXRpb25DbGFzc18pO1xuICAgICAgdGhpcy5lbmFibGVBbmltYXRpb25FbmRIYW5kbGVyXyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZUNoZWNrU3RhdGVfKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURSxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNJbmRldGVybWluYXRlKCkpIHtcbiAgICAgIHJldHVybiBUUkFOU0lUSU9OX1NUQVRFX0lOREVURVJNSU5BVEU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzQ2hlY2tlZCgpID8gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEIDogVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFN0YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTdGF0ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfSU5JVCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRCxcbiAgICAgIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VELFxuICAgIH0gPSBzdHJpbmdzO1xuXG4gICAgY29uc3Qge1xuICAgICAgQU5JTV9VTkNIRUNLRURfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fVU5DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0NIRUNLRURfVU5DSEVDS0VELFxuICAgICAgQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEUsXG4gICAgICBBTklNX0lOREVURVJNSU5BVEVfQ0hFQ0tFRCxcbiAgICAgIEFOSU1fSU5ERVRFUk1JTkFURV9VTkNIRUNLRUQsXG4gICAgfSA9IE1EQ0NoZWNrYm94Rm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuXG4gICAgc3dpdGNoIChvbGRTdGF0ZSkge1xuICAgIGNhc2UgVFJBTlNJVElPTl9TVEFURV9JTklUOlxuICAgICAgaWYgKG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgLy8gZmFsbHRocm91Z2hcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfVU5DSEVDS0VEOlxuICAgICAgcmV0dXJuIG5ld1N0YXRlID09PSBUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQgPyBBTklNX1VOQ0hFQ0tFRF9DSEVDS0VEIDogQU5JTV9VTkNIRUNLRURfSU5ERVRFUk1JTkFURTtcbiAgICBjYXNlIFRSQU5TSVRJT05fU1RBVEVfQ0hFQ0tFRDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9VTkNIRUNLRUQgPyBBTklNX0NIRUNLRURfVU5DSEVDS0VEIDogQU5JTV9DSEVDS0VEX0lOREVURVJNSU5BVEU7XG4gICAgLy8gVFJBTlNJVElPTl9TVEFURV9JTkRFVEVSTUlOQVRFXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXdTdGF0ZSA9PT0gVFJBTlNJVElPTl9TVEFURV9DSEVDS0VEID9cbiAgICAgICAgQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQgOiBBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUFyaWFDaGVja2VkXygpIHtcbiAgICAvLyBFbnN1cmUgYXJpYS1jaGVja2VkIGlzIHNldCB0byBtaXhlZCBpZiBjaGVja2JveCBpcyBpbiBpbmRldGVybWluYXRlIHN0YXRlLlxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzSW5kZXRlcm1pbmF0ZSgpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldE5hdGl2ZUNvbnRyb2xBdHRyKFxuICAgICAgICBzdHJpbmdzLkFSSUFfQ0hFQ0tFRF9BVFRSLCBzdHJpbmdzLkFSSUFfQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFX1ZBTFVFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG9uL29mZiBzdGF0ZSBkb2VzIG5vdCBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgYXJpYS1jaGVja2VkLCBzaW5jZVxuICAgICAgLy8gdGhlIHNjcmVlbnJlYWRlciB1c2VzIHRoZSBjaGVja2VkIHByb3BlcnR5IG9uIHRoZSBjaGVja2JveCBlbGVtZW50LlxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVOYXRpdmVDb250cm9sQXR0cihzdHJpbmdzLkFSSUFfQ0hFQ0tFRF9BVFRSKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hlY2tib3hGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGb3JtIEZpZWxkLiBQcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIG1hbmFnaW5nXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHJpcHBsZSBhY3RpdmF0aW9uXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENGb3JtRmllbGRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7IUV2ZW50TGlzdGVuZXJ9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICBhY3RpdmF0ZUlucHV0UmlwcGxlKCkge31cblxuICBkZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGb3JtRmllbGRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1mb3JtLWZpZWxkJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZvcm0tZmllbGQgPiBsYWJlbCcsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0Zvcm1GaWVsZEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGb3JtRmllbGRBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtjc3NDbGFzc2VzfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU1EQ0Zvcm1GaWVsZEFkYXB0ZXJ9ICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge30sXG4gICAgICBkZWFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGb3JtRmllbGRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqL1xuICAgIHRoaXMuY2xpY2tIYW5kbGVyXyA9IC8qKiBAdHlwZSB7IUV2ZW50TGlzdGVuZXJ9ICovIChcbiAgICAgICgpID0+IHRoaXMuaGFuZGxlQ2xpY2tfKCkpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignY2xpY2snLCB0aGlzLmNsaWNrSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUNsaWNrXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlSW5wdXRSaXBwbGUoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlSW5wdXRSaXBwbGUoKSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRm9ybUZpZWxkRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIG5vUHJlZml4OiBzdHJpbmcsXG4gKiAgIHdlYmtpdFByZWZpeDogc3RyaW5nLFxuICogICBzdHlsZVByb3BlcnR5OiBzdHJpbmdcbiAqIH19XG4gKi9cbmxldCBWZW5kb3JQcm9wZXJ0eU1hcFR5cGU7XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgZXZlbnRUeXBlTWFwID0ge1xuICAnYW5pbWF0aW9uc3RhcnQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25zdGFydCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0QW5pbWF0aW9uU3RhcnQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uZW5kJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAnYW5pbWF0aW9uaXRlcmF0aW9uJzoge1xuICAgIG5vUHJlZml4OiAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25JdGVyYXRpb24nLFxuICAgIHN0eWxlUHJvcGVydHk6ICdhbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNpdGlvbmVuZCc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgIHN0eWxlUHJvcGVydHk6ICd0cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKiBAY29uc3Qge09iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqL1xuY29uc3QgY3NzUHJvcGVydHlNYXAgPSB7XG4gICdhbmltYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtYW5pbWF0aW9uJyxcbiAgfSxcbiAgJ3RyYW5zZm9ybSc6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zZm9ybScsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2Zvcm0nLFxuICB9LFxuICAndHJhbnNpdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ3RyYW5zaXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJy13ZWJraXQtdHJhbnNpdGlvbicsXG4gIH0sXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHtcbiAgcmV0dXJuICh3aW5kb3dPYmpbJ2RvY3VtZW50J10gIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10gPT09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGV2ZW50Rm91bmRJbk1hcHMoZXZlbnRUeXBlKSB7XG4gIHJldHVybiAoZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCB8fCBldmVudFR5cGUgaW4gY3NzUHJvcGVydHlNYXApO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEBwYXJhbSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSBtYXBcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEphdmFTY3JpcHRFdmVudE5hbWUoZXZlbnRUeXBlLCBtYXAsIGVsKSB7XG4gIHJldHVybiBtYXBbZXZlbnRUeXBlXS5zdHlsZVByb3BlcnR5IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGRldGVybWluZSBicm93c2VyIHByZWZpeCBmb3IgQ1NTMyBhbmltYXRpb24gZXZlbnRzXG4gKiBhbmQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcGFyYW0geyFPYmplY3R9IHdpbmRvd09ialxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRBbmltYXRpb25OYW1lKHdpbmRvd09iaiwgZXZlbnRUeXBlKSB7XG4gIGlmICghaGFzUHJvcGVyU2hhcGUod2luZG93T2JqKSB8fCAhZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpKSB7XG4gICAgcmV0dXJuIGV2ZW50VHlwZTtcbiAgfVxuXG4gIGNvbnN0IG1hcCA9IC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFWZW5kb3JQcm9wZXJ0eU1hcFR5cGU+fSAqLyAoXG4gICAgZXZlbnRUeXBlIGluIGV2ZW50VHlwZU1hcCA/IGV2ZW50VHlwZU1hcCA6IGNzc1Byb3BlcnR5TWFwXG4gICk7XG4gIGNvbnN0IGVsID0gd2luZG93T2JqWydkb2N1bWVudCddWydjcmVhdGVFbGVtZW50J10oJ2RpdicpO1xuICBsZXQgZXZlbnROYW1lID0gJyc7XG5cbiAgaWYgKG1hcCA9PT0gZXZlbnRUeXBlTWFwKSB7XG4gICAgZXZlbnROYW1lID0gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50TmFtZSA9IG1hcFtldmVudFR5cGVdLm5vUHJlZml4IGluIGVsLnN0eWxlID8gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggOiBtYXBbZXZlbnRUeXBlXS53ZWJraXRQcmVmaXg7XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBQdWJsaWMgZnVuY3Rpb25zIHRvIGFjY2VzcyBnZXRBbmltYXRpb25OYW1lKCkgZm9yIEphdmFTY3JpcHQgZXZlbnRzIG9yIENTU1xuLy8gcHJvcGVydHkgbmFtZXMuXG5cbmNvbnN0IHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyA9IFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdNb3pUcmFuc2Zvcm0nLCAnT1RyYW5zZm9ybScsICdNU1RyYW5zZm9ybSddO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RFdmVudE5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgcmV0dXJuIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpO1xufVxuXG5leHBvcnQge3RyYW5zZm9ybVN0eWxlUHJvcGVydGllcywgZ2V0Q29ycmVjdEV2ZW50TmFtZSwgZ2V0Q29ycmVjdFByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiIGNsYXNzPVwibWRjLWNoZWNrYm94LXdyYXBwZXJcIj5cbiAgICA8ZGl2IHJlZj1cInJvb3RcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgY2xhc3M9XCJtZGMtY2hlY2tib3hcIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICByZWY9XCJjb250cm9sXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICA6dmFsdWU9XCJ2YWx1ZVwiXG4gICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19uYXRpdmUtY29udHJvbFwiXG4gICAgICAgIEBjaGFuZ2U9XCJvbkNoYW5nZVwiXG4gICAgICAvPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1jaGVja2JveF9fYmFja2dyb3VuZFwiPlxuICAgICAgICA8c3ZnIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmtcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCI+XG4gICAgICAgICAgPHBhdGhcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLWNoZWNrYm94X19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgICBmaWxsPVwibm9uZVwiXG4gICAgICAgICAgICBzdHJva2U9XCJ3aGl0ZVwiXG4gICAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIlxuICAgICAgICAgIC8+XG4gICAgICAgIDwvc3ZnPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLWNoZWNrYm94X19taXhlZG1hcmtcIiAvPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGxhYmVsIHJlZj1cImxhYmVsXCIgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgID48c2xvdD57eyBsYWJlbCB9fTwvc2xvdD48L2xhYmVsXG4gICAgPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG4vKiBnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbmltcG9ydCBNRENDaGVja2JveEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2NoZWNrYm94L2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZ2V0Q29ycmVjdEV2ZW50TmFtZSB9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcbmltcG9ydCB7IGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5cbmNvbnN0IENCX1BST1RPX1BST1BTID0gWydjaGVja2VkJywgJ2luZGV0ZXJtaW5hdGUnXVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hlY2tib3gnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdjaGVja2VkJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBjaGVja2VkOiBbQm9vbGVhbiwgQXJyYXldLFxuICAgIGluZGV0ZXJtaW5hdGU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICAnYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAnb24nXG4gICAgICB9XG4gICAgfSxcbiAgICBuYW1lOiBTdHJpbmdcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGNsYXNzZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGhhc0xhYmVsKCkge1xuICAgICAgcmV0dXJuIHRoaXMubGFiZWwgfHwgdGhpcy4kc2xvdHMuZGVmYXVsdFxuICAgIH0sXG4gICAgZm9ybUZpZWxkQ2xhc3NlcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdtZGMtZm9ybS1maWVsZCc6IHRoaXMuaGFzTGFiZWwsXG4gICAgICAgICdtZGMtZm9ybS1maWVsZC0tYWxpZ24tZW5kJzogdGhpcy5oYXNMYWJlbCAmJiB0aGlzLmFsaWduRW5kXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQ6ICdzZXRDaGVja2VkJyxcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRJbmRldGVybWluYXRlKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hlY2tib3hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xBdHRyOiAoYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVOYXRpdmVDb250cm9sQXR0cjogYXR0ciA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVBdHRyaWJ1dGUoYXR0cilcbiAgICAgIH0sXG4gICAgICAvLyBnZXROYXRpdmVDb250cm9sOiAoKSA9PiB0aGlzLiRyZWZzLmNvbnRyb2wsXG4gICAgICBpc0luZGV0ZXJtaW5hdGU6ICgpID0+IHRoaXMuJHJlZnMuY29udHJvbC5pbmRldGVybWluYXRlLFxuICAgICAgaXNDaGVja2VkOiAoKSA9PiB0aGlzLmNoZWNrZWQsXG4gICAgICBoYXNOYXRpdmVDb250cm9sOiAoKSA9PiAhIXRoaXMuJHJlZnMuY29udHJvbCxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xEaXNhYmxlZDogZGlzYWJsZWQgPT5cbiAgICAgICAgKHRoaXMuJHJlZnMuY29udHJvbC5kaXNhYmxlZCA9IGRpc2FibGVkKSxcbiAgICAgIGZvcmNlTGF5b3V0OiAoKSA9PiB0aGlzLiRyZWZzLnJvb3Qub2Zmc2V0V2lkdGgsXG4gICAgICBpc0F0dGFjaGVkVG9ET006ICgpID0+IEJvb2xlYW4odGhpcy4kZWwucGFyZW50Tm9kZSlcbiAgICB9KVxuXG4gICAgdGhpcy5oYW5kbGVBbmltYXRpb25FbmRfID0gKCkgPT4gdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUFuaW1hdGlvbkVuZCgpXG5cbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICdhbmltYXRpb25lbmQnKSxcbiAgICAgIHRoaXMuaGFuZGxlQW5pbWF0aW9uRW5kX1xuICAgIClcblxuICAgIHRoaXMuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKClcblxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IFJpcHBsZUJhc2UuaXNTdXJmYWNlQWN0aXZlKHRoaXMuJHJlZnMuY29udHJvbCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3JtRmllbGQgPSBuZXcgTURDRm9ybUZpZWxkRm91bmRhdGlvbih7XG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5hY3RpdmF0ZSgpXG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZUlucHV0UmlwcGxlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucmlwcGxlICYmIHRoaXMucmlwcGxlLmRlYWN0aXZhdGUoKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gICAgdGhpcy5mb3JtRmllbGQuaW5pdCgpXG4gICAgdGhpcy5zZXRDaGVja2VkKHRoaXMuY2hlY2tlZClcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQodGhpcy5kaXNhYmxlZClcbiAgICB0aGlzLnNldEluZGV0ZXJtaW5hdGUodGhpcy5pbmRldGVybWluYXRlKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoXG4gICAgICBnZXRDb3JyZWN0RXZlbnROYW1lKHdpbmRvdywgJ2FuaW1hdGlvbmVuZCcpLFxuICAgICAgdGhpcy5oYW5kbGVBbmltYXRpb25FbmRfXG4gICAgKVxuXG4gICAgdGhpcy5mb3JtRmllbGQuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG5cbiAgICB0aGlzLnVuaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5jaGVja2VkID0gQXJyYXkuaXNBcnJheShjaGVja2VkKVxuICAgICAgICA/IGNoZWNrZWQuaW5kZXhPZih0aGlzLnZhbHVlKSA+IC0xXG4gICAgICAgIDogY2hlY2tlZFxuICAgIH0sXG4gICAgc2V0SW5kZXRlcm1pbmF0ZShpbmRldGVybWluYXRlKSB7XG4gICAgICB0aGlzLiRyZWZzLmNvbnRyb2wuaW5kZXRlcm1pbmF0ZSA9IGluZGV0ZXJtaW5hdGVcbiAgICB9LFxuXG4gICAgb25DaGFuZ2UoKSB7XG4gICAgICB0aGlzLiRlbWl0KCd1cGRhdGU6aW5kZXRlcm1pbmF0ZScsIHRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICAgIGNvbnN0IGlzQ2hlY2tlZCA9IHRoaXMuJHJlZnMuY29udHJvbC5jaGVja2VkXG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2hlY2tlZCkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5jaGVja2VkLmluZGV4T2YodGhpcy52YWx1ZSlcbiAgICAgICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgICAgIGlkeCA8IDAgJiYgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5jaGVja2VkLmNvbmNhdCh0aGlzLnZhbHVlKSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZHggPiAtMSAmJlxuICAgICAgICAgICAgdGhpcy4kZW1pdChcbiAgICAgICAgICAgICAgJ2NoYW5nZScsXG4gICAgICAgICAgICAgIHRoaXMuY2hlY2tlZC5zbGljZSgwLCBpZHgpLmNvbmNhdCh0aGlzLmNoZWNrZWQuc2xpY2UoaWR4ICsgMSkpXG4gICAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGlzQ2hlY2tlZClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaW5zdGFsbFByb3BlcnR5Q2hhbmdlSG9va3NfKCkge1xuICAgICAgY29uc3QgbmF0aXZlQ2IgPSB0aGlzLiRyZWZzLmNvbnRyb2xcbiAgICAgIGNvbnN0IGNiUHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YobmF0aXZlQ2IpXG5cbiAgICAgIENCX1BST1RPX1BST1BTLmZvckVhY2goY29udHJvbFN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY2JQcm90bywgY29udHJvbFN0YXRlKVxuICAgICAgICAvLyBXZSBoYXZlIHRvIGNoZWNrIGZvciB0aGlzIGRlc2NyaXB0b3IsIHNpbmNlIHNvbWUgYnJvd3NlcnMgKFNhZmFyaSkgZG9uJ3Qgc3VwcG9ydCBpdHMgcmV0dXJuLlxuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD00OTczOVxuICAgICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgICAgY29uc3QgbmF0aXZlQ2JEZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoe1xuICAgICAgICAgICAgZ2V0OiBkZXNjLmdldCxcbiAgICAgICAgICAgIHNldDogc3RhdGUgPT4ge1xuICAgICAgICAgICAgICBkZXNjLnNldC5jYWxsKG5hdGl2ZUNiLCBzdGF0ZSlcbiAgICAgICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNoYW5nZSgpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBkZXNjLmNvbmZpZ3VyYWJsZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2MuZW51bWVyYWJsZVxuICAgICAgICAgIH0pXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIG5hdGl2ZUNiRGVzYylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuXG4gICAgdW5pbnN0YWxsUHJvcGVydHlDaGFuZ2VIb29rc18oKSB7XG4gICAgICBjb25zdCBuYXRpdmVDYiA9IHRoaXMuJHJlZnMuY29udHJvbFxuICAgICAgY29uc3QgY2JQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihuYXRpdmVDYilcblxuICAgICAgQ0JfUFJPVE9fUFJPUFMuZm9yRWFjaChjb250cm9sU3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBkZXNjID0gLyoqIEB0eXBlIHshT2JqZWN0UHJvcGVydHlEZXNjcmlwdG9yfSAqLyAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBjYlByb3RvLFxuICAgICAgICAgIGNvbnRyb2xTdGF0ZVxuICAgICAgICApKVxuICAgICAgICBpZiAodmFsaWREZXNjcmlwdG9yKGRlc2MpKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5hdGl2ZUNiLCBjb250cm9sU3RhdGUsIGRlc2MpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG5cbi8vID09PVxuLy8gUHJpdmF0ZSBmdW5jdGlvbnNcbi8vID09PVxuXG5mdW5jdGlvbiB2YWxpZERlc2NyaXB0b3IoaW5wdXRQcm9wRGVzYykge1xuICByZXR1cm4gISFpbnB1dFByb3BEZXNjICYmIHR5cGVvZiBpbnB1dFByb3BEZXNjLnNldCA9PT0gJ2Z1bmN0aW9uJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNDaGVja2JveCBmcm9tICcuL21kYy1jaGVja2JveC52dWUnXG5cbmV4cG9ydCB7IG1kY0NoZWNrYm94IH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0NoZWNrYm94XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGlwLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIENoaXAgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0NoaXBBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgbGVhZGluZyBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzVG9MZWFkaW5nSWNvbihjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsZWFkaW5nIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24oY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGFyZ2V0IGhhcyBjbGFzc05hbWUsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHshRXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBldmVudFRhcmdldEhhc0NsYXNzKHRhcmdldCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBcIk1EQ0NoaXA6aW50ZXJhY3Rpb25cIiBldmVudCBkZW5vdGluZyB0aGUgY2hpcCBoYXMgYmVlblxuICAgKiBpbnRlcmFjdGVkIHdpdGggKHR5cGljYWxseSBvbiBjbGljayBvciBrZXlkb3duKS5cbiAgICovXG4gIG5vdGlmeUludGVyYWN0aW9uKCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOnNlbGVjdGlvblwiIGV2ZW50IGRlbm90aW5nIHRoZSBjaGlwIGhhcyBiZWVuIHNlbGVjdGVkIG9yIGRlc2VsZWN0ZWQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICovXG4gIG5vdGlmeVNlbGVjdGlvbihzZWxlY3RlZCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gXCJNRENDaGlwOnRyYWlsaW5nSWNvbkludGVyYWN0aW9uXCIgZXZlbnQgZGVub3RpbmcgdGhlIHRyYWlsaW5nIGljb24gaGFzIGJlZW5cbiAgICogaW50ZXJhY3RlZCB3aXRoICh0eXBpY2FsbHkgb24gY2xpY2sgb3Iga2V5ZG93bikuXG4gICAqL1xuICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IFwiTURDQ2hpcDpyZW1vdmFsXCIgZGVub3RpbmcgdGhlIGNoaXAgd2lsbCBiZSByZW1vdmVkLlxuICAgKi9cbiAgbm90aWZ5UmVtb3ZhbCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldENvbXB1dGVkU3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHByb3BlcnR5IHZhbHVlIG9mIHRoZSBnaXZlbiBzdHlsZSBwcm9wZXJ0eSBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENDaGlwQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEVOVFJZX0FOSU1BVElPTl9OQU1FOiAnbWRjLWNoaXAtZW50cnknLFxuICBJTlRFUkFDVElPTl9FVkVOVDogJ01EQ0NoaXA6aW50ZXJhY3Rpb24nLFxuICBTRUxFQ1RJT05fRVZFTlQ6ICdNRENDaGlwOnNlbGVjdGlvbicsXG4gIFRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQ6ICdNRENDaGlwOnRyYWlsaW5nSWNvbkludGVyYWN0aW9uJyxcbiAgUkVNT1ZBTF9FVkVOVDogJ01EQ0NoaXA6cmVtb3ZhbCcsXG4gIENIRUNLTUFSS19TRUxFQ1RPUjogJy5tZGMtY2hpcF9fY2hlY2ttYXJrJyxcbiAgTEVBRElOR19JQ09OX1NFTEVDVE9SOiAnLm1kYy1jaGlwX19pY29uLS1sZWFkaW5nJyxcbiAgVFJBSUxJTkdfSUNPTl9TRUxFQ1RPUjogJy5tZGMtY2hpcF9faWNvbi0tdHJhaWxpbmcnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBDSEVDS01BUks6ICdtZGMtY2hpcF9fY2hlY2ttYXJrJyxcbiAgQ0hJUF9FWElUOiAnbWRjLWNoaXAtLWV4aXQnLFxuICBISURERU5fTEVBRElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLWxlYWRpbmctaGlkZGVuJyxcbiAgTEVBRElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLWxlYWRpbmcnLFxuICBUUkFJTElOR19JQ09OOiAnbWRjLWNoaXBfX2ljb24tLXRyYWlsaW5nJyxcbiAgU0VMRUNURUQ6ICdtZGMtY2hpcC0tc2VsZWN0ZWQnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDaGlwQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hpcEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0NoaXBGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDQ2hpcEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDQ2hpcEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGlwQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGFkZENsYXNzVG9MZWFkaW5nSWNvbjogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0Zyb21MZWFkaW5nSWNvbjogKCkgPT4ge30sXG4gICAgICBldmVudFRhcmdldEhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUludGVyYWN0aW9uOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeVNlbGVjdGlvbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlSZW1vdmFsOiAoKSA9PiB7fSxcbiAgICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZTogKCkgPT4ge30sXG4gICAgICBzZXRTdHlsZVByb3BlcnR5OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENDaGlwQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDQ2hpcEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgYSB0cmFpbGluZyBpY29uIGNsaWNrIHNob3VsZCBpbW1lZGlhdGVseSB0cmlnZ2VyIGV4aXQvcmVtb3ZhbCBvZiB0aGUgY2hpcC5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKiAqL1xuICAgIHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1NlbGVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICovXG4gIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG4gICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVNlbGVjdGlvbihzZWxlY3RlZCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldFNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2soKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja187XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZW1vdmVcbiAgICovXG4gIHNldFNob3VsZFJlbW92ZU9uVHJhaWxpbmdJY29uQ2xpY2soc2hvdWxkUmVtb3ZlKSB7XG4gICAgdGhpcy5zaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrXyA9IHNob3VsZFJlbW92ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbnMgdGhlIGV4aXQgYW5pbWF0aW9uIHdoaWNoIGxlYWRzIHRvIHJlbW92YWwgb2YgdGhlIGNoaXAuXG4gICAqL1xuICBiZWdpbkV4aXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkNISVBfRVhJVCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW50ZXJhY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgLy8gSGFuZGxlIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSBjaGlwIHdoZW4gaXQgaXMgYWJvdXQgdG8gYmUgcmVtb3ZlZC5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuQ0hJUF9FWElUKSkge1xuICAgICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICd3aWR0aCcpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlSZW1vdmFsKCk7XG4gICAgICB9IGVsc2UgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgPT09ICdvcGFjaXR5Jykge1xuICAgICAgICAvLyBTZWU6IGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vdXNpbmctY3NzLXRyYW5zaXRpb25zLWF1dG8tZGltZW5zaW9ucy8jYXJ0aWNsZS1oZWFkZXItaWQtNVxuICAgICAgICBjb25zdCBjaGlwV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnd2lkdGgnKTtcblxuICAgICAgICAvLyBPbiB0aGUgbmV4dCBmcmFtZSAob25jZSB3ZSBnZXQgdGhlIGNvbXB1dGVkIHdpZHRoKSwgZXhwbGljaXRseSBzZXQgdGhlIGNoaXAncyB3aWR0aFxuICAgICAgICAvLyB0byBpdHMgY3VycmVudCBwaXhlbCB3aWR0aCwgc28gd2UgYXJlbid0IHRyYW5zaXRpb25pbmcgb3V0IG9mICdhdXRvJy5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlUHJvcGVydHkoJ3dpZHRoJywgY2hpcFdpZHRoKTtcblxuICAgICAgICAgIC8vIFRvIG1pdGlnYXRlIGppdHRlciwgc3RhcnQgdHJhbnNpdGlvbmluZyBwYWRkaW5nIGFuZCBtYXJnaW4gYmVmb3JlIHdpZHRoLlxuICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgncGFkZGluZycsICcwJyk7XG4gICAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZVByb3BlcnR5KCdtYXJnaW4nLCAnMCcpO1xuXG4gICAgICAgICAgLy8gT24gdGhlIG5leHQgZnJhbWUgKG9uY2Ugd2lkdGggaXMgZXhwbGljaXRseSBzZXQpLCB0cmFuc2l0aW9uIHdpZHRoIHRvIDAuXG4gICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVQcm9wZXJ0eSgnd2lkdGgnLCAnMCcpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgYSB0cmFuc2l0aW9uIGVuZCBldmVudCBvbiB0aGUgbGVhZGluZyBpY29uIG9yIGNoZWNrbWFyaywgc2luY2UgdGhlIHRyYW5zaXRpb24gZW5kIGV2ZW50IGJ1YmJsZXMuXG4gICAgaWYgKGV2dC5wcm9wZXJ0eU5hbWUgIT09ICdvcGFjaXR5Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuTEVBRElOR19JQ09OKSAmJlxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU0VMRUNURUQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzVG9MZWFkaW5nSWNvbihjc3NDbGFzc2VzLkhJRERFTl9MRUFESU5HX0lDT04pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZXZ0LnRhcmdldCksIGNzc0NsYXNzZXMuQ0hFQ0tNQVJLKSAmJlxuICAgICAgICAgICAgICAgIXRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TRUxFQ1RFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24oY3NzQ2xhc3Nlcy5ISURERU5fTEVBRElOR19JQ09OKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudCBvbiB0aGUgdHJhaWxpbmcgaWNvbiBlbGVtZW50LiBUaGlzIGlzIHVzZWQgdG9cbiAgICogcHJldmVudCB0aGUgcmlwcGxlIGZyb20gYWN0aXZhdGluZyBvbiBpbnRlcmFjdGlvbiB3aXRoIHRoZSB0cmFpbGluZyBpY29uLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbihldnQpIHtcbiAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uKCk7XG4gICAgICBpZiAodGhpcy5zaG91bGRSZW1vdmVPblRyYWlsaW5nSWNvbkNsaWNrXykge1xuICAgICAgICB0aGlzLmJlZ2luRXhpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGRldGFpbDoge1xuICogICAgIGNoaXBJZDogc3RyaW5nLFxuICogICB9LFxuICogICBidWJibGVzOiBib29sZWFuLFxuICogfX1cbiAqL1xubGV0IE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBkZXRhaWw6IHtcbiAqICAgICBjaGlwSWQ6IHN0cmluZyxcbiAqICAgICBzZWxlY3RlZDogYm9vbGVhbixcbiAqICAgfSxcbiAqICAgYnViYmxlczogYm9vbGVhbixcbiAqIH19XG4gKi9cbmxldCBNRENDaGlwU2VsZWN0aW9uRXZlbnRUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGRldGFpbDoge1xuICogICAgIGNoaXBJZDogc3RyaW5nLFxuICogICAgIHJvb3Q6IEVsZW1lbnQsXG4gKiAgIH0sXG4gKiAgIGJ1YmJsZXM6IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgTURDQ2hpcFJlbW92YWxFdmVudFR5cGU7XG5cbmV4cG9ydCB7TURDQ2hpcEZvdW5kYXRpb24sIE1EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZSwgTURDQ2hpcFNlbGVjdGlvbkV2ZW50VHlwZSwgTURDQ2hpcFJlbW92YWxFdmVudFR5cGV9O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmlkPVwiaWRcIlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICBAY2xpY2s9XCJoYW5kbGVJbnRlcmFjdGlvblwiXG4gICAgQGtleWRvd249XCJoYW5kbGVJbnRlcmFjdGlvblwiXG4gICAgQHRyYW5zaXRpb25lbmQ9XCJoYW5kbGVUcmFuc2l0aW9uRW5kXCJcbiAgPlxuICAgIDxpXG4gICAgICB2LWlmPVwiaGF2ZWxlYWRpbmdJY29uXCJcbiAgICAgIHJlZj1cImxlYWRpbmdJY29uXCJcbiAgICAgIDpjbGFzcz1cImxlYWRpbmdDbGFzc2VzXCJcbiAgICAgIGNsYXNzPVwibWRjLWNoaXBfX2ljb24gbWRjLWNoaXBfX2ljb24tLWxlYWRpbmdcIlxuICAgICAgPnt7IGxlYWRpbmdJY29uIH19PC9pXG4gICAgPlxuICAgIDxkaXYgdi1pZj1cImlzRmlsdGVyXCIgY2xhc3M9XCJtZGMtY2hpcF9fY2hlY2ttYXJrXCI+XG4gICAgICA8c3ZnIGNsYXNzPVwibWRjLWNoaXBfX2NoZWNrbWFyay1zdmdcIiB2aWV3Qm94PVwiLTIgLTMgMzAgMzBcIj5cbiAgICAgICAgPHBhdGhcbiAgICAgICAgICBjbGFzcz1cIm1kYy1jaGlwX19jaGVja21hcmstcGF0aFwiXG4gICAgICAgICAgZmlsbD1cIm5vbmVcIlxuICAgICAgICAgIHN0cm9rZT1cImJsYWNrXCJcbiAgICAgICAgICBkPVwiTTEuNzMsMTIuOTEgOC4xLDE5LjI4IDIyLjc5LDQuNTlcIlxuICAgICAgICAvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1jaGlwX190ZXh0XCI+PHNsb3QgLz48L2Rpdj5cbiAgICA8aVxuICAgICAgdi1pZj1cImhhdmV0cmFpbGluZ0ljb25cIlxuICAgICAgcmVmPVwidHJhaWxpbmdJY29uXCJcbiAgICAgIDpjbGFzcz1cInRyYWlsaW5nQ2xhc3Nlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1jaGlwX19pY29uIG1kYy1jaGlwX19pY29uLS10cmFpbGluZ1wiXG4gICAgICB0YWJpbmRleD1cIjBcIlxuICAgICAgcm9sZT1cImJ1dHRvblwiXG4gICAgICBAY2xpY2s9XCJoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvblwiXG4gICAgICBAa2V5ZG93bj1cImhhbmRsZVRyYWlsaW5nSWNvbkludGVyYWN0aW9uXCJcbiAgICAgID57eyB0cmFpbGluZ0ljb24gfX08L2lcbiAgICA+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cbmFwcGx5UGFzc2l2ZVxuPHNjcmlwdD5cbmltcG9ydCB7IE1EQ0NoaXBGb3VuZGF0aW9uIH0gZnJvbSAnQG1hdGVyaWFsL2NoaXBzL2NoaXAvZm91bmRhdGlvbidcbmltcG9ydCB7IEN1c3RvbUxpbmtNaXhpbiwgZW1pdEN1c3RvbUV2ZW50IH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1jaGlwJyxcbiAgbWl4aW5zOiBbQ3VzdG9tTGlua01peGluXSxcbiAgcHJvcHM6IHtcbiAgICBsZWFkaW5nSWNvbjogW1N0cmluZ10sXG4gICAgdHJhaWxpbmdJY29uOiBbU3RyaW5nXSxcbiAgICBsZWFkaW5nSWNvbkNsYXNzZXM6IFtPYmplY3RdLFxuICAgIHRyYWlsaW5nSWNvbkNsYXNzZXM6IFtPYmplY3RdXG4gIH0sXG4gIGluamVjdDogWydtZGNDaGlwU2V0J10sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1jaGlwJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHN0eWxlczoge30sXG4gICAgICBpZDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgc2VsZWN0ZWQ6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc1NlbGVjdGVkKClcbiAgICAgIH0sXG4gICAgICBzZXQobnYpIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFNlbGVjdGVkKG52KVxuICAgICAgfVxuICAgIH0sXG4gICAgaXNGaWx0ZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNDaGlwU2V0ICYmIHRoaXMubWRjQ2hpcFNldC5maWx0ZXJcbiAgICB9LFxuICAgIGhhdmVsZWFkaW5nSWNvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubGVhZGluZ0ljb24gfHwgdGhpcy5sZWFkaW5nSWNvbkNsYXNzZXNcbiAgICB9LFxuICAgIGhhdmV0cmFpbGluZ0ljb24oKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnRyYWlsaW5nSWNvbiB8fCB0aGlzLnRyYWlsaW5nSWNvbkNsYXNzZXNcbiAgICB9LFxuICAgIGxlYWRpbmdDbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICB7XG4gICAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmxlYWRpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMubGVhZGluZ0ljb25DbGFzc2VzXG4gICAgICApXG4gICAgfSxcbiAgICB0cmFpbGluZ0NsYXNzZXMoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIHtcbiAgICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMudHJhaWxpbmdJY29uXG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMudHJhaWxpbmdJY29uQ2xhc3Nlc1xuICAgICAgKVxuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkKCkge1xuICAgIHRoaXMuaWQgPSB0aGlzLm1kY0NoaXBTZXQubmV4dElkKClcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hpcEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFkZENsYXNzVG9MZWFkaW5nSWNvbjogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaGF2ZWxlYWRpbmdJY29uKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sZWFkaW5nSWNvbi5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzRnJvbUxlYWRpbmdJY29uOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXZlbGVhZGluZ0ljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxlYWRpbmdJY29uLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBub3RpZnlJbnRlcmFjdGlvbjogKCkgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5JTlRFUkFDVElPTl9FVkVOVCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaGlwSWQ6IHRoaXMuaWRcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuICAgICAgICB0aGlzLm1kY0NoaXBTZXQgJiYgdGhpcy5tZGNDaGlwU2V0LmhhbmRsZUludGVyYWN0aW9uXG4gICAgICB9LFxuXG4gICAgICBub3RpZnlTZWxlY3Rpb246IHNlbGVjdGVkID0+XG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlNFTEVDVElPTl9FVkVOVCxcbiAgICAgICAgICB7IGNoaXBJZDogdGhpcy5pZCwgc2VsZWN0ZWQ6IHNlbGVjdGVkIH0sXG4gICAgICAgICAgdHJ1ZSAvKiBzaG91bGRCdWJibGUgKi9cbiAgICAgICAgKSxcbiAgICAgIG5vdGlmeVRyYWlsaW5nSWNvbkludGVyYWN0aW9uOiAoKSA9PiB7XG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2hpcElkOiB0aGlzLmlkXG4gICAgICAgICAgfSxcbiAgICAgICAgICB0cnVlXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBub3RpZnlSZW1vdmFsOiAoKSA9PiB7XG4gICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICBNRENDaGlwRm91bmRhdGlvbi5zdHJpbmdzLlJFTU9WQUxfRVZFTlQsXG4gICAgICAgICAgeyBjaGlwSWQ6IHRoaXMuaWQsIHJvb3Q6IHRoaXMuJGVsIH0sXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT5cbiAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKSxcbiAgICAgIHNldFN0eWxlUHJvcGVydHk6IChwcm9wZXJ0eSwgdmFsdWUpID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLm1kY0NoaXBTZXQuY2hpcHMucHVzaCh0aGlzKVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMucmlwcGxlLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUludGVyYWN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUludGVyYWN0aW9uKGV2dClcbiAgICB9LFxuICAgIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpXG4gICAgfSxcbiAgICBoYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbihldnQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVUcmFpbGluZ0ljb25JbnRlcmFjdGlvbihldnQpXG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3RlZCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi50b2dnbGVTZWxlY3RlZCgpXG4gICAgfSxcbiAgICBpc1NlbGVjdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc1NlbGVjdGVkKClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBDaGlwIFNldC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBDaGlwIFNldCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDQ2hpcFNldEFkYXB0ZXIge1xuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSByb290IGVsZW1lbnQgY29udGFpbnMgdGhlIGdpdmVuIGNsYXNzIG5hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgY2hpcCB3aXRoIHRoZSBnaXZlbiBpZCBmcm9tIHRoZSBjaGlwIHNldC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaXBJZFxuICAgKi9cbiAgcmVtb3ZlQ2hpcChjaGlwSWQpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNlbGVjdGVkIHN0YXRlIG9mIHRoZSBjaGlwIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpcElkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICovXG4gIHNldFNlbGVjdGVkKGNoaXBJZCwgc2VsZWN0ZWQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NoaXBTZXRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQ0hJUF9TRUxFQ1RPUjogJy5tZGMtY2hpcCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIENIT0lDRTogJ21kYy1jaGlwLXNldC0tY2hvaWNlJyxcbiAgRklMVEVSOiAnbWRjLWNoaXAtc2V0LS1maWx0ZXInLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENDaGlwU2V0QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge01EQ0NoaXBJbnRlcmFjdGlvbkV2ZW50VHlwZSwgTURDQ2hpcFNlbGVjdGlvbkV2ZW50VHlwZSwgTURDQ2hpcFJlbW92YWxFdmVudFR5cGV9IGZyb20gJy4uL2NoaXAvZm91bmRhdGlvbic7XG5pbXBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDQ2hpcFNldEFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0NoaXBTZXRGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDQ2hpcFNldEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDQ2hpcFNldEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENDaGlwU2V0QWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNoaXA6ICgpID0+IHt9LFxuICAgICAgc2V0U2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0NoaXBTZXRBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENDaGlwU2V0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGlkcyBvZiB0aGUgc2VsZWN0ZWQgY2hpcHMgaW4gdGhlIHNldC4gT25seSB1c2VkIGZvciBjaG9pY2UgY2hpcCBzZXQgb3IgZmlsdGVyIGNoaXAgc2V0LlxuICAgICAqIEBwcml2YXRlIHshQXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGVkQ2hpcElkc18gPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBJRHMgb2YgYWxsIHNlbGVjdGVkIGNoaXBzLlxuICAgKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAgICovXG4gIGdldFNlbGVjdGVkQ2hpcElkcygpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZENoaXBJZHNfO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgc2VsZWN0aW9uIG9mIHRoZSBjaGlwIHdpdGggdGhlIGdpdmVuIGlkLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpcElkXG4gICAqL1xuICB0b2dnbGVTZWxlY3RfKGNoaXBJZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQ2hpcElkc18uaW5kZXhPZihjaGlwSWQpID49IDApIHtcbiAgICAgIHRoaXMuZGVzZWxlY3RfKGNoaXBJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VsZWN0KGNoaXBJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbGVjdHMgdGhlIGNoaXAgd2l0aCB0aGUgZ2l2ZW4gaWQuIERlc2VsZWN0cyBhbGwgb3RoZXIgY2hpcHMgaWYgdGhlIGNoaXAgc2V0IGlzIG9mIHRoZSBjaG9pY2UgdmFyaWFudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaXBJZFxuICAgKi9cbiAgc2VsZWN0KGNoaXBJZCkge1xuICAgIGlmICh0aGlzLnNlbGVjdGVkQ2hpcElkc18uaW5kZXhPZihjaGlwSWQpID49IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkNIT0lDRSkgJiYgdGhpcy5zZWxlY3RlZENoaXBJZHNfLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzbHlTZWxlY3RlZENoaXAgPSB0aGlzLnNlbGVjdGVkQ2hpcElkc19bMF07XG4gICAgICB0aGlzLnNlbGVjdGVkQ2hpcElkc18ubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U2VsZWN0ZWQocHJldmlvdXNseVNlbGVjdGVkQ2hpcCwgZmFsc2UpO1xuICAgIH1cbiAgICB0aGlzLnNlbGVjdGVkQ2hpcElkc18ucHVzaChjaGlwSWQpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2VsZWN0ZWQoY2hpcElkLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlbGVjdHMgdGhlIGNoaXAgd2l0aCB0aGUgZ2l2ZW4gaWQuXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlwSWRcbiAgICovXG4gIGRlc2VsZWN0XyhjaGlwSWQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2VsZWN0ZWRDaGlwSWRzXy5pbmRleE9mKGNoaXBJZCk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRDaGlwSWRzXy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTZWxlY3RlZChjaGlwSWQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNoaXAgaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNoaXBJZFxuICAgKi9cbiAgaGFuZGxlQ2hpcEludGVyYWN0aW9uKGNoaXBJZCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuQ0hPSUNFKSB8fCB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuRklMVEVSKSkge1xuICAgICAgdGhpcy50b2dnbGVTZWxlY3RfKGNoaXBJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSBjaGlwIHNlbGVjdGlvbiBldmVudCwgdXNlZCB0byBoYW5kbGUgZGlzY3JlcGFuY3kgd2hlbiBzZWxlY3Rpb24gc3RhdGUgaXMgc2V0IGRpcmVjdGx5IG9uIHRoZSBDaGlwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hpcElkXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0ZWRcbiAgICovXG4gIGhhbmRsZUNoaXBTZWxlY3Rpb24oY2hpcElkLCBzZWxlY3RlZCkge1xuICAgIGNvbnN0IGNoaXBJc1NlbGVjdGVkID0gdGhpcy5zZWxlY3RlZENoaXBJZHNfLmluZGV4T2YoY2hpcElkKSA+PSAwO1xuICAgIGlmIChzZWxlY3RlZCAmJiAhY2hpcElzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuc2VsZWN0KGNoaXBJZCk7XG4gICAgfSBlbHNlIGlmICghc2VsZWN0ZWQgJiYgY2hpcElzU2VsZWN0ZWQpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3RfKGNoaXBJZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGV2ZW50IHdoZW4gYSBjaGlwIGlzIHJlbW92ZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGlwSWRcbiAgICovXG4gIGhhbmRsZUNoaXBSZW1vdmFsKGNoaXBJZCkge1xuICAgIHRoaXMuZGVzZWxlY3RfKGNoaXBJZCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDaGlwKGNoaXBJZCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDQ2hpcFNldEZvdW5kYXRpb247XG4iLCI8c2NyaXB0PlxuaW1wb3J0IE1EQ0NoaXBTZXRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9jaGlwcy9jaGlwLXNldC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgTURDQ2hpcEZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvY2hpcHMvY2hpcC9mb3VuZGF0aW9uJ1xuXG5sZXQgaWRDb3VudGVyID0gMFxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtY2hpcC1zZXQnLFxuICBwcm9wczoge1xuICAgIGNob2ljZTogW0Jvb2xlYW5dLFxuICAgIGZpbHRlcjogW0Jvb2xlYW5dLFxuICAgIGlucHV0OiBbQm9vbGVhbl1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNDaGlwU2V0OiB0aGlzIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLWNoaXAtc2V0JzogdHJ1ZSxcbiAgICAgICAgJ21kYy1jaGlwLXNldC0tY2hvaWNlJzogdGhpcy5jaG9pY2UsXG4gICAgICAgICdtZGMtY2hpcC1zZXQtLWZpbHRlcic6IHRoaXMuZmlsdGVyLFxuICAgICAgICAnbWRjLWNoaXAtc2V0LS1pbnB1dCc6IHRoaXMuaW5wdXRcbiAgICAgIH0sXG5cbiAgICAgIGNoaXBzOiBbXVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDQ2hpcFNldEZvdW5kYXRpb24oe1xuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNoaXA6IGNoaXBJZCA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5maW5kQ2hpcEluZGV4KGNoaXBJZClcblxuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgdGhpcy4kbmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGlwcy5zcGxpY2UoaW5kZXgsIDEpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFNlbGVjdGVkOiAoY2hpcElkLCBzZWxlY3RlZCkgPT4ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZENoaXBJbmRleChjaGlwSWQpXG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5jaGlwc1tpbmRleF0uc2VsZWN0ZWQgPSBzZWxlY3RlZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBuZXh0SWQoKSB7XG4gICAgICByZXR1cm4gYG1kYy1jaGlwLSR7KytpZENvdW50ZXJ9YFxuICAgIH0sXG4gICAgZmluZENoaXBJbmRleChjaGlwSWQpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGhpcy5jaGlwc1tpXS5pZCA9PT0gY2hpcElkKSB7XG4gICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xXG4gICAgfSxcbiAgICBoYW5kbGVDaGlwSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hpcEludGVyYWN0aW9uKGV2dC5kZXRhaWwuY2hpcElkKVxuICAgIH0sXG4gICAgaGFuZGxlQ2hpcFJlbW92YWwoZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hpcFJlbW92YWwoZXZ0LmRldGFpbC5jaGlwSWQpXG4gICAgfSxcbiAgICBoYW5kbGVDaGlwU2VsZWN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNoaXBTZWxlY3Rpb24oXG4gICAgICAgIGV2dC5kZXRhaWwuY2hpcElkLFxuICAgICAgICBldnQuZGV0YWlsLnNlbGVjdGVkXG4gICAgICApXG4gICAgfVxuICB9LFxuICByZW5kZXIoaCkge1xuICAgIHJldHVybiBoKFxuICAgICAgJ2RpdicsXG4gICAgICB7XG4gICAgICAgIGNsYXNzOiB0aGlzLmNsYXNzZXMsXG4gICAgICAgIG9uOiB7XG4gICAgICAgICAgW01EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RJT05fRVZFTlRdOiBldnQgPT5cbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2hpcEludGVyYWN0aW9uKGV2dCksXG4gICAgICAgICAgW01EQ0NoaXBGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNUSU9OX0VWRU5UXTogZXZ0ID0+XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoaXBTZWxlY3Rpb24oZXZ0KSxcbiAgICAgICAgICBbTURDQ2hpcEZvdW5kYXRpb24uc3RyaW5ncy5SRU1PVkFMX0VWRU5UXTogZXZ0ID0+XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoaXBSZW1vdmFsKGV2dClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHRoaXMuJHNsb3RzLmRlZmF1bHRcbiAgICApXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjQ2hpcCBmcm9tICcuL21kYy1jaGlwLnZ1ZSdcbmltcG9ydCBtZGNDaGlwU2V0IGZyb20gJy4vbWRjLWNoaXAtc2V0LnZ1ZSdcblxuZXhwb3J0IHsgbWRjQ2hpcCwgbWRjQ2hpcFNldCB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNDaGlwLFxuICBtZGNDaGlwU2V0XG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBEaWFsb2cuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmc6XG4gKiAtIENTUyBjbGFzc2VzXG4gKiAtIERPTVxuICogLSBFdmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDRGlhbG9nQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRCb2R5Q2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUJvZHlDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBldmVudFRhcmdldE1hdGNoZXModGFyZ2V0LCBzZWxlY3Rvcikge31cblxuICB0cmFwRm9jdXMoKSB7fVxuICByZWxlYXNlRm9jdXMoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0NvbnRlbnRTY3JvbGxhYmxlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYXJlQnV0dG9uc1N0YWNrZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGdldEFjdGlvbkZyb21FdmVudChldmVudCkge31cblxuICBjbGlja0RlZmF1bHRCdXR0b24oKSB7fVxuICByZXZlcnNlQnV0dG9ucygpIHt9XG5cbiAgbm90aWZ5T3BlbmluZygpIHt9XG4gIG5vdGlmeU9wZW5lZCgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb25cbiAgICovXG4gIG5vdGlmeUNsb3NpbmcoYWN0aW9uKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYWN0aW9uXG4gICAqL1xuICBub3RpZnlDbG9zZWQoYWN0aW9uKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENEaWFsb2dBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIE9QRU46ICdtZGMtZGlhbG9nLS1vcGVuJyxcbiAgT1BFTklORzogJ21kYy1kaWFsb2ctLW9wZW5pbmcnLFxuICBDTE9TSU5HOiAnbWRjLWRpYWxvZy0tY2xvc2luZycsXG4gIFNDUk9MTEFCTEU6ICdtZGMtZGlhbG9nLS1zY3JvbGxhYmxlJyxcbiAgU1RBQ0tFRDogJ21kYy1kaWFsb2ctLXN0YWNrZWQnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kaWFsb2ctc2Nyb2xsLWxvY2snLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgU0NSSU1fU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fc2NyaW0nLFxuICBDT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLWRpYWxvZ19fY29udGFpbmVyJyxcbiAgU1VSRkFDRV9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19zdXJmYWNlJyxcbiAgQ09OVEVOVF9TRUxFQ1RPUjogJy5tZGMtZGlhbG9nX19jb250ZW50JyxcbiAgQlVUVE9OX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2dfX2J1dHRvbicsXG4gIERFRkFVTFRfQlVUVE9OX1NFTEVDVE9SOiAnLm1kYy1kaWFsb2dfX2J1dHRvbi0tZGVmYXVsdCcsXG4gIFNVUFBSRVNTX0RFRkFVTFRfUFJFU1NfU0VMRUNUT1I6IFtcbiAgICAndGV4dGFyZWEnLFxuICAgICcubWRjLW1lbnUgLm1kYy1saXN0LWl0ZW0nLFxuICBdLmpvaW4oJywgJyksXG5cbiAgT1BFTklOR19FVkVOVDogJ01EQ0RpYWxvZzpvcGVuaW5nJyxcbiAgT1BFTkVEX0VWRU5UOiAnTURDRGlhbG9nOm9wZW5lZCcsXG4gIENMT1NJTkdfRVZFTlQ6ICdNRENEaWFsb2c6Y2xvc2luZycsXG4gIENMT1NFRF9FVkVOVDogJ01EQ0RpYWxvZzpjbG9zZWQnLFxuXG4gIEFDVElPTl9BVFRSSUJVVEU6ICdkYXRhLW1kYy1kaWFsb2ctYWN0aW9uJyxcblxuICBDTE9TRV9BQ1RJT046ICdjbG9zZScsXG4gIERFU1RST1lfQUNUSU9OOiAnZGVzdHJveScsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBESUFMT0dfQU5JTUFUSU9OX09QRU5fVElNRV9NUzogMTUwLFxuICBESUFMT0dfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVM6IDc1LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENEaWFsb2dBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIG51bWJlcnMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuY2xhc3MgTURDRGlhbG9nRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENEaWFsb2dBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZXZlbnRUYXJnZXRNYXRjaGVzOiAoLyogdGFyZ2V0OiAhRXZlbnRUYXJnZXQsIHNlbGVjdG9yOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgdHJhcEZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHJlbGVhc2VGb2N1czogKCkgPT4ge30sXG4gICAgICBpc0NvbnRlbnRTY3JvbGxhYmxlOiAoKSA9PiB7fSxcbiAgICAgIGFyZUJ1dHRvbnNTdGFja2VkOiAoKSA9PiB7fSxcbiAgICAgIGdldEFjdGlvbkZyb21FdmVudDogKC8qIGV2ZW50OiAhRXZlbnQgKi8pID0+IHt9LFxuICAgICAgY2xpY2tEZWZhdWx0QnV0dG9uOiAoKSA9PiB7fSxcbiAgICAgIHJldmVyc2VCdXR0b25zOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeU9wZW5pbmc6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5T3BlbmVkOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNsb3Npbmc6ICgvKiBhY3Rpb246ID9zdHJpbmcgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5Q2xvc2VkOiAoLyogYWN0aW9uOiA/c3RyaW5nICovKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENEaWFsb2dBZGFwdGVyPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDRGlhbG9nRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25GcmFtZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25UaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5lc2NhcGVLZXlBY3Rpb25fID0gc3RyaW5ncy5DTE9TRV9BQ1RJT047XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZ30gKi9cbiAgICB0aGlzLnNjcmltQ2xpY2tBY3Rpb25fID0gc3RyaW5ncy5DTE9TRV9BQ1RJT047XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hdXRvU3RhY2tCdXR0b25zXyA9IHRydWU7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5hcmVCdXR0b25zU3RhY2tlZF8gPSBmYWxzZTtcbiAgfTtcblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuU1RBQ0tFRCkpIHtcbiAgICAgIHRoaXMuc2V0QXV0b1N0YWNrQnV0dG9ucyhmYWxzZSk7XG4gICAgfVxuICB9O1xuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuXykge1xuICAgICAgdGhpcy5jbG9zZShzdHJpbmdzLkRFU1RST1lfQUNUSU9OKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hbmltYXRpb25UaW1lcl8pIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxheW91dEZyYW1lXykge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5sYXlvdXRGcmFtZV8pO1xuICAgICAgdGhpcy5sYXlvdXRGcmFtZV8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeU9wZW5pbmcoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuT1BFTklORyk7XG5cbiAgICAvLyBXYWl0IGEgZnJhbWUgb25jZSBkaXNwbGF5IGlzIG5vIGxvbmdlciBcIm5vbmVcIiwgdG8gZXN0YWJsaXNoIGJhc2lzIGZvciBhbmltYXRpb25cbiAgICB0aGlzLnJ1bk5leHRBbmltYXRpb25GcmFtZV8oKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLk9QRU4pO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG5cbiAgICAgIHRoaXMubGF5b3V0KCk7XG5cbiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlQW5pbWF0aW9uVGltZXJFbmRfKCk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udHJhcEZvY3VzKCk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5T3BlbmVkKCk7XG4gICAgICB9LCBudW1iZXJzLkRJQUxPR19BTklNQVRJT05fT1BFTl9USU1FX01TKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGFjdGlvblxuICAgKi9cbiAgY2xvc2UoYWN0aW9uID0gJycpIHtcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgLy8gQXZvaWQgcmVkdW5kYW50IGNsb3NlIGNhbGxzIChhbmQgZXZlbnRzKSwgZS5nLiBmcm9tIGtleWRvd24gb24gZWxlbWVudHMgdGhhdCBpbmhlcmVudGx5IGVtaXQgY2xpY2tcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNsb3NpbmcoYWN0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0xPU0lORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLk9QRU4pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQm9keUNsYXNzKGNzc0NsYXNzZXMuU0NST0xMX0xPQ0spO1xuXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZV8pO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVfID0gMDtcblxuICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyXyk7XG4gICAgdGhpcy5hbmltYXRpb25UaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVsZWFzZUZvY3VzKCk7XG4gICAgICB0aGlzLmhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zZWQoYWN0aW9uKTtcbiAgICB9LCBudW1iZXJzLkRJQUxPR19BTklNQVRJT05fQ0xPU0VfVElNRV9NUyk7XG4gIH1cblxuICBpc09wZW4oKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNPcGVuXztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gIGdldEVzY2FwZUtleUFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5lc2NhcGVLZXlBY3Rpb25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gKi9cbiAgc2V0RXNjYXBlS2V5QWN0aW9uKGFjdGlvbikge1xuICAgIHRoaXMuZXNjYXBlS2V5QWN0aW9uXyA9IGFjdGlvbjtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtzdHJpbmd9ICovXG4gIGdldFNjcmltQ2xpY2tBY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyaW1DbGlja0FjdGlvbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGFjdGlvbiAqL1xuICBzZXRTY3JpbUNsaWNrQWN0aW9uKGFjdGlvbikge1xuICAgIHRoaXMuc2NyaW1DbGlja0FjdGlvbl8gPSBhY3Rpb247XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0QXV0b1N0YWNrQnV0dG9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRvU3RhY2tCdXR0b25zXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGF1dG9TdGFjayAqL1xuICBzZXRBdXRvU3RhY2tCdXR0b25zKGF1dG9TdGFjaykge1xuICAgIHRoaXMuYXV0b1N0YWNrQnV0dG9uc18gPSBhdXRvU3RhY2s7XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgaWYgKHRoaXMubGF5b3V0RnJhbWVfKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmxheW91dEZyYW1lXyk7XG4gICAgfVxuICAgIHRoaXMubGF5b3V0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMubGF5b3V0SW50ZXJuYWxfKCk7XG4gICAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG4gICAgfSk7XG4gIH1cblxuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgaWYgKHRoaXMuYXV0b1N0YWNrQnV0dG9uc18pIHtcbiAgICAgIHRoaXMuZGV0ZWN0U3RhY2tlZEJ1dHRvbnNfKCk7XG4gICAgfVxuICAgIHRoaXMuZGV0ZWN0U2Nyb2xsYWJsZUNvbnRlbnRfKCk7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGV0ZWN0U3RhY2tlZEJ1dHRvbnNfKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY2xhc3MgZmlyc3QgdG8gbGV0IHVzIG1lYXN1cmUgdGhlIGJ1dHRvbnMnIG5hdHVyYWwgcG9zaXRpb25zLlxuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TVEFDS0VEKTtcblxuICAgIGNvbnN0IGFyZUJ1dHRvbnNTdGFja2VkID0gdGhpcy5hZGFwdGVyXy5hcmVCdXR0b25zU3RhY2tlZCgpO1xuXG4gICAgaWYgKGFyZUJ1dHRvbnNTdGFja2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuU1RBQ0tFRCk7XG4gICAgfVxuXG4gICAgaWYgKGFyZUJ1dHRvbnNTdGFja2VkICE9PSB0aGlzLmFyZUJ1dHRvbnNTdGFja2VkXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZXZlcnNlQnV0dG9ucygpO1xuICAgICAgdGhpcy5hcmVCdXR0b25zU3RhY2tlZF8gPSBhcmVCdXR0b25zU3RhY2tlZDtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGV0ZWN0U2Nyb2xsYWJsZUNvbnRlbnRfKCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY2xhc3MgZmlyc3QgdG8gbGV0IHVzIG1lYXN1cmUgdGhlIG5hdHVyYWwgaGVpZ2h0IG9mIHRoZSBjb250ZW50LlxuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExBQkxFKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc0NvbnRlbnRTY3JvbGxhYmxlKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExBQkxFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgY29uc3QgaXNDbGljayA9IGV2dC50eXBlID09PSAnY2xpY2snO1xuICAgIGNvbnN0IGlzRW50ZXIgPSBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMztcblxuICAgIC8vIENoZWNrIGZvciBzY3JpbSBjbGljayBmaXJzdCBzaW5jZSBpdCBkb2Vzbid0IHJlcXVpcmUgcXVlcnlpbmcgYW5jZXN0b3JzXG4gICAgaWYgKGlzQ2xpY2sgJiYgdGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldE1hdGNoZXMoZXZ0LnRhcmdldCwgc3RyaW5ncy5TQ1JJTV9TRUxFQ1RPUikgJiZcbiAgICAgIHRoaXMuc2NyaW1DbGlja0FjdGlvbl8gIT09ICcnKSB7XG4gICAgICB0aGlzLmNsb3NlKHRoaXMuc2NyaW1DbGlja0FjdGlvbl8pO1xuICAgIH0gZWxzZSBpZiAoaXNDbGljayB8fCBldnQua2V5ID09PSAnU3BhY2UnIHx8IGV2dC5rZXlDb2RlID09PSAzMiB8fCBpc0VudGVyKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSB0aGlzLmFkYXB0ZXJfLmdldEFjdGlvbkZyb21FdmVudChldnQpO1xuICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICB0aGlzLmNsb3NlKGFjdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGlzRW50ZXIgJiYgIXRoaXMuYWRhcHRlcl8uZXZlbnRUYXJnZXRNYXRjaGVzKGV2dC50YXJnZXQsIHN0cmluZ3MuU1VQUFJFU1NfREVGQVVMVF9QUkVTU19TRUxFQ1RPUikpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5jbGlja0RlZmF1bHRCdXR0b24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb2N1bWVudEtleWRvd24oZXZ0KSB7XG4gICAgaWYgKChldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpICYmIHRoaXMuZXNjYXBlS2V5QWN0aW9uXyAhPT0gJycpIHtcbiAgICAgIHRoaXMuY2xvc2UodGhpcy5lc2NhcGVLZXlBY3Rpb25fKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgaGFuZGxlQW5pbWF0aW9uVGltZXJFbmRfKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXJfID0gMDtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuT1BFTklORyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkNMT1NJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGdpdmVuIGxvZ2ljIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSwgdXNpbmcgc2V0VGltZW91dCB0byBmYWN0b3IgaW4gRmlyZWZveCByZWZsb3cgYmVoYXZpb3IuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydW5OZXh0QW5pbWF0aW9uRnJhbWVfKGNhbGxiYWNrKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5hbmltYXRpb25GcmFtZV8pO1xuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVfID0gMDtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLmFuaW1hdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIDApO1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0RpYWxvZ0ZvdW5kYXRpb247XG4iLCJ2YXIgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF0nLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG5dO1xudmFyIGNhbmRpZGF0ZVNlbGVjdG9yID0gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxudmFyIG1hdGNoZXMgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCdcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5mdW5jdGlvbiB0YWJiYWJsZShlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgZWxlbWVudERvY3VtZW50ID0gZWwub3duZXJEb2N1bWVudCB8fCBlbDtcbiAgdmFyIHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgdmFyIG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcblxuICB2YXIgdW50b3VjaGFiaWxpdHlDaGVja2VyID0gbmV3IFVudG91Y2hhYmlsaXR5Q2hlY2tlcihlbGVtZW50RG9jdW1lbnQpO1xuICB2YXIgY2FuZGlkYXRlcyA9IGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpO1xuXG4gIGlmIChvcHRpb25zLmluY2x1ZGVDb250YWluZXIpIHtcbiAgICBpZiAobWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICAgIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoY2FuZGlkYXRlcyk7XG4gICAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpLCBjYW5kaWRhdGUsIGNhbmRpZGF0ZVRhYmluZGV4O1xuICBmb3IgKGkgPSAwOyBpIDwgY2FuZGlkYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNhbmRpZGF0ZSA9IGNhbmRpZGF0ZXNbaV07XG5cbiAgICBpZiAoIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShjYW5kaWRhdGUsIHVudG91Y2hhYmlsaXR5Q2hlY2tlcikpIGNvbnRpbnVlO1xuXG4gICAgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChjYW5kaWRhdGUpO1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgcmVndWxhclRhYmJhYmxlcy5wdXNoKGNhbmRpZGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgbm9kZTogY2FuZGlkYXRlLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHRhYmJhYmxlTm9kZXMgPSBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLm1hcChmdW5jdGlvbihhKSB7IHJldHVybiBhLm5vZGUgfSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xuXG4gIHJldHVybiB0YWJiYWJsZU5vZGVzO1xufVxuXG50YWJiYWJsZS5pc1RhYmJhYmxlID0gaXNUYWJiYWJsZTtcbnRhYmJhYmxlLmlzRm9jdXNhYmxlID0gaXNGb2N1c2FibGU7XG5cbmZ1bmN0aW9uIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShub2RlLCB1bnRvdWNoYWJpbGl0eUNoZWNrZXIpIHtcbiAgaWYgKFxuICAgICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG5vZGUsIHVudG91Y2hhYmlsaXR5Q2hlY2tlcilcbiAgICB8fCBpc05vblRhYmJhYmxlUmFkaW8obm9kZSlcbiAgICB8fCBnZXRUYWJpbmRleChub2RlKSA8IDBcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1RhYmJhYmxlKG5vZGUsIHVudG91Y2hhYmlsaXR5Q2hlY2tlcikge1xuICBpZiAoIW5vZGUpIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShub2RlLCB1bnRvdWNoYWJpbGl0eUNoZWNrZXIpO1xufVxuXG5mdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG5vZGUsIHVudG91Y2hhYmlsaXR5Q2hlY2tlcikge1xuICB1bnRvdWNoYWJpbGl0eUNoZWNrZXIgPSB1bnRvdWNoYWJpbGl0eUNoZWNrZXIgfHwgbmV3IFVudG91Y2hhYmlsaXR5Q2hlY2tlcihub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSk7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkXG4gICAgfHwgaXNIaWRkZW5JbnB1dChub2RlKVxuICAgIHx8IHVudG91Y2hhYmlsaXR5Q2hlY2tlci5pc1VudG91Y2hhYmxlKG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gY2FuZGlkYXRlU2VsZWN0b3JzLmNvbmNhdCgnaWZyYW1lJykuam9pbignLCcpO1xuZnVuY3Rpb24gaXNGb2N1c2FibGUobm9kZSwgdW50b3VjaGFiaWxpdHlDaGVja2VyKSB7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShub2RlLCB1bnRvdWNoYWJpbGl0eUNoZWNrZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRUYWJpbmRleChub2RlKSB7XG4gIHZhciB0YWJpbmRleEF0dHIgPSBwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoIWlzTmFOKHRhYmluZGV4QXR0cikpIHJldHVybiB0YWJpbmRleEF0dHI7XG4gIC8vIEJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gIGlmIChpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgcmV0dXJuIDA7XG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufVxuXG5mdW5jdGlvbiBzb3J0T3JkZXJlZFRhYmJhYmxlcyhhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4ID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59XG5cbi8vIEFycmF5LnByb3RvdHlwZS5maW5kIG5vdCBhdmFpbGFibGUgaW4gSUUuXG5mdW5jdGlvbiBmaW5kKGxpc3QsIHByZWRpY2F0ZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGlzdC5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChwcmVkaWNhdGUobGlzdFtpXSkpIHJldHVybiBsaXN0W2ldO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udGVudEVkaXRhYmxlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZSc7XG59XG5cbmZ1bmN0aW9uIGlzSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufVxuXG5mdW5jdGlvbiBpc0hpZGRlbklucHV0KG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn1cblxuZnVuY3Rpb24gaXNSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn1cblxuZnVuY3Rpb24gaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q2hlY2tlZFJhZGlvKG5vZGVzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1RhYmJhYmxlUmFkaW8obm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkgcmV0dXJuIHRydWU7XG4gIC8vIFRoaXMgd29uJ3QgYWNjb3VudCBmb3IgdGhlIGVkZ2UgY2FzZSB3aGVyZSB5b3UgaGF2ZSByYWRpbyBncm91cHMgd2l0aCB0aGUgc2FtZVxuICAvLyBpbiBzZXBhcmF0ZSBmb3JtcyBvbiB0aGUgc2FtZSBwYWdlLlxuICB2YXIgcmFkaW9TZXQgPSBub2RlLm93bmVyRG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbm9kZS5uYW1lICsgJ1wiXScpO1xuICB2YXIgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufVxuXG4vLyBBbiBlbGVtZW50IGlzIFwidW50b3VjaGFibGVcIiBpZiAqaXQgb3Igb25lIG9mIGl0cyBhbmNlc3RvcnMqIGhhc1xuLy8gYHZpc2liaWxpdHk6IGhpZGRlbmAgb3IgYGRpc3BsYXk6IG5vbmVgLlxuZnVuY3Rpb24gVW50b3VjaGFiaWxpdHlDaGVja2VyKGVsZW1lbnREb2N1bWVudCkge1xuICB0aGlzLmRvYyA9IGVsZW1lbnREb2N1bWVudDtcbiAgLy8gTm9kZSBjYWNoZSBtdXN0IGJlIHJlZnJlc2hlZCBvbiBldmVyeSBjaGVjaywgaW4gY2FzZVxuICAvLyB0aGUgY29udGVudCBvZiB0aGUgZWxlbWVudCBoYXMgY2hhbmdlZC4gVGhlIGNhY2hlIGNvbnRhaW5zIHR1cGxlc1xuICAvLyBtYXBwaW5nIG5vZGVzIHRvIHRoZWlyIGJvb2xlYW4gcmVzdWx0LlxuICB0aGlzLmNhY2hlID0gW107XG59XG5cbi8vIGdldENvbXB1dGVkU3R5bGUgYWNjdXJhdGVseSByZWZsZWN0cyBgdmlzaWJpbGl0eTogaGlkZGVuYCBvZiBhbmNlc3RvcnNcbi8vIGJ1dCBub3QgYGRpc3BsYXk6IG5vbmVgLCBzbyB3ZSBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGNoZWNrIHBhcmVudHMuXG5VbnRvdWNoYWJpbGl0eUNoZWNrZXIucHJvdG90eXBlLmhhc0Rpc3BsYXlOb25lID0gZnVuY3Rpb24gaGFzRGlzcGxheU5vbmUobm9kZSwgbm9kZUNvbXB1dGVkU3R5bGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBTZWFyY2ggZm9yIGEgY2FjaGVkIHJlc3VsdC5cbiAgICB2YXIgY2FjaGVkID0gZmluZCh0aGlzLmNhY2hlLCBmdW5jdGlvbihpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbSA9PT0gbm9kZTtcbiAgICB9KTtcbiAgICBpZiAoY2FjaGVkKSByZXR1cm4gY2FjaGVkWzFdO1xuXG4gICAgbm9kZUNvbXB1dGVkU3R5bGUgPSBub2RlQ29tcHV0ZWRTdHlsZSB8fCB0aGlzLmRvYy5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgaWYgKG5vZGVDb21wdXRlZFN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5oYXNEaXNwbGF5Tm9uZShub2RlLnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIHRoaXMuY2FjaGUucHVzaChbbm9kZSwgcmVzdWx0XSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5VbnRvdWNoYWJpbGl0eUNoZWNrZXIucHJvdG90eXBlLmlzVW50b3VjaGFibGUgPSBmdW5jdGlvbiBpc1VudG91Y2hhYmxlKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuZG9jLmRvY3VtZW50RWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICB2YXIgY29tcHV0ZWRTdHlsZSA9IHRoaXMuZG9jLmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGlmICh0aGlzLmhhc0Rpc3BsYXlOb25lKG5vZGUsIGNvbXB1dGVkU3R5bGUpKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGFiYmFibGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4dGVuZFxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBleHRlbmQoKSB7XG4gICAgdmFyIHRhcmdldCA9IHt9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldXG5cbiAgICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldFxufVxuIiwidmFyIHRhYmJhYmxlID0gcmVxdWlyZSgndGFiYmFibGUnKTtcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhcFF1ZXVlID0gW107XG4gIHJldHVybiB7XG4gICAgYWN0aXZhdGVUcmFwOiBmdW5jdGlvbih0cmFwKSB7XG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFjdGl2ZVRyYXAgPSB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICAgIGFjdGl2ZVRyYXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG4gICAgICBpZiAodHJhcEluZGV4ID09PSAtMSkge1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdGhpcyBleGlzdGluZyB0cmFwIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uKHRyYXApIHtcbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcbiAgICAgIGlmICh0cmFwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYXBRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyYXBRdWV1ZVt0cmFwUXVldWUubGVuZ3RoIC0gMV0udW5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGZvY3VzVHJhcChlbGVtZW50LCB1c2VyT3B0aW9ucykge1xuICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gIHZhciBjb250YWluZXIgPVxuICAgIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0geHRlbmQoXG4gICAge1xuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IHRydWUsXG4gICAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZVxuICAgIH0sXG4gICAgdXNlck9wdGlvbnNcbiAgKTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyc3RUYWJiYWJsZU5vZGU6IG51bGwsXG4gICAgbGFzdFRhYmJhYmxlTm9kZTogbnVsbCxcbiAgICBub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb246IG51bGwsXG4gICAgbW9zdFJlY2VudGx5Rm9jdXNlZE5vZGU6IG51bGwsXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBwYXVzZWQ6IGZhbHNlXG4gIH07XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2VcbiAgfTtcblxuICByZXR1cm4gdHJhcDtcblxuICBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG5cbiAgICBzdGF0ZS5hY3RpdmUgPSB0cnVlO1xuICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvYy5hY3RpdmVFbGVtZW50O1xuXG4gICAgdmFyIG9uQWN0aXZhdGUgPVxuICAgICAgYWN0aXZhdGVPcHRpb25zICYmIGFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlXG4gICAgICAgID8gYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGVcbiAgICAgICAgOiBjb25maWcub25BY3RpdmF0ZTtcbiAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgb25BY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGFkZExpc3RlbmVycygpO1xuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVhY3RpdmF0ZShkZWFjdGl2YXRlT3B0aW9ucykge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcblxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodHJhcCk7XG5cbiAgICB2YXIgb25EZWFjdGl2YXRlID1cbiAgICAgIGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uRGVhY3RpdmF0ZTtcbiAgICBpZiAob25EZWFjdGl2YXRlKSB7XG4gICAgICBvbkRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRm9jdXMgPVxuICAgICAgZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzXG4gICAgICAgIDogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlO1xuICAgIGlmIChyZXR1cm5Gb2N1cykge1xuICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeUZvY3VzKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGxpc3RlbmluZyBmb2N1cyB0cmFwIGF0IGEgdGltZVxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXApO1xuXG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgLy8gRGVsYXkgZW5zdXJlcyB0aGF0IHRoZSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCBjYXB0dXJlIHRoZSBldmVudFxuICAgIC8vIHRoYXQgY2F1c2VkIHRoZSBmb2N1cyB0cmFwIGFjdGl2YXRpb24uXG4gICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlO1xuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZSA9IGRvYy5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzTm9kZSgpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJykgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5jb250YWlucyhkb2MuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2FuJ3QgaGF2ZSBhIGZvY3VzLXRyYXAgd2l0aG91dCBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnRcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBvbiBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgaW5zdGVhZCBvZiBjbGlja1xuICAvLyBzbyB0aGF0IGl0IHByZWNlZGVzIHRoZSBmb2N1cyBldmVudC5cbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSB7XG4gICAgICBkZWFjdGl2YXRlKHtcbiAgICAgICAgcmV0dXJuRm9jdXM6ICF0YWJiYWJsZS5pc0ZvY3VzYWJsZShlLnRhcmdldClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW4gY2FzZSBmb2N1cyBlc2NhcGVzIHRoZSB0cmFwIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLCBwdWxsIGl0IGJhY2sgaW4uXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXNJbihlKSB7XG4gICAgLy8gSW4gRmlyZWZveCB3aGVuIHlvdSBUYWIgb3V0IG9mIGFuIGlmcmFtZSB0aGUgRG9jdW1lbnQgaXMgYnJpZWZseSBmb2N1c2VkLlxuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMgIT09IGZhbHNlICYmIGlzRXNjYXBlRXZlbnQoZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVGFiRXZlbnQoZSkpIHtcbiAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhpamFjayBUYWIgZXZlbnRzIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgb2YgdGhlIHRyYXAsXG4gIC8vIGluIG9yZGVyIHRvIHByZXZlbnQgZm9jdXMgZnJvbSBlc2NhcGluZy4gSWYgaXQgZXNjYXBlcyBmb3IgZXZlbiBhXG4gIC8vIG1vbWVudCBpdCBjYW4gZW5kIHVwIHNjcm9sbGluZyB0aGUgcGFnZSBhbmQgY2F1c2luZyBjb25mdXNpb24gc28gd2VcbiAgLy8ga2luZCBvZiBuZWVkIHRvIGNhcHR1cmUgdGhlIGFjdGlvbiBhdCB0aGUga2V5ZG93biBwaGFzZS5cbiAgZnVuY3Rpb24gY2hlY2tUYWIoZSkge1xuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLnRhcmdldCA9PT0gc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWUuc2hpZnRLZXkgJiYgZS50YXJnZXQgPT09IHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdmFyIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIpO1xuICAgIHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCk7XG4gICAgc3RhdGUubGFzdFRhYmJhYmxlTm9kZSA9XG4gICAgICB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV0gfHwgZ2V0SW5pdGlhbEZvY3VzTm9kZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5Rm9jdXMobm9kZSkge1xuICAgIGlmIChub2RlID09PSBkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuO1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLmZvY3VzKCk7XG4gICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuICAgIGlmIChpc1NlbGVjdGFibGVJbnB1dChub2RlKSkge1xuICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudGFnTmFtZSAmJlxuICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmXG4gICAgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5KGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c1RyYXA7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IGNyZWF0ZUZvY3VzVHJhcCBmcm9tICdmb2N1cy10cmFwJztcblxuLyoqXG4gKiBAcGFyYW0geyFFbGVtZW50fSBzdXJmYWNlRWxcbiAqIEBwYXJhbSB7P0VsZW1lbnQ9fSBpbml0aWFsRm9jdXNFbFxuICogQHBhcmFtIHtmdW5jdGlvbighRWxlbWVudCwgIUZvY3VzVHJhcENyZWF0ZU9wdGlvbnMpOiAhRm9jdXNUcmFwSW5zdGFuY2V9IGZvY3VzVHJhcEZhY3RvcnlcbiAqIEByZXR1cm4geyFGb2N1c1RyYXBJbnN0YW5jZX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2Uoc3VyZmFjZUVsLCBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwLCBpbml0aWFsRm9jdXNFbCA9IG51bGwpIHtcbiAgcmV0dXJuIGZvY3VzVHJhcEZhY3Rvcnkoc3VyZmFjZUVsLCB7XG4gICAgaW5pdGlhbEZvY3VzOiBpbml0aWFsRm9jdXNFbCxcbiAgICBlc2NhcGVEZWFjdGl2YXRlczogZmFsc2UsIC8vIERpYWxvZyBmb3VuZGF0aW9uIGhhbmRsZXMgZXNjYXBlIGtleVxuICAgIGNsaWNrT3V0c2lkZURlYWN0aXZhdGVzOiB0cnVlLCAvLyBBbGxvdyBoYW5kbGluZyBvZiBzY3JpbSBjbGlja3NcbiAgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzU2Nyb2xsYWJsZShlbCkge1xuICByZXR1cm4gZWwuc2Nyb2xsSGVpZ2h0ID4gZWwub2Zmc2V0SGVpZ2h0O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5PCFFbGVtZW50PnwhTm9kZUxpc3R9IGVsc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gYXJlVG9wc01pc2FsaWduZWQoZWxzKSB7XG4gIGNvbnN0IHRvcHMgPSBuZXcgU2V0KCk7XG4gIFtdLmZvckVhY2guY2FsbChlbHMsIChlbCkgPT4gdG9wcy5hZGQoZWwub2Zmc2V0VG9wKSk7XG4gIHJldHVybiB0b3BzLnNpemUgPiAxO1xufVxuXG5leHBvcnQge2NyZWF0ZUZvY3VzVHJhcEluc3RhbmNlLCBpc1Njcm9sbGFibGUsIGFyZVRvcHNNaXNhbGlnbmVkfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXcgQSBcInBvbnlmaWxsXCIgaXMgYSBwb2x5ZmlsbCB0aGF0IGRvZXNuJ3QgbW9kaWZ5IHRoZSBnbG9iYWwgcHJvdG90eXBlIGNoYWluLlxuICogVGhpcyBtYWtlcyBwb255ZmlsbHMgc2FmZXIgdGhhbiB0cmFkaXRpb25hbCBwb2x5ZmlsbHMsIGVzcGVjaWFsbHkgZm9yIGxpYnJhcmllcyBsaWtlIE1EQy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7P0VsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGNsb3Nlc3QoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsZW1lbnQuY2xvc2VzdCkge1xuICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICB9XG5cbiAgbGV0IGVsID0gZWxlbWVudDtcbiAgd2hpbGUgKGVsKSB7XG4gICAgaWYgKG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBtYXRjaGVzKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gIGNvbnN0IG5hdGl2ZU1hdGNoZXMgPSBlbGVtZW50Lm1hdGNoZXNcbiAgICB8fCBlbGVtZW50LndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICAgIHx8IGVsZW1lbnQubXNNYXRjaGVzU2VsZWN0b3I7XG4gIHJldHVybiBuYXRpdmVNYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG5leHBvcnQge2Nsb3Nlc3QsIG1hdGNoZXN9O1xuIiwidmFyIHRhYmJhYmxlID0gcmVxdWlyZSgndGFiYmFibGUnKTtcbnZhciB4dGVuZCA9IHJlcXVpcmUoJ3h0ZW5kJyk7XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgdHJhcFF1ZXVlID0gW107XG4gIHJldHVybiB7XG4gICAgYWN0aXZhdGVUcmFwOiBmdW5jdGlvbih0cmFwKSB7XG4gICAgICBpZiAodHJhcFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIGFjdGl2ZVRyYXAgPSB0cmFwUXVldWVbdHJhcFF1ZXVlLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAoYWN0aXZlVHJhcCAhPT0gdHJhcCkge1xuICAgICAgICAgIGFjdGl2ZVRyYXAucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFF1ZXVlLmluZGV4T2YodHJhcCk7XG4gICAgICBpZiAodHJhcEluZGV4ID09PSAtMSkge1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1vdmUgdGhpcyBleGlzdGluZyB0cmFwIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcbiAgICAgICAgdHJhcFF1ZXVlLnNwbGljZSh0cmFwSW5kZXgsIDEpO1xuICAgICAgICB0cmFwUXVldWUucHVzaCh0cmFwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZGVhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uKHRyYXApIHtcbiAgICAgIHZhciB0cmFwSW5kZXggPSB0cmFwUXVldWUuaW5kZXhPZih0cmFwKTtcbiAgICAgIGlmICh0cmFwSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRyYXBRdWV1ZS5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYXBRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRyYXBRdWV1ZVt0cmFwUXVldWUubGVuZ3RoIC0gMV0udW5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGZvY3VzVHJhcChlbGVtZW50LCB1c2VyT3B0aW9ucykge1xuICB2YXIgZG9jID0gZG9jdW1lbnQ7XG4gIHZhciBjb250YWluZXIgPVxuICAgIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcblxuICB2YXIgY29uZmlnID0geHRlbmQoXG4gICAge1xuICAgICAgcmV0dXJuRm9jdXNPbkRlYWN0aXZhdGU6IHRydWUsXG4gICAgICBlc2NhcGVEZWFjdGl2YXRlczogdHJ1ZVxuICAgIH0sXG4gICAgdXNlck9wdGlvbnNcbiAgKTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgZmlyc3RUYWJiYWJsZU5vZGU6IG51bGwsXG4gICAgbGFzdFRhYmJhYmxlTm9kZTogbnVsbCxcbiAgICBub2RlRm9jdXNlZEJlZm9yZUFjdGl2YXRpb246IG51bGwsXG4gICAgbW9zdFJlY2VudGx5Rm9jdXNlZE5vZGU6IG51bGwsXG4gICAgYWN0aXZlOiBmYWxzZSxcbiAgICBwYXVzZWQ6IGZhbHNlXG4gIH07XG5cbiAgdmFyIHRyYXAgPSB7XG4gICAgYWN0aXZhdGU6IGFjdGl2YXRlLFxuICAgIGRlYWN0aXZhdGU6IGRlYWN0aXZhdGUsXG4gICAgcGF1c2U6IHBhdXNlLFxuICAgIHVucGF1c2U6IHVucGF1c2VcbiAgfTtcblxuICByZXR1cm4gdHJhcDtcblxuICBmdW5jdGlvbiBhY3RpdmF0ZShhY3RpdmF0ZU9wdGlvbnMpIHtcbiAgICBpZiAoc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG5cbiAgICBzdGF0ZS5hY3RpdmUgPSB0cnVlO1xuICAgIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IGRvYy5hY3RpdmVFbGVtZW50O1xuXG4gICAgdmFyIG9uQWN0aXZhdGUgPVxuICAgICAgYWN0aXZhdGVPcHRpb25zICYmIGFjdGl2YXRlT3B0aW9ucy5vbkFjdGl2YXRlXG4gICAgICAgID8gYWN0aXZhdGVPcHRpb25zLm9uQWN0aXZhdGVcbiAgICAgICAgOiBjb25maWcub25BY3RpdmF0ZTtcbiAgICBpZiAob25BY3RpdmF0ZSkge1xuICAgICAgb25BY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGFkZExpc3RlbmVycygpO1xuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVhY3RpdmF0ZShkZWFjdGl2YXRlT3B0aW9ucykge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICByZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICBzdGF0ZS5hY3RpdmUgPSBmYWxzZTtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcblxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodHJhcCk7XG5cbiAgICB2YXIgb25EZWFjdGl2YXRlID1cbiAgICAgIGRlYWN0aXZhdGVPcHRpb25zICYmIGRlYWN0aXZhdGVPcHRpb25zLm9uRGVhY3RpdmF0ZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gZGVhY3RpdmF0ZU9wdGlvbnMub25EZWFjdGl2YXRlXG4gICAgICAgIDogY29uZmlnLm9uRGVhY3RpdmF0ZTtcbiAgICBpZiAob25EZWFjdGl2YXRlKSB7XG4gICAgICBvbkRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0dXJuRm9jdXMgPVxuICAgICAgZGVhY3RpdmF0ZU9wdGlvbnMgJiYgZGVhY3RpdmF0ZU9wdGlvbnMucmV0dXJuRm9jdXMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGRlYWN0aXZhdGVPcHRpb25zLnJldHVybkZvY3VzXG4gICAgICAgIDogY29uZmlnLnJldHVybkZvY3VzT25EZWFjdGl2YXRlO1xuICAgIGlmIChyZXR1cm5Gb2N1cykge1xuICAgICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRyeUZvY3VzKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdXNlKCkge1xuICAgIGlmIChzdGF0ZS5wYXVzZWQgfHwgIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuICAgIHN0YXRlLnBhdXNlZCA9IHRydWU7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bnBhdXNlKCkge1xuICAgIGlmICghc3RhdGUucGF1c2VkIHx8ICFzdGF0ZS5hY3RpdmUpIHJldHVybjtcbiAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoIXN0YXRlLmFjdGl2ZSkgcmV0dXJuO1xuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGxpc3RlbmluZyBmb2N1cyB0cmFwIGF0IGEgdGltZVxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXApO1xuXG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuXG4gICAgLy8gRGVsYXkgZW5zdXJlcyB0aGF0IHRoZSBmb2N1c2VkIGVsZW1lbnQgZG9lc24ndCBjYXB0dXJlIHRoZSBldmVudFxuICAgIC8vIHRoYXQgY2F1c2VkIHRoZSBmb2N1cyB0cmFwIGFjdGl2YXRpb24uXG4gICAgZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICB0cnlGb2N1cyhnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgY2hlY2tGb2N1c0luLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjaGVja0NsaWNrLCB0cnVlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGNoZWNrS2V5LCB0cnVlKTtcblxuICAgIHJldHVybiB0cmFwO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSByZXR1cm47XG5cbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0tleSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gdHJhcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE5vZGVGb3JPcHRpb24ob3B0aW9uTmFtZSkge1xuICAgIHZhciBvcHRpb25WYWx1ZSA9IGNvbmZpZ1tvcHRpb25OYW1lXTtcbiAgICB2YXIgbm9kZSA9IG9wdGlvblZhbHVlO1xuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgbm9kZSA9IGRvYy5xdWVyeVNlbGVjdG9yKG9wdGlvblZhbHVlKTtcbiAgICAgIGlmICghbm9kZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2AnICsgb3B0aW9uTmFtZSArICdgIHJlZmVycyB0byBubyBrbm93biBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG5vZGUgPSBvcHRpb25WYWx1ZSgpO1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYCcgKyBvcHRpb25OYW1lICsgJ2AgZGlkIG5vdCByZXR1cm4gYSBub2RlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzTm9kZSgpIHtcbiAgICB2YXIgbm9kZTtcbiAgICBpZiAoZ2V0Tm9kZUZvck9wdGlvbignaW5pdGlhbEZvY3VzJykgIT09IG51bGwpIHtcbiAgICAgIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdpbml0aWFsRm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRhaW5lci5jb250YWlucyhkb2MuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIG5vZGUgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZSA9IHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlIHx8IGdldE5vZGVGb3JPcHRpb24oJ2ZhbGxiYWNrRm9jdXMnKTtcbiAgICB9XG5cbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJZb3UgY2FuJ3QgaGF2ZSBhIGZvY3VzLXRyYXAgd2l0aG91dCBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnRcIlxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIC8vIFRoaXMgbmVlZHMgdG8gYmUgZG9uZSBvbiBtb3VzZWRvd24gYW5kIHRvdWNoc3RhcnQgaW5zdGVhZCBvZiBjbGlja1xuICAvLyBzbyB0aGF0IGl0IHByZWNlZGVzIHRoZSBmb2N1cyBldmVudC5cbiAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRG93bihlKSB7XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSB7XG4gICAgICBkZWFjdGl2YXRlKHtcbiAgICAgICAgcmV0dXJuRm9jdXM6ICF0YWJiYWJsZS5pc0ZvY3VzYWJsZShlLnRhcmdldClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW4gY2FzZSBmb2N1cyBlc2NhcGVzIHRoZSB0cmFwIGZvciBzb21lIHN0cmFuZ2UgcmVhc29uLCBwdWxsIGl0IGJhY2sgaW4uXG4gIGZ1bmN0aW9uIGNoZWNrRm9jdXNJbihlKSB7XG4gICAgLy8gSW4gRmlyZWZveCB3aGVuIHlvdSBUYWIgb3V0IG9mIGFuIGlmcmFtZSB0aGUgRG9jdW1lbnQgaXMgYnJpZWZseSBmb2N1c2VkLlxuICAgIGlmIChjb250YWluZXIuY29udGFpbnMoZS50YXJnZXQpIHx8IGUudGFyZ2V0IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0cnlGb2N1cyhzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tLZXkoZSkge1xuICAgIGlmIChjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMgIT09IGZhbHNlICYmIGlzRXNjYXBlRXZlbnQoZSkpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGRlYWN0aXZhdGUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzVGFiRXZlbnQoZSkpIHtcbiAgICAgIGNoZWNrVGFiKGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhpamFjayBUYWIgZXZlbnRzIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgb2YgdGhlIHRyYXAsXG4gIC8vIGluIG9yZGVyIHRvIHByZXZlbnQgZm9jdXMgZnJvbSBlc2NhcGluZy4gSWYgaXQgZXNjYXBlcyBmb3IgZXZlbiBhXG4gIC8vIG1vbWVudCBpdCBjYW4gZW5kIHVwIHNjcm9sbGluZyB0aGUgcGFnZSBhbmQgY2F1c2luZyBjb25mdXNpb24gc28gd2VcbiAgLy8ga2luZCBvZiBuZWVkIHRvIGNhcHR1cmUgdGhlIGFjdGlvbiBhdCB0aGUga2V5ZG93biBwaGFzZS5cbiAgZnVuY3Rpb24gY2hlY2tUYWIoZSkge1xuICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICBpZiAoZS5zaGlmdEtleSAmJiBlLnRhcmdldCA9PT0gc3RhdGUuZmlyc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWUuc2hpZnRLZXkgJiYgZS50YXJnZXQgPT09IHN0YXRlLmxhc3RUYWJiYWJsZU5vZGUpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRyeUZvY3VzKHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0NsaWNrKGUpIHtcbiAgICBpZiAoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzKSByZXR1cm47XG4gICAgaWYgKGNvbnRhaW5lci5jb250YWlucyhlLnRhcmdldCkpIHJldHVybjtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB7XG4gICAgdmFyIHRhYmJhYmxlTm9kZXMgPSB0YWJiYWJsZShjb250YWluZXIpO1xuICAgIHN0YXRlLmZpcnN0VGFiYmFibGVOb2RlID0gdGFiYmFibGVOb2Rlc1swXSB8fCBnZXRJbml0aWFsRm9jdXNOb2RlKCk7XG4gICAgc3RhdGUubGFzdFRhYmJhYmxlTm9kZSA9XG4gICAgICB0YWJiYWJsZU5vZGVzW3RhYmJhYmxlTm9kZXMubGVuZ3RoIC0gMV0gfHwgZ2V0SW5pdGlhbEZvY3VzTm9kZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJ5Rm9jdXMobm9kZSkge1xuICAgIGlmIChub2RlID09PSBkb2MuYWN0aXZlRWxlbWVudCkgcmV0dXJuO1xuICAgIGlmICghbm9kZSB8fCAhbm9kZS5mb2N1cykge1xuICAgICAgdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLmZvY3VzKCk7XG4gICAgc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgPSBub2RlO1xuICAgIGlmIChpc1NlbGVjdGFibGVJbnB1dChub2RlKSkge1xuICAgICAgbm9kZS5zZWxlY3QoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkge1xuICByZXR1cm4gKFxuICAgIG5vZGUudGFnTmFtZSAmJlxuICAgIG5vZGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmXG4gICAgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nXG4gICk7XG59XG5cbmZ1bmN0aW9uIGlzRXNjYXBlRXZlbnQoZSkge1xuICByZXR1cm4gZS5rZXkgPT09ICdFc2NhcGUnIHx8IGUua2V5ID09PSAnRXNjJyB8fCBlLmtleUNvZGUgPT09IDI3O1xufVxuXG5mdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIGUua2V5ID09PSAnVGFiJyB8fCBlLmtleUNvZGUgPT09IDk7XG59XG5cbmZ1bmN0aW9uIGRlbGF5KGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c1RyYXA7XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICByZWY9XCJyb290XCJcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIGFyaWEtbW9kYWw9XCJ0cnVlXCJcbiAgICA6YXJpYS1sYWJlbGxlZGJ5PVwiJ2xhYmVsJyArIHZtYV91aWRfXCJcbiAgICA6YXJpYS1kZXNjcmliZWRieT1cIidkZXNjJyArIHZtYV91aWRfXCJcbiAgICBjbGFzcz1cIm1kYy1kaWFsb2dcIlxuICAgIHJvbGU9XCJhbGVydGRpYWxvZ1wiXG4gICAgQGNsaWNrPVwib25DbGlja1wiXG4gICAgQGtleWRvd249XCJvbkNsaWNrXCJcbiAgPlxuICAgIDxkaXYgcmVmPVwiY29udGFpbmVyXCIgY2xhc3M9XCJtZGMtZGlhbG9nX19jb250YWluZXJcIj5cbiAgICAgIDxkaXYgcmVmPVwic3VyZmFjZVwiIDpjbGFzcz1cInN1cmZhY2VDbGFzc2VzXCIgY2xhc3M9XCJtZGMtZGlhbG9nX19zdXJmYWNlXCI+XG4gICAgICAgIDxoMiB2LWlmPVwidGl0bGVcIiBjbGFzcz1cIm1kYy1kaWFsb2dfX3RpdGxlXCIgOmlkPVwiJ2xhYmVsJyArIHZtYV91aWRfXCI+XG4gICAgICAgICAgPCEtLVxuICAgICAgICAgIC0tPnt7IHRpdGxlXG4gICAgICAgICAgfX08IS0tLS0+XG4gICAgICAgIDwvaDI+XG4gICAgICAgIDxkaXYgcmVmPVwiY29udGVudFwiIGNsYXNzPVwibWRjLWRpYWxvZ19fY29udGVudFwiIDppZD1cIidkZXNjJyArIHZtYV91aWRfXCI+XG4gICAgICAgICAgPHNsb3QgLz5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxmb290ZXIgdi1pZj1cImFjY2VwdCB8fCBjYW5jZWxcIiBjbGFzcz1cIm1kYy1kaWFsb2dfX2FjdGlvbnNcIj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICAgIHYtaWY9XCJjYW5jZWxcIlxuICAgICAgICAgICAgY2xhc3M9XCJtZGMtYnV0dG9uIG1kYy1kaWFsb2dfX2J1dHRvblwiXG4gICAgICAgICAgICBkYXRhLW1kYy1kaWFsb2ctYWN0aW9uPVwibm9cIlxuICAgICAgICAgID5cbiAgICAgICAgICAgIHt7IGNhbmNlbCB9fVxuICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgICAgcmVmPVwiZGVmYXVsdEJ1dHRvblwiXG4gICAgICAgICAgICA6ZGlzYWJsZWQ9XCJhY2NlcHREaXNhYmxlZFwiXG4gICAgICAgICAgICBjbGFzcz1cIm1kYy1idXR0b24gbWRjLWRpYWxvZ19fYnV0dG9uIFwiXG4gICAgICAgICAgICBkYXRhLW1kYy1kaWFsb2ctYWN0aW9uPVwieWVzXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7eyBhY2NlcHQgfX1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9mb290ZXI+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRpYWxvZ19fc2NyaW1cIiAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRGlhbG9nRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZGlhbG9nL2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kaWFsb2cvdXRpbCdcbmltcG9ydCB7IG1kY0J1dHRvbiB9IGZyb20gJy4uL2J1dHRvbidcbmltcG9ydCB7IFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgY2xvc2VzdCwgbWF0Y2hlcyB9IGZyb20gJ0BtYXRlcmlhbC9kb20vcG9ueWZpbGwnXG5pbXBvcnQgY3JlYXRlRm9jdXNUcmFwIGZyb20gJ2ZvY3VzLXRyYXAnXG5jb25zdCBzdHJpbmdzID0gTURDRGlhbG9nRm91bmRhdGlvbi5zdHJpbmdzXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kaWFsb2cnLFxuICBjb21wb25lbnRzOiB7XG4gICAgbWRjQnV0dG9uOiBtZGNCdXR0b25cbiAgfSxcbiAgbWl4aW5zOiBbVk1BVW5pcXVlSWRNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ29wZW4nLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHRpdGxlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuICAgIGFjY2VwdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ09rJ1xuICAgIH0sXG4gICAgYWNjZXB0RGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgYWNjZXB0UmFpc2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNhbmNlbDoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcbiAgICBjYW5jZWxSYWlzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiBmYWxzZVxuICAgIH0sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHNjcm9sbGFibGU6IEJvb2xlYW4sXG4gICAgb3BlbjogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdGhlbWUtLWRhcmsnOiB0aGlzLmRhcmtcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgc3VyZmFjZUNsYXNzZXM6IHt9LFxuICAgICAgYm9keUNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1kaWFsb2dfX2JvZHktLXNjcm9sbGFibGUnOiB0aGlzLnNjcm9sbGFibGVcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ29uT3Blbl8nXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgaWYgKHRoaXMuYWNjZXB0KSB7XG4gICAgICB0aGlzLmZvY3VzVHJhcCA9IHV0aWwuY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICAgIHRoaXMuJHJlZnMuY29udGFpbmVyLFxuICAgICAgICBjcmVhdGVGb2N1c1RyYXBcbiAgICAgIClcbiAgICB9XG5cbiAgICB0aGlzLmJ1dHRvbnNfID0gW10uc2xpY2UuY2FsbChcbiAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoc3RyaW5ncy5CVVRUT05fU0VMRUNUT1IpXG4gICAgKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0RpYWxvZ0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcbiAgICAgIGFkZEJvZHlDbGFzczogY2xhc3NOYW1lID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpLFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiBjbGFzc05hbWUgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSksXG4gICAgICBldmVudFRhcmdldE1hdGNoZXM6ICh0YXJnZXQsIHNlbGVjdG9yKSA9PiBtYXRjaGVzKHRhcmdldCwgc2VsZWN0b3IpLFxuICAgICAgdHJhcEZvY3VzOiAoKSA9PiB0aGlzLmZvY3VzVHJhcCAmJiB0aGlzLmZvY3VzVHJhcC5hY3RpdmF0ZSgpLFxuICAgICAgcmVsZWFzZUZvY3VzOiAoKSA9PiB0aGlzLmZvY3VzVHJhcCAmJiB0aGlzLmZvY3VzVHJhcC5kZWFjdGl2YXRlKCksXG4gICAgICBpc0NvbnRlbnRTY3JvbGxhYmxlOiAoKSA9PlxuICAgICAgICAhIXRoaXMuJHJlZnMuY29udGVudCAmJiB1dGlsLmlzU2Nyb2xsYWJsZSh0aGlzLiRyZWZzLmNvbnRlbnQpLFxuICAgICAgYXJlQnV0dG9uc1N0YWNrZWQ6ICgpID0+IHV0aWwuYXJlVG9wc01pc2FsaWduZWQodGhpcy5idXR0b25zXyksXG5cbiAgICAgIGdldEFjdGlvbkZyb21FdmVudDogZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gY2xvc2VzdChldmVudC50YXJnZXQsIGBbJHtzdHJpbmdzLkFDVElPTl9BVFRSSUJVVEV9XWApXG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKHN0cmluZ3MuQUNUSU9OX0FUVFJJQlVURSlcbiAgICAgIH0sXG4gICAgICBjbGlja0RlZmF1bHRCdXR0b246ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMuZGVmYXVsdEJ1dHRvbikge1xuICAgICAgICAgIHRoaXMuJHJlZnMuZGVmYXVsdEJ1dHRvbi5jbGljaygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXZlcnNlQnV0dG9uczogKCkgPT4ge1xuICAgICAgICB0aGlzLmJ1dHRvbnNfLnJldmVyc2UoKVxuICAgICAgICB0aGlzLmJ1dHRvbnNfLmZvckVhY2goYnV0dG9uID0+XG4gICAgICAgICAgYnV0dG9uLnBhcmVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKVxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbmluZzogKCkgPT4gdGhpcy4kZW1pdChzdHJpbmdzLk9QRU5JTkdfRVZFTlQsIHt9KSxcbiAgICAgIG5vdGlmeU9wZW5lZDogKCkgPT4gdGhpcy4kZW1pdChzdHJpbmdzLk9QRU5FRF9FVkVOVCwge30pLFxuICAgICAgbm90aWZ5Q2xvc2luZzogYWN0aW9uID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGFjdGlvbilcbiAgICAgICAgdGhpcy4kZW1pdChzdHJpbmdzLkNMT1NJTkdfRVZFTlQsIGFjdGlvbiA/IHsgYWN0aW9uIH0gOiB7fSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDbG9zZWQ6IGFjdGlvbiA9PlxuICAgICAgICB0aGlzLiRlbWl0KHN0cmluZ3MuQ0xPU0VEX0VWRU5ULCBhY3Rpb24gPyB7IGFjdGlvbiB9IDoge30pXG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLm9wZW4gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIG9uT3Blbl8odmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlSW50ZXJhY3Rpb24oZXZlbnQpXG4gICAgfSxcbiAgICBvbkNhbmNlbCgpIHtcbiAgICAgIGlmICh0aGlzLiRsaXN0ZW5lcnNbJ3ZhbGlkYXRlQ2FuY2VsJ10pIHtcbiAgICAgICAgdGhpcy4kZW1pdCgndmFsaWRhdGVDYW5jZWwnLCB7XG4gICAgICAgICAgY2FuY2VsOiAobm90aWZ5ID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgLy8gaWYgbm90aWZ5ID0gZmFsc2UsIHRoZSBkaWFsb2cgd2lsbCBjbG9zZVxuICAgICAgICAgICAgLy8gYnV0IHRoZSBub3RpZnlBY2NlcHQgbWV0aG9kIHdpbGwgbm90IGJlIGNhbGxlZFxuICAgICAgICAgICAgLy8gc28gd2UgbmVlZCB0byBub3RpZnkgbGlzdGVuZXJzIHRoZSBvcGVuIHN0YXRlXG4gICAgICAgICAgICAvLyBpcyBjaGFuZ2luZy5cbiAgICAgICAgICAgIGlmICghbm90aWZ5KSB7XG4gICAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNhbmNlbChub3RpZnkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmNhbmNlbCh0cnVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgb25BY2NlcHQoKSB7XG4gICAgICBpZiAodGhpcy4kbGlzdGVuZXJzWyd2YWxpZGF0ZSddKSB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ3ZhbGlkYXRlJywge1xuICAgICAgICAgIGFjY2VwdDogKG5vdGlmeSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIC8vIGlmIG5vdGlmeSA9IGZhbHNlLCB0aGUgZGlhbG9nIHdpbGwgY2xvc2VcbiAgICAgICAgICAgIC8vIGJ1dCB0aGUgbm90aWZ5QWNjZXB0IG1ldGhvZCB3aWxsIG5vdCBiZSBjYWxsZWRcbiAgICAgICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gbm90aWZ5IGxpc3RlbmVycyB0aGUgb3BlbiBzdGF0ZVxuICAgICAgICAgICAgLy8gaXMgY2hhbmdpbmcuXG4gICAgICAgICAgICBpZiAoIW5vdGlmeSkge1xuICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZm91bmRhdGlvbi5hY2NlcHQobm90aWZ5KVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5hY2NlcHQodHJ1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIHNob3coKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0RpYWxvZyBmcm9tICcuL21kYy1kaWFsb2cudnVlJ1xuXG5leHBvcnQgeyBtZGNEaWFsb2cgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRGlhbG9nXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBEcmF3ZXJcbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBEcmF3ZXIgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0RyYXdlckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgRWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudCB0YXJnZXQgZWxlbWVudCB0byB2ZXJpZnkgY2xhc3MgbmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIGNsYXNzIG5hbWVcbiAgICovXG4gIGVsZW1lbnRIYXNDbGFzcyhlbGVtZW50LCBjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNhdmVzIHRoZSBmb2N1cyBvZiBjdXJyZW50bHkgYWN0aXZlIGVsZW1lbnQuXG4gICAqL1xuICBzYXZlRm9jdXMoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXN0b3JlcyBmb2N1cyB0byBlbGVtZW50IHByZXZpb3VzbHkgc2F2ZWQgd2l0aCAnc2F2ZUZvY3VzJy5cbiAgICovXG4gIHJlc3RvcmVGb2N1cygpIHt9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIGFjdGl2ZSAvIHNlbGVjdGVkIG5hdmlnYXRpb24gaXRlbS5cbiAgICovXG4gIGZvY3VzQWN0aXZlTmF2aWdhdGlvbkl0ZW0oKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBcIk1EQ0RyYXdlcjpjbG9zZWRcIiBkZW5vdGluZyB0aGUgZHJhd2VyIGhhcyBjbG9zZWQuXG4gICAqL1xuICBub3RpZnlDbG9zZSgpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IFwiTURDRHJhd2VyOm9wZW5lZFwiIGRlbm90aW5nIHRoZSBkcmF3ZXIgaGFzIG9wZW5lZC5cbiAgICovXG4gIG5vdGlmeU9wZW4oKSB7fVxuXG4gIC8qKlxuICAgKiBUcmFwcyBmb2N1cyBvbiByb290IGVsZW1lbnQgYW5kIGZvY3VzZXMgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGVsZW1lbnQuXG4gICAqL1xuICB0cmFwRm9jdXMoKSB7fVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBmb2N1cyB0cmFwIGZyb20gcm9vdCBlbGVtZW50IHdoaWNoIHdhcyBzZXQgYnkgYHRyYXBGb2N1c2BcbiAgICogYW5kIHJlc3RvcmVzIGZvY3VzIHRvIHdoZXJlIGl0IHdhcyBwcmlvciB0byBjYWxsaW5nIGB0cmFwRm9jdXNgLlxuICAgKi9cbiAgcmVsZWFzZUZvY3VzKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRHJhd2VyQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlcicsXG4gIERJU01JU1NJQkxFOiAnbWRjLWRyYXdlci0tZGlzbWlzc2libGUnLFxuICBNT0RBTDogJ21kYy1kcmF3ZXItLW1vZGFsJyxcbiAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxuICBBTklNQVRFOiAnbWRjLWRyYXdlci0tYW5pbWF0ZScsXG4gIE9QRU5JTkc6ICdtZGMtZHJhd2VyLS1vcGVuaW5nJyxcbiAgQ0xPU0lORzogJ21kYy1kcmF3ZXItLWNsb3NpbmcnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUFBfQ09OVEVOVF9TRUxFQ1RPUjogJy5tZGMtZHJhd2VyLWFwcC1jb250ZW50JyxcbiAgU0NSSU1fU0VMRUNUT1I6ICcubWRjLWRyYXdlci1zY3JpbScsXG4gIENMT1NFX0VWRU5UOiAnTURDRHJhd2VyOmNsb3NlZCcsXG4gIE9QRU5fRVZFTlQ6ICdNRENEcmF3ZXI6b3BlbmVkJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0RyYXdlckFkYXB0ZXIgZnJvbSAnLi4vYWRhcHRlcic7XG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDRHJhd2VyQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ0Rpc21pc3NpYmxlRHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDRHJhd2VyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGVsZW1lbnRIYXNDbGFzczogKC8qIGVsZW1lbnQ6ICFFbGVtZW50LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge30sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7fSxcbiAgICAgIHNhdmVGb2N1czogKCkgPT4ge30sXG4gICAgICByZXN0b3JlRm9jdXM6ICgpID0+IHt9LFxuICAgICAgZm9jdXNBY3RpdmVOYXZpZ2F0aW9uSXRlbTogKCkgPT4ge30sXG4gICAgICB0cmFwRm9jdXM6ICgpID0+IHt9LFxuICAgICAgcmVsZWFzZUZvY3VzOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0Rpc21pc3NpYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25GcmFtZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25UaW1lcl8gPSAwO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25GcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVfKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uVGltZXJfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcl8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBvcGVuIHRoZSBkcmF3ZXIuXG4gICAqL1xuICBvcGVuKCkge1xuICAgIGlmICh0aGlzLmlzT3BlbigpIHx8IHRoaXMuaXNPcGVuaW5nKCkgfHwgdGhpcy5pc0Nsb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQU5JTUFURSk7XG5cbiAgICAvLyBXYWl0IGEgZnJhbWUgb25jZSBkaXNwbGF5IGlzIG5vIGxvbmdlciBcIm5vbmVcIiwgdG8gZXN0YWJsaXNoIGJhc2lzIGZvciBhbmltYXRpb25cbiAgICB0aGlzLnJ1bk5leHRBbmltYXRpb25GcmFtZV8oKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLk9QRU5JTkcpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5zYXZlRm9jdXMoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBjbG9zZSB0aGUgZHJhd2VyLlxuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzT3BlbigpIHx8IHRoaXMuaXNPcGVuaW5nKCkgfHwgdGhpcy5pc0Nsb3NpbmcoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TSU5HKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgZm9yIHdoZW4gZHJhd2VyIGZpbmlzaGVzIG9wZW4gYW5pbWF0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBvcGVuZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBFeHRlbnNpb24gcG9pbnQgZm9yIHdoZW4gZHJhd2VyIGZpbmlzaGVzIGNsb3NlIGFuaW1hdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgY2xvc2VkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGRyYXdlciBpcyBpbiBvcGVuIHN0YXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuT1BFTik7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGRyYXdlciBpcyBhbmltYXRpbmcgb3Blbi5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzT3BlbmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLk9QRU5JTkcpIHx8IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5BTklNQVRFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgZHJhd2VyIGlzIGFuaW1hdGluZyBjbG9zZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0Nsb3NpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TSU5HKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBLZXlkb3duIGhhbmRsZXIgdG8gY2xvc2UgZHJhd2VyIHdoZW4ga2V5IGlzIGVzY2FwZS5cbiAgICogQHBhcmFtIGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bihldnQpIHtcbiAgICBjb25zdCB7a2V5Q29kZSwga2V5fSA9IGV2dDtcblxuICAgIGNvbnN0IGlzRXNjYXBlID0ga2V5ID09PSAnRXNjYXBlJyB8fCBrZXlDb2RlID09PSAyNztcbiAgICBpZiAoaXNFc2NhcGUpIHtcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIHRyYW5zaXRpb24gZW5kIGV2ZW50IG9uIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KSB7XG4gICAgY29uc3Qge09QRU5JTkcsIENMT1NJTkcsIE9QRU4sIEFOSU1BVEUsIFJPT1R9ID0gY3NzQ2xhc3NlcztcblxuICAgIC8vIEluIEVkZ2UsIHRyYW5zaXRpb25lbmQgb24gcmlwcGxlIHBzZXVkby1lbGVtZW50cyB5aWVsZHMgYSB0YXJnZXQgd2l0aG91dCBjbGFzc0xpc3QsIHNvIGNoZWNrIGZvciBFbGVtZW50IGZpcnN0LlxuICAgIGNvbnN0IGlzRWxlbWVudCA9IGV2dC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50O1xuICAgIGlmICghaXNFbGVtZW50IHx8ICF0aGlzLmFkYXB0ZXJfLmVsZW1lbnRIYXNDbGFzcygvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAoZXZ0LnRhcmdldCksIFJPT1QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNDbG9zaW5nKCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoT1BFTik7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlc3RvcmVGb2N1cygpO1xuICAgICAgdGhpcy5jbG9zZWQoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0FjdGl2ZU5hdmlnYXRpb25JdGVtKCk7XG4gICAgICB0aGlzLm9wZW5lZCgpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuKCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhBTklNQVRFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE9QRU5JTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQ0xPU0lORyk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyB0aGUgZ2l2ZW4gbG9naWMgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLCB1c2luZyBzZXRUaW1lb3V0IHRvIGZhY3RvciBpbiBGaXJlZm94IHJlZmxvdyBiZWhhdmlvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJ1bk5leHRBbmltYXRpb25GcmFtZV8oY2FsbGJhY2spIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lXyk7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hbmltYXRpb25GcmFtZV8gPSAwO1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXJfKTtcbiAgICAgIHRoaXMuYW5pbWF0aW9uVGltZXJfID0gc2V0VGltZW91dChjYWxsYmFjaywgMCk7XG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRGlzbWlzc2libGVEcmF3ZXJGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENEcmF3ZXJBZGFwdGVyIGZyb20gJy4uL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ0Rpc21pc3NpYmxlRHJhd2VyRm91bmRhdGlvbiBmcm9tICcuLi9kaXNtaXNzaWJsZS9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRGlzbWlzc2libGVEcmF3ZXJGb3VuZGF0aW9ufVxuICovXG5jbGFzcyBNRENNb2RhbERyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENEaXNtaXNzaWJsZURyYXdlckZvdW5kYXRpb24ge1xuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gZHJhd2VyIGZpbmlzaGVzIG9wZW4gYW5pbWF0aW9uLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIG9wZW5lZCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnRyYXBGb2N1cygpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGRyYXdlciBmaW5pc2hlcyBjbG9zZSBhbmltYXRpb24uXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgY2xvc2VkKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVsZWFzZUZvY3VzKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayBldmVudCBvbiBzY3JpbS5cbiAgICovXG4gIGhhbmRsZVNjcmltQ2xpY2soKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ01vZGFsRHJhd2VyRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTGlzdC4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZyBmb2N1cy5cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ0xpc3RBZGFwdGVyIHtcbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TGlzdEl0ZW1Db3VudCgpIHt9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0Rm9jdXNlZEVsZW1lbnRJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4KGluZGV4LCBhdHRyaWJ1dGUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlRm9yRWxlbWVudEluZGV4KGluZGV4LCBhdHRyaWJ1dGUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc0ZvckVsZW1lbnRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3NGb3JFbGVtZW50SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogRm9jdXNlcyBsaXN0IGl0ZW0gYXQgdGhlIGluZGV4IHNwZWNpZmllZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBmb2N1c0l0ZW1BdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0YWJpbmRleCB0byB0aGUgdmFsdWUgc3BlY2lmaWVkIGZvciBhbGwgYnV0dG9uL2EgZWxlbWVudCBjaGlsZHJlbiBvZlxuICAgKiB0aGUgbGlzdCBpdGVtIGF0IHRoZSBpbmRleCBzcGVjaWZpZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaXN0SXRlbUluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YWJJbmRleFZhbHVlXG4gICAqL1xuICBzZXRUYWJJbmRleEZvckxpc3RJdGVtQ2hpbGRyZW4obGlzdEl0ZW1JbmRleCwgdGFiSW5kZXhWYWx1ZSkge31cblxuICAvKipcbiAgICogSWYgdGhlIGdpdmVuIGVsZW1lbnQgaGFzIGFuIGhyZWYsIGZvbGxvd3MgdGhlIGxpbmsuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZVxuICAgKi9cbiAgZm9sbG93SHJlZihlbGUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgcmFkaW8gYnV0dG9uIGlzIHByZXNlbnQgYXQgZ2l2ZW4gbGlzdCBpdGVtIGluZGV4LlxuICAgKi9cbiAgaGFzUmFkaW9BdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGNoZWNrYm94IGlzIHByZXNlbnQgYXQgZ2l2ZW4gbGlzdCBpdGVtIGluZGV4LlxuICAgKi9cbiAgaGFzQ2hlY2tib3hBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGNoZWNrYm94IGluc2lkZSBhIGxpc3QgaXRlbSBpcyBjaGVja2VkLlxuICAgKi9cbiAgaXNDaGVja2JveENoZWNrZWRBdEluZGV4KGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjaGVja2VkIHN0YXR1cyBvZiBjaGVja2JveCBvciByYWRpbyBhdCBnaXZlbiBsaXN0IGl0ZW0gaW5kZXguXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQ2hlY2tlZFxuICAgKi9cbiAgc2V0Q2hlY2tlZENoZWNrYm94T3JSYWRpb0F0SW5kZXgoaW5kZXgsIGlzQ2hlY2tlZCkge31cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIHdoZW4gdGhlIGN1cnJlbnQgZm9jdXNlZCBlbGVtZW50IGlzIGluc2lkZSBsaXN0IHJvb3QuXG4gICAqL1xuICBpc0ZvY3VzSW5zaWRlTGlzdCgpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpc3RBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1saXN0JyxcbiAgTElTVF9JVEVNX0NMQVNTOiAnbWRjLWxpc3QtaXRlbScsXG4gIExJU1RfSVRFTV9TRUxFQ1RFRF9DTEFTUzogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcbiAgTElTVF9JVEVNX0FDVElWQVRFRF9DTEFTUzogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfT1JJRU5UQVRJT046ICdhcmlhLW9yaWVudGF0aW9uJyxcbiAgQVJJQV9PUklFTlRBVElPTl9IT1JJWk9OVEFMOiAnaG9yaXpvbnRhbCcsXG4gIEFSSUFfU0VMRUNURUQ6ICdhcmlhLXNlbGVjdGVkJyxcbiAgQVJJQV9DSEVDS0VEOiAnYXJpYS1jaGVja2VkJyxcbiAgQVJJQV9DSEVDS0VEX1JBRElPX1NFTEVDVE9SOiAnW3JvbGU9XCJyYWRpb1wiXVthcmlhLWNoZWNrZWQ9XCJ0cnVlXCJdJyxcbiAgQVJJQV9ST0xFX0NIRUNLQk9YX1NFTEVDVE9SOiAnW3JvbGU9XCJjaGVja2JveFwiXScsXG4gIEFSSUFfQ0hFQ0tFRF9DSEVDS0JPWF9TRUxFQ1RPUjogJ1tyb2xlPVwiY2hlY2tib3hcIl1bYXJpYS1jaGVja2VkPVwidHJ1ZVwiXScsXG4gIFJBRElPX1NFTEVDVE9SOiAnaW5wdXRbdHlwZT1cInJhZGlvXCJdOm5vdCg6ZGlzYWJsZWQpJyxcbiAgQ0hFQ0tCT1hfU0VMRUNUT1I6ICdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl06bm90KDpkaXNhYmxlZCknLFxuICBDSEVDS0JPWF9SQURJT19TRUxFQ1RPUjogJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXTpub3QoOmRpc2FibGVkKSwgaW5wdXRbdHlwZT1cInJhZGlvXCJdOm5vdCg6ZGlzYWJsZWQpJyxcbiAgQ0hJTERfRUxFTUVOVFNfVE9fVE9HR0xFX1RBQklOREVYOiBgLiR7Y3NzQ2xhc3Nlcy5MSVNUX0lURU1fQ0xBU1N9IGJ1dHRvbjpub3QoOmRpc2FibGVkKSxcbiAgLiR7Y3NzQ2xhc3Nlcy5MSVNUX0lURU1fQ0xBU1N9IGFgLFxuICBGT0NVU0FCTEVfQ0hJTERfRUxFTUVOVFM6IGAuJHtjc3NDbGFzc2VzLkxJU1RfSVRFTV9DTEFTU30gYnV0dG9uOm5vdCg6ZGlzYWJsZWQpLCAuJHtjc3NDbGFzc2VzLkxJU1RfSVRFTV9DTEFTU30gYSxcbiAgLiR7Y3NzQ2xhc3Nlcy5MSVNUX0lURU1fQ0xBU1N9IGlucHV0W3R5cGU9XCJyYWRpb1wiXTpub3QoOmRpc2FibGVkKSxcbiAgLiR7Y3NzQ2xhc3Nlcy5MSVNUX0lURU1fQ0xBU1N9IGlucHV0W3R5cGU9XCJjaGVja2JveFwiXTpub3QoOmRpc2FibGVkKWAsXG4gIEVOQUJMRURfSVRFTVNfU0VMRUNUT1I6ICcubWRjLWxpc3QtaXRlbTpub3QoLm1kYy1saXN0LWl0ZW0tLWRpc2FibGVkKScsXG59O1xuXG4vKiogQHR5cGVkZWYge251bWJlcnwhQXJyYXk8bnVtYmVyPn0gKi9cbmxldCBJbmRleDtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzLCBJbmRleH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDTGlzdEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7c3RyaW5ncywgY3NzQ2xhc3NlcywgSW5kZXh9IGZyb20gJy4vY29uc3RhbnRzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5jb25zdCBFTEVNRU5UU19LRVlfQUxMT1dFRF9JTiA9IFsnaW5wdXQnLCAnYnV0dG9uJywgJ3RleHRhcmVhJywgJ3NlbGVjdCddO1xuXG5jbGFzcyBNRENMaXN0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ0xpc3RBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ0xpc3RBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDTGlzdEFkYXB0ZXJ9ICovICh7XG4gICAgICBnZXRMaXN0SXRlbUNvdW50OiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRFbGVtZW50SW5kZXg6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZUZvckVsZW1lbnRJbmRleDogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzc0ZvckVsZW1lbnRJbmRleDogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0ZvckVsZW1lbnRJbmRleDogKCkgPT4ge30sXG4gICAgICBmb2N1c0l0ZW1BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHNldFRhYkluZGV4Rm9yTGlzdEl0ZW1DaGlsZHJlbjogKCkgPT4ge30sXG4gICAgICBmb2xsb3dIcmVmOiAoKSA9PiB7fSxcbiAgICAgIGhhc1JhZGlvQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBoYXNDaGVja2JveEF0SW5kZXg6ICgpID0+IHt9LFxuICAgICAgaXNDaGVja2JveENoZWNrZWRBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHNldENoZWNrZWRDaGVja2JveE9yUmFkaW9BdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGlzRm9jdXNJbnNpZGVMaXN0OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENMaXN0QWRhcHRlcj19IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMud3JhcEZvY3VzXyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWZXJ0aWNhbF8gPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNTaW5nbGVTZWxlY3Rpb25MaXN0XyA9IGZhbHNlO1xuXG4gICAgLyoqIEBwcml2YXRlIHshSW5kZXh9ICovXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IC0xO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5mb2N1c2VkSXRlbUluZGV4XyA9IC0xO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMudXNlQWN0aXZhdGVkQ2xhc3NfID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc0NoZWNrYm94TGlzdF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzUmFkaW9MaXN0XyA9IGZhbHNlO1xuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmdldExpc3RJdGVtQ291bnQoKSA9PT0gMCkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2hlY2tib3hBdEluZGV4KDApKSB7XG4gICAgICB0aGlzLmlzQ2hlY2tib3hMaXN0XyA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkYXB0ZXJfLmhhc1JhZGlvQXRJbmRleCgwKSkge1xuICAgICAgdGhpcy5pc1JhZGlvTGlzdF8gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcml2YXRlIHdyYXBGb2N1c18gdmFyaWFibGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHNldFdyYXBGb2N1cyh2YWx1ZSkge1xuICAgIHRoaXMud3JhcEZvY3VzXyA9IHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGlzVmVydGljYWxfIHByaXZhdGUgdmFyaWFibGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmFsdWVcbiAgICovXG4gIHNldFZlcnRpY2FsT3JpZW50YXRpb24odmFsdWUpIHtcbiAgICB0aGlzLmlzVmVydGljYWxfID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgaXNTaW5nbGVTZWxlY3Rpb25MaXN0XyBwcml2YXRlIHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gICAqL1xuICBzZXRTaW5nbGVTZWxlY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmlzU2luZ2xlU2VsZWN0aW9uTGlzdF8gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1c2VBY3RpdmF0ZWRDbGFzc18gcHJpdmF0ZSB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBY3RpdmF0ZWRcbiAgICovXG4gIHNldFVzZUFjdGl2YXRlZENsYXNzKHVzZUFjdGl2YXRlZCkge1xuICAgIHRoaXMudXNlQWN0aXZhdGVkQ2xhc3NfID0gdXNlQWN0aXZhdGVkO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFJbmRleH0gKi9cbiAgZ2V0U2VsZWN0ZWRJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWxlY3RlZEluZGV4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFJbmRleH0gaW5kZXggKi9cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge1xuICAgIGlmICghdGhpcy5pc0luZGV4VmFsaWRfKGluZGV4KSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuaXNDaGVja2JveExpc3RfKSB7XG4gICAgICB0aGlzLnNldENoZWNrYm94QXRJbmRleF8oLyoqIEB0eXBlIHshQXJyYXk8bnVtYmVyPn0gKi8gKGluZGV4KSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzUmFkaW9MaXN0Xykge1xuICAgICAgdGhpcy5zZXRSYWRpb0F0SW5kZXhfKC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAoaW5kZXgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRTaW5nbGVTZWxlY3Rpb25BdEluZGV4XygvKiogQHR5cGUge251bWJlcn0gKi8gKGluZGV4KSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzIGluIGhhbmRsZXIgZm9yIHRoZSBsaXN0IGl0ZW1zLlxuICAgKiBAcGFyYW0gZXZ0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsaXN0SXRlbUluZGV4XG4gICAqL1xuICBoYW5kbGVGb2N1c0luKGV2dCwgbGlzdEl0ZW1JbmRleCkge1xuICAgIGlmIChsaXN0SXRlbUluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXhGb3JMaXN0SXRlbUNoaWxkcmVuKGxpc3RJdGVtSW5kZXgsIDApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb2N1cyBvdXQgaGFuZGxlciBmb3IgdGhlIGxpc3QgaXRlbXMuXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGlzdEl0ZW1JbmRleFxuICAgKi9cbiAgaGFuZGxlRm9jdXNPdXQoZXZ0LCBsaXN0SXRlbUluZGV4KSB7XG4gICAgaWYgKGxpc3RJdGVtSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleEZvckxpc3RJdGVtQ2hpbGRyZW4obGlzdEl0ZW1JbmRleCwgLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJldHdlZW4gRm9jdXNvdXQgJiBGb2N1c2luIHNvbWUgYnJvd3NlcnMgZG8gbm90IGhhdmUgZm9jdXMgb24gYW55IGVsZW1lbnQuIFNldHRpbmcgYSBkZWxheSB0byB3YWl0IHRpbGwgdGhlIGZvY3VzXG4gICAgICogaXMgbW92ZWQgdG8gbmV4dCBlbGVtZW50LlxuICAgICAqL1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzRm9jdXNJbnNpZGVMaXN0KCkpIHtcbiAgICAgICAgdGhpcy5zZXRUYWJpbmRleFRvRmlyc3RTZWxlY3RlZEl0ZW1fKCk7XG4gICAgICB9XG4gICAgfSwgMCk7XG4gIH1cblxuICAvKipcbiAgICogS2V5IGhhbmRsZXIgZm9yIHRoZSBsaXN0LlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1Jvb3RMaXN0SXRlbVxuICAgKiBAcGFyYW0ge251bWJlcn0gbGlzdEl0ZW1JbmRleFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bihldnQsIGlzUm9vdExpc3RJdGVtLCBsaXN0SXRlbUluZGV4KSB7XG4gICAgY29uc3QgYXJyb3dMZWZ0ID0gZXZ0LmtleSA9PT0gJ0Fycm93TGVmdCcgfHwgZXZ0LmtleUNvZGUgPT09IDM3O1xuICAgIGNvbnN0IGFycm93VXAgPSBldnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZ0LmtleUNvZGUgPT09IDM4O1xuICAgIGNvbnN0IGFycm93UmlnaHQgPSBldnQua2V5ID09PSAnQXJyb3dSaWdodCcgfHwgZXZ0LmtleUNvZGUgPT09IDM5O1xuICAgIGNvbnN0IGFycm93RG93biA9IGV2dC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2dC5rZXlDb2RlID09PSA0MDtcbiAgICBjb25zdCBpc0hvbWUgPSBldnQua2V5ID09PSAnSG9tZScgfHwgZXZ0LmtleUNvZGUgPT09IDM2O1xuICAgIGNvbnN0IGlzRW5kID0gZXZ0LmtleSA9PT0gJ0VuZCcgfHwgZXZ0LmtleUNvZGUgPT09IDM1O1xuICAgIGNvbnN0IGlzRW50ZXIgPSBldnQua2V5ID09PSAnRW50ZXInIHx8IGV2dC5rZXlDb2RlID09PSAxMztcbiAgICBjb25zdCBpc1NwYWNlID0gZXZ0LmtleSA9PT0gJ1NwYWNlJyB8fCBldnQua2V5Q29kZSA9PT0gMzI7XG5cbiAgICBsZXQgY3VycmVudEluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRGb2N1c2VkRWxlbWVudEluZGV4KCk7XG4gICAgbGV0IG5leHRJbmRleCA9IC0xO1xuICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICBjdXJyZW50SW5kZXggPSBsaXN0SXRlbUluZGV4O1xuICAgICAgaWYgKGN1cnJlbnRJbmRleCA8IDApIHtcbiAgICAgICAgLy8gSWYgdGhpcyBldmVudCBkb2Vzbid0IGhhdmUgYSBtZGMtbGlzdC1pdGVtIGFuY2VzdG9yIGZyb20gdGhlXG4gICAgICAgIC8vIGN1cnJlbnQgbGlzdCAobm90IGZyb20gYSBzdWJsaXN0KSwgcmV0dXJuIGVhcmx5LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLmlzVmVydGljYWxfICYmIGFycm93RG93bikgfHwgKCF0aGlzLmlzVmVydGljYWxfICYmIGFycm93UmlnaHQpKSB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0RXZlbnRfKGV2dCk7XG4gICAgICBuZXh0SW5kZXggPSB0aGlzLmZvY3VzTmV4dEVsZW1lbnQoY3VycmVudEluZGV4KTtcbiAgICB9IGVsc2UgaWYgKCh0aGlzLmlzVmVydGljYWxfICYmIGFycm93VXApIHx8ICghdGhpcy5pc1ZlcnRpY2FsXyAmJiBhcnJvd0xlZnQpKSB7XG4gICAgICB0aGlzLnByZXZlbnREZWZhdWx0RXZlbnRfKGV2dCk7XG4gICAgICBuZXh0SW5kZXggPSB0aGlzLmZvY3VzUHJldkVsZW1lbnQoY3VycmVudEluZGV4KTtcbiAgICB9IGVsc2UgaWYgKGlzSG9tZSkge1xuICAgICAgdGhpcy5wcmV2ZW50RGVmYXVsdEV2ZW50XyhldnQpO1xuICAgICAgbmV4dEluZGV4ID0gdGhpcy5mb2N1c0ZpcnN0RWxlbWVudCgpO1xuICAgIH0gZWxzZSBpZiAoaXNFbmQpIHtcbiAgICAgIHRoaXMucHJldmVudERlZmF1bHRFdmVudF8oZXZ0KTtcbiAgICAgIG5leHRJbmRleCA9IHRoaXMuZm9jdXNMYXN0RWxlbWVudCgpO1xuICAgIH0gZWxzZSBpZiAoaXNFbnRlciB8fCBpc1NwYWNlKSB7XG4gICAgICBpZiAoaXNSb290TGlzdEl0ZW0pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTZWxlY3RhYmxlTGlzdF8oKSkge1xuICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleE9uQWN0aW9uXyhjdXJyZW50SW5kZXgpO1xuICAgICAgICAgIHRoaXMucHJldmVudERlZmF1bHRFdmVudF8oZXZ0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEV4cGxpY2l0bHkgYWN0aXZhdGUgbGlua3MsIHNpbmNlIHdlJ3JlIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBFbnRlciwgYW5kIFNwYWNlIGRvZXNuJ3QgYWN0aXZhdGUgdGhlbS5cbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2xsb3dIcmVmKGN1cnJlbnRJbmRleCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5mb2N1c2VkSXRlbUluZGV4XyA9IGN1cnJlbnRJbmRleDtcblxuICAgIGlmIChuZXh0SW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5zZXRUYWJpbmRleEF0SW5kZXhfKG5leHRJbmRleCk7XG4gICAgICB0aGlzLmZvY3VzZWRJdGVtSW5kZXhfID0gbmV4dEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGljayBoYW5kbGVyIGZvciB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdG9nZ2xlQ2hlY2tib3hcbiAgICovXG4gIGhhbmRsZUNsaWNrKGluZGV4LCB0b2dnbGVDaGVja2JveCkge1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmlzU2VsZWN0YWJsZUxpc3RfKCkpIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleE9uQWN0aW9uXyhpbmRleCwgdG9nZ2xlQ2hlY2tib3gpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VGFiaW5kZXhBdEluZGV4XyhpbmRleCk7XG4gICAgdGhpcy5mb2N1c2VkSXRlbUluZGV4XyA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCBwcmV2ZW50RGVmYXVsdCBpcyBvbmx5IGNhbGxlZCBpZiB0aGUgY29udGFpbmluZyBlbGVtZW50IGRvZXNuJ3RcbiAgICogY29uc3VtZSB0aGUgZXZlbnQsIGFuZCBpdCB3aWxsIGNhdXNlIGFuIHVuaW50ZW5kZWQgc2Nyb2xsLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByZXZlbnREZWZhdWx0RXZlbnRfKGV2dCkge1xuICAgIGNvbnN0IHRhZ05hbWUgPSBgJHtldnQudGFyZ2V0LnRhZ05hbWV9YC50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChFTEVNRU5UU19LRVlfQUxMT1dFRF9JTi5pbmRleE9mKHRhZ05hbWUpID09PSAtMSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvY3VzZXMgdGhlIG5leHQgZWxlbWVudCBvbiB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZvY3VzTmV4dEVsZW1lbnQoaW5kZXgpIHtcbiAgICBjb25zdCBjb3VudCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGlzdEl0ZW1Db3VudCgpO1xuICAgIGxldCBuZXh0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaWYgKG5leHRJbmRleCA+PSBjb3VudCkge1xuICAgICAgaWYgKHRoaXMud3JhcEZvY3VzXykge1xuICAgICAgICBuZXh0SW5kZXggPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmV0dXJuIGVhcmx5IGJlY2F1c2UgbGFzdCBpdGVtIGlzIGFscmVhZHkgZm9jdXNlZC5cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgobmV4dEluZGV4KTtcblxuICAgIHJldHVybiBuZXh0SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgcHJldmlvdXMgZWxlbWVudCBvbiB0aGUgbGlzdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGZvY3VzUHJldkVsZW1lbnQoaW5kZXgpIHtcbiAgICBsZXQgcHJldkluZGV4ID0gaW5kZXggLSAxO1xuICAgIGlmIChwcmV2SW5kZXggPCAwKSB7XG4gICAgICBpZiAodGhpcy53cmFwRm9jdXNfKSB7XG4gICAgICAgIHByZXZJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0TGlzdEl0ZW1Db3VudCgpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJldHVybiBlYXJseSBiZWNhdXNlIGZpcnN0IGl0ZW0gaXMgYWxyZWFkeSBmb2N1c2VkLlxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNJdGVtQXRJbmRleChwcmV2SW5kZXgpO1xuXG4gICAgcmV0dXJuIHByZXZJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBmb2N1c0ZpcnN0RWxlbWVudCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzSXRlbUF0SW5kZXgoMCk7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZm9jdXNMYXN0RWxlbWVudCgpIHtcbiAgICBjb25zdCBsYXN0SW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldExpc3RJdGVtQ291bnQoKSAtIDE7XG4gICAgdGhpcy5hZGFwdGVyXy5mb2N1c0l0ZW1BdEluZGV4KGxhc3RJbmRleCk7XG4gICAgcmV0dXJuIGxhc3RJbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNpbmdsZVNlbGVjdGlvbkF0SW5kZXhfKGluZGV4KSB7XG4gICAgbGV0IHNlbGVjdGVkQ2xhc3NOYW1lID0gY3NzQ2xhc3Nlcy5MSVNUX0lURU1fU0VMRUNURURfQ0xBU1M7XG4gICAgaWYgKHRoaXMudXNlQWN0aXZhdGVkQ2xhc3NfKSB7XG4gICAgICBzZWxlY3RlZENsYXNzTmFtZSA9IGNzc0NsYXNzZXMuTElTVF9JVEVNX0FDVElWQVRFRF9DTEFTUztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZWxlY3RlZEluZGV4XyA+PSAwICYmIHRoaXMuc2VsZWN0ZWRJbmRleF8gIT09IGluZGV4KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzRm9yRWxlbWVudEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sIHNlbGVjdGVkQ2xhc3NOYW1lKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4KHRoaXMuc2VsZWN0ZWRJbmRleF8sIHN0cmluZ3MuQVJJQV9TRUxFQ1RFRCwgJ2ZhbHNlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzc0ZvckVsZW1lbnRJbmRleChpbmRleCwgc2VsZWN0ZWRDbGFzc05hbWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4KGluZGV4LCBzdHJpbmdzLkFSSUFfU0VMRUNURUQsICd0cnVlJyk7XG5cbiAgICB0aGlzLnNlbGVjdGVkSW5kZXhfID0gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyByYWRpbyBhdCBnaXZlIGluZGV4LiBSYWRpbyBkb2Vzbid0IGNoYW5nZSB0aGUgY2hlY2tlZCBzdGF0ZSBpZiBpdCBpcyBhbHJlYWR5IGNoZWNrZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0UmFkaW9BdEluZGV4XyhpbmRleCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Q2hlY2tlZENoZWNrYm94T3JSYWRpb0F0SW5kZXgoaW5kZXgsIHRydWUpO1xuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGVGb3JFbGVtZW50SW5kZXgodGhpcy5zZWxlY3RlZEluZGV4Xywgc3RyaW5ncy5BUklBX0NIRUNLRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4KGluZGV4LCBzdHJpbmdzLkFSSUFfQ0hFQ0tFRCwgJ3RydWUnKTtcblxuICAgIHRoaXMuc2VsZWN0ZWRJbmRleF8gPSBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTxudW1iZXI+fSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0Q2hlY2tib3hBdEluZGV4XyhpbmRleCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hZGFwdGVyXy5nZXRMaXN0SXRlbUNvdW50KCk7IGkrKykge1xuICAgICAgbGV0IGlzQ2hlY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKGluZGV4LmluZGV4T2YoaSkgPj0gMCkge1xuICAgICAgICBpc0NoZWNrZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldENoZWNrZWRDaGVja2JveE9yUmFkaW9BdEluZGV4KGksIGlzQ2hlY2tlZCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZUZvckVsZW1lbnRJbmRleChpLCBzdHJpbmdzLkFSSUFfQ0hFQ0tFRCwgaXNDaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfVxuXG4gICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VGFiaW5kZXhBdEluZGV4XyhpbmRleCkge1xuICAgIGlmICh0aGlzLmZvY3VzZWRJdGVtSW5kZXhfID09PSAtMSAmJiBpbmRleCAhPT0gMCkge1xuICAgICAgLy8gSWYgbm8gbGlzdCBpdGVtIHdhcyBzZWxlY3RlZCBzZXQgZmlyc3QgbGlzdCBpdGVtJ3MgdGFiaW5kZXggdG8gLTEuXG4gICAgICAvLyBHZW5lcmFsbHksIHRhYmluZGV4IGlzIHNldCB0byAwIG9uIGZpcnN0IGxpc3QgaXRlbSBvZiBsaXN0IHRoYXQgaGFzIG5vIHByZXNlbGVjdGVkIGl0ZW1zLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGVGb3JFbGVtZW50SW5kZXgoMCwgJ3RhYmluZGV4JywgLTEpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5mb2N1c2VkSXRlbUluZGV4XyA+PSAwICYmIHRoaXMuZm9jdXNlZEl0ZW1JbmRleF8gIT09IGluZGV4KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZUZvckVsZW1lbnRJbmRleCh0aGlzLmZvY3VzZWRJdGVtSW5kZXhfLCAndGFiaW5kZXgnLCAtMSk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGVGb3JFbGVtZW50SW5kZXgoaW5kZXgsICd0YWJpbmRleCcsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybiB0cnVlIGlmIGl0IGlzIHNpbmdsZSBzZWxlY3RpbiBsaXN0LCBjaGVja2JveCBsaXN0IG9yIHJhZGlvIGxpc3QuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1NlbGVjdGFibGVMaXN0XygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NpbmdsZVNlbGVjdGlvbkxpc3RfIHx8IHRoaXMuaXNDaGVja2JveExpc3RfIHx8IHRoaXMuaXNSYWRpb0xpc3RfO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHNldFRhYmluZGV4VG9GaXJzdFNlbGVjdGVkSXRlbV8oKSB7XG4gICAgbGV0IHRhcmdldEluZGV4ID0gMDtcblxuICAgIGlmICh0aGlzLmlzU2VsZWN0YWJsZUxpc3RfKCkpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3RlZEluZGV4XyA9PT0gJ251bWJlcicgJiYgdGhpcy5zZWxlY3RlZEluZGV4XyAhPT0gLTEpIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSB0aGlzLnNlbGVjdGVkSW5kZXhfO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXhfIGluc3RhbmNlb2YgQXJyYXkgJiYgdGhpcy5zZWxlY3RlZEluZGV4Xy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gdGhpcy5zZWxlY3RlZEluZGV4Xy5yZWR1Y2UoKGN1cnJlbnRJbmRleCwgbWluSW5kZXgpID0+IE1hdGgubWluKGN1cnJlbnRJbmRleCwgbWluSW5kZXgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldFRhYmluZGV4QXRJbmRleF8odGFyZ2V0SW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUluZGV4fSBpbmRleFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNJbmRleFZhbGlkXyhpbmRleCkge1xuICAgIGlmIChpbmRleCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBpZiAoIXRoaXMuaXNDaGVja2JveExpc3RfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTURDTGlzdEZvdW5kYXRpb246IEFycmF5IG9mIGluZGV4IGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjaGVja2JveCBiYXNlZCBsaXN0Jyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gaW5kZXguc29tZSgoaSkgPT4gdGhpcy5pc0luZGV4SW5SYW5nZV8oaSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKHRoaXMuaXNDaGVja2JveExpc3RfKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTURDTGlzdEZvdW5kYXRpb246IEV4cGVjdGVkIGFycmF5IG9mIGluZGV4IGZvciBjaGVja2JveCBiYXNlZCBsaXN0IGJ1dCBnb3QgbnVtYmVyOiAnICsgaW5kZXgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaXNJbmRleEluUmFuZ2VfKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzSW5kZXhJblJhbmdlXyhpbmRleCkge1xuICAgIGNvbnN0IGxpc3RTaXplID0gdGhpcy5hZGFwdGVyXy5nZXRMaXN0SXRlbUNvdW50KCk7XG4gICAgcmV0dXJuIGluZGV4ID49IDAgJiYgaW5kZXggPCBsaXN0U2l6ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtib29sZWFuPX0gdG9nZ2xlQ2hlY2tib3hcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNlbGVjdGVkSW5kZXhPbkFjdGlvbl8oaW5kZXgsIHRvZ2dsZUNoZWNrYm94ID0gdHJ1ZSkge1xuICAgIGlmICh0aGlzLmlzQ2hlY2tib3hMaXN0Xykge1xuICAgICAgdGhpcy50b2dnbGVDaGVja2JveEF0SW5kZXhfKGluZGV4LCB0b2dnbGVDaGVja2JveCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0U2VsZWN0ZWRJbmRleChpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHRvZ2dsZUNoZWNrYm94XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0b2dnbGVDaGVja2JveEF0SW5kZXhfKGluZGV4LCB0b2dnbGVDaGVja2JveCkge1xuICAgIGxldCBpc0NoZWNrZWQgPSB0aGlzLmFkYXB0ZXJfLmlzQ2hlY2tib3hDaGVja2VkQXRJbmRleChpbmRleCk7XG5cbiAgICBpZiAodG9nZ2xlQ2hlY2tib3gpIHtcbiAgICAgIGlzQ2hlY2tlZCA9ICFpc0NoZWNrZWQ7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldENoZWNrZWRDaGVja2JveE9yUmFkaW9BdEluZGV4KGluZGV4LCBpc0NoZWNrZWQpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4KGluZGV4LCBzdHJpbmdzLkFSSUFfQ0hFQ0tFRCwgaXNDaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG5cbiAgICAvLyBJZiBub25lIG9mIHRoZSBjaGVja2JveCBpdGVtcyBhcmUgc2VsZWN0ZWQgYW5kIHNlbGVjdGVkSW5kZXggaXMgbm90IGluaXRpYWxpemVkIHRoZW4gcHJvdmlkZSBhIGRlZmF1bHQgdmFsdWUuXG4gICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRleF8gPT09IC0xKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXhfID0gW107XG4gICAgfVxuXG4gICAgaWYgKGlzQ2hlY2tlZCkge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4Xy5wdXNoKGluZGV4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWxlY3RlZEluZGV4XyA9IHRoaXMuc2VsZWN0ZWRJbmRleF8uZmlsdGVyKChpKSA9PiBpICE9PSBpbmRleCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpc3RGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENDb21wb25lbnQgZnJvbSAnQG1hdGVyaWFsL2Jhc2UvY29tcG9uZW50JztcbmltcG9ydCBNRENMaXN0Rm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0xpc3RBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge21hdGNoZXN9IGZyb20gJ0BtYXRlcmlhbC9kb20vcG9ueWZpbGwnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBJbmRleH0gZnJvbSAnLi9jb25zdGFudHMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQGV4dGVuZHMgTURDQ29tcG9uZW50PCFNRENMaXN0Rm91bmRhdGlvbj5cbiAqL1xuY2xhc3MgTURDTGlzdCBleHRlbmRzIE1EQ0NvbXBvbmVudCB7XG4gIC8qKiBAcGFyYW0gey4uLj99IGFyZ3MgKi9cbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuaGFuZGxlS2V5ZG93bl87XG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5oYW5kbGVDbGlja187XG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5mb2N1c0luRXZlbnRMaXN0ZW5lcl87XG4gICAgLyoqIEBwcml2YXRlIHshRnVuY3Rpb259ICovXG4gICAgdGhpcy5mb2N1c091dEV2ZW50TGlzdGVuZXJfO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IHJvb3RcbiAgICogQHJldHVybiB7IU1EQ0xpc3R9XG4gICAqL1xuICBzdGF0aWMgYXR0YWNoVG8ocm9vdCkge1xuICAgIHJldHVybiBuZXcgTURDTGlzdChyb290KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duXyk7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlQ2xpY2tfKTtcbiAgICB0aGlzLnJvb3RfLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCB0aGlzLmZvY3VzSW5FdmVudExpc3RlbmVyXyk7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c291dCcsIHRoaXMuZm9jdXNPdXRFdmVudExpc3RlbmVyXyk7XG4gIH1cblxuICBpbml0aWFsU3luY1dpdGhET00oKSB7XG4gICAgdGhpcy5oYW5kbGVDbGlja18gPSB0aGlzLmhhbmRsZUNsaWNrRXZlbnRfLmJpbmQodGhpcyk7XG4gICAgdGhpcy5oYW5kbGVLZXlkb3duXyA9IHRoaXMuaGFuZGxlS2V5ZG93bkV2ZW50Xy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZm9jdXNJbkV2ZW50TGlzdGVuZXJfID0gdGhpcy5oYW5kbGVGb2N1c0luRXZlbnRfLmJpbmQodGhpcyk7XG4gICAgdGhpcy5mb2N1c091dEV2ZW50TGlzdGVuZXJfID0gdGhpcy5oYW5kbGVGb2N1c091dEV2ZW50Xy5iaW5kKHRoaXMpO1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5ZG93bl8pO1xuICAgIHRoaXMucm9vdF8uYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIHRoaXMuZm9jdXNJbkV2ZW50TGlzdGVuZXJfKTtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3Vzb3V0JywgdGhpcy5mb2N1c091dEV2ZW50TGlzdGVuZXJfKTtcbiAgICB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVDbGlja18pO1xuICAgIHRoaXMubGF5b3V0KCk7XG4gICAgdGhpcy5pbml0aWFsaXplTGlzdFR5cGUoKTtcbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSB0aGlzLnJvb3RfLmdldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfT1JJRU5UQVRJT04pO1xuICAgIHRoaXMudmVydGljYWwgPSBkaXJlY3Rpb24gIT09IHN0cmluZ3MuQVJJQV9PUklFTlRBVElPTl9IT1JJWk9OVEFMO1xuXG4gICAgLy8gTGlzdCBpdGVtcyBuZWVkIHRvIGhhdmUgYXQgbGVhc3QgdGFiaW5kZXg9LTEgdG8gYmUgZm9jdXNhYmxlLlxuICAgIFtdLnNsaWNlLmNhbGwodGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKCcubWRjLWxpc3QtaXRlbTpub3QoW3RhYmluZGV4XSknKSlcbiAgICAgIC5mb3JFYWNoKChlbGUpID0+IHtcbiAgICAgICAgZWxlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSk7XG4gICAgICB9KTtcblxuICAgIC8vIENoaWxkIGJ1dHRvbi9hIGVsZW1lbnRzIGFyZSBub3QgdGFiYmFibGUgdW50aWwgdGhlIGxpc3QgaXRlbSBpcyBmb2N1c2VkLlxuICAgIFtdLnNsaWNlLmNhbGwodGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKHN0cmluZ3MuRk9DVVNBQkxFX0NISUxEX0VMRU1FTlRTKSlcbiAgICAgIC5mb3JFYWNoKChlbGUpID0+IGVsZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpKTtcblxuICAgIHRoaXMuZm91bmRhdGlvbl8ubGF5b3V0KCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IHdoaWNoIGxpc3QgaXRlbSB0aGlzIGV2ZW50IGlzIHRhcmdldHRpbmcuIE9yIHJldHVybnMgLTEgaWZcbiAgICogdGhlcmUgaXMgbm8gbGlzdCBpdGVtXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TGlzdEl0ZW1JbmRleF8oZXZ0KSB7XG4gICAgbGV0IGV2ZW50VGFyZ2V0ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpO1xuICAgIGxldCBpbmRleCA9IC0xO1xuXG4gICAgLy8gRmluZCB0aGUgZmlyc3QgYW5jZXN0b3IgdGhhdCBpcyBhIGxpc3QgaXRlbSBvciB0aGUgbGlzdC5cbiAgICB3aGlsZSAoIWV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzc2VzLkxJU1RfSVRFTV9DTEFTUylcbiAgICAmJiAhZXZlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzZXMuUk9PVCkpIHtcbiAgICAgIGV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQucGFyZW50RWxlbWVudDtcbiAgICB9XG5cbiAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IGlmIGl0IGlzIGEgbGlzdCBpdGVtLlxuICAgIGlmIChldmVudFRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY3NzQ2xhc3Nlcy5MSVNUX0lURU1fQ0xBU1MpKSB7XG4gICAgICBpbmRleCA9IHRoaXMubGlzdEVsZW1lbnRzLmluZGV4T2YoZXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggZWxlbWVudCB3YXMgY2xpY2tlZCBiZWZvcmUgc2VuZGluZyB0aGUgZXZlbnQgdG8gdGhlIGZvdW5kYXRpb24uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlRm9jdXNJbkV2ZW50XyhldnQpIHtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0TGlzdEl0ZW1JbmRleF8oZXZ0KTtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZUZvY3VzSW4oZXZ0LCBpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IHdoaWNoIGVsZW1lbnQgd2FzIGNsaWNrZWQgYmVmb3JlIHNlbmRpbmcgdGhlIGV2ZW50IHRvIHRoZSBmb3VuZGF0aW9uLlxuICAgKiBAcGFyYW0ge0V2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZUZvY3VzT3V0RXZlbnRfKGV2dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMaXN0SXRlbUluZGV4XyhldnQpO1xuICAgIHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlRm9jdXNPdXQoZXZ0LCBpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBmaWd1cmUgb3V0IHdoaWNoIGVsZW1lbnQgd2FzIGZvY3VzZWQgd2hlbiBrZXlkb3duIGV2ZW50IG9jY3VycmVkIGJlZm9yZSBzZW5kaW5nIHRoZSBldmVudCB0byB0aGVcbiAgICogZm91bmRhdGlvbi5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVLZXlkb3duRXZlbnRfKGV2dCkge1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMaXN0SXRlbUluZGV4XyhldnQpO1xuXG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbl8uaGFuZGxlS2V5ZG93bihldnQsIGV2dC50YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNzc0NsYXNzZXMuTElTVF9JVEVNX0NMQVNTKSwgaW5kZXgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGZpZ3VyZSBvdXQgd2hpY2ggZWxlbWVudCB3YXMgY2xpY2tlZCBiZWZvcmUgc2VuZGluZyB0aGUgZXZlbnQgdG8gdGhlIGZvdW5kYXRpb24uXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlQ2xpY2tFdmVudF8oZXZ0KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmdldExpc3RJdGVtSW5kZXhfKGV2dCk7XG5cbiAgICAvLyBUb2dnbGUgdGhlIGNoZWNrYm94IG9ubHkgaWYgaXQncyBub3QgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQsIG9yIHRoZSBjaGVja2JveCB3aWxsIGhhdmUgMiBjaGFuZ2UgZXZlbnRzLlxuICAgIGNvbnN0IHRvZ2dsZUNoZWNrYm94ID0gIW1hdGNoZXMoLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpLCBzdHJpbmdzLkNIRUNLQk9YX1JBRElPX1NFTEVDVE9SKTtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmhhbmRsZUNsaWNrKGluZGV4LCB0b2dnbGVDaGVja2JveCk7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBzZWxlY3RlZEluZGV4IHZhbHVlIGJhc2VkIG9uIHByZS1zZWxlY3RlZCBjaGVja2JveCBsaXN0IGl0ZW1zLCBzaW5nbGUgc2VsZWN0aW9uIG9yIHJhZGlvLlxuICAgKi9cbiAgaW5pdGlhbGl6ZUxpc3RUeXBlKCkge1xuICAgIGNvbnN0IGNoZWNrYm94TGlzdEl0ZW1zID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yQWxsKHN0cmluZ3MuQVJJQV9ST0xFX0NIRUNLQk9YX1NFTEVDVE9SKTtcbiAgICBjb25zdCBzaW5nbGVTZWxlY3RlZExpc3RJdGVtID0gdGhpcy5yb290Xy5xdWVyeVNlbGVjdG9yKGAuJHtjc3NDbGFzc2VzLkxJU1RfSVRFTV9BQ1RJVkFURURfQ0xBU1N9LFxuICAgICAgICAuJHtjc3NDbGFzc2VzLkxJU1RfSVRFTV9TRUxFQ1RFRF9DTEFTU31gKTtcbiAgICBjb25zdCByYWRpb1NlbGVjdGVkTGlzdEl0ZW0gPSB0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3Ioc3RyaW5ncy5BUklBX0NIRUNLRURfUkFESU9fU0VMRUNUT1IpO1xuXG4gICAgaWYgKGNoZWNrYm94TGlzdEl0ZW1zLmxlbmd0aCkge1xuICAgICAgY29uc3QgcHJlc2VsZWN0ZWRJdGVtcyA9IHRoaXMucm9vdF8ucXVlcnlTZWxlY3RvckFsbChzdHJpbmdzLkFSSUFfQ0hFQ0tFRF9DSEVDS0JPWF9TRUxFQ1RPUik7XG4gICAgICB0aGlzLnNlbGVjdGVkSW5kZXggPSBbXS5tYXAuY2FsbChwcmVzZWxlY3RlZEl0ZW1zLCAobGlzdEl0ZW0pID0+IHRoaXMubGlzdEVsZW1lbnRzLmluZGV4T2YobGlzdEl0ZW0pKTtcbiAgICB9IGVsc2UgaWYgKHNpbmdsZVNlbGVjdGVkTGlzdEl0ZW0pIHtcbiAgICAgIGlmIChzaW5nbGVTZWxlY3RlZExpc3RJdGVtLmNsYXNzTGlzdC5jb250YWlucyhjc3NDbGFzc2VzLkxJU1RfSVRFTV9BQ1RJVkFURURfQ0xBU1MpKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbl8uc2V0VXNlQWN0aXZhdGVkQ2xhc3ModHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2luZ2xlU2VsZWN0aW9uID0gdHJ1ZTtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMubGlzdEVsZW1lbnRzLmluZGV4T2Yoc2luZ2xlU2VsZWN0ZWRMaXN0SXRlbSk7XG4gICAgfSBlbHNlIGlmIChyYWRpb1NlbGVjdGVkTGlzdEl0ZW0pIHtcbiAgICAgIHRoaXMuc2VsZWN0ZWRJbmRleCA9IHRoaXMubGlzdEVsZW1lbnRzLmluZGV4T2YocmFkaW9TZWxlY3RlZExpc3RJdGVtKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuICBzZXQgdmVydGljYWwodmFsdWUpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFZlcnRpY2FsT3JpZW50YXRpb24odmFsdWUpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gQXJyYXk8IUVsZW1lbnQ+Ki9cbiAgZ2V0IGxpc3RFbGVtZW50cygpIHtcbiAgICByZXR1cm4gW10uc2xpY2UuY2FsbCh0aGlzLnJvb3RfLnF1ZXJ5U2VsZWN0b3JBbGwoc3RyaW5ncy5FTkFCTEVEX0lURU1TX1NFTEVDVE9SKSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB2YWx1ZSAqL1xuICBzZXQgd3JhcEZvY3VzKHZhbHVlKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRXcmFwRm9jdXModmFsdWUpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTaW5nbGVTZWxlY3Rpb25MaXN0ICovXG4gIHNldCBzaW5nbGVTZWxlY3Rpb24oaXNTaW5nbGVTZWxlY3Rpb25MaXN0KSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uXy5zZXRTaW5nbGVTZWxlY3Rpb24oaXNTaW5nbGVTZWxlY3Rpb25MaXN0KTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshSW5kZXh9ICovXG4gIGdldCBzZWxlY3RlZEluZGV4KCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fLmdldFNlbGVjdGVkSW5kZXgoKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFJbmRleH0gaW5kZXggKi9cbiAgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb25fLnNldFNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENMaXN0Rm91bmRhdGlvbn0gKi9cbiAgZ2V0RGVmYXVsdEZvdW5kYXRpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBNRENMaXN0Rm91bmRhdGlvbigvKiogQHR5cGUgeyFNRENMaXN0QWRhcHRlcn0gKi8gKE9iamVjdC5hc3NpZ24oe1xuICAgICAgZ2V0TGlzdEl0ZW1Db3VudDogKCkgPT4gdGhpcy5saXN0RWxlbWVudHMubGVuZ3RoLFxuICAgICAgZ2V0Rm9jdXNlZEVsZW1lbnRJbmRleDogKCkgPT4gdGhpcy5saXN0RWxlbWVudHMuaW5kZXhPZihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSxcbiAgICAgIHNldEF0dHJpYnV0ZUZvckVsZW1lbnRJbmRleDogKGluZGV4LCBhdHRyLCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZUZvckVsZW1lbnRJbmRleDogKGluZGV4LCBhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RFbGVtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGRDbGFzc0ZvckVsZW1lbnRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzRm9yRWxlbWVudEluZGV4OiAoaW5kZXgsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZm9jdXNJdGVtQXRJbmRleDogKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RFbGVtZW50c1tpbmRleF07XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0VGFiSW5kZXhGb3JMaXN0SXRlbUNoaWxkcmVuOiAobGlzdEl0ZW1JbmRleCwgdGFiSW5kZXhWYWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5saXN0RWxlbWVudHNbbGlzdEl0ZW1JbmRleF07XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtQ2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzdHJpbmdzLkNISUxEX0VMRU1FTlRTX1RPX1RPR0dMRV9UQUJJTkRFWCkpO1xuICAgICAgICBsaXN0SXRlbUNoaWxkcmVuLmZvckVhY2goKGVsZSkgPT4gZWxlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0YWJJbmRleFZhbHVlKSk7XG4gICAgICB9LFxuICAgICAgZm9sbG93SHJlZjogKGluZGV4KSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdO1xuICAgICAgICBpZiAobGlzdEl0ZW0gJiYgbGlzdEl0ZW0uaHJlZikge1xuICAgICAgICAgIGxpc3RJdGVtLmNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBoYXNDaGVja2JveEF0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuICEhbGlzdEl0ZW0ucXVlcnlTZWxlY3RvcihzdHJpbmdzLkNIRUNLQk9YX1NFTEVDVE9SKTtcbiAgICAgIH0sXG4gICAgICBoYXNSYWRpb0F0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgcmV0dXJuICEhbGlzdEl0ZW0ucXVlcnlTZWxlY3RvcihzdHJpbmdzLlJBRElPX1NFTEVDVE9SKTtcbiAgICAgIH0sXG4gICAgICBpc0NoZWNrYm94Q2hlY2tlZEF0SW5kZXg6IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbSA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XTtcbiAgICAgICAgY29uc3QgdG9nZ2xlRWwgPSBsaXN0SXRlbS5xdWVyeVNlbGVjdG9yKHN0cmluZ3MuQ0hFQ0tCT1hfU0VMRUNUT1IpO1xuICAgICAgICByZXR1cm4gdG9nZ2xlRWwuY2hlY2tlZDtcbiAgICAgIH0sXG4gICAgICBzZXRDaGVja2VkQ2hlY2tib3hPclJhZGlvQXRJbmRleDogKGluZGV4LCBpc0NoZWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSB0aGlzLmxpc3RFbGVtZW50c1tpbmRleF07XG4gICAgICAgIGNvbnN0IHRvZ2dsZUVsID0gbGlzdEl0ZW0ucXVlcnlTZWxlY3RvcihzdHJpbmdzLkNIRUNLQk9YX1JBRElPX1NFTEVDVE9SKTtcbiAgICAgICAgdG9nZ2xlRWwuY2hlY2tlZCA9IGlzQ2hlY2tlZDtcblxuICAgICAgICBjb25zdCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpO1xuICAgICAgICB0b2dnbGVFbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBpc0ZvY3VzSW5zaWRlTGlzdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290Xy5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcbiAgICAgIH0sXG4gICAgfSkpKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ0xpc3QsIE1EQ0xpc3RGb3VuZGF0aW9ufTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8YXNpZGUgcmVmPVwiZHJhd2VyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIGNsYXNzPVwibWRjLWRyYXdlciBtZGMtZHJhd2VyLS1tb2RhbFwiPlxuICAgICAgPHNsb3Qgdi1pZj1cIiRzbG90c1snaGVhZGVyJ11cIiBuYW1lPVwiaGVhZGVyXCI+PC9zbG90PlxuICAgICAgPCEtLSA8ZGl2IHYtaWY9XCIkc2xvdHNbJ2hlYWRlciddXCIgY2xhc3M9XCJtZGMtZHJhd2VyX19oZWFkZXJcIj48PC9kaXY+IC0tPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2NvbnRlbnRcIj48c2xvdD48L3Nsb3Q+PC9kaXY+XG4gICAgPC9hc2lkZT5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWRyYXdlci1zY3JpbVwiPjwvZGl2PlxuXG4gICAgPGRpdiB2LWlmPVwidG9vbGJhclNwYWNlclwiIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyLS1maXhlZC1hZGp1c3RcIiAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDRGlzbWlzc2libGVEcmF3ZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvZGlzbWlzc2libGUvZm91bmRhdGlvbidcbmltcG9ydCBNRENNb2RhbERyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci9tb2RhbC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgTURDTGlzdCB9IGZyb20gJ0BtYXRlcmlhbC9saXN0L2luZGV4J1xuaW1wb3J0IE1EQ0xpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saXN0L2ZvdW5kYXRpb24nXG5pbXBvcnQgY3JlYXRlRm9jdXNUcmFwIGZyb20gJ2ZvY3VzLXRyYXAnXG5cbmNvbnN0IG1lZGlhID0gbmV3IGNsYXNzIHtcbiAgZ2V0IHNtYWxsKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9zbWFsbCB8fCAodGhpcy5fc21hbGwgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1heC13aWR0aDogODM5cHgpJykpXG4gICAgKVxuICB9XG5cbiAgZ2V0IGxhcmdlKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLl9sYXJnZSB8fCAodGhpcy5fbGFyZ2UgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi13aWR0aDogMTIwMHB4KScpKVxuICAgIClcbiAgfVxufSgpXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBtb2RhbDogQm9vbGVhbixcbiAgICBvcGVuOiBCb29sZWFuLFxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXG4gICAgdG9nZ2xlT246IFN0cmluZyxcbiAgICB0b2dnbGVPblNvdXJjZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgcmVxdWlyZWQ6IGZhbHNlXG4gICAgfSxcbiAgICBvcGVuT246IFN0cmluZyxcbiAgICBvcGVuT25Tb3VyY2U6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgIH0sXG4gICAgY2xvc2VPbjogU3RyaW5nLFxuICAgIGNsb3NlT25Tb3VyY2U6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHJlcXVpcmVkOiBmYWxzZVxuICAgIH1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNEcmF3ZXI6IHRoaXMgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBvcGVuXzogZmFsc2UsXG4gICAgICBjbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICB0eXBlKCkge30sXG4gICAgaXNNb2RhbCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGFsXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW46ICdvbk9wZW5fJ1xuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZHJhd2VyXyA9IHRoaXMuJHJlZnMuZHJhd2VyXG4gICAgY29uc3QgYWRhcHRlciA9IHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy5kcmF3ZXJfLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgZWxlbWVudEhhc0NsYXNzOiAoZWxlbWVudCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIHRoaXMucHJldmlvdXNGb2N1c18gPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50XG4gICAgICB9LFxuICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRm9jdXMgPSB0aGlzLnByZXZpb3VzRm9jdXNfICYmIHRoaXMucHJldmlvdXNGb2N1c18uZm9jdXNcbiAgICAgICAgaWYgKHRoaXMuZHJhd2VyXy5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSAmJiBwcmV2aW91c0ZvY3VzKSB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXy5mb2N1cygpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1c0FjdGl2ZU5hdmlnYXRpb25JdGVtOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGFjdGl2ZU5hdkl0ZW1FbCA9IHRoaXMuZHJhd2VyXy5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIGAuJHtNRENMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkxJU1RfSVRFTV9BQ1RJVkFURURfQ0xBU1N9YFxuICAgICAgICApXG4gICAgICAgIGlmIChhY3RpdmVOYXZJdGVtRWwpIHtcbiAgICAgICAgICBhY3RpdmVOYXZJdGVtRWwuZm9jdXMoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2xvc2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIHRyYXBGb2N1czogKCkgPT4gdGhpcy5mb2N1c1RyYXBfLmFjdGl2YXRlKCksXG4gICAgICByZWxlYXNlRm9jdXM6ICgpID0+IHRoaXMuZm9jdXNUcmFwXy5kZWFjdGl2YXRlKClcbiAgICB9XG5cbiAgICBjb25zdCB7IERJU01JU1NJQkxFLCBNT0RBTCB9ID0gTURDRGlzbWlzc2libGVEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXNcbiAgICBpZiAodGhpcy5kcmF3ZXJfLmNsYXNzTGlzdC5jb250YWlucyhESVNNSVNTSUJMRSkpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENEaXNtaXNzaWJsZURyYXdlckZvdW5kYXRpb24oYWRhcHRlcilcbiAgICB9IGVsc2UgaWYgKHRoaXMuZHJhd2VyXy5jbGFzc0xpc3QuY29udGFpbnMoTU9EQUwpKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDTW9kYWxEcmF3ZXJGb3VuZGF0aW9uKGFkYXB0ZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYE1EQ0RyYXdlcjogRmFpbGVkIHRvIGluc3RhbnRpYXRlIGNvbXBvbmVudC4gU3VwcG9ydGVkIHZhcmlhbnRzIGFyZSAke0RJU01JU1NJQkxFfSBhbmQgJHtNT0RBTH0uYFxuICAgICAgKVxuICAgIH1cbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuaW5pdGlhbFN5bmNXaXRoRE9NKClcblxuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UgPSB0aGlzLnRvZ2dsZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZS4kb24odGhpcy50b2dnbGVPbiwgdGhpcy50b2dnbGUpXG4gICAgfVxuICAgIGlmICh0aGlzLm9wZW5Pbikge1xuICAgICAgdGhpcy5vcGVuT25FdmVudFNvdXJjZSA9IHRoaXMub3Blbk9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9uKHRoaXMub3Blbk9uLCB0aGlzLnNob3cpXG4gICAgfVxuICAgIGlmICh0aGlzLmNsb3NlT24pIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlID0gdGhpcy5jbG9zZU9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvbih0aGlzLmNsb3NlT24sIHRoaXMuY2xvc2UpXG4gICAgfVxuICAgIC8vIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIC8vIG1lZGlhLmxhcmdlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKVxuICAgIC8vIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVmcmVzaE1lZGlhKCkpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBudWxsXG4gICAgLy8gbWVkaWEuc21hbGwucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG4gICAgLy8gbWVkaWEubGFyZ2UucmVtb3ZlTGlzdGVuZXIodGhpcy5yZWZyZXNoTWVkaWEpXG5cbiAgICBpZiAodGhpcy50b2dnbGVPbkV2ZW50U291cmNlKSB7XG4gICAgICB0aGlzLnRvZ2dsZU9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZSlcbiAgICB9XG4gICAgaWYgKHRoaXMub3Blbk9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLm9wZW5PbiwgdGhpcy5zaG93KVxuICAgIH1cbiAgICBpZiAodGhpcy5jbG9zZU9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMuY2xvc2VPbkV2ZW50U291cmNlLiRvZmYodGhpcy5jbG9zZU9uLCB0aGlzLmNsb3NlKVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAgIGNvbnN0IHsgTU9EQUwgfSA9IE1EQ0Rpc21pc3NpYmxlRHJhd2VyRm91bmRhdGlvbi5jc3NDbGFzc2VzXG5cbiAgICAgIGlmICh0aGlzLmRyYXdlcl8uY2xhc3NMaXN0LmNvbnRhaW5zKE1PREFMKSkge1xuICAgICAgICBjb25zdCB7IFNDUklNX1NFTEVDVE9SIH0gPSBNRENEaXNtaXNzaWJsZURyYXdlckZvdW5kYXRpb24uc3RyaW5nc1xuICAgICAgICB0aGlzLnNjcmltXyA9IHRoaXMuZHJhd2VyXy5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0NSSU1fU0VMRUNUT1IpXG4gICAgICAgIHRoaXMuaGFuZGxlU2NyaW1DbGlja18gPSAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaGFuZGxlU2NyaW1DbGljaygpXG4gICAgICAgIHRoaXMuc2NyaW1fLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVTY3JpbUNsaWNrXylcbiAgICAgICAgdGhpcy5mb2N1c1RyYXBfID0gY3JlYXRlRm9jdXNUcmFwSW5zdGFuY2UoXG4gICAgICAgICAgdGhpcy5kcmF3ZXJfLFxuICAgICAgICAgIHRoaXMuZm9jdXNUcmFwRmFjdG9yeV9cbiAgICAgICAgKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmhhbmRsZUtleWRvd25fID0gZXZ0ID0+IHRoaXMuZm91bmRhdGlvbi5oYW5kbGVLZXlkb3duKGV2dClcbiAgICAgIHRoaXMuaGFuZGxlVHJhbnNpdGlvbkVuZF8gPSBldnQgPT5cbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZVRyYW5zaXRpb25FbmQoZXZ0KVxuXG4gICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duXylcbiAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLmhhbmRsZVRyYW5zaXRpb25FbmRfKVxuICAgIH0sXG4gICAgb25PcGVuXyh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLm9wZW4oKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBvbkNoYW5nZShldmVudCkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQpXG4gICAgICB0aGlzLiRyb290LiRlbWl0KCd2bWE6bGF5b3V0JylcbiAgICB9LFxuICAgIHNob3coKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSxcbiAgICBjbG9zZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfSxcbiAgICB0b2dnbGUoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaXNPcGVuKClcbiAgICAgICAgPyB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgICA6IHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICB9LFxuICAgIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uaXNPcGVuKClcbiAgICB9LFxuICAgIHJlZnJlc2hNZWRpYSgpIHtcbiAgICAgIC8vIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzXG4gICAgICAvLyB0aGlzLmxhcmdlID0gbWVkaWEubGFyZ2UubWF0Y2hlc1xuICAgICAgLy8gaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XG4gICAgICAvLyAgIGlmICh0aGlzLmxhcmdlKSB7XG4gICAgICAvLyAgICAgdGhpcy5zaG93KClcbiAgICAgIC8vICAgfSBlbHNlIHtcbiAgICAgIC8vICAgICB0aGlzLmNsb3NlKClcbiAgICAgIC8vICAgfVxuICAgICAgLy8gfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZShcbiAgc3VyZmFjZUVsLFxuICBmb2N1c1RyYXBGYWN0b3J5ID0gY3JlYXRlRm9jdXNUcmFwXG4pIHtcbiAgcmV0dXJuIGZvY3VzVHJhcEZhY3Rvcnkoc3VyZmFjZUVsLCB7XG4gICAgY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXM6IHRydWUsXG4gICAgaW5pdGlhbEZvY3VzOiBmYWxzZSwgLy8gTmF2aWdhdGlvbiBkcmF3ZXIgaGFuZGxlcyBmb2N1c2luZyBvbiBhY3RpdmUgbmF2IGl0ZW0uXG4gICAgZXNjYXBlRGVhY3RpdmF0ZXM6IGZhbHNlLCAvLyBOYXZpZ2F0aW9uIGRyYXdlciBoYW5kbGVzIEVTQy5cbiAgICByZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZTogZmFsc2UgLy8gTmF2aWdhdGlvbiBkcmF3ZXIgaGFuZGxlcyByZXN0b3JlIGZvY3VzLlxuICB9KVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyLWhlYWRlciBtZGMtZHJhd2VyX19oZWFkZXJcIj5cbiAgICAgIDxzbG90IC8+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItaGVhZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxuYXYgXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLWRyYXdlci1saXN0IG1kYy1saXN0XCI+XG4gICAgPHNsb3QvPlxuICA8L25hdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxpc3QnLFxuICBwcm9wczoge1xuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWxpbmtcbiAgICA6bGluaz1cImxpbmtcIlxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWl0ZW0gbWRjLWxpc3QtaXRlbVwiXG4gICAgdi1vbj1cIm15bGlzdGVuZXJzXCJcbiAgPlxuICAgIDxzcGFuIHYtaWY9XCJoYXNTdGFydERldGFpbFwiIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fZ3JhcGhpY1wiPlxuICAgICAgPHNsb3QgbmFtZT1cInN0YXJ0LWRldGFpbFwiPlxuICAgICAgICA8aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgc3RhcnRJY29uIH19PC9pPlxuICAgICAgPC9zbG90PlxuICAgIDwvc3Bhbj5cbiAgICA8c2xvdCAvPlxuICA8L2N1c3RvbS1saW5rPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tTGlua01peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItaXRlbScsXG4gIGluamVjdDogWydtZGNEcmF3ZXInXSxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW5dLFxuICBwcm9wczoge1xuICAgIHN0YXJ0SWNvbjogU3RyaW5nLFxuICAgIG1vZGFsQ2xvc2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW4sXG4gICAgZXhhY3RBY3RpdmVDbGFzczoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgZGVmYXVsdDogJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCdcbiAgICB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBteWxpc3RlbmVycygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnRoaXMuJGxpc3RlbmVycyxcbiAgICAgICAgY2xpY2s6IGUgPT4ge1xuICAgICAgICAgIHRoaXMubWRjRHJhd2VyLmlzTW9kYWwgJiYgdGhpcy5tb2RhbENsb3NlICYmIHRoaXMubWRjRHJhd2VyLmNsb3NlKClcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxpc3QtaXRlbS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJY29uIHx8IHRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUgPSBudWxsXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8aHIgY2xhc3M9XCJtZGMtbGlzdC1kaXZpZGVyXCI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWRyYXdlci1kaXZpZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJIZWFkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWhlYWRlci52dWUnXG5pbXBvcnQgbWRjRHJhd2VyTGlzdCBmcm9tICcuL21kYy1kcmF3ZXItbGlzdC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySXRlbSBmcm9tICcuL21kYy1kcmF3ZXItaXRlbS52dWUnXG5pbXBvcnQgbWRjRHJhd2VyRGl2aWRlciBmcm9tICcuL21kYy1kcmF3ZXItZGl2aWRlci52dWUnXG5cbmV4cG9ydCB7XG4gIG1kY0RyYXdlcixcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckhlYWRlcixcbiAgbWRjRHJhd2VyTGlzdCxcbiAgbWRjRHJhd2VySXRlbSxcbiAgbWRjRHJhd2VyRGl2aWRlclxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLWVsZXZhdGlvblwiPlxuICAgIDxzbG90Lz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWVsZXZhdGlvbicsXG4gIHByb3BzOiB7XG4gICAgejoge1xuICAgICAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgICAgIGRlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIGxldCBlbGV2YXRpb25DbGFzc2VzID0ge31cbiAgICBlbGV2YXRpb25DbGFzc2VzW2BtZGMtZWxldmF0aW9uLS16JHt0aGlzLnp9YF0gPSB0cnVlXG5cbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3NlczogZWxldmF0aW9uQ2xhc3Nlc1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNFbGV2YXRpb24gZnJvbSAnLi9tZGMtZWxldmF0aW9uLnZ1ZSdcblxuZXhwb3J0IHsgbWRjRWxldmF0aW9uIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0VsZXZhdGlvblxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGN1c3RvbS1idXR0b24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDpocmVmPVwiaHJlZlwiXG4gICAgOmxpbms9XCJsaW5rXCIgXG4gICAgY2xhc3M9XCJtZGMtZmFiXCIgXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiID5cbiAgICA8c3BhbiBjbGFzcz1cIm1kYy1mYWJfX2ljb25cIj5cbiAgICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gICAgPC9zcGFuPlxuICA8L2N1c3RvbS1idXR0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21CdXR0b25NaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWZhYicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgQ3VzdG9tQnV0dG9uTWl4aW4sIFJpcHBsZU1peGluXSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmcsXG4gICAgbWluaTogQm9vbGVhbixcbiAgICBhYnNvbHV0ZTogQm9vbGVhbixcbiAgICBmaXhlZDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtYXRlcmlhbC1pY29ucyc6IHRoaXMuaWNvbixcbiAgICAgICAgJ21kYy1mYWItLW1pbmknOiB0aGlzLm1pbmksXG4gICAgICAgICdtZGMtZmFiLS1hYnNvbHV0ZSc6IHRoaXMuYWJzb2x1dGUsXG4gICAgICAgICdtZGMtZmFiLS1maXhlZCc6IHRoaXMuZml4ZWRcbiAgICAgIH0sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGljb24oKSB7XG4gICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCAnbWF0ZXJpYWwtaWNvbnMnLCB0aGlzLmljb24pXG4gICAgfSxcbiAgICBtaW5pKCkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1mYWItLW1pbmknLCB0aGlzLm1pbmkpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0ZBQiBmcm9tICcuL21kYy1mYWIudnVlJ1xuXG5leHBvcnQgeyBtZGNGQUIgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjRkFCXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgVElMRVNfU0VMRUNUT1I6ICcubWRjLWdyaWQtbGlzdF9fdGlsZXMnLFxuICBUSUxFX1NFTEVDVE9SOiAnLm1kYy1ncmlkLXRpbGUnLFxufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCB7c3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENHcmlkTGlzdEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0TnVtYmVyT2ZUaWxlczogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4OiAoLyogaW5kZXg6IG51bWJlciAqLykgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBzZXRTdHlsZUZvclRpbGVzRWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDR3JpZExpc3RGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMuYWxpZ25DZW50ZXIoKTtcbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IDA7XG4gIH1cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFsaWduQ2VudGVyKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG4gIGFsaWduQ2VudGVyKCkge1xuICAgIGlmICh0aGlzLnJlc2l6ZUZyYW1lXyAhPT0gMCkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXNpemVGcmFtZV8pO1xuICAgIH1cbiAgICB0aGlzLnJlc2l6ZUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFsaWduQ2VudGVyXygpO1xuICAgICAgdGhpcy5yZXNpemVGcmFtZV8gPSAwO1xuICAgIH0pO1xuICB9XG4gIGFsaWduQ2VudGVyXygpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROdW1iZXJPZlRpbGVzKCkgPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBncmlkV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgaXRlbVdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRPZmZzZXRXaWR0aEZvclRpbGVBdEluZGV4KDApO1xuICAgIGNvbnN0IHRpbGVzV2lkdGggPSBpdGVtV2lkdGggKiBNYXRoLmZsb29yKGdyaWRXaWR0aCAvIGl0ZW1XaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTdHlsZUZvclRpbGVzRWxlbWVudCgnd2lkdGgnLCBgJHt0aWxlc1dpZHRofXB4YCk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1ncmlkLWxpc3RcIj5cbiAgICA8dWwgXG4gICAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgICA6c3R5bGU9XCJzdHlsZXNcIiBcbiAgICAgIGNsYXNzPVwibWRjLWdyaWQtbGlzdF9fdGlsZXNcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3VsPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDR3JpZExpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ncmlkLWxpc3QvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgd2lkdGg6IFtTdHJpbmcsIE51bWJlcl0sXG4gICAgcmF0aW86IFN0cmluZyxcbiAgICAnbmFycm93LWd1dHRlcic6IEJvb2xlYW4sXG4gICAgJ2hlYWRlci1jYXB0aW9uJzogQm9vbGVhbixcbiAgICAnaWNvbi1hbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2ljb24tYWxpZ24tZW5kJzogQm9vbGVhbixcbiAgICAnd2l0aC1zdXBwb3J0LXRleHQnOiBCb29sZWFuLFxuICAgIGludGVyYWN0aXZlOiBCb29sZWFuXG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjR3JpZDogdGhpcyB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0tdGlsZS1ndXR0ZXItMSddID0gdGhpcy5uYXJyb3dHdXR0ZXJcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLWhlYWRlci1jYXB0aW9uJ10gPSB0aGlzLmhlYWRlckNhcHRpb25cbiAgICAgIGNsYXNzZXNbYG1kYy1ncmlkLWxpc3QtLXRpbGUtYXNwZWN0LSR7dGhpcy5yYXRpb31gXSA9IHRoaXMucmF0aW9cbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXdpdGgtaWNvbi1hbGlnbi1zdGFydCddID0gdGhpcy5pY29uQWxpZ25TdGFydFxuICAgICAgY2xhc3Nlc1snbWRjLWdyaWQtbGlzdC0td2l0aC1pY29uLWFsaWduLWVuZCddID0gdGhpcy5pY29uQWxpZ25FbmRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLXR3b2xpbmUtY2FwdGlvbiddID0gdGhpcy53aXRoU3VwcG9ydFRleHRcbiAgICAgIGNsYXNzZXNbJ21kYy1ncmlkLWxpc3QtLW5vbi1pbnRlcmFjdGl2ZSddID0gIXRoaXMuaW50ZXJhY3RpdmVcblxuICAgICAgcmV0dXJuIGNsYXNzZXNcbiAgICB9LFxuICAgIHN0eWxlcygpIHtcbiAgICAgIHZhciBkZWZhdWx0V2lkdGggPSAyMDBcbiAgICAgIHJldHVybiB7XG4gICAgICAgICctLW1kYy1ncmlkLWxpc3QtdGlsZS13aWR0aCc6IGAke3RoaXMud2lkdGggfHwgZGVmYXVsdFdpZHRofXB4YFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDR3JpZExpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldE51bWJlck9mVGlsZXM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApLmxlbmd0aFxuICAgICAgfSxcbiAgICAgIGdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRV9TRUxFQ1RPUlxuICAgICAgICApW2luZGV4XS5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yVGlsZXNFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDR3JpZExpc3RGb3VuZGF0aW9uLnN0cmluZ3MuVElMRVNfU0VMRUNUT1JcbiAgICAgICAgKS5zdHlsZVtwcm9wZXJ0eV0gPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpIFxuICAgIDpjbGFzcz1cIltjbGFzc2VzLCBpdGVtQ2xhc3Nlc11cIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cImlzSW50ZXJhY3RpdmUgPyAnMCcgOiB1bmRlZmluZWRcIlxuICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZVwiXG4gICAgdi1vbj1cImlzSW50ZXJhY3RpdmUgPyBsaXN0ZW5lcnMgOiBjbGlja0xpc3RlbmVyXCI+XG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCJjb3ZlclwiIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8ZGl2IFxuICAgICAgICA6c3R5bGU9XCJ7IGJhY2tncm91bmRJbWFnZTogJ3VybCgnICsgc3JjICsgJyknIH1cIlxuICAgICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3ByaW1hcnktY29udGVudFwiLz5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2IFxuICAgICAgdi1lbHNlIFxuICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19wcmltYXJ5XCI+XG4gICAgICA8aW1nIFxuICAgICAgICA6c3JjPVwic3JjXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fcHJpbWFyeS1jb250ZW50XCIgPlxuICAgIDwvZGl2PlxuICAgIDxzcGFuIFxuICAgICAgdi1pZj1cInRpdGxlIHx8IHN1cHBvcnRUZXh0XCIgXG4gICAgICBjbGFzcz1cIm1kYy1ncmlkLXRpbGVfX3NlY29uZGFyeVwiPlxuICAgICAgPGkgXG4gICAgICAgIHYtaWY9XCJpY29uXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9faWNvbiBtYXRlcmlhbC1pY29uc1wiPnt7IGljb24gfX08L2k+XG4gICAgICA8c3BhbiBcbiAgICAgICAgdi1pZj1cInRpdGxlXCIgXG4gICAgICAgIGNsYXNzPVwibWRjLWdyaWQtdGlsZV9fdGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDxzcGFuIFxuICAgICAgICB2LWlmPVwic3VwcG9ydFRleHRcIiBcbiAgICAgICAgY2xhc3M9XCJtZGMtZ3JpZC10aWxlX19zdXBwb3J0LXRleHRcIj57eyBzdXBwb3J0VGV4dCB9fTwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIDwvbGk+XG48L3RlbXBsYXRlPlxuXG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWdyaWQtdGlsZScsXG4gIGluamVjdDogWydtZGNHcmlkJ10sXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbl0sXG4gIHByb3BzOiB7XG4gICAgc3JjOiBTdHJpbmcsXG4gICAgY292ZXI6IEJvb2xlYW4sXG4gICAgaWNvbjogU3RyaW5nLFxuICAgIHRpdGxlOiBTdHJpbmcsXG4gICAgJ3N1cHBvcnQtdGV4dCc6IFN0cmluZyxcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsaWNrTGlzdGVuZXIoKSB7XG4gICAgICByZXR1cm4geyBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSkgfVxuICAgIH0sXG4gICAgaXRlbUNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tc2VsZWN0ZWQnOiB0aGlzLnNlbGVjdGVkLFxuICAgICAgICAnbWRjLWdyaWQtdGlsZS0tYWN0aXZhdGVkJzogdGhpcy5hY3RpdmF0ZWRcbiAgICAgIH1cbiAgICB9LFxuICAgIGlzSW50ZXJhY3RpdmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZGNHcmlkICYmIHRoaXMubWRjR3JpZC5pbnRlcmFjdGl2ZVxuICAgIH0sXG4gICAgaGFzU3RhcnREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFydEljb24gfHwgdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfSxcbiAgICBoYXNFbmREZXRhaWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbmRJY29uIHx8IHRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgaXNJbnRlcmFjdGl2ZSh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYWRkUmlwcGxlKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucmVtb3ZlUmlwcGxlKClcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5pc0ludGVyYWN0aXZlICYmIHRoaXMuYWRkUmlwcGxlKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhZGRSaXBwbGUoKSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgICAgICByaXBwbGUuaW5pdCgpXG4gICAgICAgIHRoaXMucmlwcGxlID0gcmlwcGxlXG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVSaXBwbGUoKSB7XG4gICAgICBpZiAodGhpcy5yaXBwbGUpIHtcbiAgICAgICAgbGV0IHJpcHBsZSA9IHRoaXMucmlwcGxlXG4gICAgICAgIHRoaXMucmlwcGxlID0gbnVsbFxuICAgICAgICByaXBwbGUuZGVzdHJveSgpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0dyaWRMaXN0IGZyb20gJy4vbWRjLWdyaWQtbGlzdC52dWUnXG5pbXBvcnQgbWRjR3JpZFRpbGUgZnJvbSAnLi9tZGMtZ3JpZC10aWxlLnZ1ZSdcblxuZXhwb3J0IHsgbWRjR3JpZExpc3QsIG1kY0dyaWRUaWxlIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0dyaWRMaXN0LFxuICBtZGNHcmlkVGlsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiIFxuICAgIGNsYXNzPVwibWRjLWljb24gbWRjLWljb24tLW1hdGVyaWFsXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uJyxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcclxuaW1wb3J0IG1kY0ljb24gZnJvbSAnLi9tZGMtaWNvbi52dWUnXHJcblxyXG5leHBvcnQgeyBtZGNJY29uIH1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xyXG4gIG1kY0ljb25cclxufSlcclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBJY29uIEJ1dHRvbiBUb2dnbGUuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gaW5uZXIgdGV4dFxuICogLSBldmVudCBoYW5kbGVyc1xuICogLSBldmVudCBkaXNwYXRjaFxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuXG5jbGFzcyBNRENJY29uQnV0dG9uVG9nZ2xlQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ck5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJWYWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyTmFtZSwgYXR0clZhbHVlKSB7fVxuXG4gIC8qKiBAcGFyYW0geyFJY29uQnV0dG9uVG9nZ2xlRXZlbnR9IGV2dERhdGEgKi9cbiAgbm90aWZ5Q2hhbmdlKGV2dERhdGEpIHt9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgaXNPbjogYm9vbGVhbixcbiAqIH19XG4gKi9cbmxldCBJY29uQnV0dG9uVG9nZ2xlRXZlbnQ7XG5cbmV4cG9ydCB7TURDSWNvbkJ1dHRvblRvZ2dsZUFkYXB0ZXIsIEljb25CdXR0b25Ub2dnbGVFdmVudH07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWljb24tYnV0dG9uJyxcbiAgSUNPTl9CVVRUT05fT046ICdtZGMtaWNvbi1idXR0b24tLW9uJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9QUkVTU0VEOiAnYXJpYS1wcmVzc2VkJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvbkJ1dHRvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25CdXR0b25Ub2dnbGVBZGFwdGVyLCBJY29uQnV0dG9uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvbkJ1dHRvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uQnV0dG9uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNoYW5nZTogKCkgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0ljb25CdXR0b25Ub2dnbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuQVJJQV9QUkVTU0VELCBgJHt0aGlzLmlzT24oKX1gKTtcbiAgfVxuXG4gIGhhbmRsZUNsaWNrKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoLyoqIEB0eXBlIHshSWNvbkJ1dHRvblRvZ2dsZUV2ZW50fSAqLyAoe2lzT246IHRoaXMuaXNPbigpfSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5JQ09OX0JVVFRPTl9PTik7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFuPX0gaXNPbiAqL1xuICB0b2dnbGUoaXNPbiA9ICF0aGlzLmlzT24oKSkge1xuICAgIGlmIChpc09uKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSUNPTl9CVVRUT05fT04pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuSUNPTl9CVVRUT05fT04pO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLkFSSUFfUFJFU1NFRCwgYCR7aXNPbn1gKTtcbiAgfVxufVxuXG4vKiogQHJlY29yZCAqL1xuY2xhc3MgSWNvbkJ1dHRvblRvZ2dsZVN0YXRlIHt9XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ljb25CdXR0b25Ub2dnbGVGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8YVxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIDpzdHlsZT1cInN0eWxlc1wiXG4gICAgY2xhc3M9XCJtZGMtaWNvbi1idXR0b24gbWF0ZXJpYWwtaWNvbnNcIlxuICAgIEBjbGljaz1cIm9uQ2xpY2tcIlxuICAgIHYtaWY9XCJpc0xpbmtcIlxuICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gID5cbiAgICA8c2xvdCAvPlxuICA8L2E+XG4gIDxidXR0b25cbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIGNsYXNzPVwibWRjLWljb24tYnV0dG9uIG1hdGVyaWFsLWljb25zXCJcbiAgICBAY2xpY2s9XCJvbkNsaWNrXCJcbiAgICB2LWJpbmQ9XCIkYXR0cnNcIlxuICAgIHYtZWxzZVxuICA+XG4gICAgPHNsb3QgLz5cbiAgPC9idXR0b24+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0ljb25CdXR0b25Ub2dnbGVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9pY29uLWJ1dHRvbi9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWljb24tYnV0dG9uJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnaXNPbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgaXNPbjogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpc09uOiAnb25Pbl8nXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0ljb25CdXR0b25Ub2dnbGVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBzZXRBdHRyOiAoYXR0ck5hbWUsIGF0dHJWYWx1ZSkgPT5cbiAgICAgICAgdGhpcy4kZWwuc2V0QXR0cmlidXRlKGF0dHJOYW1lLCBhdHRyVmFsdWUpLFxuICAgICAgbm90aWZ5Q2hhbmdlOiBldnREYXRhID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdChNRENJY29uQnV0dG9uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzLkNIQU5HRV9FVkVOVCwgZXZ0RGF0YSlcblxuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBldnREYXRhLmlzT24pXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi50b2dnbGUodGhpcy5pc09uKVxuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Pbl8oaXNPbikge1xuICAgICAgaWYgKHRoaXMuaXNPbiAhPT0gaXNPbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKGlzT24pXG4gICAgICB9XG4gICAgfSxcblxuICAgIG9uQ2xpY2soZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2xpY2soZXZ0KVxuICAgIH1cbiAgfSxcblxuICBjb21wdXRlZDoge1xuICAgIGlzTGluaygpIHtcbiAgICAgIHJldHVybiB0aGlzLiRlbCAmJiBCb29sZWFuKHRoaXMuJGVsLmdldEF0dHJpYnV0ZSgnaHJlZicpKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNJY29uQnV0dG9uIGZyb20gJy4vbWRjLWljb24tYnV0dG9uLnZ1ZSdcblxuZXhwb3J0IHsgbWRjSWNvbkJ1dHRvbiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNJY29uQnV0dG9uXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBJY29uIFRvZ2dsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBpbm5lciB0ZXh0XG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIGV2ZW50IGRpc3BhdGNoXG4gKlxuICogQWRkaXRpb25hbGx5LCBwcm92aWRlcyB0eXBlIGluZm9ybWF0aW9uIGZvciB0aGUgYWRhcHRlciB0byB0aGUgQ2xvc3VyZVxuICogY29tcGlsZXIuXG4gKlxuICogSW1wbGVtZW50IHRoaXMgYWRhcHRlciBmb3IgeW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlIHRvIGRlbGVnYXRlIHVwZGF0ZXMgdG9cbiAqIHRoZSBjb21wb25lbnQgaW4geW91ciBmcmFtZXdvcmsgb2YgY2hvaWNlLiBTZWUgYXJjaGl0ZWN0dXJlIGRvY3VtZW50YXRpb25cbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2NvZGUvYXJjaGl0ZWN0dXJlLm1kXG4gKlxuICogQHJlY29yZFxuICovXG5cbmNsYXNzIE1EQ0ljb25Ub2dnbGVBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHshRXZlbnRMaXN0ZW5lcn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAqL1xuICBzZXRUZXh0KHRleHQpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VGFiSW5kZXgoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gdGFiSW5kZXggKi9cbiAgc2V0VGFiSW5kZXgodGFiSW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIobmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKG5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAqL1xuICBybUF0dHIobmFtZSkge31cblxuICAvKiogQHBhcmFtIHshSWNvblRvZ2dsZUV2ZW50fSBldnREYXRhICovXG4gIG5vdGlmeUNoYW5nZShldnREYXRhKSB7fVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGlzT246IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgSWNvblRvZ2dsZUV2ZW50O1xuXG5leHBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1pY29uLXRvZ2dsZScsXG4gIERJU0FCTEVEOiAnbWRjLWljb24tdG9nZ2xlLS1kaXNhYmxlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIERBVEFfVE9HR0xFX09OOiAnZGF0YS10b2dnbGUtb24nLFxuICBEQVRBX1RPR0dMRV9PRkY6ICdkYXRhLXRvZ2dsZS1vZmYnLFxuICBBUklBX1BSRVNTRUQ6ICdhcmlhLXByZXNzZWQnLFxuICBBUklBX0RJU0FCTEVEOiAnYXJpYS1kaXNhYmxlZCcsXG4gIEFSSUFfTEFCRUw6ICdhcmlhLWxhYmVsJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDSWNvblRvZ2dsZTpjaGFuZ2UnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ0ljb25Ub2dnbGVBZGFwdGVyLCBJY29uVG9nZ2xlRXZlbnR9IGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDSWNvblRvZ2dsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiB7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBzZXRUZXh0OiAoLyogdGV4dDogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIHNldFRhYkluZGV4OiAoLyogdGFiSW5kZXg6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmcgKi8gJycsXG4gICAgICBzZXRBdHRyOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJtQXR0cjogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiBJY29uVG9nZ2xlRXZlbnQgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMub25fID0gZmFsc2U7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSAtMTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0ljb25Ub2dnbGVTdGF0ZX0gKi9cbiAgICB0aGlzLnRvZ2dsZU9uRGF0YV8gPSBudWxsO1xuXG4gICAgLyoqIEBwcml2YXRlIHs/SWNvblRvZ2dsZVN0YXRlfSAqL1xuICAgIHRoaXMudG9nZ2xlT2ZmRGF0YV8gPSBudWxsO1xuXG4gICAgdGhpcy5jbGlja0hhbmRsZXJfID0gLyoqIEBwcml2YXRlIHshRXZlbnRMaXN0ZW5lcn0gKi8gKFxuICAgICAgKCkgPT4gdGhpcy50b2dnbGVGcm9tRXZ0XygpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzSGFuZGxpbmdLZXlkb3duXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5rZXlkb3duSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSB0cnVlO1xuICAgICAgICByZXR1cm4gZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB0aGlzLmtleXVwSGFuZGxlcl8gPSAvKiogQHByaXZhdGUgeyFFdmVudExpc3RlbmVyfSAqLyAoKC8qKiBAdHlwZSB7IUtleWJvYXJkS2V5fSAqLyBldnQpID0+IHtcbiAgICAgIGlmIChpc1NwYWNlKGV2dCkpIHtcbiAgICAgICAgdGhpcy5pc0hhbmRsaW5nS2V5ZG93bl8gPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b2dnbGVGcm9tRXZ0XygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLnJlZnJlc2hUb2dnbGVEYXRhKCk7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXl1cCcsIHRoaXMua2V5dXBIYW5kbGVyXyk7XG4gIH1cblxuICByZWZyZXNoVG9nZ2xlRGF0YSgpIHtcbiAgICBjb25zdCB7REFUQV9UT0dHTEVfT04sIERBVEFfVE9HR0xFX09GRn0gPSBNRENJY29uVG9nZ2xlRm91bmRhdGlvbi5zdHJpbmdzO1xuICAgIHRoaXMudG9nZ2xlT25EYXRhXyA9IHRoaXMucGFyc2VKc29uRGF0YUF0dHJfKERBVEFfVE9HR0xFX09OKTtcbiAgICB0aGlzLnRvZ2dsZU9mZkRhdGFfID0gdGhpcy5wYXJzZUpzb25EYXRhQXR0cl8oREFUQV9UT0dHTEVfT0ZGKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmtleXVwSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHRvZ2dsZUZyb21FdnRfKCkge1xuICAgIHRoaXMudG9nZ2xlKCk7XG4gICAgY29uc3Qge29uXzogaXNPbn0gPSB0aGlzO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKC8qKiBAdHlwZSB7IUljb25Ub2dnbGVFdmVudH0gKi8gKHtpc09ufSkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzT24oKSB7XG4gICAgcmV0dXJuIHRoaXMub25fO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbj19IGlzT24gKi9cbiAgdG9nZ2xlKGlzT24gPSAhdGhpcy5vbl8pIHtcbiAgICB0aGlzLm9uXyA9IGlzT247XG5cbiAgICBjb25zdCB7QVJJQV9MQUJFTCwgQVJJQV9QUkVTU0VEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICBpZiAodGhpcy5vbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihBUklBX1BSRVNTRUQsICdmYWxzZScpO1xuICAgIH1cblxuICAgIGNvbnN0IHtjc3NDbGFzczogY2xhc3NUb1JlbW92ZX0gPVxuICAgICAgICB0aGlzLm9uXyA/IHRoaXMudG9nZ2xlT2ZmRGF0YV8gOiB0aGlzLnRvZ2dsZU9uRGF0YV87XG5cbiAgICBpZiAoY2xhc3NUb1JlbW92ZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc1RvUmVtb3ZlKTtcbiAgICB9XG5cbiAgICBjb25zdCB7Y29udGVudCwgbGFiZWwsIGNzc0NsYXNzfSA9IHRoaXMub25fID8gdGhpcy50b2dnbGVPbkRhdGFfIDogdGhpcy50b2dnbGVPZmZEYXRhXztcblxuICAgIGlmIChjc3NDbGFzcykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRleHQoY29udGVudCk7XG4gICAgfVxuICAgIGlmIChsYWJlbCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfTEFCRUwsIGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFBdHRyXG4gICAqIEByZXR1cm4geyFJY29uVG9nZ2xlU3RhdGV9XG4gICAqL1xuICBwYXJzZUpzb25EYXRhQXR0cl8oZGF0YUF0dHIpIHtcbiAgICBjb25zdCB2YWwgPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoZGF0YUF0dHIpO1xuICAgIGlmICghdmFsKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFJY29uVG9nZ2xlU3RhdGV9ICovIChKU09OLnBhcnNlKHZhbCkpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNEaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChpc0Rpc2FibGVkKSB7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBpc0Rpc2FibGVkO1xuXG4gICAgY29uc3Qge0RJU0FCTEVEfSA9IE1EQ0ljb25Ub2dnbGVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgY29uc3Qge0FSSUFfRElTQUJMRUR9ID0gTURDSWNvblRvZ2dsZUZvdW5kYXRpb24uc3RyaW5ncztcblxuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0VGFiSW5kZXgoLTEpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKEFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUYWJJbmRleCh0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucm1BdHRyKEFSSUFfRElTQUJMRUQpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhESVNBQkxFRCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzS2V5Ym9hcmRBY3RpdmF0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNIYW5kbGluZ0tleWRvd25fO1xuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAga2V5OiBzdHJpbmcsXG4gKiAgIGtleUNvZGU6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEtleWJvYXJkS2V5O1xuXG4vKipcbiAqIEBwYXJhbSB7IUtleWJvYXJkS2V5fSBrZXlib2FyZEtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNTcGFjZShrZXlib2FyZEtleSkge1xuICByZXR1cm4ga2V5Ym9hcmRLZXkua2V5ID09PSAnU3BhY2UnIHx8IGtleWJvYXJkS2V5LmtleUNvZGUgPT09IDMyO1xufVxuXG5cbi8qKiBAcmVjb3JkICovXG5jbGFzcyBJY29uVG9nZ2xlU3RhdGUge31cblxuLyoqXG4gKiBUaGUgYXJpYS1sYWJlbCB2YWx1ZSBvZiB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBhcmlhLWxhYmVsLlxuICogQGV4cG9ydCB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuSWNvblRvZ2dsZVN0YXRlLnByb3RvdHlwZS5sYWJlbDtcblxuLyoqXG4gKiBUaGUgdGV4dCBmb3IgdGhlIGljb24gdG9nZ2xlLCBvciB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gdGV4dC5cbiAqIEBleHBvcnQge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbkljb25Ub2dnbGVTdGF0ZS5wcm90b3R5cGUuY29udGVudDtcblxuLyoqXG4gKiBUaGUgQ1NTIGNsYXNzIHRvIGFkZCB0byB0aGUgaWNvbiB0b2dnbGUsIG9yIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBDU1MgY2xhc3MuXG4gKiBAZXhwb3J0IHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5JY29uVG9nZ2xlU3RhdGUucHJvdG90eXBlLmNzc0NsYXNzO1xuXG5leHBvcnQgZGVmYXVsdCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPHNwYW4gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIDpzdHlsZT1cInN0eWxlc1wiIFxuICAgIDp0YWJpbmRleD1cInRhYkluZGV4XCJcbiAgICA6ZGF0YS10b2dnbGUtb249XCJ0b2dnbGVPbkRhdGFcIiBcbiAgICA6ZGF0YS10b2dnbGUtb2ZmPVwidG9nZ2xlT2ZmRGF0YVwiXG4gICAgY2xhc3M9XCJtZGMtaWNvbi10b2dnbGVcIlxuICAgIHJvbGU9XCJidXR0b25cIlxuICAgIGFyaWEtcHJlc3NlZD1cImZhbHNlXCI+XG4gICAgPGkgXG4gICAgICA6Y2xhc3M9XCJpY29uQ2xhc3Nlc1wiIFxuICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3sgdGV4dCB9fTwvaT5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENJY29uVG9nZ2xlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvaWNvbi10b2dnbGUvZm91bmRhdGlvbidcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1pY29uLXRvZ2dsZScsXG4gIHByb3BzOiB7XG4gICAgdG9nZ2xlT246IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgdG9nZ2xlT2ZmOiBbU3RyaW5nLCBPYmplY3RdLFxuICAgIHZhbHVlOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGFjY2VudDogQm9vbGVhblxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtaWNvbi10b2dnbGUtLWFjY2VudCc6IHRoaXMuYWNjZW50XG4gICAgICB9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGljb25DbGFzc2VzOiB7fSxcbiAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgdGV4dDogJydcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgdG9nZ2xlT25EYXRhKCkge1xuICAgICAgbGV0IHRvZ2dsZSA9IHRoaXMudG9nZ2xlT25cbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICBsZXQgdG9nZ2xlID0gdGhpcy50b2dnbGVPZmZcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHRvZ2dsZSAmJlxuICAgICAgICBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICB0eXBlb2YgdG9nZ2xlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29udGVudDogdG9nZ2xlLFxuICAgICAgICAgICAgICAgIGNzc0NsYXNzOiAnbWF0ZXJpYWwtaWNvbnMnXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRvZ2dsZS5pY29uIHx8IHRvZ2dsZS5jb250ZW50LFxuICAgICAgICAgICAgICAgIGxhYmVsOiB0b2dnbGUubGFiZWwsXG4gICAgICAgICAgICAgICAgY3NzQ2xhc3M6IHRvZ2dsZS5pY29uID8gJ21hdGVyaWFsLWljb25zJyA6IHRvZ2dsZS5jc3NDbGFzc1xuICAgICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHZhbHVlKVxuICAgIH0sXG4gICAgZGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0RGlzYWJsZWQoZGlzYWJsZWQpXG4gICAgfSxcbiAgICB0b2dnbGVPbkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIHRvZ2dsZU9mZkRhdGEoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnJlZnJlc2hUb2dnbGVEYXRhKClcbiAgICB9LFxuICAgIGFjY2VudCh2YWx1ZSkge1xuICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgJ21kYy1pY29uLXRvZ2dsZS0tc2Vjb25kYXJ5JywgdmFsdWUpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENJY29uVG9nZ2xlRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmljb25DbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5pY29uQ2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PlxuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciksXG4gICAgICBzZXRUZXh0OiB0ZXh0ID0+IHtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dFxuICAgICAgfSxcbiAgICAgIGdldFRhYkluZGV4OiAoKSA9PiB0aGlzLnRhYkluZGV4LFxuICAgICAgc2V0VGFiSW5kZXg6IHRhYkluZGV4ID0+IHtcbiAgICAgICAgdGhpcy50YWJJbmRleCA9IHRhYkluZGV4XG4gICAgICB9LFxuICAgICAgZ2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5nZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgc2V0QXR0cjogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBybUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6IGV2dERhdGEgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIGV2dERhdGEuaXNPbilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgICB0aGlzLmZvdW5kYXRpb24udG9nZ2xlKHRoaXMudmFsdWUpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMsIHtcbiAgICAgIGlzVW5ib3VuZGVkOiAoKSA9PiB0cnVlLFxuICAgICAgaXNTdXJmYWNlQWN0aXZlOiAoKSA9PiB0aGlzLmZvdW5kYXRpb24uaXNLZXlib2FyZEFjdGl2YXRlZCgpXG4gICAgfSlcbiAgICB0aGlzLnJpcHBsZS5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjSUNvblRvZ2dsZSBmcm9tICcuL21kYy1pY29uLXRvZ2dsZS52dWUnXG5cbmV4cG9ydCB7IG1kY0lDb25Ub2dnbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjSUNvblRvZ2dsZVxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtYXBwLS10b3BhcHBiYXItd3JhcHBlclwiPlxuICAgICAgPHNsb3QgbmFtZT1cInRvcGFwcGJhclwiIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLW1haW4tY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLWxheW91dC1hcHAtLWRyYXdlci13cmFwcGVyXCI+PHNsb3QgbmFtZT1cImRyYXdlclwiIC8+PC9kaXY+XG5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWFwcC0tY29udGVudC13cmFwcGVyXCI+PHNsb3QgLz48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1hcHAnXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xheW91dEFwcCBmcm9tICcuL21kYy1sYXlvdXQtYXBwLnZ1ZSdcblxuZXhwb3J0IHsgbWRjTGF5b3V0QXBwIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY0xheW91dEFwcFxufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1sYXlvdXQtZ3JpZF9faW5uZXJcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1ncmlkJyxcbiAgcHJvcHM6IHtcbiAgICAnZml4ZWQtY29sdW1uLXdpZHRoJzogQm9vbGVhbixcbiAgICAnYWxpZ24tbGVmdCc6IEJvb2xlYW4sXG4gICAgJ2FsaWduLXJpZ2h0JzogQm9vbGVhblxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxheW91dC1ncmlkJzogdHJ1ZSxcbiAgICAgICAgJ21kYy1sYXlvdXQtZ3JpZC0tZml4ZWQtY29sdW1uLXdpZHRoJzogdGhpcy5maXhlZENvbHVtbldpZHRoLFxuICAgICAgICAnbWRjLWxheW91dC1ncmlkLS1hbGlnbi1sZWZ0JzogdGhpcy5hbGlnbkxlZnQsXG4gICAgICAgICdtZGMtbGF5b3V0LWdyaWQtLWFsaWduLXJpZ2h0JzogdGhpcy5hbGlnblJpZ2h0XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgY2xhc3M9XCJtZGMtbGF5b3V0LWNlbGwgbWRjLWxheW91dC1ncmlkX19jZWxsXCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5jb25zdCBzcGFuT3B0aW9ucyA9IHtcbiAgdHlwZTogW1N0cmluZywgTnVtYmVyXSxcbiAgZGVmYXVsdDogbnVsbCxcbiAgdmFsaWRhdG9yOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHZhciBudW0gPSBOdW1iZXIodmFsdWUpXG4gICAgcmV0dXJuIGlzRmluaXRlKG51bSkgJiYgbnVtIDw9IDEyICYmIG51bSA+IDBcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGF5b3V0LWNlbGwnLFxuICBwcm9wczoge1xuICAgIHNwYW46IHNwYW5PcHRpb25zLFxuICAgIG9yZGVyOiBzcGFuT3B0aW9ucyxcbiAgICBwaG9uZTogc3Bhbk9wdGlvbnMsXG4gICAgdGFibGV0OiBzcGFuT3B0aW9ucyxcbiAgICBkZXNrdG9wOiBzcGFuT3B0aW9ucyxcbiAgICBhbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsaWRhdG9yOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJywgJ21pZGRsZSddLmluZGV4T2YodmFsdWUpICE9PSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgbGV0IGNsYXNzZXMgPSBbXVxuXG4gICAgICBpZiAodGhpcy5zcGFuKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5zcGFufWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9yZGVyKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1vcmRlci0ke3RoaXMub3JkZXJ9YClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucGhvbmUpIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLXNwYW4tJHt0aGlzLnBob25lfS1waG9uZWApXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnRhYmxldCkge1xuICAgICAgICBjbGFzc2VzLnB1c2goYG1kYy1sYXlvdXQtZ3JpZF9fY2VsbC0tc3Bhbi0ke3RoaXMudGFibGV0fS10YWJsZXRgKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kZXNrdG9wKSB7XG4gICAgICAgIGNsYXNzZXMucHVzaChgbWRjLWxheW91dC1ncmlkX19jZWxsLS1zcGFuLSR7dGhpcy5kZXNrdG9wfS1kZXNrdG9wYClcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYWxpZ24pIHtcbiAgICAgICAgY2xhc3Nlcy5wdXNoKGBtZGMtbGF5b3V0LWdyaWRfX2NlbGwtLWFsaWduLSR7dGhpcy5hbGlnbn1gKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xhc3Nlc1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtbGF5b3V0LWlubmVyLWdyaWQgbWRjLWxheW91dC1ncmlkX19pbm5lclwiPlxuICAgIDxzbG90Lz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxheW91dC1pbm5lci1ncmlkJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMYXlvdXRHcmlkIGZyb20gJy4vbWRjLWxheW91dC1ncmlkLnZ1ZSdcbmltcG9ydCBtZGNMYXlvdXRDZWxsIGZyb20gJy4vbWRjLWxheW91dC1jZWxsLnZ1ZSdcbmltcG9ydCBtZGNMYXlvdXRJbm5lckdyaWQgZnJvbSAnLi9tZGMtbGF5b3V0LWlubmVyLWdyaWQudnVlJ1xuXG5leHBvcnQgeyBtZGNMYXlvdXRHcmlkLCBtZGNMYXlvdXRDZWxsLCBtZGNMYXlvdXRJbm5lckdyaWQgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGF5b3V0R3JpZCxcbiAgbWRjTGF5b3V0Q2VsbCxcbiAgbWRjTGF5b3V0SW5uZXJHcmlkXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBDTE9TRURfQ0xBU1M6ICdtZGMtbGluZWFyLXByb2dyZXNzLS1jbG9zZWQnLFxuICBJTkRFVEVSTUlOQVRFX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0taW5kZXRlcm1pbmF0ZScsXG4gIFJFVkVSU0VEX0NMQVNTOiAnbWRjLWxpbmVhci1wcm9ncmVzcy0tcmV2ZXJzZWQnLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIFBSSU1BUllfQkFSX1NFTEVDVE9SOiAnLm1kYy1saW5lYXItcHJvZ3Jlc3NfX3ByaW1hcnktYmFyJyxcbiAgQlVGRkVSX1NFTEVDVE9SOiAnLm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcicsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHt0cmFuc2Zvcm1TdHlsZVByb3BlcnRpZXN9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0UHJpbWFyeUJhcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge30sXG4gICAgICBnZXRCdWZmZXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHt9LFxuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gZmFsc2UsXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoLyogZWw6IEVsZW1lbnQsIHN0eWxlUHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmRldGVybWluYXRlXyA9ICF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSU5ERVRFUk1JTkFURV9DTEFTUyk7XG4gICAgdGhpcy5yZXZlcnNlXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgdGhpcy5wcm9ncmVzc18gPSAwO1xuICB9XG5cbiAgc2V0RGV0ZXJtaW5hdGUoaXNEZXRlcm1pbmF0ZSkge1xuICAgIHRoaXMuZGV0ZXJtaW5hdGVfID0gaXNEZXRlcm1pbmF0ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB0aGlzLnByb2dyZXNzXyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5JTkRFVEVSTUlOQVRFX0NMQVNTKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCAxKTtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0QnVmZmVyKCksIDEpO1xuICAgIH1cbiAgfVxuXG4gIHNldFByb2dyZXNzKHZhbHVlKSB7XG4gICAgdGhpcy5wcm9ncmVzc18gPSB2YWx1ZTtcbiAgICBpZiAodGhpcy5kZXRlcm1pbmF0ZV8pIHtcbiAgICAgIHRoaXMuc2V0U2NhbGVfKHRoaXMuYWRhcHRlcl8uZ2V0UHJpbWFyeUJhcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0QnVmZmVyKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGV0ZXJtaW5hdGVfKSB7XG4gICAgICB0aGlzLnNldFNjYWxlXyh0aGlzLmFkYXB0ZXJfLmdldEJ1ZmZlcigpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgc2V0UmV2ZXJzZShpc1JldmVyc2VkKSB7XG4gICAgdGhpcy5yZXZlcnNlXyA9IGlzUmV2ZXJzZWQ7XG4gICAgaWYgKHRoaXMucmV2ZXJzZV8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5SRVZFUlNFRF9DTEFTUyk7XG4gICAgfVxuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuQ0xPU0VEX0NMQVNTKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TRURfQ0xBU1MpO1xuICB9XG5cbiAgc2V0U2NhbGVfKGVsLCBzY2FsZVZhbHVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSAnc2NhbGVYKCcgKyBzY2FsZVZhbHVlICsgJyknO1xuICAgIHRyYW5zZm9ybVN0eWxlUHJvcGVydGllcy5mb3JFYWNoKCh0cmFuc2Zvcm1TdHlsZVByb3BlcnR5KSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKGVsLCB0cmFuc2Zvcm1TdHlsZVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgOnN0eWxlPVwic3R5bGVzXCIgXG4gICAgcm9sZT1cInByb2dyZXNzYmFyXCIgXG4gICAgY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2J1ZmZlcmluZy1kb3RzXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJidWZmZXJcIiBcbiAgICAgIGNsYXNzPVwibWRjLWxpbmVhci1wcm9ncmVzc19fYnVmZmVyXCIvPlxuICAgIDxkaXYgXG4gICAgICByZWY9XCJwcmltYXJ5XCIgXG4gICAgICBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19wcmltYXJ5LWJhclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGluZWFyLXByb2dyZXNzX19iYXItaW5uZXJcIi8+XG4gICAgPC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2JhciBtZGMtbGluZWFyLXByb2dyZXNzX19zZWNvbmRhcnktYmFyXCI+XG4gICAgICA8c3BhbiBjbGFzcz1cIm1kYy1saW5lYXItcHJvZ3Jlc3NfX2Jhci1pbm5lclwiLz5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+ICBcbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saW5lYXItcHJvZ3Jlc3MvZm91bmRhdGlvbidcblxuY29uc3QgUHJvZ3Jlc3NQcm9wVHlwZSA9IHtcbiAgdHlwZTogW051bWJlciwgU3RyaW5nXSxcbiAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgcmV0dXJuIE51bWJlcih2YWx1ZSkgPj0gMCAmJiBOdW1iZXIodmFsdWUpIDw9IDFcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGluZWFyLXByb2dyZXNzJyxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfSxcbiAgICBpbmRldGVybWluYXRlOiBCb29sZWFuLFxuICAgIHJldmVyc2U6IEJvb2xlYW4sXG4gICAgYWNjZW50OiBCb29sZWFuLFxuICAgIHByb2dyZXNzOiBQcm9ncmVzc1Byb3BUeXBlLFxuICAgIGJ1ZmZlcjogUHJvZ3Jlc3NQcm9wVHlwZVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7ICdtZGMtbGluZWFyLXByb2dyZXNzLS1hY2NlbnQnOiB0aGlzLmFjY2VudCB9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgaWYgKHRoaXMub3Blbikge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgcHJvZ3Jlc3MoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIH0sXG4gICAgYnVmZmVyKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEJ1ZmZlcihOdW1iZXIodGhpcy5idWZmZXIpKVxuICAgIH0sXG4gICAgaW5kZXRlcm1pbmF0ZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXREZXRlcm1pbmF0ZSghdGhpcy5pbmRldGVybWluYXRlKVxuICAgIH0sXG4gICAgcmV2ZXJzZSgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpbmVhclByb2dyZXNzRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIGdldFByaW1hcnlCYXI6ICgpID0+IC8qIGVsOiBFbGVtZW50ICovIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucHJpbWFyeVxuICAgICAgfSxcbiAgICAgIGdldEJ1ZmZlcjogKCkgPT4gLyogZWw6IEVsZW1lbnQgKi8ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5idWZmZXJcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlOiAoZWwsIHN0eWxlUHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGVsLnN0eWxlW3N0eWxlUHJvcGVydHldID0gdmFsdWVcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRSZXZlcnNlKHRoaXMucmV2ZXJzZSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0UHJvZ3Jlc3MoTnVtYmVyKHRoaXMucHJvZ3Jlc3MpKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRCdWZmZXIoTnVtYmVyKHRoaXMuYnVmZmVyKSlcbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0RGV0ZXJtaW5hdGUoIXRoaXMuaW5kZXRlcm1pbmF0ZSlcbiAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24ub3BlbigpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbi5kZXN0cm95KClcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNMaW5lYXJQcm9ncmVzcyBmcm9tICcuL21kYy1saW5lYXItcHJvZ3Jlc3MudnVlJ1xuXG5leHBvcnQgeyBtZGNMaW5lYXJQcm9ncmVzcyB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNMaW5lYXJQcm9ncmVzc1xufSlcbiIsIjx0ZW1wbGF0ZT5cbiAgPHVsXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgY2xhc3M9XCJtZGMtbGlzdFwiXG4gICAgOmFyaWEtb3JpZW50YXRpb249XCJvcmllbnRhdGlvblwiXG4gICAgQGNsaWNrPVwiaGFuZGxlQ2xpY2tFdmVudFwiXG4gICAgQGtleWRvd249XCJoYW5kbGVLZXlkb3duRXZlbnRcIlxuICAgIEBmb2N1c2luPVwiaGFuZGxlRm9jdXNJbkV2ZW50XCJcbiAgICBAZm9jdXNvdXQ9XCJoYW5kbGVGb2N1c091dEV2ZW50XCJcbiAgPlxuICAgIDxzbG90IC8+XG4gIDwvdWw+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0xpc3RGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9saXN0L2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBtYXRjaGVzIH0gZnJvbSAnQG1hdGVyaWFsL2RvbS9wb255ZmlsbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QnLFxuICBwcm9wczoge1xuICAgIGRlbnNlOiBCb29sZWFuLFxuICAgIGF2YXRhckxpc3Q6IEJvb2xlYW4sXG4gICAgdHdvTGluZTogQm9vbGVhbixcbiAgICBib3JkZXJlZDogQm9vbGVhbixcbiAgICBpbnRlcmFjdGl2ZTogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH0sXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBCb29sZWFuLFxuICAgIHZlcnRpY2FsOiB7IHR5cGU6IEJvb2xlYW4sIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICBwcm92aWRlKCkge1xuICAgIHJldHVybiB7IG1kY0xpc3Q6IHRoaXMgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLWxpc3QtLWRlbnNlJzogdGhpcy5kZW5zZSxcbiAgICAgICAgJ21kYy1saXN0LS1hdmF0YXItbGlzdCc6IHRoaXMuYXZhdGFyTGlzdCxcbiAgICAgICAgJ21kYy1saXN0LS10d28tbGluZSc6IHRoaXMudHdvTGluZSxcbiAgICAgICAgJ21kYy1saXN0LS1ib3JkZXJlZCc6IHRoaXMuYm9yZGVyZWQsXG4gICAgICAgICdtZGMtbGlzdC0tbm9uLWludGVyYWN0aXZlJzogIXRoaXMuaW50ZXJhY3RpdmVcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgb3JpZW50YXRpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNhbCA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCdcbiAgICB9LFxuXG4gICAgbGlzdEVsZW1lbnRzKCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoXG4gICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgTURDTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5FTkFCTEVEX0lURU1TX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVGb2N1c0luRXZlbnQoZXZ0KSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0TGlzdEl0ZW1JbmRleChldnQpXG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlRm9jdXNJbihldnQsIGluZGV4KVxuICAgIH0sXG4gICAgaGFuZGxlRm9jdXNPdXRFdmVudChldnQpIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5nZXRMaXN0SXRlbUluZGV4KGV2dClcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVGb2N1c091dChldnQsIGluZGV4KVxuICAgIH0sXG5cbiAgICBoYW5kbGVLZXlkb3duRXZlbnQoZXZ0KSB7XG4gICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0TGlzdEl0ZW1JbmRleChldnQpXG5cbiAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVLZXlkb3duKFxuICAgICAgICAgIGV2dCxcbiAgICAgICAgICBldnQudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcbiAgICAgICAgICAgIE1EQ0xpc3RGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTElTVF9JVEVNX0NMQVNTXG4gICAgICAgICAgKSxcbiAgICAgICAgICBpbmRleFxuICAgICAgICApXG4gICAgICB9XG4gICAgfSxcbiAgICBoYW5kbGVDbGlja0V2ZW50KGV2dCkge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldExpc3RJdGVtSW5kZXgoZXZ0KVxuXG4gICAgICAvLyBUb2dnbGUgdGhlIGNoZWNrYm94IG9ubHkgaWYgaXQncyBub3QgdGhlIHRhcmdldCBvZiB0aGUgZXZlbnQsIG9yIHRoZSBjaGVja2JveCB3aWxsIGhhdmUgMiBjaGFuZ2UgZXZlbnRzLlxuICAgICAgY29uc3QgdG9nZ2xlQ2hlY2tib3ggPSAhbWF0Y2hlcyhcbiAgICAgICAgZXZ0LnRhcmdldCxcbiAgICAgICAgTURDTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5DSEVDS0JPWF9SQURJT19TRUxFQ1RPUlxuICAgICAgKVxuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNsaWNrKGluZGV4LCB0b2dnbGVDaGVja2JveClcbiAgICB9LFxuXG4gICAgbGF5b3V0KCkge1xuICAgICAgLy8gTGlzdCBpdGVtcyBuZWVkIHRvIGhhdmUgYXQgbGVhc3QgdGFiaW5kZXg9LTEgdG8gYmUgZm9jdXNhYmxlLlxuICAgICAgO1tdLnNsaWNlXG4gICAgICAgIC5jYWxsKHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoJy5tZGMtbGlzdC1pdGVtOm5vdChbdGFiaW5kZXhdKScpKVxuICAgICAgICAuZm9yRWFjaChlbGUgPT4ge1xuICAgICAgICAgIGVsZS5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICAgIH0pXG5cbiAgICAgIC8vIENoaWxkIGJ1dHRvbi9hIGVsZW1lbnRzIGFyZSBub3QgdGFiYmFibGUgdW50aWwgdGhlIGxpc3QgaXRlbSBpcyBmb2N1c2VkLlxuICAgICAgO1tdLnNsaWNlXG4gICAgICAgIC5jYWxsKFxuICAgICAgICAgIHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAgICAgICBNRENMaXN0Rm91bmRhdGlvbi5zdHJpbmdzLkZPQ1VTQUJMRV9DSElMRF9FTEVNRU5UU1xuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAuZm9yRWFjaChlbGUgPT4gZWxlLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAtMSkpXG4gICAgfSxcblxuICAgIGluaXRpYWxpemVMaXN0VHlwZSgpIHtcbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgc2V0IHNpbmdsZSBzZWxlY3Rpb24gaWYgc2VsZWN0ZWQvYWN0aXZhdGVkIGNsYXNzZXMgYXJlIHByZXNlbnQuXG4gICAgICBjb25zdCBwcmVzZWxlY3RlZEVsZW1lbnQgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBgLiR7TURDTGlzdEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5MSVNUX0lURU1fQUNUSVZBVEVEX0NMQVNTfSwgLiR7XG4gICAgICAgICAgTURDTGlzdEZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5MSVNUX0lURU1fU0VMRUNURURfQ0xBU1NcbiAgICAgICAgfWBcbiAgICAgIClcblxuICAgICAgaWYgKHByZXNlbGVjdGVkRWxlbWVudCkge1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcHJlc2VsZWN0ZWRFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhcbiAgICAgICAgICAgIE1EQ0xpc3RGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTElTVF9JVEVNX0FDVElWQVRFRF9DTEFTU1xuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFVzZUFjdGl2YXRlZENsYXNzKHRydWUpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNpbmdsZVNlbGVjdGlvbiA9IHRydWVcbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4ID0gdGhpcy5saXN0RWxlbWVudHMuaW5kZXhPZihwcmVzZWxlY3RlZEVsZW1lbnQpXG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldExpc3RJdGVtSW5kZXgoZXZ0KSB7XG4gICAgICBsZXQgZXZlbnRUYXJnZXQgPSBldnQudGFyZ2V0XG4gICAgICBsZXQgaW5kZXggPSAtMVxuXG4gICAgICAvLyBGaW5kIHRoZSBmaXJzdCBhbmNlc3RvciB0aGF0IGlzIGEgbGlzdCBpdGVtIG9yIHRoZSBsaXN0LlxuICAgICAgd2hpbGUgKFxuICAgICAgICAhZXZlbnRUYXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKFxuICAgICAgICAgIE1EQ0xpc3RGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTElTVF9JVEVNX0NMQVNTXG4gICAgICAgICkgJiZcbiAgICAgICAgIWV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhNRENMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldC5wYXJlbnRFbGVtZW50XG4gICAgICB9XG5cbiAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgaWYgaXQgaXMgYSBsaXN0IGl0ZW0uXG4gICAgICBpZiAoXG4gICAgICAgIGV2ZW50VGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcbiAgICAgICAgICBNRENMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkxJU1RfSVRFTV9DTEFTU1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLmxpc3RFbGVtZW50cy5pbmRleE9mKGV2ZW50VGFyZ2V0KVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5kZXhcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ0xpc3RGb3VuZGF0aW9uKHtcbiAgICAgIGdldExpc3RJdGVtQ291bnQ6ICgpID0+IHRoaXMubGlzdEVsZW1lbnRzLmxlbmd0aCxcbiAgICAgIGdldEZvY3VzZWRFbGVtZW50SW5kZXg6ICgpID0+XG4gICAgICAgIHRoaXMubGlzdEVsZW1lbnRzLmluZGV4T2YoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCksXG4gICAgICBzZXRBdHRyaWJ1dGVGb3JFbGVtZW50SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVtb3ZlQXR0cmlidXRlRm9yRWxlbWVudEluZGV4OiAoaW5kZXgsIGF0dHIpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHIpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBhZGRDbGFzc0ZvckVsZW1lbnRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzc0ZvckVsZW1lbnRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2luZGV4XVxuICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmb2N1c0l0ZW1BdEluZGV4OiBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmxpc3RFbGVtZW50c1tpbmRleF1cbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmZvY3VzKClcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNldFRhYkluZGV4Rm9yTGlzdEl0ZW1DaGlsZHJlbjogKGxpc3RJdGVtSW5kZXgsIHRhYkluZGV4VmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMubGlzdEVsZW1lbnRzW2xpc3RJdGVtSW5kZXhdXG4gICAgICAgIGNvbnN0IGxpc3RJdGVtQ2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKFxuICAgICAgICAgIGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICAgIE1EQ0xpc3RGb3VuZGF0aW9uLnN0cmluZ3MuQ0hJTERfRUxFTUVOVFNfVE9fVE9HR0xFX1RBQklOREVYXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICAgIGxpc3RJdGVtQ2hpbGRyZW4uZm9yRWFjaChlbGUgPT5cbiAgICAgICAgICBlbGUuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRhYkluZGV4VmFsdWUpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBmb2xsb3dIcmVmOiBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdXG4gICAgICAgIGlmIChsaXN0SXRlbSAmJiBsaXN0SXRlbS5ocmVmKSB7XG4gICAgICAgICAgbGlzdEl0ZW0uY2xpY2soKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzQ2hlY2tib3hBdEluZGV4OiBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdXG4gICAgICAgIHJldHVybiAhIWxpc3RJdGVtLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5DSEVDS0JPWF9TRUxFQ1RPUlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgaGFzUmFkaW9BdEluZGV4OiBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdXG4gICAgICAgIHJldHVybiAhIWxpc3RJdGVtLnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDTGlzdEZvdW5kYXRpb24uc3RyaW5ncy5SQURJT19TRUxFQ1RPUlxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgaXNDaGVja2JveENoZWNrZWRBdEluZGV4OiBpbmRleCA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5saXN0RWxlbWVudHNbaW5kZXhdXG4gICAgICAgIGNvbnN0IHRvZ2dsZUVsID0gbGlzdEl0ZW0ucXVlcnlTZWxlY3RvcihcbiAgICAgICAgICBNRENMaXN0Rm91bmRhdGlvbi5zdHJpbmdzLkNIRUNLQk9YX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIHRvZ2dsZUVsLmNoZWNrZWRcbiAgICAgIH0sXG4gICAgICBzZXRDaGVja2VkQ2hlY2tib3hPclJhZGlvQXRJbmRleDogKGluZGV4LCBpc0NoZWNrZWQpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSB0aGlzLmxpc3RFbGVtZW50c1tpbmRleF1cbiAgICAgICAgY29uc3QgdG9nZ2xlRWwgPSBsaXN0SXRlbS5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIE1EQ0xpc3RGb3VuZGF0aW9uLnN0cmluZ3MuQ0hFQ0tCT1hfUkFESU9fU0VMRUNUT1JcbiAgICAgICAgKVxuICAgICAgICB0b2dnbGVFbC5jaGVja2VkID0gaXNDaGVja2VkXG5cbiAgICAgICAgY29uc3QgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKVxuICAgICAgICBldmVudC5pbml0RXZlbnQoJ2NoYW5nZScsIHRydWUsIHRydWUpXG4gICAgICAgIHRvZ2dsZUVsLmRpc3BhdGNoRXZlbnQoZXZlbnQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTaW5nbGVTZWxlY3Rpb24odGhpcy5zaW5nbGVTZWxlY3Rpb24pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmVydGljYWxPcmllbnRhdGlvbih0aGlzLnZlcnRpY2FsKVxuXG4gICAgdGhpcy5sYXlvdXQoKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGxpXG4gICAgOmNsYXNzPVwiW2NsYXNzZXMsIGl0ZW1DbGFzc2VzXVwiXG4gICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICA6dGFiaW5kZXg9XCJpc0ludGVyYWN0aXZlID8gJzAnIDogdW5kZWZpbmVkXCJcbiAgICBjbGFzcz1cIm1kYy1saXN0LWl0ZW1cIlxuICAgIHYtb249XCJpc0ludGVyYWN0aXZlID8gJGxpc3RlbmVycyA6IHt9XCJcbiAgPlxuICAgIDwhLS0gPHNwYW4gdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCIgY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19ncmFwaGljXCI+IC0tPlxuICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIiAvPlxuICAgIDwhLS0gPC9zcGFuPiAtLT5cblxuICAgIDxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fdGV4dFwiIHYtaWY9XCJoYXNTZWNvbmRhcnlcIlxuICAgICAgPjxzcGFuIGNsYXNzPVwibWRjLWxpc3QtaXRlbV9fcHJpbWFyeS10ZXh0XCI+IDxzbG90IC8+PC9zcGFuPlxuICAgICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19zZWNvbmRhcnktdGV4dFwiIHYtaWY9XCJoYXNTZWNvbmRhcnlcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cInNlY29uZGFyeVwiIC8+XG4gICAgICA8L3NwYW4+XG4gICAgPC9zcGFuPlxuXG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX190ZXh0XCIgdi1lbHNlPiA8c2xvdCAvPiA8L3NwYW4+XG5cbiAgICA8IS0tIDxzcGFuIHYtaWY9XCJoYXNFbmREZXRhaWxcIiBjbGFzcz1cIm1kYy1saXN0LWl0ZW1fX21ldGFcIj4gLS0+XG4gICAgPHNsb3QgbmFtZT1cImVuZC1kZXRhaWxcIiAvPlxuICAgIDwhLS0gPC9zcGFuPiAtLT5cbiAgPC9saT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1pdGVtJyxcbiAgaW5qZWN0OiBbJ21kY0xpc3QnXSxcbiAgcHJvcHM6IHtcbiAgICBzZWxlY3RlZDogQm9vbGVhbixcbiAgICBhY3RpdmF0ZWQ6IEJvb2xlYW5cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgICBzdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGl0ZW1DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJzogdGhpcy5zZWxlY3RlZCxcbiAgICAgICAgJ21kYy1saXN0LWl0ZW0tLWFjdGl2YXRlZCc6IHRoaXMuYWN0aXZhdGVkXG4gICAgICB9XG4gICAgfSxcbiAgICBpc0ludGVyYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QuaW50ZXJhY3RpdmVcbiAgICB9LFxuICAgIGhhc1NlY29uZGFyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLiRzbG90c1snc2Vjb25kYXJ5J10gJiYgKHRoaXMubWRjTGlzdCAmJiB0aGlzLm1kY0xpc3QudHdvTGluZSlcbiAgICB9LFxuICAgIGhhc0VuZERldGFpbCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuJHNsb3RzWydlbmQtZGV0YWlsJ11cbiAgICB9LFxuICAgIGhhc1N0YXJ0RGV0YWlsKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy4kc2xvdHNbJ3N0YXJ0LWRldGFpbCddXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGlzSW50ZXJhY3RpdmUodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB0aGlzLmFkZFJpcHBsZSgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZSgpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuaXNJbnRlcmFjdGl2ZSAmJiB0aGlzLmFkZFJpcHBsZSgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yZW1vdmVSaXBwbGUoKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgYWRkUmlwcGxlKCkge1xuICAgICAgaWYgKCF0aGlzLnJpcHBsZSkge1xuICAgICAgICBsZXQgcmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgICAgcmlwcGxlLmluaXQoKVxuICAgICAgICB0aGlzLnJpcHBsZSA9IHJpcHBsZVxuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmlwcGxlKCkge1xuICAgICAgaWYgKHRoaXMucmlwcGxlKSB7XG4gICAgICAgIGxldCByaXBwbGUgPSB0aGlzLnJpcHBsZVxuICAgICAgICB0aGlzLnJpcHBsZSA9IG51bGxcbiAgICAgICAgcmlwcGxlLmRlc3Ryb3koKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaSBcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCIgXG4gICAgcm9sZT1cInNlcGFyYXRvclwiIFxuICAgIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiLz5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbGlzdC1kaXZpZGVyJyxcbiAgcHJvcHM6IHtcbiAgICBpbnNldDogQm9vbGVhbixcbiAgICBwYWRkZWQ6IEJvb2xlYW5cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBjbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLWluc2V0JzogdGhpcy5pbnNldCxcbiAgICAgICAgJ21kYy1saXN0LWRpdmlkZXItLXBhZGRlZCc6IHRoaXMucGFkZGVkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1saXN0LWdyb3VwXCI+PHNsb3QvPjwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxoMyBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWhlYWRlciBtZGMtbGlzdC1ncm91cF9fc3ViaGVhZGVyXCI+PHNsb3QvPjwvaDM+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLWxpc3QtZ3JvdXAtaGVhZGVyJ1xufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxociBjbGFzcz1cIm1kYy1saXN0LWdyb3VwLWRpdmlkZXIgbWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1saXN0LWdyb3VwLWRpdmlkZXInXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY0xpc3QgZnJvbSAnLi9tZGMtbGlzdC52dWUnXG5pbXBvcnQgbWRjTGlzdEl0ZW0gZnJvbSAnLi9tZGMtbGlzdC1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNMaXN0RGl2aWRlciBmcm9tICcuL21kYy1saXN0LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cCBmcm9tICcuL21kYy1saXN0LWdyb3VwLnZ1ZSdcbmltcG9ydCBtZGNMaXN0R3JvdXBIZWFkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0xpc3RHcm91cERpdmlkZXIgZnJvbSAnLi9tZGMtbGlzdC1ncm91cC1kaXZpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTGlzdCxcbiAgbWRjTGlzdEl0ZW0sXG4gIG1kY0xpc3REaXZpZGVyLFxuICBtZGNMaXN0R3JvdXAsXG4gIG1kY0xpc3RHcm91cEhlYWRlcixcbiAgbWRjTGlzdEdyb3VwRGl2aWRlclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgTWVudS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBzZWxlY3RlZCBlbGVtZW50IGNsYXNzZXNcbiAqIC0gZ2V0IGZvY3VzZWQgZWxlbWVudHNcbiAqIC0gdG9nZ2xpbmcgYSBjaGVja2JveCBpbnNpZGUgYSBsaXN0IGl0ZW1cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ01lbnVBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgZWxlbWVudCBhdCB0aGUgaW5kZXggcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzc1RvRWxlbWVudEF0SW5kZXgoaW5kZXgsIGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGVsZW1lbnQgYXQgdGhlIGluZGV4IHByb3ZpZGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzc0Zyb21FbGVtZW50QXRJbmRleChpbmRleCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGF0dHJpYnV0ZSwgd2l0aCB2YWx1ZSwgdG8gdGhlIGVsZW1lbnQgYXQgdGhlIGluZGV4IHByb3ZpZGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBhZGRBdHRyaWJ1dGVUb0VsZW1lbnRBdEluZGV4KGluZGV4LCBhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSBhbiBlbGVtZW50IGF0IHRoZSBpbmRleCBwcm92aWRlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGVGcm9tRWxlbWVudEF0SW5kZXgoaW5kZXgsIGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBjb250YWlucyB0aGUgY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVsZW1lbnQgY29udGFpbnMgdGhlIGNsYXNzTmFtZVxuICAgKi9cbiAgZWxlbWVudENvbnRhaW5zQ2xhc3MoZWxlbWVudCwgY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1lbnUtc3VyZmFjZS5cbiAgICovXG4gIGNsb3NlU3VyZmFjZSgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IGZvciB0aGUgZWxlbWVudCBwcm92aWRlZC5cbiAgICogQHBhcmFtIHs/SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmRleCBvZiB0aGUgZWxlbWVudCBpbiB0aGUgbGlzdCBvciAtMSBpZiBpdCBpcyBub3QgaW4gdGhlIGxpc3QuXG4gICAqL1xuICBnZXRFbGVtZW50SW5kZXgoZWxlbWVudCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50RWxlbWVudCBvZiB0aGUgcHJvdmlkZWQgZWxlbWVudC5cbiAgICogQHBhcmFtIHs/SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7P0hUTUxFbGVtZW50fSBwYXJlbnRFbGVtZW50IG9mIHRoZSBlbGVtZW50IHByb3ZpZGVkLlxuICAgKi9cbiAgZ2V0UGFyZW50RWxlbWVudChlbGVtZW50KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBlbGVtZW50IHdpdGhpbiB0aGUgc2VsZWN0aW9uR3JvdXAgY29udGFpbmluZyB0aGUgc2VsZWN0ZWQgZWxlbWVudCBjbGFzcy5cbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHNlbGVjdGlvbkdyb3VwXG4gICAqIEByZXR1cm4ge251bWJlcn0gZWxlbWVudCB3aXRoaW4gdGhlIHNlbGVjdGlvbkdyb3VwIHRoYXQgY29udGFpbnMgdGhlIHNlbGVjdGVkIGVsZW1lbnQgY2xhc3MuXG4gICAqL1xuICBnZXRTZWxlY3RlZEVsZW1lbnRJbmRleChzZWxlY3Rpb25Hcm91cCkge31cblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgdXNpbmcgdGhlIGV2dERhdGEuXG4gICAqIEBwYXJhbSB7e1xuICogICAgaW5kZXg6IG51bWJlclxuICogICB9fSBldnREYXRhXG4gICAqL1xuICBub3RpZnlTZWxlY3RlZChldnREYXRhKSB7fVxufVxuXG5leHBvcnQge01EQ01lbnVBZGFwdGVyfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIFJPT1Q6ICdtZGMtbWVudScsXG4gIE1FTlVfU0VMRUNURURfTElTVF9JVEVNOiAnbWRjLW1lbnUtaXRlbS0tc2VsZWN0ZWQnLFxuICBNRU5VX1NFTEVDVElPTl9HUk9VUDogJ21kYy1tZW51X19zZWxlY3Rpb24tZ3JvdXAnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBTRUxFQ1RFRF9FVkVOVDogJ01EQ01lbnU6c2VsZWN0ZWQnLFxuICBBUklBX1NFTEVDVEVEX0FUVFI6ICdhcmlhLXNlbGVjdGVkJyxcbiAgTElTVF9TRUxFQ1RPUjogJy5tZGMtbGlzdCcsXG4gIENIRUNLQk9YX1NFTEVDVE9SOiAnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDTWVudVN1cmZhY2UuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZm9jdXNcbiAqIC0gcG9zaXRpb25cbiAqIC0gZGltZW5zaW9uc1xuICogLSBldmVudCBoYW5kbGVyc1xuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDTWVudVN1cmZhY2VBZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBoYXNBbmNob3IoKSB7fVxuXG4gIC8qKiBFbWl0cyBhbiBldmVudCB3aGVuIHRoZSBtZW51IHN1cmZhY2UgaXMgY2xvc2VkLiAqL1xuICBub3RpZnlDbG9zZSgpIHt9XG5cbiAgLyoqIEVtaXRzIGFuIGV2ZW50IHdoZW4gdGhlIG1lbnUgc3VyZmFjZSBpcyBvcGVuZWQuICovXG4gIG5vdGlmeU9wZW4oKSB7fVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICAgKi9cbiAgaXNFbGVtZW50SW5Db250YWluZXIoZWwpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzUnRsKCkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IG9yaWdpbiAqL1xuICBzZXRUcmFuc2Zvcm1PcmlnaW4ob3JpZ2luKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuICBpc0ZvY3VzZWQoKSB7fVxuXG4gIC8qKiBTYXZlcyB0aGUgZWxlbWVudCB0aGF0IHdhcyBmb2N1c2VkIGJlZm9yZSB0aGUgbWVudSBzdXJmYWNlIHdhcyBvcGVuZWQuICovXG4gIHNhdmVGb2N1cygpIHt9XG5cbiAgLyoqIFJlc3RvcmVzIGZvY3VzIHRvIHRoZSBlbGVtZW50IHRoYXQgd2FzIGZvY3VzZWQgYmVmb3JlIHRoZSBtZW51IHN1cmZhY2Ugd2FzIG9wZW5lZC4gKi9cbiAgcmVzdG9yZUZvY3VzKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNGaXJzdEVsZW1lbnRGb2N1c2VkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNMYXN0RWxlbWVudEZvY3VzZWQoKSB7fVxuXG4gIC8qKiBGb2N1c2VzIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBpbiB0aGUgbWVudS1zdXJmYWNlLiAqL1xuICBmb2N1c0ZpcnN0RWxlbWVudCgpIHt9XG5cbiAgLyoqIEZvY3VzZXMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGluIHRoZSBtZW51LXN1cmZhY2UuICovXG4gIGZvY3VzTGFzdEVsZW1lbnQoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHshe3dpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyfX0gKi9cbiAgZ2V0SW5uZXJEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7IXt3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciwgdG9wOiBudW1iZXIsIHJpZ2h0OiBudW1iZXIsIGJvdHRvbTogbnVtYmVyLCBsZWZ0OiBudW1iZXJ9fSAqL1xuICBnZXRBbmNob3JEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7IXsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0V2luZG93RGltZW5zaW9ucygpIHt9XG5cbiAgLyoqIEByZXR1cm4geyF7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gIGdldEJvZHlEaW1lbnNpb25zKCkge31cblxuICAvKiogQHJldHVybiB7IXsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfX0gKi9cbiAgZ2V0V2luZG93U2Nyb2xsKCkge31cblxuICAvKiogQHBhcmFtIHshe1xuICAqICAgdG9wOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICByaWdodDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAqICAgYm90dG9tOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICogICBsZWZ0OiAoc3RyaW5nfHVuZGVmaW5lZClcbiAgKiB9fSBwb3NpdGlvbiAqL1xuICBzZXRQb3NpdGlvbihwb3NpdGlvbikge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGhlaWdodCAqL1xuICBzZXRNYXhIZWlnaHQoaGVpZ2h0KSB7fVxufVxuXG5leHBvcnQge01EQ01lbnVTdXJmYWNlQWRhcHRlcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBBTkNIT1I6ICdtZGMtbWVudS1zdXJmYWNlLS1hbmNob3InLFxuICBBTklNQVRJTkdfQ0xPU0VEOiAnbWRjLW1lbnUtc3VyZmFjZS0tYW5pbWF0aW5nLWNsb3NlZCcsXG4gIEFOSU1BVElOR19PUEVOOiAnbWRjLW1lbnUtc3VyZmFjZS0tYW5pbWF0aW5nLW9wZW4nLFxuICBGSVhFRDogJ21kYy1tZW51LXN1cmZhY2UtLWZpeGVkJyxcbiAgT1BFTjogJ21kYy1tZW51LXN1cmZhY2UtLW9wZW4nLFxuICBST09UOiAnbWRjLW1lbnUtc3VyZmFjZScsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIENMT1NFRF9FVkVOVDogJ01EQ01lbnVTdXJmYWNlOmNsb3NlZCcsXG4gIE9QRU5FRF9FVkVOVDogJ01EQ01lbnVTdXJmYWNlOm9wZW5lZCcsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUzogJ2J1dHRvbjpub3QoOmRpc2FibGVkKSwgW2hyZWZdOm5vdChbYXJpYS1kaXNhYmxlZD1cInRydWVcIl0pLCBpbnB1dDpub3QoOmRpc2FibGVkKSwgJyArXG4gICdzZWxlY3Q6bm90KDpkaXNhYmxlZCksIHRleHRhcmVhOm5vdCg6ZGlzYWJsZWQpLCBbdGFiaW5kZXhdOm5vdChbdGFiaW5kZXg9XCItMVwiXSk6bm90KFthcmlhLWRpc2FibGVkPVwidHJ1ZVwiXSknLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51LXN1cmZhY2Ugb3BlbiBhbmltYXRpb24uXG4gIFRSQU5TSVRJT05fT1BFTl9EVVJBVElPTjogMTIwLFxuICAvLyBUb3RhbCBkdXJhdGlvbiBvZiBtZW51LXN1cmZhY2UgY2xvc2UgYW5pbWF0aW9uLlxuICBUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OOiA3NSxcbiAgLy8gTWFyZ2luIGxlZnQgdG8gdGhlIGVkZ2Ugb2YgdGhlIHZpZXdwb3J0IHdoZW4gbWVudS1zdXJmYWNlIGlzIGF0IG1heGltdW0gcG9zc2libGUgaGVpZ2h0LlxuICBNQVJHSU5fVE9fRURHRTogMzIsXG4gIC8vIFJhdGlvIG9mIGFuY2hvciB3aWR0aCB0byBtZW51LXN1cmZhY2Ugd2lkdGggZm9yIHN3aXRjaGluZyBmcm9tIGNvcm5lciBwb3NpdGlvbmluZyB0byBjZW50ZXIgcG9zaXRpb25pbmcuXG4gIEFOQ0hPUl9UT19NRU5VX1NVUkZBQ0VfV0lEVEhfUkFUSU86IDAuNjcsXG59O1xuXG4vKipcbiAqIEVudW0gZm9yIGJpdHMgaW4gdGhlIHtAc2VlIENvcm5lcikgYml0bWFwLlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ29ybmVyQml0ID0ge1xuICBCT1RUT006IDEsXG4gIENFTlRFUjogMixcbiAgUklHSFQ6IDQsXG4gIEZMSVBfUlRMOiA4LFxufTtcblxuLyoqXG4gKiBFbnVtIGZvciByZXByZXNlbnRpbmcgYW4gZWxlbWVudCBjb3JuZXIgZm9yIHBvc2l0aW9uaW5nIHRoZSBtZW51LXN1cmZhY2UuXG4gKlxuICogVGhlIFNUQVJUIGNvbnN0YW50cyBtYXAgdG8gTEVGVCBpZiBlbGVtZW50IGRpcmVjdGlvbmFsaXR5IGlzIGxlZnRcbiAqIHRvIHJpZ2h0IGFuZCBSSUdIVCBpZiB0aGUgZGlyZWN0aW9uYWxpdHkgaXMgcmlnaHQgdG8gbGVmdC5cbiAqIExpa2V3aXNlIEVORCBtYXBzIHRvIFJJR0hUIG9yIExFRlQgZGVwZW5kaW5nIG9uIHRoZSBkaXJlY3Rpb25hbGl0eS5cbiAqXG4gKiBAZW51bSB7bnVtYmVyfVxuICovXG5jb25zdCBDb3JuZXIgPSB7XG4gIFRPUF9MRUZUOiAwLFxuICBUT1BfUklHSFQ6IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX0xFRlQ6IENvcm5lckJpdC5CT1RUT00sXG4gIEJPVFRPTV9SSUdIVDogQ29ybmVyQml0LkJPVFRPTSB8IENvcm5lckJpdC5SSUdIVCxcbiAgVE9QX1NUQVJUOiBDb3JuZXJCaXQuRkxJUF9SVEwsXG4gIFRPUF9FTkQ6IENvcm5lckJpdC5GTElQX1JUTCB8IENvcm5lckJpdC5SSUdIVCxcbiAgQk9UVE9NX1NUQVJUOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxuICBCT1RUT01fRU5EOiBDb3JuZXJCaXQuQk9UVE9NIHwgQ29ybmVyQml0LlJJR0hUIHwgQ29ybmVyQml0LkZMSVBfUlRMLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBDb3JuZXJCaXQsIENvcm5lcn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICB0b3A6IG51bWJlcixcbiAqICAgcmlnaHQ6IG51bWJlcixcbiAqICAgYm90dG9tOiBudW1iZXIsXG4gKiAgIGxlZnQ6IG51bWJlclxuICogfX1cbiAqL1xubGV0IEFuY2hvck1hcmdpbjtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmlld3BvcnQ6IHsgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIgfSxcbiAqICAgdmlld3BvcnREaXN0YW5jZToge3RvcDogbnVtYmVyLCByaWdodDogbnVtYmVyLCBib3R0b206IG51bWJlciwgbGVmdDogbnVtYmVyfSxcbiAqICAgYW5jaG9ySGVpZ2h0OiBudW1iZXIsXG4gKiAgIGFuY2hvcldpZHRoOiBudW1iZXIsXG4gKiAgIHN1cmZhY2VIZWlnaHQ6IG51bWJlcixcbiAqICAgc3VyZmFjZVdpZHRoOiBudW1iZXIsXG4gKiAgIGJvZHlEaW1lbnNpb25zLFxuICogICB3aW5kb3dTY3JvbGwsXG4gKiB9fVxuICovXG5sZXQgQXV0b0xheW91dE1lYXN1cmVtZW50cztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge01EQ01lbnVTdXJmYWNlQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVycywgQ29ybmVyLCBDb3JuZXJCaXR9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDTWVudVN1cmZhY2VBZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcn0gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJ9ICovXG4gIHN0YXRpYyBnZXQgQ29ybmVyKCkge1xuICAgIHJldHVybiBDb3JuZXI7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTWVudVN1cmZhY2VBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ01lbnVTdXJmYWNlQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ01lbnVTdXJmYWNlQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiBmYWxzZSxcbiAgICAgIGhhc0FuY2hvcjogKCkgPT4gZmFsc2UsXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge30sXG4gICAgICBub3RpZnlPcGVuOiAoKSA9PiB7fSxcbiAgICAgIGlzRWxlbWVudEluQ29udGFpbmVyOiAoKSA9PiBmYWxzZSxcbiAgICAgIGlzUnRsOiAoKSA9PiBmYWxzZSxcbiAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IGZhbHNlLFxuICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7fSxcbiAgICAgIHJlc3RvcmVGb2N1czogKCkgPT4ge30sXG4gICAgICBpc0ZpcnN0RWxlbWVudEZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgaXNMYXN0RWxlbWVudEZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgZm9jdXNGaXJzdEVsZW1lbnQ6ICgpID0+IHt9LFxuICAgICAgZm9jdXNMYXN0RWxlbWVudDogKCkgPT4ge30sXG4gICAgICBnZXRJbm5lckRpbWVuc2lvbnM6ICgpID0+ICh7fSksXG4gICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0V2luZG93RGltZW5zaW9uczogKCkgPT4gKHt9KSxcbiAgICAgIGdldEJvZHlEaW1lbnNpb25zOiAoKSA9PiAoe30pLFxuICAgICAgZ2V0V2luZG93U2Nyb2xsOiAoKSA9PiAoe30pLFxuICAgICAgc2V0UG9zaXRpb246ICgpID0+IHt9LFxuICAgICAgc2V0TWF4SGVpZ2h0OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENNZW51U3VyZmFjZUFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5vcGVuQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyA9IDA7XG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hbmltYXRpb25SZXF1ZXN0SWRfID0gMDtcbiAgICAvKiogQHByaXZhdGUgeyF7IHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH19ICovXG4gICAgdGhpcy5kaW1lbnNpb25zXztcbiAgICAvKiogQHByaXZhdGUgeyFDb3JuZXJ9ICovXG4gICAgdGhpcy5hbmNob3JDb3JuZXJfID0gQ29ybmVyLlRPUF9TVEFSVDtcbiAgICAvKiogQHByaXZhdGUgeyFBbmNob3JNYXJnaW59ICovXG4gICAgdGhpcy5hbmNob3JNYXJnaW5fID0ge3RvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMH07XG4gICAgLyoqIEBwcml2YXRlIHs/QXV0b0xheW91dE1lYXN1cmVtZW50c30gKi9cbiAgICB0aGlzLm1lYXN1cmVzXyA9IG51bGw7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMucXVpY2tPcGVuXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmhvaXN0ZWRFbGVtZW50XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzRml4ZWRQb3NpdGlvbl8gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgeyF7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICAgIHRoaXMucG9zaXRpb25fID0ge3g6IDAsIHk6IDB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7Uk9PVCwgT1BFTn0gPSBNRENNZW51U3VyZmFjZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhPUEVOKSkge1xuICAgICAgdGhpcy5pc09wZW5fID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyk7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuY2xvc2VBbmltYXRpb25FbmRUaW1lcklkXyk7XG4gICAgLy8gQ2FuY2VsIGFueSBjdXJyZW50bHkgcnVubmluZyBhbmltYXRpb25zLlxuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshQ29ybmVyfSBjb3JuZXIgRGVmYXVsdCBhbmNob3IgY29ybmVyIGFsaWdubWVudCBvZiB0b3AtbGVmdCBtZW51IHN1cmZhY2UgY29ybmVyLlxuICAgKi9cbiAgc2V0QW5jaG9yQ29ybmVyKGNvcm5lcikge1xuICAgIHRoaXMuYW5jaG9yQ29ybmVyXyA9IGNvcm5lcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBbmNob3JNYXJnaW59IG1hcmdpbiBzZXQgb2YgbWFyZ2luIHZhbHVlcyBmcm9tIGFuY2hvci5cbiAgICovXG4gIHNldEFuY2hvck1hcmdpbihtYXJnaW4pIHtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8udG9wID0gdHlwZW9mIG1hcmdpbi50b3AgPT09ICdudW1iZXInID8gbWFyZ2luLnRvcCA6IDA7XG4gICAgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0ID0gdHlwZW9mIG1hcmdpbi5yaWdodCA9PT0gJ251bWJlcicgPyBtYXJnaW4ucmlnaHQgOiAwO1xuICAgIHRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b20gPSB0eXBlb2YgbWFyZ2luLmJvdHRvbSA9PT0gJ251bWJlcicgPyBtYXJnaW4uYm90dG9tIDogMDtcbiAgICB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA9IHR5cGVvZiBtYXJnaW4ubGVmdCA9PT0gJ251bWJlcicgPyBtYXJnaW4ubGVmdCA6IDA7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBpbmRpY2F0ZSBpZiB0aGUgbWVudS1zdXJmYWNlIGlzIGhvaXN0ZWQgdG8gdGhlIGJvZHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIb2lzdGVkXG4gICAqL1xuICBzZXRJc0hvaXN0ZWQoaXNIb2lzdGVkKSB7XG4gICAgdGhpcy5ob2lzdGVkRWxlbWVudF8gPSBpc0hvaXN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBzZXQgdGhlIG1lbnUtc3VyZmFjZSBjYWxjdWxhdGlvbnMgYmFzZWQgb24gYSBmaXhlZCBwb3NpdGlvbiBtZW51LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRml4ZWRQb3NpdGlvblxuICAgKi9cbiAgc2V0Rml4ZWRQb3NpdGlvbihpc0ZpeGVkUG9zaXRpb24pIHtcbiAgICB0aGlzLmlzRml4ZWRQb3NpdGlvbl8gPSBpc0ZpeGVkUG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgbWVudS1zdXJmYWNlIHBvc2l0aW9uIG9uIHRoZSBwYWdlLlxuICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgKi9cbiAgc2V0QWJzb2x1dGVQb3NpdGlvbih4LCB5KSB7XG4gICAgdGhpcy5wb3NpdGlvbl8ueCA9IHRoaXMudHlwZUNoZWNraXNGaW5pdGVfKHgpID8geCA6IDA7XG4gICAgdGhpcy5wb3NpdGlvbl8ueSA9IHRoaXMudHlwZUNoZWNraXNGaW5pdGVfKHkpID8geSA6IDA7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBxdWlja09wZW4gKi9cbiAgc2V0UXVpY2tPcGVuKHF1aWNrT3Blbikge1xuICAgIHRoaXMucXVpY2tPcGVuXyA9IHF1aWNrT3BlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgY2xpY2tzIGFuZCBjbG9zZSBpZiBub3Qgd2l0aGluIG1lbnUtc3VyZmFjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVCb2R5Q2xpY2soZXZ0KSB7XG4gICAgY29uc3QgZWwgPSBldnQudGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNFbGVtZW50SW5Db250YWluZXIoZWwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5jbG9zZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5cyB0aGF0IGNsb3NlIHRoZSBzdXJmYWNlLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVLZXlkb3duKGV2dCkge1xuICAgIGNvbnN0IHtrZXlDb2RlLCBrZXksIHNoaWZ0S2V5fSA9IGV2dDtcblxuICAgIGNvbnN0IGlzRXNjYXBlID0ga2V5ID09PSAnRXNjYXBlJyB8fCBrZXlDb2RlID09PSAyNztcbiAgICBjb25zdCBpc1RhYiA9IGtleSA9PT0gJ1RhYicgfHwga2V5Q29kZSA9PT0gOTtcblxuICAgIGlmIChpc0VzY2FwZSkge1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH0gZWxzZSBpZiAoaXNUYWIpIHtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzTGFzdEVsZW1lbnRGb2N1c2VkKCkgJiYgIXNoaWZ0S2V5KSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNGaXJzdEVsZW1lbnQoKTtcbiAgICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYWRhcHRlcl8uaXNGaXJzdEVsZW1lbnRGb2N1c2VkKCkgJiYgc2hpZnRLZXkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5mb2N1c0xhc3RFbGVtZW50KCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQXV0b0xheW91dE1lYXN1cmVtZW50c30gTWVhc3VyZW1lbnRzIHVzZWQgdG8gcG9zaXRpb24gbWVudSBzdXJmYWNlIHBvcHVwLlxuICAgKi9cbiAgZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18oKSB7XG4gICAgbGV0IGFuY2hvclJlY3QgPSB0aGlzLmFkYXB0ZXJfLmdldEFuY2hvckRpbWVuc2lvbnMoKTtcbiAgICBjb25zdCB2aWV3cG9ydCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93RGltZW5zaW9ucygpO1xuICAgIGNvbnN0IGJvZHlEaW1lbnNpb25zID0gdGhpcy5hZGFwdGVyXy5nZXRCb2R5RGltZW5zaW9ucygpO1xuICAgIGNvbnN0IHdpbmRvd1Njcm9sbCA9IHRoaXMuYWRhcHRlcl8uZ2V0V2luZG93U2Nyb2xsKCk7XG5cbiAgICBpZiAoIWFuY2hvclJlY3QpIHtcbiAgICAgIGFuY2hvclJlY3QgPSAvKiogQHR5cGUge0NsaWVudFJlY3R9ICovICh7XG4gICAgICAgIHg6IHRoaXMucG9zaXRpb25fLngsXG4gICAgICAgIHk6IHRoaXMucG9zaXRpb25fLnksXG4gICAgICAgIHRvcDogdGhpcy5wb3NpdGlvbl8ueSxcbiAgICAgICAgYm90dG9tOiB0aGlzLnBvc2l0aW9uXy55LFxuICAgICAgICBsZWZ0OiB0aGlzLnBvc2l0aW9uXy54LFxuICAgICAgICByaWdodDogdGhpcy5wb3NpdGlvbl8ueCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3cG9ydCxcbiAgICAgIGJvZHlEaW1lbnNpb25zLFxuICAgICAgd2luZG93U2Nyb2xsLFxuICAgICAgdmlld3BvcnREaXN0YW5jZToge1xuICAgICAgICB0b3A6IGFuY2hvclJlY3QudG9wLFxuICAgICAgICByaWdodDogdmlld3BvcnQud2lkdGggLSBhbmNob3JSZWN0LnJpZ2h0LFxuICAgICAgICBsZWZ0OiBhbmNob3JSZWN0LmxlZnQsXG4gICAgICAgIGJvdHRvbTogdmlld3BvcnQuaGVpZ2h0IC0gYW5jaG9yUmVjdC5ib3R0b20sXG4gICAgICB9LFxuICAgICAgYW5jaG9ySGVpZ2h0OiBhbmNob3JSZWN0LmhlaWdodCxcbiAgICAgIGFuY2hvcldpZHRoOiBhbmNob3JSZWN0LndpZHRoLFxuICAgICAgc3VyZmFjZUhlaWdodDogdGhpcy5kaW1lbnNpb25zXy5oZWlnaHQsXG4gICAgICBzdXJmYWNlV2lkdGg6IHRoaXMuZGltZW5zaW9uc18ud2lkdGgsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgY29ybmVyIG9mIHRoZSBhbmNob3IgZnJvbSB3aGljaCB0byBhbmltYXRlIGFuZCBwb3NpdGlvbiB0aGUgbWVudSBzdXJmYWNlLlxuICAgKiBAcmV0dXJuIHshQ29ybmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0T3JpZ2luQ29ybmVyXygpIHtcbiAgICAvLyBEZWZhdWx0czogb3BlbiBmcm9tIHRoZSB0b3AgbGVmdC5cbiAgICBsZXQgY29ybmVyID0gQ29ybmVyLlRPUF9MRUZUO1xuXG4gICAgY29uc3Qge3ZpZXdwb3J0RGlzdGFuY2UsIGFuY2hvckhlaWdodCwgYW5jaG9yV2lkdGgsIHN1cmZhY2VIZWlnaHQsIHN1cmZhY2VXaWR0aH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGF2YWlsYWJsZVRvcCA9IGlzQm90dG9tQWxpZ25lZCA/IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgYW5jaG9ySGVpZ2h0ICsgdGhpcy5hbmNob3JNYXJnaW5fLmJvdHRvbVxuICAgICAgOiB2aWV3cG9ydERpc3RhbmNlLnRvcCArIHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgY29uc3QgYXZhaWxhYmxlQm90dG9tID0gaXNCb3R0b21BbGlnbmVkID8gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tXG4gICAgICA6IHZpZXdwb3J0RGlzdGFuY2UuYm90dG9tICsgYW5jaG9ySGVpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnRvcDtcblxuICAgIGNvbnN0IHRvcE92ZXJmbG93ID0gc3VyZmFjZUhlaWdodCAtIGF2YWlsYWJsZVRvcDtcbiAgICBjb25zdCBib3R0b21PdmVyZmxvdyA9IHN1cmZhY2VIZWlnaHQgLSBhdmFpbGFibGVCb3R0b207XG4gICAgaWYgKGJvdHRvbU92ZXJmbG93ID4gMCAmJiB0b3BPdmVyZmxvdyA8IGJvdHRvbU92ZXJmbG93KSB7XG4gICAgICBjb3JuZXIgfD0gQ29ybmVyQml0LkJPVFRPTTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1J0bCA9IHRoaXMuYWRhcHRlcl8uaXNSdGwoKTtcbiAgICBjb25zdCBpc0ZsaXBSdGwgPSBCb29sZWFuKHRoaXMuYW5jaG9yQ29ybmVyXyAmIENvcm5lckJpdC5GTElQX1JUTCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcbiAgICBjb25zdCBpc0FsaWduZWRSaWdodCA9IChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc1J0bCkgfHxcbiAgICAgICghYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCAmJiBpc0ZsaXBSdGwgJiYgaXNSdGwpO1xuICAgIGNvbnN0IGF2YWlsYWJsZUxlZnQgPSBpc0FsaWduZWRSaWdodCA/IHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIGFuY2hvcldpZHRoICsgdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UubGVmdCArIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICAgIGNvbnN0IGF2YWlsYWJsZVJpZ2h0ID0gaXNBbGlnbmVkUmlnaHQgPyB2aWV3cG9ydERpc3RhbmNlLnJpZ2h0IC0gdGhpcy5hbmNob3JNYXJnaW5fLnJpZ2h0IDpcbiAgICAgIHZpZXdwb3J0RGlzdGFuY2UucmlnaHQgKyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuXG4gICAgY29uc3QgbGVmdE92ZXJmbG93ID0gc3VyZmFjZVdpZHRoIC0gYXZhaWxhYmxlTGVmdDtcbiAgICBjb25zdCByaWdodE92ZXJmbG93ID0gc3VyZmFjZVdpZHRoIC0gYXZhaWxhYmxlUmlnaHQ7XG5cbiAgICBpZiAoKGxlZnRPdmVyZmxvdyA8IDAgJiYgaXNBbGlnbmVkUmlnaHQgJiYgaXNSdGwpIHx8XG4gICAgICAgIChhdm9pZEhvcml6b250YWxPdmVybGFwICYmICFpc0FsaWduZWRSaWdodCAmJiBsZWZ0T3ZlcmZsb3cgPCAwKSB8fFxuICAgICAgICAocmlnaHRPdmVyZmxvdyA+IDAgJiYgbGVmdE92ZXJmbG93IDwgcmlnaHRPdmVyZmxvdykpIHtcbiAgICAgIGNvcm5lciB8PSBDb3JuZXJCaXQuUklHSFQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7Q29ybmVyfSAqLyAoY29ybmVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDb3JuZXJ9IGNvcm5lciBPcmlnaW4gY29ybmVyIG9mIHRoZSBtZW51IHN1cmZhY2UuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSG9yaXpvbnRhbCBvZmZzZXQgb2YgbWVudSBzdXJmYWNlIG9yaWdpbiBjb3JuZXIgZnJvbSBjb3JyZXNwb25kaW5nIGFuY2hvciBjb3JuZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRIb3Jpem9udGFsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpIHtcbiAgICBjb25zdCB7YW5jaG9yV2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgLy8gaXNSaWdodEFsaWduZWQgY29ycmVzcG9uZHMgdG8gdXNpbmcgdGhlICdyaWdodCcgcHJvcGVydHkgb24gdGhlIHN1cmZhY2UuXG4gICAgY29uc3QgaXNSaWdodEFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCk7XG4gICAgY29uc3QgYXZvaWRIb3Jpem9udGFsT3ZlcmxhcCA9IEJvb2xlYW4odGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LlJJR0hUKTtcblxuICAgIGlmIChpc1JpZ2h0QWxpZ25lZCkge1xuICAgICAgY29uc3QgcmlnaHRPZmZzZXQgPSBhdm9pZEhvcml6b250YWxPdmVybGFwID8gYW5jaG9yV2lkdGggLSB0aGlzLmFuY2hvck1hcmdpbl8ubGVmdCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodDtcblxuICAgICAgLy8gRm9yIGhvaXN0ZWQgb3IgZml4ZWQgZWxlbWVudHMsIGFkanVzdCB0aGUgb2Zmc2V0IGJ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdmlld3BvcnQgd2lkdGggYW5kIGJvZHkgd2lkdGggc29cbiAgICAgIC8vIHdoZW4gd2UgY2FsY3VsYXRlIHRoZSByaWdodCB2YWx1ZSAoYGFkanVzdFBvc2l0aW9uRm9ySG9pc3RlZEVsZW1lbnRfYCkgYmFzZWQgb24gdGhlIGVsZW1lbnQgcG9zaXRpb24sXG4gICAgICAvLyB0aGUgcmlnaHQgcHJvcGVydHkgaXMgY29ycmVjdC5cbiAgICAgIGlmICh0aGlzLmhvaXN0ZWRFbGVtZW50XyB8fCB0aGlzLmlzRml4ZWRQb3NpdGlvbl8pIHtcbiAgICAgICAgcmV0dXJuIHJpZ2h0T2Zmc2V0IC0gKHRoaXMubWVhc3VyZXNfLnZpZXdwb3J0LndpZHRoIC0gdGhpcy5tZWFzdXJlc18uYm9keURpbWVuc2lvbnMud2lkdGgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmlnaHRPZmZzZXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGF2b2lkSG9yaXpvbnRhbE92ZXJsYXAgPyBhbmNob3JXaWR0aCAtIHRoaXMuYW5jaG9yTWFyZ2luXy5yaWdodCA6IHRoaXMuYW5jaG9yTWFyZ2luXy5sZWZ0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUNvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUgc3VyZmFjZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBWZXJ0aWNhbCBvZmZzZXQgb2YgbWVudSBzdXJmYWNlIG9yaWdpbiBjb3JuZXIgZnJvbSBjb3JyZXNwb25kaW5nIGFuY2hvciBjb3JuZXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRWZXJ0aWNhbE9yaWdpbk9mZnNldF8oY29ybmVyKSB7XG4gICAgY29uc3Qge2FuY2hvckhlaWdodH0gPSB0aGlzLm1lYXN1cmVzXztcbiAgICBjb25zdCBpc0JvdHRvbUFsaWduZWQgPSBCb29sZWFuKGNvcm5lciAmIENvcm5lckJpdC5CT1RUT00pO1xuICAgIGNvbnN0IGF2b2lkVmVydGljYWxPdmVybGFwID0gQm9vbGVhbih0aGlzLmFuY2hvckNvcm5lcl8gJiBDb3JuZXJCaXQuQk9UVE9NKTtcbiAgICBsZXQgeSA9IDA7XG5cbiAgICBpZiAoaXNCb3R0b21BbGlnbmVkKSB7XG4gICAgICB5ID0gYXZvaWRWZXJ0aWNhbE92ZXJsYXAgPyBhbmNob3JIZWlnaHQgLSB0aGlzLmFuY2hvck1hcmdpbl8udG9wIDogLXRoaXMuYW5jaG9yTWFyZ2luXy5ib3R0b207XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBhdm9pZFZlcnRpY2FsT3ZlcmxhcCA/IChhbmNob3JIZWlnaHQgKyB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tKSA6IHRoaXMuYW5jaG9yTWFyZ2luXy50b3A7XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUNvcm5lcn0gY29ybmVyIE9yaWdpbiBjb3JuZXIgb2YgdGhlIG1lbnUgc3VyZmFjZS5cbiAgICogQHJldHVybiB7bnVtYmVyfSBNYXhpbXVtIGhlaWdodCBvZiB0aGUgbWVudSBzdXJmYWNlLCBiYXNlZCBvbiBhdmFpbGFibGUgc3BhY2UuIDAgaW5kaWNhdGVzIHNob3VsZCBub3QgYmUgc2V0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWVudVN1cmZhY2VNYXhIZWlnaHRfKGNvcm5lcikge1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHt2aWV3cG9ydERpc3RhbmNlfSA9IHRoaXMubWVhc3VyZXNfO1xuICAgIGNvbnN0IGlzQm90dG9tQWxpZ25lZCA9IEJvb2xlYW4oY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSk7XG4gICAgY29uc3Qge01BUkdJTl9UT19FREdFfSA9IE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5udW1iZXJzO1xuXG4gICAgLy8gV2hlbiBtYXhpbXVtIGhlaWdodCBpcyBub3Qgc3BlY2lmaWVkLCBpdCBpcyBoYW5kbGVkIGZyb20gY3NzLlxuICAgIGlmIChpc0JvdHRvbUFsaWduZWQpIHtcbiAgICAgIG1heEhlaWdodCA9IHZpZXdwb3J0RGlzdGFuY2UudG9wICsgdGhpcy5hbmNob3JNYXJnaW5fLnRvcCAtIE1BUkdJTl9UT19FREdFO1xuICAgICAgaWYgKCEodGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSkpIHtcbiAgICAgICAgbWF4SGVpZ2h0ICs9IHRoaXMubWVhc3VyZXNfLmFuY2hvckhlaWdodDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4SGVpZ2h0ID0gdmlld3BvcnREaXN0YW5jZS5ib3R0b20gLSB0aGlzLmFuY2hvck1hcmdpbl8uYm90dG9tICsgdGhpcy5tZWFzdXJlc18uYW5jaG9ySGVpZ2h0IC0gTUFSR0lOX1RPX0VER0U7XG4gICAgICBpZiAodGhpcy5hbmNob3JDb3JuZXJfICYgQ29ybmVyQml0LkJPVFRPTSkge1xuICAgICAgICBtYXhIZWlnaHQgLT0gdGhpcy5tZWFzdXJlc18uYW5jaG9ySGVpZ2h0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtYXhIZWlnaHQ7XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgYXV0b1Bvc2l0aW9uXygpIHtcbiAgICAvLyBDb21wdXRlIG1lYXN1cmVtZW50cyBmb3IgYXV0b3Bvc2l0aW9uIG1ldGhvZHMgcmV1c2UuXG4gICAgdGhpcy5tZWFzdXJlc18gPSB0aGlzLmdldEF1dG9MYXlvdXRNZWFzdXJlbWVudHNfKCk7XG5cbiAgICBjb25zdCBjb3JuZXIgPSB0aGlzLmdldE9yaWdpbkNvcm5lcl8oKTtcbiAgICBjb25zdCBtYXhNZW51U3VyZmFjZUhlaWdodCA9IHRoaXMuZ2V0TWVudVN1cmZhY2VNYXhIZWlnaHRfKGNvcm5lcik7XG4gICAgY29uc3QgdmVydGljYWxBbGlnbm1lbnQgPSAoY29ybmVyICYgQ29ybmVyQml0LkJPVFRPTSkgPyAnYm90dG9tJyA6ICd0b3AnO1xuICAgIGxldCBob3Jpem9udGFsQWxpZ25tZW50ID0gKGNvcm5lciAmIENvcm5lckJpdC5SSUdIVCkgPyAncmlnaHQnIDogJ2xlZnQnO1xuICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSB0aGlzLmdldEhvcml6b250YWxPcmlnaW5PZmZzZXRfKGNvcm5lcik7XG4gICAgY29uc3QgdmVydGljYWxPZmZzZXQgPSB0aGlzLmdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0Xyhjb3JuZXIpO1xuICAgIGxldCBwb3NpdGlvbiA9IHtcbiAgICAgIFtob3Jpem9udGFsQWxpZ25tZW50XTogaG9yaXpvbnRhbE9mZnNldCA/IGhvcml6b250YWxPZmZzZXQgOiAnMCcsXG4gICAgICBbdmVydGljYWxBbGlnbm1lbnRdOiB2ZXJ0aWNhbE9mZnNldCA/IHZlcnRpY2FsT2Zmc2V0IDogJzAnLFxuICAgIH07XG4gICAgY29uc3Qge2FuY2hvcldpZHRoLCBzdXJmYWNlV2lkdGh9ID0gdGhpcy5tZWFzdXJlc187XG4gICAgLy8gQ2VudGVyIGFsaWduIHdoZW4gYW5jaG9yIHdpZHRoIGlzIGNvbXBhcmFibGUgb3IgZ3JlYXRlciB0aGFuIG1lbnUgc3VyZmFjZSwgb3RoZXJ3aXNlIGtlZXAgY29ybmVyLlxuICAgIGlmIChhbmNob3JXaWR0aCAvIHN1cmZhY2VXaWR0aCA+IG51bWJlcnMuQU5DSE9SX1RPX01FTlVfU1VSRkFDRV9XSURUSF9SQVRJTykge1xuICAgICAgaG9yaXpvbnRhbEFsaWdubWVudCA9ICdjZW50ZXInO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBtZW51LXN1cmZhY2UgaGFzIGJlZW4gaG9pc3RlZCB0byB0aGUgYm9keSwgaXQncyBubyBsb25nZXIgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBlbGVtZW50XG4gICAgaWYgKHRoaXMuaG9pc3RlZEVsZW1lbnRfIHx8IHRoaXMuaXNGaXhlZFBvc2l0aW9uXykge1xuICAgICAgcG9zaXRpb24gPSB0aGlzLmFkanVzdFBvc2l0aW9uRm9ySG9pc3RlZEVsZW1lbnRfKHBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcG9zaXRpb24pIHtcbiAgICAgIGlmIChwb3NpdGlvbi5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBwb3NpdGlvbltwcm9wXSAhPT0gJzAnKSB7XG4gICAgICAgIHBvc2l0aW9uW3Byb3BdID0gYCR7cGFyc2VJbnQocG9zaXRpb25bcHJvcF0sIDEwKX1weGA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2Zvcm1PcmlnaW4oYCR7aG9yaXpvbnRhbEFsaWdubWVudH0gJHt2ZXJ0aWNhbEFsaWdubWVudH1gKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE1heEhlaWdodChtYXhNZW51U3VyZmFjZUhlaWdodCA/IG1heE1lbnVTdXJmYWNlSGVpZ2h0ICsgJ3B4JyA6ICcnKTtcblxuICAgIC8vIENsZWFyIG1lYXN1cmVzIGFmdGVyIHBvc2l0aW9uaW5nIGlzIGNvbXBsZXRlLlxuICAgIHRoaXMubWVhc3VyZXNfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBvZmZzZXRzIGZvciBwb3NpdGlvbmluZyB0aGUgbWVudS1zdXJmYWNlIHdoZW4gdGhlIG1lbnUtc3VyZmFjZSBoYXMgYmVlblxuICAgKiBob2lzdGVkIHRvIHRoZSBib2R5LlxuICAgKiBAcGFyYW0geyF7XG4gICAqICAgdG9wOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgcmlnaHQ6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgICogICBib3R0b206IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgICogICBsZWZ0OiAoc3RyaW5nfHVuZGVmaW5lZClcbiAgICogfX0gcG9zaXRpb25cbiAgICogQHJldHVybiB7IXtcbiAgICogICB0b3A6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgICogICByaWdodDogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAgKiAgIGJvdHRvbTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAgKiAgIGxlZnQ6IChzdHJpbmd8dW5kZWZpbmVkKVxuICAgKiB9fSBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWRqdXN0UG9zaXRpb25Gb3JIb2lzdGVkRWxlbWVudF8ocG9zaXRpb24pIHtcbiAgICBjb25zdCB7d2luZG93U2Nyb2xsLCB2aWV3cG9ydERpc3RhbmNlfSA9IHRoaXMubWVhc3VyZXNfO1xuXG4gICAgZm9yIChjb25zdCBwcm9wIGluIHBvc2l0aW9uKSB7XG4gICAgICBpZiAocG9zaXRpb24uaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgLy8gSG9pc3RlZCBzdXJmYWNlcyBuZWVkIHRvIGhhdmUgdGhlIGFuY2hvciBlbGVtZW50cyBsb2NhdGlvbiBvbiB0aGUgcGFnZSBhZGRlZCB0byB0aGVcbiAgICAgICAgLy8gcG9zaXRpb24gcHJvcGVydGllcyBmb3IgcHJvcGVyIGFsaWdubWVudCBvbiB0aGUgYm9keS5cbiAgICAgICAgaWYgKHZpZXdwb3J0RGlzdGFuY2UuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcbiAgICAgICAgICBwb3NpdGlvbltwcm9wXSA9IHBhcnNlSW50KHBvc2l0aW9uW3Byb3BdLCAxMCkgKyB2aWV3cG9ydERpc3RhbmNlW3Byb3BdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3VyZmFjZXMgdGhhdCBhcmUgYWJzb2x1dGVseSBwb3NpdGlvbmVkIG5lZWQgdG8gaGF2ZSBhZGRpdGlvbmFsIGNhbGN1bGF0aW9ucyBmb3Igc2Nyb2xsXG4gICAgICAgIC8vIGFuZCBib3R0b20gcG9zaXRpb25pbmcuXG4gICAgICAgIGlmICghdGhpcy5pc0ZpeGVkUG9zaXRpb25fKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICd0b3AnKSB7XG4gICAgICAgICAgICBwb3NpdGlvbltwcm9wXSA9IHBhcnNlSW50KHBvc2l0aW9uW3Byb3BdLCAxMCkgKyB3aW5kb3dTY3JvbGwueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdib3R0b20nKSB7XG4gICAgICAgICAgICBwb3NpdGlvbltwcm9wXSA9IHBhcnNlSW50KHBvc2l0aW9uW3Byb3BdLCAxMCkgLSB3aW5kb3dTY3JvbGwueTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgcG9zaXRpb25bcHJvcF0gPSBwYXJzZUludChwb3NpdGlvbltwcm9wXSwgMTApICsgd2luZG93U2Nyb2xsLng7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICBwb3NpdGlvbltwcm9wXSA9IHBhcnNlSW50KHBvc2l0aW9uW3Byb3BdLCAxMCkgLSB3aW5kb3dTY3JvbGwueDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cblxuICAvKipcbiAgICogT3BlbiB0aGUgbWVudSBzdXJmYWNlLlxuICAgKi9cbiAgb3BlbigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNhdmVGb2N1cygpO1xuXG4gICAgaWYgKCF0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HX09QRU4pO1xuICAgIH1cblxuICAgIHRoaXMuYW5pbWF0aW9uUmVxdWVzdElkXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5jc3NDbGFzc2VzLk9QRU4pO1xuICAgICAgdGhpcy5kaW1lbnNpb25zXyA9IHRoaXMuYWRhcHRlcl8uZ2V0SW5uZXJEaW1lbnNpb25zKCk7XG4gICAgICB0aGlzLmF1dG9Qb3NpdGlvbl8oKTtcbiAgICAgIGlmICh0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMub3BlbkFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19PUEVOKTtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeU9wZW4oKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX09QRU5fRFVSQVRJT04pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBtZW51IHN1cmZhY2UuXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMucXVpY2tPcGVuXykge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENNZW51U3VyZmFjZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkdfQ0xPU0VEKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENNZW51U3VyZmFjZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICAgIGlmICh0aGlzLnF1aWNrT3Blbl8pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gMDtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOSU1BVElOR19DTE9TRUQpO1xuICAgICAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2xvc2UoKTtcbiAgICAgICAgfSwgbnVtYmVycy5UUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIHRoaXMubWF5YmVSZXN0b3JlRm9jdXNfKCk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxhc3QgZm9jdXNlZCBlbGVtZW50IHdoZW4gdGhlIG1lbnUgc3VyZmFjZSB3YXMgb3BlbmVkIHNob3VsZCByZWdhaW4gZm9jdXMsIGlmIHRoZSB1c2VyIGlzXG4gICAqIGZvY3VzZWQgb24gb3Igd2l0aGluIHRoZSBtZW51IHN1cmZhY2Ugd2hlbiBpdCBpcyBjbG9zZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtYXliZVJlc3RvcmVGb2N1c18oKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNGb2N1c2VkKCkgfHwgdGhpcy5hZGFwdGVyXy5pc0VsZW1lbnRJbkNvbnRhaW5lcihkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZXN0b3JlRm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKipcbiAgICogaXNGaW5pdGUgdGhhdCBkb2Vzbid0IGZvcmNlIGNvbnZlcnNpb24gdG8gbnVtYmVyIHR5cGUuXG4gICAqIEVxdWl2YWxlbnQgdG8gTnVtYmVyLmlzRmluaXRlIGluIEVTMjAxNSwgYnV0IGlzIG5vdCBpbmNsdWRlZCBpbiBJRTExLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0eXBlQ2hlY2tpc0Zpbml0ZV8obnVtKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIGlzRmluaXRlKG51bSk7XG4gIH1cbn1cblxuZXhwb3J0IHtNRENNZW51U3VyZmFjZUZvdW5kYXRpb24sIEFuY2hvck1hcmdpbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQge01EQ01lbnVBZGFwdGVyfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQge01EQ01lbnVTdXJmYWNlRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL21lbnUtc3VyZmFjZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENMaXN0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGlzdC9mb3VuZGF0aW9uJztcblxuY29uc3QgRUxFTUVOVFNfS0VZX0FMTE9XRURfSU4gPSBbJ2lucHV0JywgJ2J1dHRvbicsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnYSddO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENNZW51QWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ01lbnVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW17Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTWVudUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTWVudUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENNZW51QWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzVG9FbGVtZW50QXRJbmRleDogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzc0Zyb21FbGVtZW50QXRJbmRleDogKCkgPT4ge30sXG4gICAgICBhZGRBdHRyaWJ1dGVUb0VsZW1lbnRBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZUZyb21FbGVtZW50QXRJbmRleDogKCkgPT4ge30sXG4gICAgICBlbGVtZW50Q29udGFpbnNDbGFzczogKCkgPT4ge30sXG4gICAgICBjbG9zZVN1cmZhY2U6ICgpID0+IHt9LFxuICAgICAgZ2V0RWxlbWVudEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGdldFBhcmVudEVsZW1lbnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0U2VsZWN0ZWRFbGVtZW50SW5kZXg6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7IU1EQ01lbnVBZGFwdGVyfSBhZGFwdGVyICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ01lbnVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICB0aGlzLmNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8gPSAwO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlU3VyZmFjZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBrZXlkb3duIGV2ZW50cy5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bihldnQpIHtcbiAgICBjb25zdCB7a2V5LCBrZXlDb2RlfSA9IGV2dDtcblxuICAgIGNvbnN0IGlzU3BhY2UgPSBrZXkgPT09ICdTcGFjZScgfHwga2V5Q29kZSA9PT0gMzI7XG4gICAgY29uc3QgaXNFbnRlciA9IGtleSA9PT0gJ0VudGVyJyB8fCBrZXlDb2RlID09PSAxMztcbiAgICBjb25zdCBpc1RhYiA9IGtleSA9PT0gJ1RhYicgfHwga2V5Q29kZSA9PT0gOTtcblxuICAgIGlmIChpc1NwYWNlIHx8IGlzRW50ZXIpIHtcbiAgICAgIHRoaXMuaGFuZGxlQWN0aW9uXyhldnQpO1xuICAgIH0gZWxzZSBpZiAoaXNUYWIpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uY2xvc2VTdXJmYWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIHRoZSBjbGljayBldmVudHMuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUNsaWNrKGV2dCkge1xuICAgIHRoaXMuaGFuZGxlQWN0aW9uXyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbWJpbmVkIGFjdGlvbiBoYW5kbGluZyBmb3IgY2xpY2sva2V5cHJlc3MgZXZlbnRzLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVBY3Rpb25fKGV2dCkge1xuICAgIGNvbnN0IGxpc3RJdGVtID0gdGhpcy5nZXRMaXN0SXRlbV8oLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKGV2dC50YXJnZXQpKTtcbiAgICBpZiAobGlzdEl0ZW0pIHtcbiAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uKGxpc3RJdGVtKTtcbiAgICAgIHRoaXMucHJldmVudERlZmF1bHRFdmVudF8oZXZ0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlciBmb3IgYSBzZWxlY3RlZCBsaXN0IGl0ZW0uXG4gICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSBsaXN0SXRlbVxuICAgKi9cbiAgaGFuZGxlU2VsZWN0aW9uKGxpc3RJdGVtKSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldEVsZW1lbnRJbmRleChsaXN0SXRlbSk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5U2VsZWN0ZWQoe2luZGV4fSk7XG4gICAgdGhpcy5hZGFwdGVyXy5jbG9zZVN1cmZhY2UoKTtcblxuICAgIC8vIFdhaXQgZm9yIHRoZSBtZW51IHRvIGNsb3NlIGJlZm9yZSBhZGRpbmcvcmVtb3ZpbmcgY2xhc3NlcyB0aGF0IGFmZmVjdCBzdHlsZXMuXG4gICAgdGhpcy5jbG9zZUFuaW1hdGlvbkVuZFRpbWVySWRfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Hcm91cCA9IHRoaXMuZ2V0U2VsZWN0aW9uR3JvdXBfKGxpc3RJdGVtKTtcblxuICAgICAgaWYgKHNlbGVjdGlvbkdyb3VwICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2VsZWN0aW9uR3JvdXBfKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyAoc2VsZWN0aW9uR3JvdXApLCBpbmRleCk7XG4gICAgICB9XG4gICAgfSwgTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uLm51bWJlcnMuVFJBTlNJVElPTl9DTE9TRV9EVVJBVElPTik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyB0b2dnbGluZyB0aGUgc2VsZWN0ZWQgY2xhc3NlcyBpbiBhIHNlbGVjdGlvbiBncm91cCB3aGVuIGFcbiAgICogc2VsZWN0aW9uIGlzIG1hZGUuXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBzZWxlY3Rpb25Hcm91cFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIHNlbGVjdGVkIGluZGV4IHZhbHVlXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVTZWxlY3Rpb25Hcm91cF8oc2VsZWN0aW9uR3JvdXAsIGluZGV4KSB7XG4gICAgLy8gRGUtc2VsZWN0IHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gaW4gdGhpcyBncm91cC5cbiAgICBjb25zdCBzZWxlY3RlZEluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRTZWxlY3RlZEVsZW1lbnRJbmRleChzZWxlY3Rpb25Hcm91cCk7XG4gICAgaWYgKHNlbGVjdGVkSW5kZXggPj0gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGVGcm9tRWxlbWVudEF0SW5kZXgoc2VsZWN0ZWRJbmRleCwgc3RyaW5ncy5BUklBX1NFTEVDVEVEX0FUVFIpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzc0Zyb21FbGVtZW50QXRJbmRleChzZWxlY3RlZEluZGV4LCBjc3NDbGFzc2VzLk1FTlVfU0VMRUNURURfTElTVF9JVEVNKTtcbiAgICB9XG4gICAgLy8gU2VsZWN0IHRoZSBuZXcgbGlzdCBpdGVtIGluIHRoaXMgZ3JvdXAuXG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzc1RvRWxlbWVudEF0SW5kZXgoaW5kZXgsIGNzc0NsYXNzZXMuTUVOVV9TRUxFQ1RFRF9MSVNUX0lURU0pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQXR0cmlidXRlVG9FbGVtZW50QXRJbmRleChpbmRleCwgc3RyaW5ncy5BUklBX1NFTEVDVEVEX0FUVFIsICd0cnVlJyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFyZW50IHNlbGVjdGlvbiBncm91cCBvZiBhbiBlbGVtZW50IGlmIG9uZSBleGlzdHMuXG4gICAqIEBwYXJhbSBsaXN0SXRlbVxuICAgKiBAcmV0dXJuIHs/SFRNTEVsZW1lbnR9IHBhcmVudCBzZWxlY3Rpb24gZ3JvdXAgZWxlbWVudCBvciBudWxsLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uR3JvdXBfKGxpc3RJdGVtKSB7XG4gICAgbGV0IHBhcmVudCA9IHRoaXMuYWRhcHRlcl8uZ2V0UGFyZW50RWxlbWVudChsaXN0SXRlbSk7XG4gICAgbGV0IGlzR3JvdXAgPSB0aGlzLmFkYXB0ZXJfLmVsZW1lbnRDb250YWluc0NsYXNzKHBhcmVudCwgY3NzQ2xhc3Nlcy5NRU5VX1NFTEVDVElPTl9HUk9VUCk7XG5cbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggYW5jZXN0b3JzIHVudGlsIHdlIGZpbmQgdGhlIGdyb3VwIG9yIGdldCB0byB0aGUgbGlzdC5cbiAgICB3aGlsZSAoIWlzR3JvdXAgJiYgIXRoaXMuYWRhcHRlcl8uZWxlbWVudENvbnRhaW5zQ2xhc3MocGFyZW50LCBNRENMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLlJPT1QpKSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLmFkYXB0ZXJfLmdldFBhcmVudEVsZW1lbnQocGFyZW50KTtcbiAgICAgIGlzR3JvdXAgPSB0aGlzLmFkYXB0ZXJfLmVsZW1lbnRDb250YWluc0NsYXNzKHBhcmVudCwgY3NzQ2xhc3Nlcy5NRU5VX1NFTEVDVElPTl9HUk9VUCk7XG4gICAgfVxuXG4gICAgaWYgKGlzR3JvdXApIHtcbiAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIHRoZSBmaXJzdCBhbmNlc3RvciB3aXRoIHRoZSBtZGMtbGlzdC1pdGVtIGNsYXNzLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAqIEByZXR1cm4gez9IVE1MRWxlbWVudH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldExpc3RJdGVtXyh0YXJnZXQpIHtcbiAgICBsZXQgaXNMaXN0SXRlbSA9IHRoaXMuYWRhcHRlcl8uZWxlbWVudENvbnRhaW5zQ2xhc3ModGFyZ2V0LCBNRENMaXN0Rm91bmRhdGlvbi5jc3NDbGFzc2VzLkxJU1RfSVRFTV9DTEFTUyk7XG5cbiAgICB3aGlsZSAoIWlzTGlzdEl0ZW0pIHtcbiAgICAgIHRhcmdldCA9IHRoaXMuYWRhcHRlcl8uZ2V0UGFyZW50RWxlbWVudCh0YXJnZXQpO1xuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpc0xpc3RJdGVtID0gdGhpcy5hZGFwdGVyXy5lbGVtZW50Q29udGFpbnNDbGFzcyh0YXJnZXQsIE1EQ0xpc3RGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTElTVF9JVEVNX0NMQVNTKTtcbiAgICAgIH0gZWxzZSB7IC8vIHRhcmdldCBoYXMgbm8gcGFyZW50IGVsZW1lbnQuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH1cblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHByZXZlbnREZWZhdWx0IGlzIG9ubHkgY2FsbGVkIGlmIHRoZSBjb250YWluaW5nIGVsZW1lbnQgZG9lc24ndFxuICAgKiBjb25zdW1lIHRoZSBldmVudCwgYW5kIGl0IHdpbGwgY2F1c2UgYW4gdW5pbnRlbmRlZCBzY3JvbGwuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByZXZlbnREZWZhdWx0RXZlbnRfKGV2dCkge1xuICAgIGNvbnN0IHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyAoZXZ0LnRhcmdldCk7XG4gICAgY29uc3QgdGFnTmFtZSA9IGAke3RhcmdldC50YWdOYW1lfWAudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoRUxFTUVOVFNfS0VZX0FMTE9XRURfSU4uaW5kZXhPZih0YWdOYW1lKSA9PT0gLTEpIHtcbiAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge01EQ01lbnVGb3VuZGF0aW9ufTtcbiIsIjx0ZW1wbGF0ZT5cbiAgPG1kYy1tZW51LXN1cmZhY2VcbiAgICByZWY9XCJyb290XCJcbiAgICA6cXVpY2stb3Blbj1cInF1aWNrT3BlblwiXG4gICAgOm9wZW49XCJvcGVuXCJcbiAgICBAY2hhbmdlPVwib25DaGFuZ2VcIlxuICAgIEBjbGljay5uYXRpdmU9XCJoYW5kbGVDbGlja1wiXG4gID5cbiAgICA8bWRjLWxpc3QgcmVmPVwibGlzdFwiPiA8c2xvdCAvPiA8L21kYy1saXN0PlxuICA8L21kYy1tZW51LXN1cmZhY2U+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudUZvdW5kYXRpb24gfSBmcm9tICdAbWF0ZXJpYWwvbWVudS9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZW1pdEN1c3RvbUV2ZW50IH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUnLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICBvcGVuOiBbQm9vbGVhbiwgT2JqZWN0XSxcbiAgICAncXVpY2stb3Blbic6IEJvb2xlYW4sXG4gICAgJ2FuY2hvci1jb3JuZXInOiBbU3RyaW5nLCBOdW1iZXJdLFxuICAgICdhbmNob3ItbWFyZ2luJzogT2JqZWN0XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgcHJvdmlkZSgpIHtcbiAgICByZXR1cm4geyBtZGNNZW51OiB0aGlzIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICAvLyBhbmNob3JDb3JuZXIobnYpIHtcbiAgICAvLyAgIHRoaXMuZm91bmRhdGlvbi5zZXRBbmNob3JDb3JuZXIoTnVtYmVyKG52KSlcbiAgICAvLyB9LFxuICAgIC8vIGFuY2hvck1hcmdpbihudikge1xuICAgIC8vICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbihudilcbiAgICAvLyB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzVG9FbGVtZW50QXRJbmRleDogKGluZGV4LCBjbGFzc05hbWUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuaXRlbXNcbiAgICAgICAgbGlzdFtpbmRleF0uY2xhc3NMaXN0LmFkZChjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3NGcm9tRWxlbWVudEF0SW5kZXg6IChpbmRleCwgY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLml0ZW1zXG4gICAgICAgIGxpc3RbaW5kZXhdLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGFkZEF0dHJpYnV0ZVRvRWxlbWVudEF0SW5kZXg6IChpbmRleCwgYXR0ciwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuaXRlbXNcbiAgICAgICAgbGlzdFtpbmRleF0uc2V0QXR0cmlidXRlKGF0dHIsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZUZyb21FbGVtZW50QXRJbmRleDogKGluZGV4LCBhdHRyKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLml0ZW1zXG4gICAgICAgIGxpc3RbaW5kZXhdLnJlbW92ZUF0dHJpYnV0ZShhdHRyKVxuICAgICAgfSxcbiAgICAgIGVsZW1lbnRDb250YWluc0NsYXNzOiAoZWxlbWVudCwgY2xhc3NOYW1lKSA9PlxuICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgY2xvc2VTdXJmYWNlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgfSxcbiAgICAgIGdldEVsZW1lbnRJbmRleDogZWxlbWVudCA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZW1zLmluZGV4T2YoZWxlbWVudClcbiAgICAgIH0sXG4gICAgICBnZXRQYXJlbnRFbGVtZW50OiBlbGVtZW50ID0+IGVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgIGdldFNlbGVjdGVkRWxlbWVudEluZGV4OiBzZWxlY3Rpb25Hcm91cCA9PiB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuaXRlbXMuaW5kZXhPZihcbiAgICAgICAgICBzZWxlY3Rpb25Hcm91cC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgICAgYC4ke01EQ01lbnVGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTUVOVV9TRUxFQ1RFRF9MSVNUX0lURU19YFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICByZXR1cm4gaWR4XG4gICAgICB9LFxuICAgICAgbm90aWZ5U2VsZWN0ZWQ6IGV2dERhdGEgPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQodGhpcy4kZWwsIE1EQ01lbnVGb3VuZGF0aW9uLnN0cmluZ3MuU0VMRUNURURfRVZFTlQsIHtcbiAgICAgICAgICBpbmRleDogZXZ0RGF0YS5pbmRleCxcbiAgICAgICAgICBpdGVtOiB0aGlzLml0ZW1zW2V2dERhdGEuaW5kZXhdXG4gICAgICAgIH0pXG5cbiAgICAgICAgdGhpcy4kZW1pdCgnc2VsZWN0Jywge1xuICAgICAgICAgIGluZGV4OiBldnREYXRhLmluZGV4LFxuICAgICAgICAgIGl0ZW06IHRoaXMuaXRlbXNbZXZ0RGF0YS5pbmRleF1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuX3ByZXZpb3VzRm9jdXMgPSBudWxsXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgaXRlbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy5saXN0Lmxpc3RFbGVtZW50c1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlQ2xpY2soZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2xpY2soZXZ0KVxuICAgIH0sXG4gICAgb25DaGFuZ2UoaXRlbSkge1xuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgaXRlbSlcbiAgICB9XG4gICAgLy8gb25PcGVuXyh2YWx1ZSkge1xuICAgIC8vICAgaWYgKHZhbHVlKSB7XG4gICAgLy8gICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB2YWx1ZSA6IHZvaWQgMClcbiAgICAvLyAgIH0gZWxzZSB7XG4gICAgLy8gICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgLy8gICB9XG4gICAgLy8gfSxcbiAgICAvLyBzaG93KG9wdGlvbnMpIHtcbiAgICAvLyAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKG9wdGlvbnMpXG4gICAgLy8gfSxcbiAgICAvLyBoaWRlKCkge1xuICAgIC8vICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICAvLyB9LFxuICAgIC8vIGlzT3BlbigpIHtcbiAgICAvLyAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24gPyB0aGlzLmZvdW5kYXRpb24uaXNPcGVuKCkgOiBmYWxzZVxuICAgIC8vIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEB0eXBlIHtzdHJpbmd8dW5kZWZpbmVkfSAqL1xubGV0IHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiB0aGUgY29ycmVjdCB0cmFuc2Zvcm0gcHJvcGVydHkgdG8gdXNlIG9uIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKiBAcGFyYW0geyFXaW5kb3d9IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnd2Via2l0VHJhbnNmb3JtJyk7XG4gICAgc3RvcmVkVHJhbnNmb3JtUHJvcGVydHlOYW1lXyA9IHRyYW5zZm9ybVByb3BlcnR5TmFtZTtcbiAgfVxuXG4gIHJldHVybiBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xufVxuXG5leHBvcnQge2dldFRyYW5zZm9ybVByb3BlcnR5TmFtZX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXZcbiAgICA6Y2xhc3M9XCJjbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1tZW51IG1kYy1tZW51LXN1cmZhY2VcIlxuICAgIEBrZXlkb3duPVwiaGFuZGxlS2V5ZG93blwiXG4gICAgQE1EQ01lbnVTdXJmYWNlOm9wZW5lZD1cInJlZ2lzdGVyQm9keUNsaWNrTGlzdGVuZXJcIlxuICAgIEBNRENNZW51U3VyZmFjZTpjbG9zZWQ9XCJkZXJlZ2lzdGVyQm9keUNsaWNrTGlzdGVuZXJcIlxuICA+XG4gICAgPHNsb3QgLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uIH0gZnJvbSAnQG1hdGVyaWFsL21lbnUtc3VyZmFjZS9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgZW1pdEN1c3RvbUV2ZW50IH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL21lbnUtc3VyZmFjZS91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtbWVudS1zdXJmYWNlJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogW0Jvb2xlYW4sIE9iamVjdF0sXG4gICAgJ3F1aWNrLW9wZW4nOiBCb29sZWFuLFxuICAgICdhbmNob3ItY29ybmVyJzogW1N0cmluZywgTnVtYmVyXSxcbiAgICAnYW5jaG9yLW1hcmdpbic6IE9iamVjdFxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIHByb3ZpZGUoKSB7XG4gICAgcmV0dXJuIHsgbWRjTWVudTogdGhpcyB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgb3BlbjogJ29uT3Blbl8nLFxuICAgIHF1aWNrT3Blbihudikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFF1aWNrT3BlbihudilcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5fcHJldmlvdXNGb2N1cyA9IHVuZGVmaW5lZFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbihcbiAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHtcbiAgICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICAgICAgaGFzQW5jaG9yOiAoKSA9PiAhIXRoaXMuYW5jaG9yRWxlbWVudCxcbiAgICAgICAgICBub3RpZnlDbG9zZTogKCkgPT4ge1xuICAgICAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICB0aGlzLiRlbCxcbiAgICAgICAgICAgICAgTURDTWVudVN1cmZhY2VGb3VuZGF0aW9uLnN0cmluZ3MuQ0xPU0VEX0VWRU5ULFxuICAgICAgICAgICAgICB7fVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBmYWxzZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5vdGlmeU9wZW46ICgpID0+IHtcbiAgICAgICAgICAgIGVtaXRDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgICAgIE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5zdHJpbmdzLk9QRU5FRF9FVkVOVCxcbiAgICAgICAgICAgICAge31cbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdHJ1ZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlzRWxlbWVudEluQ29udGFpbmVyOiBlbCA9PiB0aGlzLiRlbCA9PT0gZWwgfHwgdGhpcy4kZWwuY29udGFpbnMoZWwpLFxuICAgICAgICAgIGlzUnRsOiAoKSA9PlxuICAgICAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuICAgICAgICAgIHNldFRyYW5zZm9ybU9yaWdpbjogb3JpZ2luID0+IHtcbiAgICAgICAgICAgIHRoaXMuJGVsLnN0eWxlW1xuICAgICAgICAgICAgICBgJHt1dGlsLmdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSh3aW5kb3cpfS1vcmlnaW5gXG4gICAgICAgICAgICBdID0gb3JpZ2luXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB0aGlzLmdldEZvY3VzQWRhcHRlck1ldGhvZHMoKSxcbiAgICAgICAgdGhpcy5nZXREaW1lbnNpb25BZGFwdGVyTWV0aG9kcygpXG4gICAgICApXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy4kZWwucGFyZW50RWxlbWVudCAmJlxuICAgICAgdGhpcy4kZWwucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXG4gICAgICAgIE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFOQ0hPUlxuICAgICAgKVxuICAgICkge1xuICAgICAgdGhpcy5hbmNob3JFbGVtZW50ID0gdGhpcy4kZWwucGFyZW50RWxlbWVudFxuICAgIH1cblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLl9wcmV2aW91c0ZvY3VzID0gbnVsbFxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBoYW5kbGVCb2R5Q2xpY2soZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQm9keUNsaWNrKGV2dClcbiAgICB9LFxuXG4gICAgcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lcigpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUJvZHlDbGljaylcbiAgICB9LFxuICAgIGRlcmVnaXN0ZXJCb2R5Q2xpY2tMaXN0ZW5lcigpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUJvZHlDbGljaylcbiAgICB9LFxuICAgIGhhbmRsZUtleWRvd24oZXZ0KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlS2V5ZG93bihldnQpXG4gICAgfSxcbiAgICBnZXRGb2N1c0FkYXB0ZXJNZXRob2RzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXNGb2N1c2VkOiAoKSA9PiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLiRlbCxcbiAgICAgICAgc2F2ZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5wcmV2aW91c0ZvY3VzXyA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgcmVzdG9yZUZvY3VzOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuJGVsLmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2aW91c0ZvY3VzXyAmJiB0aGlzLnByZXZpb3VzRm9jdXNfLmZvY3VzKSB7XG4gICAgICAgICAgICAgIHRoaXMucHJldmlvdXNGb2N1c18uZm9jdXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaXNGaXJzdEVsZW1lbnRGb2N1c2VkOiAoKSA9PlxuICAgICAgICAgIHRoaXMuZmlyc3RGb2N1c2FibGVFbGVtZW50XyAmJlxuICAgICAgICAgIHRoaXMuZmlyc3RGb2N1c2FibGVFbGVtZW50XyA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgaXNMYXN0RWxlbWVudEZvY3VzZWQ6ICgpID0+XG4gICAgICAgICAgdGhpcy5sYXN0Rm9jdXNhYmxlRWxlbWVudF8gJiZcbiAgICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGVFbGVtZW50XyA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCxcbiAgICAgICAgZm9jdXNGaXJzdEVsZW1lbnQ6ICgpID0+XG4gICAgICAgICAgdGhpcy5maXJzdEZvY3VzYWJsZUVsZW1lbnRfICYmXG4gICAgICAgICAgdGhpcy5maXJzdEZvY3VzYWJsZUVsZW1lbnRfLmZvY3VzICYmXG4gICAgICAgICAgdGhpcy5maXJzdEZvY3VzYWJsZUVsZW1lbnRfLmZvY3VzKCksXG4gICAgICAgIGZvY3VzTGFzdEVsZW1lbnQ6ICgpID0+XG4gICAgICAgICAgdGhpcy5sYXN0Rm9jdXNhYmxlRWxlbWVudF8gJiZcbiAgICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGVFbGVtZW50Xy5mb2N1cyAmJlxuICAgICAgICAgIHRoaXMubGFzdEZvY3VzYWJsZUVsZW1lbnRfLmZvY3VzKClcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldERpbWVuc2lvbkFkYXB0ZXJNZXRob2RzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0SW5uZXJEaW1lbnNpb25zOiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLiRlbC5vZmZzZXRXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy4kZWwub2Zmc2V0SGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRBbmNob3JEaW1lbnNpb25zOiAoKSA9PlxuICAgICAgICAgIHRoaXMuYW5jaG9yRWxlbWVudCAmJiB0aGlzLmFuY2hvckVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGdldFdpbmRvd0RpbWVuc2lvbnM6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0IH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0Qm9keURpbWVuc2lvbnM6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGRvY3VtZW50LmJvZHkuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRvY3VtZW50LmJvZHkuY2xpZW50SGVpZ2h0XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXRXaW5kb3dTY3JvbGw6ICgpID0+IHtcbiAgICAgICAgICByZXR1cm4geyB4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldCB9XG4gICAgICAgIH0sXG4gICAgICAgIHNldFBvc2l0aW9uOiBwb3NpdGlvbiA9PiB7XG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUubGVmdCA9ICdsZWZ0JyBpbiBwb3NpdGlvbiA/IHBvc2l0aW9uLmxlZnQgOiBudWxsXG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUucmlnaHQgPSAncmlnaHQnIGluIHBvc2l0aW9uID8gcG9zaXRpb24ucmlnaHQgOiBudWxsXG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUudG9wID0gJ3RvcCcgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi50b3AgOiBudWxsXG4gICAgICAgICAgdGhpcy4kZWwuc3R5bGUuYm90dG9tID0gJ2JvdHRvbScgaW4gcG9zaXRpb24gPyBwb3NpdGlvbi5ib3R0b20gOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIHNldE1heEhlaWdodDogaGVpZ2h0ID0+IHtcbiAgICAgICAgICB0aGlzLiRlbC5zdHlsZS5tYXhIZWlnaHQgPSBoZWlnaHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBvbk9wZW5fKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSB0aGlzLiRlbC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgICAgIE1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbi5zdHJpbmdzLkZPQ1VTQUJMRV9FTEVNRU5UU1xuICAgICAgICApXG4gICAgICAgIHRoaXMuZmlyc3RGb2N1c2FibGVFbGVtZW50XyA9XG4gICAgICAgICAgZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID4gMCA/IGZvY3VzYWJsZUVsZW1lbnRzWzBdIDogbnVsbFxuICAgICAgICB0aGlzLmxhc3RGb2N1c2FibGVFbGVtZW50XyA9XG4gICAgICAgICAgZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXVxuICAgICAgICAgICAgOiBudWxsXG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBob2lzdE1lbnVUb0JvZHkoKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuJGVsLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy4kZWwpKVxuICAgICAgdGhpcy5zZXRJc0hvaXN0ZWQodHJ1ZSlcbiAgICB9LFxuICAgIHNldElzSG9pc3RlZChpc0hvaXN0ZWQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRJc0hvaXN0ZWQoaXNIb2lzdGVkKVxuICAgIH0sXG4gICAgc2V0TWVudVN1cmZhY2VBbmNob3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuYW5jaG9yRWxlbWVudCA9IGVsZW1lbnRcbiAgICB9LFxuICAgIHNldEZpeGVkUG9zaXRpb24oaXNGaXhlZCkge1xuICAgICAgaWYgKGlzRml4ZWQpIHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmFkZChjc3NDbGFzc2VzLkZJWEVEKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LnJlbW92ZShjc3NDbGFzc2VzLkZJWEVEKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0Rml4ZWRQb3NpdGlvbihpc0ZpeGVkKVxuICAgIH0sXG4gICAgc2V0QWJzb2x1dGVQb3NpdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0QWJzb2x1dGVQb3NpdGlvbih4LCB5KVxuICAgICAgdGhpcy5zZXRJc0hvaXN0ZWQodHJ1ZSlcbiAgICB9LFxuICAgIHNldEFuY2hvckNvcm5lcihjb3JuZXIpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRBbmNob3JDb3JuZXIoY29ybmVyKVxuICAgIH0sXG4gICAgc2V0QW5jaG9yTWFyZ2luKG1hcmdpbikge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldEFuY2hvck1hcmdpbihtYXJnaW4pXG4gICAgfSxcbiAgICBzaG93KG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKG9wdGlvbnMpXG4gICAgfSxcbiAgICBoaWRlKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmNsb3NlKClcbiAgICB9LFxuICAgIGlzT3BlbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24gPyB0aGlzLmZvdW5kYXRpb24uaXNPcGVuKCkgOiBmYWxzZVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxsaVxuICAgIDp0YWJpbmRleD1cImRpc2FibGVkID8gJy0xJyA6ICcwJ1wiXG4gICAgOmFyaWEtZGlzYWJsZWQ9XCJkaXNhYmxlZFwiXG4gICAgY2xhc3M9XCJtZGMtbWVudS1pdGVtIG1kYy1saXN0LWl0ZW1cIlxuICAgIHJvbGU9XCJtZW51aXRlbVwiXG4gID5cbiAgICA8c2xvdCAvPlxuICA8L2xpPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LWl0ZW0nLFxuICBwcm9wczoge1xuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDogWydtZGNNZW51J10sXG5cbiAgbW91bnRlZCgpIHtcbiAgICBjb25zb2xlLmRpcih0aGlzLm1kY01lbnUpXG4gICAgdGhpcy5tZGNNZW51Lml0ZW1zLnB1c2godGhpcy4kZWwpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8bGkgXG4gICAgcm9sZT1cInNlcGFyYXRvclwiIFxuICAgIGNsYXNzPVwibWRjLW1lbnUtZGl2aWRlciBtZGMtbGlzdC1kaXZpZGVyXCIvPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1tZW51LWRpdmlkZXInXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1tZW51LXN1cmZhY2UtLWFuY2hvclwiPjxzbG90IC8+PC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLW1lbnUtYW5jaG9yJ1xufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNNZW51IGZyb20gJy4vbWRjLW1lbnUudnVlJ1xuaW1wb3J0IG1kY01lbnVTdXJmYWNlIGZyb20gJy4vbWRjLW1lbnUtc3VyZmFjZS52dWUnXG5pbXBvcnQgbWRjTWVudUl0ZW0gZnJvbSAnLi9tZGMtbWVudS1pdGVtLnZ1ZSdcbmltcG9ydCBtZGNNZW51RGl2aWRlciBmcm9tICcuL21kYy1tZW51LWRpdmlkZXIudnVlJ1xuaW1wb3J0IG1kY01lbnVBbmNob3IgZnJvbSAnLi9tZGMtbWVudS1hbmNob3IudnVlJ1xuXG5leHBvcnQgeyBtZGNNZW51LCBtZGNNZW51SXRlbSwgbWRjTWVudURpdmlkZXIsIG1kY01lbnVBbmNob3IgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjTWVudSxcbiAgbWRjTWVudVN1cmZhY2UsXG4gIG1kY01lbnVJdGVtLFxuICBtZGNNZW51RGl2aWRlcixcbiAgbWRjTWVudUFuY2hvclxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBSYWRpby4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICpcbiAqIEFkZGl0aW9uYWxseSwgcHJvdmlkZXMgdHlwZSBpbmZvcm1hdGlvbiBmb3IgdGhlIGFkYXB0ZXIgdG8gdGhlIENsb3N1cmVcbiAqIGNvbXBpbGVyLlxuICpcbiAqIEltcGxlbWVudCB0aGlzIGFkYXB0ZXIgZm9yIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZSB0byBkZWxlZ2F0ZSB1cGRhdGVzIHRvXG4gKiB0aGUgY29tcG9uZW50IGluIHlvdXIgZnJhbWV3b3JrIG9mIGNob2ljZS4gU2VlIGFyY2hpdGVjdHVyZSBkb2N1bWVudGF0aW9uXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9jb2RlL2FyY2hpdGVjdHVyZS5tZFxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDUmFkaW9BZGFwdGVyIHtcbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQoZGlzYWJsZWQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1JhZGlvQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIE5BVElWRV9DT05UUk9MX1NFTEVDVE9SOiAnLm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2wnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXJhZGlvJyxcbiAgRElTQUJMRUQ6ICdtZGMtcmFkaW8tLWRpc2FibGVkJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3Rpb25Db250cm9sU3RhdGV9IGZyb20gJ0BtYXRlcmlhbC9zZWxlY3Rpb24tY29udHJvbC9pbmRleCc7XG5pbXBvcnQgTURDUmFkaW9BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDUmFkaW9BZGFwdGVyPn1cbiAqL1xuY2xhc3MgTURDUmFkaW9Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDUmFkaW9BZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENSYWRpb0FkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0TmF0aXZlQ29udHJvbERpc2FibGVkOiAoLyogZGlzYWJsZWQ6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUR9ID0gTURDUmFkaW9Gb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXROYXRpdmVDb250cm9sRGlzYWJsZWQoZGlzYWJsZWQpO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhESVNBQkxFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSYWRpb0ZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgOmNsYXNzPVwiZm9ybUZpZWxkQ2xhc3Nlc1wiIGNsYXNzPVwibWRjLXJhZGlvLXdyYXBwZXJcIj5cbiAgICA8ZGl2IHJlZj1cInJvb3RcIiA6Y2xhc3M9XCJjbGFzc2VzXCIgOnN0eWxlPVwic3R5bGVzXCIgY2xhc3M9XCJtZGMtcmFkaW9cIj5cbiAgICAgIDxpbnB1dFxuICAgICAgICByZWY9XCJjb250cm9sXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6bmFtZT1cIm5hbWVcIlxuICAgICAgICB0eXBlPVwicmFkaW9cIlxuICAgICAgICBjbGFzcz1cIm1kYy1yYWRpb19fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICBAY2hhbmdlPVwic3luY1wiXG4gICAgICAvPlxuXG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXJhZGlvX19iYWNrZ3JvdW5kXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX291dGVyLWNpcmNsZVwiIC8+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtcmFkaW9fX2lubmVyLWNpcmNsZVwiIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8bGFiZWwgcmVmPVwibGFiZWxcIiA6Zm9yPVwidm1hX3VpZF9cIlxuICAgICAgPjxzbG90Pnt7IGxhYmVsIH19PC9zbG90PjwvbGFiZWxcbiAgICA+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENSYWRpb0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3JhZGlvL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDRm9ybUZpZWxkRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvZm9ybS1maWVsZC9mb3VuZGF0aW9uJ1xuaW1wb3J0IHsgRGlzcGF0Y2hGb2N1c01peGluLCBWTUFVbmlxdWVJZE1peGluIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXG5pbXBvcnQgeyBhcHBseVBhc3NpdmUgfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtcmFkaW8nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdwaWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIG5hbWU6IHsgdHlwZTogU3RyaW5nLCByZXF1aXJlZDogdHJ1ZSB9LFxuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgcGlja2VkOiBTdHJpbmcsXG4gICAgY2hlY2tlZDogQm9vbGVhbixcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgICdhbGlnbi1lbmQnOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fSxcbiAgICAgIGZvcm1GaWVsZENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkJzogdGhpcy5sYWJlbCxcbiAgICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiB0aGlzLmxhYmVsICYmIHRoaXMuYWxpZ25FbmRcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgY2hlY2tlZDogJ3NldENoZWNrZWQnLFxuICAgIHBpY2tlZDogJ29uUGlja2VkJyxcbiAgICBkaXNhYmxlZCh2YWx1ZSkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICAvLyBhZGQgZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENSYWRpb0ZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuXG4gICAgICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQ6IGRpc2FibGVkID0+XG4gICAgICAgICh0aGlzLiRyZWZzLmNvbnRyb2wuZGlzYWJsZWQgPSBkaXNhYmxlZClcbiAgICB9KVxuXG4gICAgLy8gYWRkIHJpcHBsZVxuICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcywge1xuICAgICAgaXNVbmJvdW5kZWQ6ICgpID0+IHRydWUsXG5cbiAgICAgIC8vIFJhZGlvIGJ1dHRvbnMgdGVjaG5pY2FsbHkgZ28gXCJhY3RpdmVcIiB3aGVuZXZlciB0aGVyZSBpcyAqYW55KiBrZXlib2FyZCBpbnRlcmFjdGlvbi4gVGhpcyBpcyBub3QgdGhlXG4gICAgICAvLyBVSSB3ZSBkZXNpcmUuXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IGZhbHNlLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmFkZEV2ZW50TGlzdGVuZXIoZXZ0LCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0LCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuY29udHJvbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dCwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm9ybUZpZWxkID0gbmV3IE1EQ0Zvcm1GaWVsZEZvdW5kYXRpb24oe1xuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMubGFiZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGFjdGl2YXRlSW5wdXRSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIGRlYWN0aXZhdGVJbnB1dFJpcHBsZTogKCkgPT4ge1xuICAgICAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZWFjdGl2YXRlKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIHRoaXMuZm9ybUZpZWxkLmluaXQoKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgdGhpcy4kcmVmcy5jb250cm9sLnZhbHVlID0gdGhpcy52YWx1ZSB8fCB0aGlzLmxhYmVsXG5cbiAgICB0aGlzLnNldENoZWNrZWQodGhpcy5jaGVja2VkIHx8IHRoaXMucGlja2VkID09IHRoaXMuJHJlZnMuY29udHJvbC52YWx1ZSlcblxuICAgIC8vIHJlZnJlc2ggbW9kZWxcbiAgICB0aGlzLmNoZWNrZWQgJiYgdGhpcy5zeW5jKClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvcm1GaWVsZC5kZXN0cm95KClcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvblBpY2tlZChudikge1xuICAgICAgdGhpcy5zZXRDaGVja2VkKHRoaXMucGlja2VkID09IHRoaXMuJHJlZnMuY29udHJvbC52YWx1ZSlcbiAgICB9LFxuICAgIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgICAgdGhpcy4kcmVmcy5jb250cm9sLmNoZWNrZWQgPSBjaGVja2VkXG4gICAgfSxcbiAgICBpc0NoZWNrZWQoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy5jb250cm9sLmNoZWNrZWRcbiAgICB9LFxuICAgIHN5bmMoZXZ0KSB7XG4gICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCB0aGlzLiRyZWZzLmNvbnRyb2wudmFsdWUpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1JhZGlvIGZyb20gJy4vbWRjLXJhZGlvLnZ1ZSdcblxuZXhwb3J0IHsgbWRjUmFkaW8gfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjUmFkaW9cbn0pXG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFNlbGVjdCBJY29uLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIHNlbGVjdCBpY29uIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3RJY29uQWRhcHRlciB7XG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBvZiBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cihhdHRyKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSBvbiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgaWNvbiBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjdXN0b20gZXZlbnQgXCJNRENTZWxlY3Q6aWNvblwiIGRlbm90aW5nIGEgdXNlciBoYXMgY2xpY2tlZCB0aGUgaWNvbi5cbiAgICovXG4gIG5vdGlmeUljb25BY3Rpb24oKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RJY29uQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIElDT05fRVZFTlQ6ICdNRENTZWxlY3Q6aWNvbicsXG4gIElDT05fUk9MRTogJ2J1dHRvbicsXG59O1xuXG5leHBvcnQge3N0cmluZ3N9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1NlbGVjdEljb25BZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge3N0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENTZWxlY3RJY29uQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDU2VsZWN0SWNvbkZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDU2VsZWN0SWNvbkFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0SWNvbkFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENTZWxlY3RJY29uQWRhcHRlcn0gKi8gKHtcbiAgICAgIGdldEF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTZWxlY3RJY29uQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2VsZWN0SWNvbkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7c3RyaW5nP30gKi9cbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gbnVsbDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0QXR0cigndGFiaW5kZXgnKTtcblxuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgdGhpcy5pbnRlcmFjdGlvbkhhbmRsZXJfKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGlmICghdGhpcy5zYXZlZFRhYkluZGV4Xykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKCdyb2xlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCB0aGlzLnNhdmVkVGFiSW5kZXhfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigncm9sZScsIHN0cmluZ3MuSUNPTl9ST0xFKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGxhYmVsICovXG4gIHNldEFyaWFMYWJlbChsYWJlbCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cignYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhbiBpbnRlcmFjdGlvbiBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbihldnQpIHtcbiAgICBpZiAoZXZ0LnR5cGUgPT09ICdjbGljaycgfHwgZXZ0LmtleSA9PT0gJ0VudGVyJyB8fCBldnQua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SWNvbkFjdGlvbigpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RJY29uRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5cbmltcG9ydCBNRENTZWxlY3RJY29uQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1NlbGVjdEljb25Gb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDU2VsZWN0SWNvbkZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdEljb24gZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0SWNvbn1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENTZWxlY3RJY29uKHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3RJY29uRm91bmRhdGlvbn1cbiAgICovXG4gIGdldCBmb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3RJY29uRm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDU2VsZWN0SWNvbkZvdW5kYXRpb24oLyoqIEB0eXBlIHshTURDU2VsZWN0SWNvbkFkYXB0ZXJ9ICovIChPYmplY3QuYXNzaWduKHtcbiAgICAgIGdldEF0dHI6IChhdHRyKSA9PiB0aGlzLnJvb3RfLmdldEF0dHJpYnV0ZShhdHRyKSxcbiAgICAgIHNldEF0dHI6IChhdHRyLCB2YWx1ZSkgPT4gdGhpcy5yb290Xy5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cjogKGF0dHIpID0+IHRoaXMucm9vdF8ucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxuICAgICAgc2V0Q29udGVudDogKGNvbnRlbnQpID0+IHtcbiAgICAgICAgdGhpcy5yb290Xy50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB0aGlzLnJvb3RfLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciksXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4gdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpLFxuICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4gdGhpcy5lbWl0KFxuICAgICAgICBNRENTZWxlY3RJY29uRm91bmRhdGlvbi5zdHJpbmdzLklDT05fRVZFTlQsIHt9IC8qIGV2dERhdGEgKi8sIHRydWUgLyogc2hvdWxkQnViYmxlICovKSxcbiAgICB9KSkpO1xuICB9XG59XG5cbmV4cG9ydCB7TURDU2VsZWN0SWNvbiwgTURDU2VsZWN0SWNvbkZvdW5kYXRpb259O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTZWxlY3QgSGVscGVyIFRleHQuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgU2VsZWN0IGhlbHBlciB0ZXh0IGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENTZWxlY3RIZWxwZXJUZXh0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgaGVscGVyIHRleHQgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgd2l0aCBhIGdpdmVuIHZhbHVlIG9uIHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW4gYXR0cmlidXRlIGZyb20gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyKGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBmb3IgdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1NlbGVjdEhlbHBlclRleHRBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9ISURERU46ICdhcmlhLWhpZGRlbicsXG4gIFJPTEU6ICdyb2xlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgSEVMUEVSX1RFWFRfUEVSU0lTVEVOVDogJ21kYy1zZWxlY3QtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnLFxuICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRzogJ21kYy1zZWxlY3QtaGVscGVyLXRleHQtLXZhbGlkYXRpb24tbXNnJyxcbn07XG5cbmV4cG9ydCB7c3RyaW5ncywgY3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDU2VsZWN0SGVscGVyVGV4dEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NlbGVjdEhlbHBlclRleHRBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1NlbGVjdEhlbHBlclRleHRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdEhlbHBlclRleHRBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2VsZWN0SGVscGVyVGV4dEFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBoYXNDbGFzczogKCkgPT4ge30sXG4gICAgICBzZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHI6ICgpID0+IHt9LFxuICAgICAgc2V0Q29udGVudDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDU2VsZWN0SGVscGVyVGV4dEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NlbGVjdEhlbHBlclRleHRGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgaGVscGVyIHRleHQgZmllbGQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRDb250ZW50KGNvbnRlbnQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnQoY29udGVudCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBpc1BlcnNpc3RlbnQgU2V0cyB0aGUgcGVyc2lzdGVuY3kgb2YgdGhlIGhlbHBlciB0ZXh0LiAqL1xuICBzZXRQZXJzaXN0ZW50KGlzUGVyc2lzdGVudCkge1xuICAgIGlmIChpc1BlcnNpc3RlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRhdGlvbiBUcnVlIHRvIG1ha2UgdGhlIGhlbHBlciB0ZXh0IGFjdCBhcyBhblxuICAgKiAgIGVycm9yIHZhbGlkYXRpb24gbWVzc2FnZS5cbiAgICovXG4gIHNldFZhbGlkYXRpb24oaXNWYWxpZGF0aW9uKSB7XG4gICAgaWYgKGlzVmFsaWRhdGlvbikge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHKTtcbiAgICB9XG4gIH1cblxuICAvKiogTWFrZXMgdGhlIGhlbHBlciB0ZXh0IHZpc2libGUgdG8gdGhlIHNjcmVlbiByZWFkZXIuICovXG4gIHNob3dUb1NjcmVlblJlYWRlcigpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHIoc3RyaW5ncy5BUklBX0hJRERFTik7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsaWRpdHkgb2YgdGhlIGhlbHBlciB0ZXh0IGJhc2VkIG9uIHRoZSBzZWxlY3QgdmFsaWRpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2VsZWN0SXNWYWxpZFxuICAgKi9cbiAgc2V0VmFsaWRpdHkoc2VsZWN0SXNWYWxpZCkge1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1BlcnNpc3RlbnQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgY29uc3QgaGVscGVyVGV4dElzVmFsaWRhdGlvbk1zZyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgY29uc3QgdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSA9IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgJiYgIXNlbGVjdElzVmFsaWQ7XG5cbiAgICBpZiAodmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuUk9MRSwgJ2FsZXJ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cihzdHJpbmdzLlJPTEUpO1xuICAgIH1cblxuICAgIGlmICghaGVscGVyVGV4dElzUGVyc2lzdGVudCAmJiAhdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5oaWRlXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgaGVscCB0ZXh0IGZyb20gc2NyZWVuIHJlYWRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX0hJRERFTiwgJ3RydWUnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDQ29tcG9uZW50IGZyb20gJ0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudCc7XG5cbmltcG9ydCBNRENTZWxlY3RIZWxwZXJUZXh0QWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IE1EQ1NlbGVjdEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0NvbXBvbmVudDwhTURDU2VsZWN0SGVscGVyVGV4dEZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1NlbGVjdEhlbHBlclRleHQgZXh0ZW5kcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDU2VsZWN0SGVscGVyVGV4dH1cbiAgICovXG4gIHN0YXRpYyBhdHRhY2hUbyhyb290KSB7XG4gICAgcmV0dXJuIG5ldyBNRENTZWxlY3RIZWxwZXJUZXh0KHJvb3QpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbn1cbiAgICovXG4gIGdldCBmb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb25fO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbn1cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIHJldHVybiBuZXcgTURDU2VsZWN0SGVscGVyVGV4dEZvdW5kYXRpb24oLyoqIEB0eXBlIHshTURDU2VsZWN0SGVscGVyVGV4dEFkYXB0ZXJ9ICovIChPYmplY3QuYXNzaWduKHtcbiAgICAgIGFkZENsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB0aGlzLnJvb3RfLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLnJvb3RfLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSksXG4gICAgICByZW1vdmVBdHRyOiAoYXR0cikgPT4gdGhpcy5yb290Xy5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXG4gICAgICBzZXRDb250ZW50OiAoY29udGVudCkgPT4ge1xuICAgICAgICB0aGlzLnJvb3RfLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgIH0sXG4gICAgfSkpKTtcbiAgfVxufVxuXG5leHBvcnQge01EQ1NlbGVjdEhlbHBlclRleHQsIE1EQ1NlbGVjdEhlbHBlclRleHRGb3VuZGF0aW9ufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1NlbGVjdEljb25Gb3VuZGF0aW9ufSBmcm9tICcuL2ljb24vaW5kZXgnO1xuaW1wb3J0IHtNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbn0gZnJvbSAnLi9oZWxwZXItdGV4dC9pbmRleCc7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgbGVhZGluZ0ljb246ICghTURDU2VsZWN0SWNvbkZvdW5kYXRpb258dW5kZWZpbmVkKSxcbiAqICAgaGVscGVyVGV4dDogKCFNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogfX1cbiAqL1xubGV0IEZvdW5kYXRpb25NYXBUeXBlO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTZWxlY3QuIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqIC0gZXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cblxuY2xhc3MgTURDU2VsZWN0QWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGNsYXNzIHRvIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcyBuYW1lLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgYm90dG9tIGxpbmUsIHNob3dpbmcgYSBmb2N1c2VkIHN0YXRlLlxuICAgKi9cbiAgYWN0aXZhdGVCb3R0b21MaW5lKCkge31cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGJvdHRvbSBsaW5lLlxuICAgKi9cbiAgZGVhY3RpdmF0ZUJvdHRvbUxpbmUoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgc2VsZWN0LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZWxlY3RlZCB2YWx1ZSBvZiB0aGUgc2VsZWN0IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldFZhbHVlKCkge31cblxuICAvKipcbiAgICogRmxvYXRzIGxhYmVsIGRldGVybWluZWQgYmFzZWQgb2ZmIG9mIHRoZSBzaG91bGRGbG9hdCBhcmd1bWVudC5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGbG9hdFxuICAgKi9cbiAgZmxvYXRMYWJlbChzaG91bGRGbG9hdCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aWR0aCBvZiBsYWJlbCBpbiBwaXhlbHMsIGlmIHRoZSBsYWJlbCBleGlzdHMuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExhYmVsV2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cywgZmFsc2UgaWYgaXQgZG9lc24ndC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc091dGxpbmUoKSB7fVxuXG4gIC8qKlxuICAgKiBPbmx5IGltcGxlbWVudCBpZiBvdXRsaW5lIGVsZW1lbnQgZXhpc3RzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGFiZWxXaWR0aFxuICAgKi9cbiAgbm90Y2hPdXRsaW5lKGxhYmVsV2lkdGgpIHt9XG5cbiAgLyoqXG4gICAqIENsb3NlcyBub3RjaCBpbiBvdXRsaW5lIGVsZW1lbnQsIGlmIHRoZSBvdXRsaW5lIGV4aXN0cy5cbiAgICovXG4gIGNsb3NlT3V0bGluZSgpIHt9XG5cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBtZW51LlxuICAgKi9cbiAgb3Blbk1lbnUoKSB7fVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIG1lbnUuXG4gICAqL1xuICBjbG9zZU1lbnUoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIG1lbnUgaXMgY3VycmVudGx5IG9wZW4uXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc01lbnVPcGVuKCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0ZWQgaW5kZXggb2YgdGhlIHNlbGVjdCB0byB0aGUgaW5kZXggcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgc2V0U2VsZWN0ZWRJbmRleChpbmRleCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2VsZWN0IHRvIGRpc2FibGVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWJsZWRcbiAgICovXG4gIHNldERpc2FibGVkKGlzRGlzYWJsZWQpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGxpbmUgcmlwcGxlIHRyYW5zZm9ybSBvcmlnaW4gY2VudGVyLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm9ybWFsaXplZFhcbiAgICovXG4gIHNldFJpcHBsZUNlbnRlcihub3JtYWxpemVkWCkge31cblxuICAvKipcbiAgICogRW1pdHMgYSBjaGFuZ2UgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIHNlbGVjdGVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIG5vdGlmeUNoYW5nZSh2YWx1ZSkge31cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzZWxlY3QgaXMgY3VycmVudGx5IHZhbGlkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpc1ZhbGlkXG4gICAqL1xuICBjaGVja1ZhbGlkaXR5KCkge31cblxuICAvKipcbiAgICogQWRkcy9SZW1vdmVzIHRoZSBpbnZhbGlkIGNsYXNzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmFsaWRcbiAgICovXG4gIHNldFZhbGlkKGlzVmFsaWQpIHt9XG59XG5cbmV4cG9ydCB7TURDU2VsZWN0QWRhcHRlciwgRm91bmRhdGlvbk1hcFR5cGV9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgRElTQUJMRUQ6ICdtZGMtc2VsZWN0LS1kaXNhYmxlZCcsXG4gIFJPT1Q6ICdtZGMtc2VsZWN0JyxcbiAgT1VUTElORUQ6ICdtZGMtc2VsZWN0LS1vdXRsaW5lZCcsXG4gIEZPQ1VTRUQ6ICdtZGMtc2VsZWN0LS1mb2N1c2VkJyxcbiAgU0VMRUNURURfSVRFTV9DTEFTUzogJ21kYy1saXN0LWl0ZW0tLXNlbGVjdGVkJyxcbiAgV0lUSF9MRUFESU5HX0lDT046ICdtZGMtc2VsZWN0LS13aXRoLWxlYWRpbmctaWNvbicsXG4gIElOVkFMSUQ6ICdtZGMtc2VsZWN0LS1pbnZhbGlkJyxcbiAgUkVRVUlSRUQ6ICdtZGMtc2VsZWN0LS1yZXF1aXJlZCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSSUFfQ09OVFJPTFM6ICdhcmlhLWNvbnRyb2xzJyxcbiAgQ0hBTkdFX0VWRU5UOiAnTURDU2VsZWN0OmNoYW5nZScsXG4gIFNFTEVDVEVEX0lURU1fU0VMRUNUT1I6IGAuJHtjc3NDbGFzc2VzLlNFTEVDVEVEX0lURU1fQ0xBU1N9YCxcbiAgTEVBRElOR19JQ09OX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX2ljb24nLFxuICBTRUxFQ1RFRF9URVhUX1NFTEVDVE9SOiAnLm1kYy1zZWxlY3RfX3NlbGVjdGVkLXRleHQnLFxuICBISURERU5fSU5QVVRfU0VMRUNUT1I6ICdpbnB1dFt0eXBlPVwiaGlkZGVuXCJdJyxcbiAgTUVOVV9TRUxFQ1RPUjogJy5tZGMtc2VsZWN0X19tZW51JyxcbiAgTElORV9SSVBQTEVfU0VMRUNUT1I6ICcubWRjLWxpbmUtcmlwcGxlJyxcbiAgTEFCRUxfU0VMRUNUT1I6ICcubWRjLWZsb2F0aW5nLWxhYmVsJyxcbiAgTkFUSVZFX0NPTlRST0xfU0VMRUNUT1I6ICcubWRjLXNlbGVjdF9fbmF0aXZlLWNvbnRyb2wnLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxuICBFTkhBTkNFRF9WQUxVRV9BVFRSOiAnZGF0YS12YWx1ZScsXG4gIEFSSUFfU0VMRUNURURfQVRUUjogJ2FyaWEtc2VsZWN0ZWQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBMQUJFTF9TQ0FMRTogMC43NSxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENTZWxlY3RBZGFwdGVyLCBGb3VuZGF0aW9uTWFwVHlwZX0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7TURDU2VsZWN0SWNvbkZvdW5kYXRpb259IGZyb20gJy4vaWNvbi9pbmRleCc7XG5pbXBvcnQge01EQ1NlbGVjdEhlbHBlclRleHRGb3VuZGF0aW9ufSBmcm9tICcuL2hlbHBlci10ZXh0L2luZGV4Jztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENTZWxlY3RBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENTZWxlY3RGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENTZWxlY3RBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1NlbGVjdEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENTZWxlY3RBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IGZhbHNlLFxuICAgICAgYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7fSxcbiAgICAgIHNldFZhbHVlOiAoKSA9PiB7fSxcbiAgICAgIGdldFZhbHVlOiAoKSA9PiB7fSxcbiAgICAgIGZsb2F0TGFiZWw6ICgvKiB2YWx1ZTogYm9vbGVhbiAqLykgPT4ge30sXG4gICAgICBnZXRMYWJlbFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGhhc091dGxpbmU6ICgpID0+IGZhbHNlLFxuICAgICAgbm90Y2hPdXRsaW5lOiAoLyogbGFiZWxXaWR0aDogbnVtYmVyLCAqLykgPT4ge30sXG4gICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHt9LFxuICAgICAgb3Blbk1lbnU6ICgpID0+IHt9LFxuICAgICAgY2xvc2VNZW51OiAoKSA9PiB7fSxcbiAgICAgIGlzTWVudU9wZW46ICgpID0+IHt9LFxuICAgICAgc2V0U2VsZWN0ZWRJbmRleDogKCkgPT4ge30sXG4gICAgICBzZXREaXNhYmxlZDogKCkgPT4ge30sXG4gICAgICBzZXRSaXBwbGVDZW50ZXI6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIGNoZWNrVmFsaWRpdHk6ICgpID0+IHt9LFxuICAgICAgc2V0VmFsaWQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1NlbGVjdEFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICogQHBhcmFtIHshRm91bmRhdGlvbk1hcFR5cGU9fSBmb3VuZGF0aW9uTWFwIE1hcCBmcm9tIHN1YmNvbXBvbmVudCBuYW1lcyB0byB0aGVpciBzdWJmb3VuZGF0aW9ucy5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIsIGZvdW5kYXRpb25NYXAgPSAvKiogQHR5cGUgeyFGb3VuZGF0aW9uTWFwVHlwZX0gKi8gKHt9KSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2VsZWN0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEB0eXBlIHshTURDU2VsZWN0SWNvbkZvdW5kYXRpb258dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMubGVhZGluZ0ljb25fID0gZm91bmRhdGlvbk1hcC5sZWFkaW5nSWNvbjtcbiAgICAvKiogQHR5cGUgeyFNRENTZWxlY3RIZWxwZXJUZXh0Rm91bmRhdGlvbnx1bmRlZmluZWR9ICovXG4gICAgdGhpcy5oZWxwZXJUZXh0XyA9IGZvdW5kYXRpb25NYXAuaGVscGVyVGV4dDtcbiAgfVxuXG4gIHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNlbGVjdGVkSW5kZXgoaW5kZXgpO1xuICAgIHRoaXMuYWRhcHRlcl8uY2xvc2VNZW51KCk7XG4gICAgY29uc3QgZGlkQ2hhbmdlID0gdHJ1ZTtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZShkaWRDaGFuZ2UpO1xuICB9XG5cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFZhbHVlKHZhbHVlKTtcbiAgICBjb25zdCBkaWRDaGFuZ2UgPSB0cnVlO1xuICAgIHRoaXMuaGFuZGxlQ2hhbmdlKGRpZENoYW5nZSk7XG4gIH1cblxuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRWYWx1ZSgpO1xuICB9XG5cbiAgc2V0RGlzYWJsZWQoaXNEaXNhYmxlZCkge1xuICAgIGlzRGlzYWJsZWQgPyB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRElTQUJMRUQpIDogdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkRJU0FCTEVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgIHRoaXMuYWRhcHRlcl8uY2xvc2VNZW51KCk7XG5cbiAgICBpZiAodGhpcy5sZWFkaW5nSWNvbl8pIHtcbiAgICAgIHRoaXMubGVhZGluZ0ljb25fLnNldERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBTZXRzIHRoZSBjb250ZW50IG9mIHRoZSBoZWxwZXIgdGV4dC5cbiAgICovXG4gIHNldEhlbHBlclRleHRDb250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Xy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBjb25zdCBvcGVuTm90Y2ggPSB0aGlzLmdldFZhbHVlKCkubGVuZ3RoID4gMDtcbiAgICB0aGlzLm5vdGNoT3V0bGluZShvcGVuTm90Y2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdmFsdWUgY2hhbmdlcywgdmlhIGNoYW5nZSBldmVudCBvciBwcm9ncmFtbWF0aWMgdXBkYXRlcy5cbiAgICovXG4gIGhhbmRsZUNoYW5nZShkaWRDaGFuZ2UgPSB0cnVlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG4gICAgY29uc3Qgb3B0aW9uSGFzVmFsdWUgPSB2YWx1ZS5sZW5ndGggPiAwO1xuICAgIGNvbnN0IGlzUmVxdWlyZWQgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuUkVRVUlSRUQpO1xuXG4gICAgdGhpcy5ub3RjaE91dGxpbmUob3B0aW9uSGFzVmFsdWUpO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuRk9DVVNFRCkpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbChvcHRpb25IYXNWYWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGRpZENoYW5nZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UodmFsdWUpO1xuXG4gICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICB0aGlzLnNldFZhbGlkKHRoaXMuaXNWYWxpZCgpKTtcbiAgICAgICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgICAgICB0aGlzLmhlbHBlclRleHRfLnNldFZhbGlkaXR5KHRoaXMuaXNWYWxpZCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGZvY3VzIGV2ZW50cyBmcm9tIHNlbGVjdCBlbGVtZW50LlxuICAgKi9cbiAgaGFuZGxlRm9jdXMoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTRUQpO1xuICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0cnVlKTtcbiAgICB0aGlzLm5vdGNoT3V0bGluZSh0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFjdGl2YXRlQm90dG9tTGluZSgpO1xuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGJsdXIgZXZlbnRzIGZyb20gc2VsZWN0IGVsZW1lbnQuXG4gICAqL1xuICBoYW5kbGVCbHVyKCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzTWVudU9wZW4oKSkgcmV0dXJuO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5GT0NVU0VEKTtcbiAgICB0aGlzLmhhbmRsZUNoYW5nZShmYWxzZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZWFjdGl2YXRlQm90dG9tTGluZSgpO1xuXG4gICAgY29uc3QgaXNSZXF1aXJlZCA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5SRVFVSVJFRCk7XG5cbiAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgdGhpcy5zZXRWYWxpZCh0aGlzLmlzVmFsaWQoKSk7XG4gICAgICBpZiAodGhpcy5oZWxwZXJUZXh0Xykge1xuICAgICAgICB0aGlzLmhlbHBlclRleHRfLnNldFZhbGlkaXR5KHRoaXMuaXNWYWxpZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVDbGljayhub3JtYWxpemVkWCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzTWVudU9wZW4oKSkgcmV0dXJuO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0UmlwcGxlQ2VudGVyKG5vcm1hbGl6ZWRYKTtcblxuICAgIHRoaXMuYWRhcHRlcl8ub3Blbk1lbnUoKTtcbiAgfVxuXG4gIGhhbmRsZUtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc01lbnVPcGVuKCkpIHJldHVybjtcblxuICAgIGNvbnN0IGlzRW50ZXIgPSBldmVudC5rZXkgPT09ICdFbnRlcicgfHwgZXZlbnQua2V5Q29kZSA9PT0gMTM7XG4gICAgY29uc3QgaXNTcGFjZSA9IGV2ZW50LmtleSA9PT0gJ1NwYWNlJyB8fCBldmVudC5rZXlDb2RlID09PSAzMjtcbiAgICBjb25zdCBhcnJvd1VwID0gZXZlbnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzg7XG4gICAgY29uc3QgYXJyb3dEb3duID0gZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXlDb2RlID09PSA0MDtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuRk9DVVNFRCkgJiYgKGlzRW50ZXIgfHwgaXNTcGFjZSB8fCBhcnJvd1VwIHx8IGFycm93RG93bikpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ub3Blbk1lbnUoKTtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9wZW5zL2Nsb3NlcyB0aGUgbm90Y2hlZCBvdXRsaW5lLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5Ob3RjaFxuICAgKi9cbiAgbm90Y2hPdXRsaW5lKG9wZW5Ob3RjaCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNPdXRsaW5lKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNGb2N1c2VkID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkZPQ1VTRUQpO1xuXG4gICAgaWYgKG9wZW5Ob3RjaCkge1xuICAgICAgY29uc3QgbGFiZWxTY2FsZSA9IG51bWJlcnMuTEFCRUxfU0NBTEU7XG4gICAgICBjb25zdCBsYWJlbFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRMYWJlbFdpZHRoKCkgKiBsYWJlbFNjYWxlO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RjaE91dGxpbmUobGFiZWxXaWR0aCk7XG4gICAgfSBlbHNlIGlmICghaXNGb2N1c2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmNsb3NlT3V0bGluZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBhcmlhIGxhYmVsIG9mIHRoZSBsZWFkaW5nIGljb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbFxuICAgKi9cbiAgc2V0TGVhZGluZ0ljb25BcmlhTGFiZWwobGFiZWwpIHtcbiAgICBpZiAodGhpcy5sZWFkaW5nSWNvbl8pIHtcbiAgICAgIHRoaXMubGVhZGluZ0ljb25fLnNldEFyaWFMYWJlbChsYWJlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgbGVhZGluZyBpY29uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0TGVhZGluZ0ljb25Db250ZW50KGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5sZWFkaW5nSWNvbl8pIHtcbiAgICAgIHRoaXMubGVhZGluZ0ljb25fLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VmFsaWQoaXNWYWxpZCk7XG4gIH1cblxuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmNoZWNrVmFsaWRpdHkoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTZWxlY3RGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBGbG9hdGluZyBMYWJlbC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBmbG9hdGluZyBsYWJlbCBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIHJvb3QgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBMQUJFTF9GTE9BVF9BQk9WRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tZmxvYXQtYWJvdmUnLFxuICBMQUJFTF9TSEFLRTogJ21kYy1mbG9hdGluZy1sYWJlbC0tc2hha2UnLFxuICBST09UOiAnbWRjLWZsb2F0aW5nLWxhYmVsJyxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENGbG9hdGluZ0xhYmVsQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGdldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0Zsb2F0aW5nTGFiZWxBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8oKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYW5pbWF0aW9uZW5kJywgdGhpcy5zaGFrZUFuaW1hdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdhbmltYXRpb25lbmQnLCB0aGlzLnNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBsYWJlbCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRXaWR0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgbGFiZWwgdG8gcHJvZHVjZSB0aGUgbGFiZWwgc2hha2UgZm9yIGVycm9ycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRTaGFrZSBhZGRzIHNoYWtlIGNsYXNzIGlmIHRydWUsXG4gICAqIG90aGVyd2lzZSByZW1vdmVzIHNoYWtlIGNsYXNzLlxuICAgKi9cbiAgc2hha2Uoc2hvdWxkU2hha2UpIHtcbiAgICBjb25zdCB7TEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoc2hvdWxkU2hha2UpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTEFCRUxfU0hBS0UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBsYWJlbCB0byBmbG9hdCBvciBkb2NrLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHNob3VsZEZsb2F0IGFkZHMgZmxvYXQgY2xhc3MgaWYgdHJ1ZSwgb3RoZXJ3aXNlIHJlbW92ZVxuICAgKiBmbG9hdCBhbmQgc2hha2UgY2xhc3MgdG8gZG9jayBsYWJlbC5cbiAgICovXG4gIGZsb2F0KHNob3VsZEZsb2F0KSB7XG4gICAgY29uc3Qge0xBQkVMX0ZMT0FUX0FCT1ZFLCBMQUJFTF9TSEFLRX0gPSBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChzaG91bGRGbG9hdCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhMQUJFTF9GTE9BVF9BQk9WRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTEFCRUxfRkxPQVRfQUJPVkUpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhMQUJFTF9TSEFLRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnQgb24gdGhlIHJvb3QgZWxlbWVudC5cbiAgICovXG4gIGhhbmRsZVNoYWtlQW5pbWF0aW9uRW5kXygpIHtcbiAgICBjb25zdCB7TEFCRUxfU0hBS0V9ID0gTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKExBQkVMX1NIQUtFKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENGbG9hdGluZ0xhYmVsRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGxhYmVsXG4gICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzXCJcbiAgICBjbGFzcz1cIm1kYy1mbG9hdGluZy1sYWJlbFwiPlxuICAgIDxzbG90IC8+XG4gIDwvbGFiZWw+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9mbG9hdGluZy1sYWJlbC9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2VsZWN0LWxhYmVsJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbGFiZWxDbGFzc2VzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5sYWJlbENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBnZXRXaWR0aDogKCkgPT4gdGhpcy4kZWwub2Zmc2V0V2lkdGgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dEZpZWxkIExpbmUgUmlwcGxlLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIGxpbmUgcmlwcGxlIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENMaW5lUmlwcGxlQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzdHlsZSBwcm9wZXJ0eSB3aXRoIHByb3BlcnR5TmFtZSB0byB2YWx1ZSBvbiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0U3R5bGUocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBsaW5lIHJpcHBsZSBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJFdmVudEhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGxpbmUgcmlwcGxlIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgTElORV9SSVBQTEVfQUNUSVZFOiAnbWRjLWxpbmUtcmlwcGxlLS1hY3RpdmUnLFxuICBMSU5FX1JJUFBMRV9ERUFDVElWQVRJTkc6ICdtZGMtbGluZS1yaXBwbGUtLWRlYWN0aXZhdGluZycsXG59O1xuXG5leHBvcnQge2Nzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0xpbmVSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENMaW5lUmlwcGxlQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDTGluZVJpcHBsZUZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTGluZVJpcHBsZUFkYXB0ZXJ9IGZvciB0eXBpbmcgaW5mb3JtYXRpb24gb24gcGFyYW1ldGVycyBhbmQgcmV0dXJuXG4gICAqIHR5cGVzLlxuICAgKiBAcmV0dXJuIHshTURDTGluZVJpcHBsZUFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENMaW5lUmlwcGxlQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlOiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJFdmVudEhhbmRsZXI6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ0xpbmVSaXBwbGVBZGFwdGVyPX0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTGluZVJpcHBsZUZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJFdmVudEhhbmRsZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRyYW5zaXRpb25FbmRIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckV2ZW50SGFuZGxlcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBjZW50ZXIgb2YgdGhlIHJpcHBsZSBhbmltYXRpb24gdG8gdGhlIGdpdmVuIFggY29vcmRpbmF0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhDb29yZGluYXRlXG4gICAqL1xuICBzZXRSaXBwbGVDZW50ZXIoeENvb3JkaW5hdGUpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0cmFuc2Zvcm0tb3JpZ2luJywgYCR7eENvb3JkaW5hdGV9cHggY2VudGVyYCk7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGxpbmUgcmlwcGxlXG4gICAqL1xuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5MSU5FX1JJUFBMRV9ERUFDVElWQVRJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYSB0cmFuc2l0aW9uIGVuZCBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2dCkge1xuICAgIC8vIFdhaXQgZm9yIHRoZSBsaW5lIHJpcHBsZSB0byBiZSBlaXRoZXIgdHJhbnNwYXJlbnQgb3Igb3BhcXVlXG4gICAgLy8gYmVmb3JlIGVtaXR0aW5nIHRoZSBhbmltYXRpb24gZW5kIGV2ZW50XG4gICAgY29uc3QgaXNEZWFjdGl2YXRpbmcgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HKTtcblxuICAgIGlmIChldnQucHJvcGVydHlOYW1lID09PSAnb3BhY2l0eScpIHtcbiAgICAgIGlmIChpc0RlYWN0aXZhdGluZykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuTElORV9SSVBQTEVfQUNUSVZFKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkxJTkVfUklQUExFX0RFQUNUSVZBVElORyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0xpbmVSaXBwbGVGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmNsYXNzPVwibGluZUNsYXNzZXNcIlxuICAgIDpzdHlsZT1cImxpbmVTdHlsZXNcIlxuICAgIGNsYXNzPVwibWRjLWxpbmUtcmlwcGxlXCIvPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNlbGVjdC1saW5lLXJpcHBsZScsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVDbGFzc2VzOiB7fSxcbiAgICAgIGxpbmVTdHlsZXM6IHt9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENMaW5lUmlwcGxlRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMubGluZUNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMubGluZUNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVTdHlsZXMsIG5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICAgIGZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBOb3RjaGVkIE91dGxpbmUuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgTm90Y2hlZCBPdXRsaW5lIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB3aWR0aCBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgbm90Y2ggZWxlbWVudC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXG4gICAqL1xuICBzZXROb3RjaFdpZHRoUHJvcGVydHkod2lkdGgpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHdpZHRoIHN0eWxlIHByb3BlcnR5IGZyb20gdGhlIG5vdGNoIGVsZW1lbnQuXG4gICAqL1xuICByZW1vdmVOb3RjaFdpZHRoUHJvcGVydHkoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOT1RDSF9FTEVNRU5UX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmVfX25vdGNoJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgLy8gVGhpcyBzaG91bGQgc3RheSBpbiBzeW5jIHdpdGggJG1kYy1ub3RjaGVkLW91dGxpbmUtcGFkZGluZyAqIDIuXG4gIE5PVENIX0VMRU1FTlRfUEFERElORzogOCxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgT1VUTElORV9OT1RDSEVEOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm90Y2hlZCcsXG4gIE9VVExJTkVfVVBHUkFERUQ6ICdtZGMtbm90Y2hlZC1vdXRsaW5lLS11cGdyYWRlZCcsXG4gIE5PX0xBQkVMOiAnbWRjLW5vdGNoZWQtb3V0bGluZS0tbm8tbGFiZWwnLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBudW1iZXJzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENOb3RjaGVkT3V0bGluZUFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICoge0BzZWUgTURDTm90Y2hlZE91dGxpbmVBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldE5vdGNoV2lkdGhQcm9wZXJ0eTogKCkgPT4ge30sXG4gICAgICByZW1vdmVOb3RjaFdpZHRoUHJvcGVydHk6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgb3V0bGluZSBub3RjaGVkIHNlbGVjdG9yIGFuZCB1cGRhdGVzIHRoZSBub3RjaCB3aWR0aFxuICAgKiBjYWxjdWxhdGVkIGJhc2VkIG9mZiBvZiBub3RjaFdpZHRoLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbm90Y2hXaWR0aFxuICAgKi9cbiAgbm90Y2gobm90Y2hXaWR0aCkge1xuICAgIGNvbnN0IHtPVVRMSU5FX05PVENIRUR9ID0gTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG5cbiAgICBpZiAobm90Y2hXaWR0aCA+IDApIHtcbiAgICAgIG5vdGNoV2lkdGggKz0gbnVtYmVycy5OT1RDSF9FTEVNRU5UX1BBRERJTkc7IC8vIEFkZCBwYWRkaW5nIGZyb20gbGVmdC9yaWdodC5cbiAgICB9XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldE5vdGNoV2lkdGhQcm9wZXJ0eShub3RjaFdpZHRoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9VVExJTkVfTk9UQ0hFRCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBub3RjaGVkIG91dGxpbmUgc2VsZWN0b3IgdG8gY2xvc2UgdGhlIG5vdGNoIGluIHRoZSBvdXRsaW5lLlxuICAgKi9cbiAgY2xvc2VOb3RjaCgpIHtcbiAgICBjb25zdCB7T1VUTElORV9OT1RDSEVEfSA9IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoT1VUTElORV9OT1RDSEVEKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZU5vdGNoV2lkdGhQcm9wZXJ0eSgpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJvdXRsaW5lZFwiXG4gICAgICA6Y2xhc3M9XCJvdXRsaW5lZENsYXNzZXNcIlxuICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lXCI+XG4gICAgICA8c3ZnPlxuICAgICAgICA8cGF0aFxuICAgICAgICAgIHJlZj1cIm91dGxpbmVkUGF0aFwiXG4gICAgICAgICAgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19wYXRoXCIvPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICAgPGRpdlxuICAgICAgcmVmPVwib3V0bGluZWRJZGxlXCJcbiAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZVwiLz5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ25vdGNoZWRPdXRsaW5lRm91bmRhdGlvbkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL25vdGNoZWQtb3V0bGluZS9mb3VuZGF0aW9uJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtc2VsZWN0LW5vdGNoZWQtb3V0bGluZScsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGxpbmVkQ2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ25vdGNoZWRPdXRsaW5lRm91bmRhdGlvbkZvdW5kYXRpb24oe1xuICAgICAgZ2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZWQub2Zmc2V0V2lkdGgsXG4gICAgICBnZXRIZWlnaHQ6ICgpID0+IHRoaXMuJHJlZnMub3V0bGluZWQub2Zmc2V0SGVpZ2h0LFxuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVkQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5vdXRsaW5lZENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBzZXRPdXRsaW5lUGF0aEF0dHI6IHZhbHVlID0+IHtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuJHJlZnMub3V0bGluZWRQYXRoXG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdkJywgdmFsdWUpXG4gICAgICB9LFxuICAgICAgZ2V0SWRsZU91dGxpbmVTdHlsZVZhbHVlOiBwcm9wZXJ0eU5hbWUgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93XG4gICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5vdXRsaW5lZElkbGUpXG4gICAgICAgICAgLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHlOYW1lKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIGxldCBmb3VuZGF0aW9uID0gdGhpcy5mb3VuZGF0aW9uXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICAgIGZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiPHRlbXBsYXRlPlxuICA8ZGl2XG4gICAgOmlkPVwiaWRcIlxuICAgIDpjbGFzcz1cInJvb3RDbGFzc2VzXCJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxuICAgIGNsYXNzPVwibWRjLXNlbGVjdFwiPlxuICAgIDxzZWxlY3RcbiAgICAgIHJlZj1cIm5hdGl2ZV9jb250cm9sXCJcbiAgICAgIDpkaXNhYmxlZD1cImRpc2FibGVkXCJcbiAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zZWxlY3RfX25hdGl2ZS1jb250cm9sXCJcbiAgICAgIHYtb249XCJsaXN0ZW5lcnNcIj5cbiAgICAgIDxvcHRpb25cbiAgICAgICAgdi1pZj1cIiEhbGFiZWxcIlxuICAgICAgICBjbGFzcz1cIm1kYy1vcHRpb25cIlxuICAgICAgICB2YWx1ZT1cIlwiXG4gICAgICAgIGRpc2FibGVkXG4gICAgICAgIHNlbGVjdGVkLz5cbiAgICAgIDxzbG90Lz5cbiAgICA8L3NlbGVjdD5cbiAgICA8IS0tIGxhYmVsIC0tPlxuICAgIDxzZWxlY3QtbGFiZWxcbiAgICAgIHYtaWY9XCJsYWJlbFwiXG4gICAgICByZWY9XCJsYWJlbFwiPnt7IGxhYmVsIH19PC9zZWxlY3QtbGFiZWw+XG4gICAgPCEtLSBsaW5lIHJpcHBsZSAtLT5cbiAgICA8c2VsZWN0LWxpbmUtcmlwbGVcbiAgICAgIHYtaWY9XCIhb3V0bGluZWRcIlxuICAgICAgcmVmPVwibGluZVwiLz5cbiAgICA8IS0tIG91dGxpbmUgLS0+XG4gICAgPHNlbGVjdC1ub3RjaGVkLW91dGxpbmVcbiAgICAgIHYtaWY9XCJvdXRsaW5lZFwiXG4gICAgICByZWY9XCJvdXRsaW5lXCJcbiAgICAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2VsZWN0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2VsZWN0L2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5pbXBvcnQgU2VsZWN0TGFiZWwgZnJvbSAnLi9tZGMtc2VsZWN0LWxhYmVsLnZ1ZSdcbmltcG9ydCBTZWxlY3RMaW5lUmlwbGUgZnJvbSAnLi9tZGMtc2VsZWN0LWxpbmUtcmlwcGxlLnZ1ZSdcbmltcG9ydCBTZWxlY3ROb3RjaGVkT3V0bGluZSBmcm9tICcuL21kYy1zZWxlY3Qtbm90Y2hlZC1vdXRsaW5lLnZ1ZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNlbGVjdCcsXG4gIGNvbXBvbmVudHM6IHtcbiAgICBTZWxlY3RMYWJlbCxcbiAgICBTZWxlY3RMaW5lUmlwbGUsXG4gICAgU2VsZWN0Tm90Y2hlZE91dGxpbmVcbiAgfSxcbiAgaW5oZXJpdEF0dHJzOiBmYWxzZSxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAndmFsdWUnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBTdHJpbmcsXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGFiZWw6IFN0cmluZyxcbiAgICBvdXRsaW5lZDogQm9vbGVhbixcbiAgICBpZDogeyB0eXBlOiBTdHJpbmcgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdHlsZXM6IHt9LFxuICAgICAgY2xhc3Nlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgcm9vdENsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWRjLXNlbGVjdC0tYm94JzogIXRoaXMub3V0bGluZWQsXG4gICAgICAgICdtZGMtc2VsZWN0LS1vdXRsaW5lZCc6IHRoaXMub3V0bGluZWQsXG4gICAgICAgIC4uLnRoaXMuY2xhc3Nlc1xuICAgICAgfVxuICAgIH0sXG4gICAgbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBjaGFuZ2U6IGV2ZW50ID0+IHRoaXMub25DaGFuZ2UoZXZlbnQpXG4gICAgICB9XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnVwZGF0ZURpc2FibGVkU3R5bGUodmFsdWUpXG4gICAgfSxcbiAgICB2YWx1ZTogJ3JlZnJlc2hJbmRleCdcbiAgfSxcbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU2VsZWN0Rm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSksXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJGVsLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpLFxuICAgICAgYWN0aXZhdGVCb3R0b21MaW5lOiAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLmxpbmUpIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmUuZm91bmRhdGlvbi5hY3RpdmF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBkZWFjdGl2YXRlQm90dG9tTGluZTogKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5saW5lKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5saW5lLmZvdW5kYXRpb24uZGVhY3RpdmF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBnZXRWYWx1ZTogKCkgPT4gdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC52YWx1ZSxcbiAgICAgIGlzUnRsOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy4kZWwpLmdldFByb3BlcnR5VmFsdWUoJ2RpcmVjdGlvbicpID09PVxuICAgICAgICAgICdydGwnXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBub3RjaE91dGxpbmU6IChsYWJlbFdpZHRoLCBpc1J0bCkgPT4ge1xuICAgICAgICBpZiAodGhpcy4kcmVmcy5vdXRsaW5lKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5vdXRsaW5lLmZvdW5kYXRpb24ubm90Y2gobGFiZWxXaWR0aCwgaXNSdGwpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMub3V0bGluZSkge1xuICAgICAgICAgIHRoaXMuJHJlZnMub3V0bGluZS5mb3VuZGF0aW9uLmNsb3NlTm90Y2goKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4gISF0aGlzLiRyZWZzLm91dGxpbmUsXG4gICAgICBmbG9hdExhYmVsOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0aGlzLiRyZWZzLmxhYmVsKSB7XG4gICAgICAgICAgdGhpcy4kcmVmcy5sYWJlbC5mb3VuZGF0aW9uLmZsb2F0KHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgaGFzTGFiZWw6ICgpID0+ICEhdGhpcy4kcmVmcy5sYWJlbCxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubGFiZWwpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5sYWJlbC5mb3VuZGF0aW9uLmdldFdpZHRoKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNoYW5nZSgpXG5cbiAgICAvLyBpbml0aWFsIHN5bmMgd2l0aCBET01cbiAgICB0aGlzLnJlZnJlc2hJbmRleCgpXG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB0aGlzLnJlZnJlc2hJbmRleCgpKVxuICAgIHRoaXMuc2xvdE9ic2VydmVyLm9ic2VydmUodGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbCwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZVxuICAgIH0pXG5cbiAgICB0aGlzLnJpcHBsZSA9IG5ldyBSaXBwbGVCYXNlKHRoaXMpXG4gICAgdGhpcy5yaXBwbGUuaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5zbG90T2JzZXJ2ZXIuZGlzY29ubmVjdCgpXG5cbiAgICBsZXQgZm91bmRhdGlvbiA9IHRoaXMuZm91bmRhdGlvblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgICBmb3VuZGF0aW9uLmRlc3Ryb3koKVxuXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICByZWZyZXNoSW5kZXgoKSB7XG4gICAgICBjb25zdCBvcHRpb25zID0gWy4uLnRoaXMuJHJlZnMubmF0aXZlX2NvbnRyb2wucXVlcnlTZWxlY3RvckFsbCgnb3B0aW9uJyldXG5cbiAgICAgIGNvbnN0IGlkeCA9IG9wdGlvbnMuZmluZEluZGV4KCh7IHZhbHVlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWUgPT09IHZhbHVlXG4gICAgICB9KVxuXG4gICAgICBpZiAodGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC5zZWxlY3RlZEluZGV4ICE9PSBpZHgpIHtcbiAgICAgICAgdGhpcy4kcmVmcy5uYXRpdmVfY29udHJvbC5zZWxlY3RlZEluZGV4ID0gaWR4XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVDaGFuZ2UoKVxuICAgICAgfVxuICAgIH0sXG4gICAgb25DaGFuZ2UoZXZlbnQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVDaGFuZ2UoKVxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQudGFyZ2V0LnZhbHVlKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTZWxlY3QgZnJvbSAnLi9tZGMtc2VsZWN0LnZ1ZSdcblxuZXhwb3J0IHsgbWRjU2VsZWN0IH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NlbGVjdFxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIEFDVElWRTogJ21kYy1zbGlkZXItLWFjdGl2ZScsXG4gIERJU0FCTEVEOiAnbWRjLXNsaWRlci0tZGlzYWJsZWQnLFxuICBESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgRk9DVVM6ICdtZGMtc2xpZGVyLS1mb2N1cycsXG4gIElOX1RSQU5TSVQ6ICdtZGMtc2xpZGVyLS1pbi10cmFuc2l0JyxcbiAgSVNfRElTQ1JFVEU6ICdtZGMtc2xpZGVyLS1kaXNjcmV0ZScsXG4gIEhBU19UUkFDS19NQVJLRVI6ICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBUUkFDS19TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjaycsXG4gIFRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyLWNvbnRhaW5lcicsXG4gIExBU1RfVFJBQ0tfTUFSS0VSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlcjpsYXN0LWNoaWxkJyxcbiAgVEhVTUJfQ09OVEFJTkVSX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lcicsXG4gIFBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlcicsXG4gIEFSSUFfVkFMVUVNSU46ICdhcmlhLXZhbHVlbWluJyxcbiAgQVJJQV9WQUxVRU1BWDogJ2FyaWEtdmFsdWVtYXgnLFxuICBBUklBX1ZBTFVFTk9XOiAnYXJpYS12YWx1ZW5vdycsXG4gIEFSSUFfRElTQUJMRUQ6ICdhcmlhLWRpc2FibGVkJyxcbiAgU1RFUF9EQVRBX0FUVFI6ICdkYXRhLXN0ZXAnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENTbGlkZXI6Y2hhbmdlJyxcbiAgSU5QVVRfRVZFTlQ6ICdNRENTbGlkZXI6aW5wdXQnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBQQUdFX0ZBQ1RPUjogNCxcbn07XG5cbmV4cG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU2xpZGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFNsaWRlciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2xpZGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2xhc3NOYW1lIGV4aXN0cyBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWYgYXR0cmlidXRlIG5hbWUgZXhpc3RzIG9uIHRoZSBzbGlkZXIgRWxlbWVudCxcbiAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYXR0cmlidXRlIG5hbWUgb24gc2xpZGVyIEVsZW1lbnQgdG8gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlIG5hbWUgZnJvbSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7P0NsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGluZGV4IG9mIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6aW5wdXQgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5SW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6Y2hhbmdlIGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhY2sgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUcmFja1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5uZXIgdGV4dCBvZiB0aGUgcGluIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0TWFya2VyVmFsdWUodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIHBhc3NlZCBudW1iZXIgb2YgdHJhY2sgbWFya2VycyB0byB0aGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTWFya2Vyc1xuICAgKi9cbiAgYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHRyYWNrIG1hcmtlcnMgZnJvbXQgaGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgcmVtb3ZlVHJhY2tNYXJrZXJzKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBsYXN0IHRyYWNrIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBSVEwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5ncywgbnVtYmVyc30gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IE1EQ1NsaWRlckFkYXB0ZXIgZnJvbSAnLi9hZGFwdGVyJztcblxuaW1wb3J0IHtnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4JztcbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IEtFWV9JRFMgPSB7XG4gIEFSUk9XX0xFRlQ6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVDogJ0Fycm93UmlnaHQnLFxuICBBUlJPV19VUDogJ0Fycm93VXAnLFxuICBBUlJPV19ET1dOOiAnQXJyb3dEb3duJyxcbiAgSE9NRTogJ0hvbWUnLFxuICBFTkQ6ICdFbmQnLFxuICBQQUdFX1VQOiAnUGFnZVVwJyxcbiAgUEFHRV9ET1dOOiAnUGFnZURvd24nLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBNT1ZFX0VWRU5UX01BUCA9IHtcbiAgJ21vdXNlZG93bic6ICdtb3VzZW1vdmUnLFxuICAndG91Y2hzdGFydCc6ICd0b3VjaG1vdmUnLFxuICAncG9pbnRlcmRvd24nOiAncG9pbnRlcm1vdmUnLFxufTtcblxuY29uc3QgRE9XTl9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdwb2ludGVyZG93bicsICd0b3VjaHN0YXJ0J107XG5jb25zdCBVUF9FVkVOVFMgPSBbJ21vdXNldXAnLCAncG9pbnRlcnVwJywgJ3RvdWNoZW5kJ107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1NsaWRlckFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENTbGlkZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ3N9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge251bWJlcnN9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU2xpZGVyQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU2xpZGVyQWRhcHRlcn0gKi8gKHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgZ2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiAvKiBzdHJpbmd8bnVsbCAqLyBudWxsLFxuICAgICAgc2V0QXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogKC8qIG5hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBjb21wdXRlQm91bmRpbmdSZWN0OiAoKSA9PiAvKiBDbGllbnRSZWN0ICovICh7XG4gICAgICAgIHRvcDogMCwgcmlnaHQ6IDAsIGJvdHRvbTogMCwgbGVmdDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCxcbiAgICAgIH0pLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiAoKSA9PiB7fSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKC8qIHByb3BlcnR5TmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiAoLyogdmFsdWU6IG51bWJlciAqLykgPT4ge30sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6ICgvKiBudW1NYXJrZXJzOiBudW1iZXIgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlVHJhY2tNYXJrZXJzOiAoKSA9PiB7fSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNSVEw6ICgpID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNRENTbGlkZXJGb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7P01EQ1NsaWRlckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1NsaWRlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgICAvKiogQHByaXZhdGUgez9DbGllbnRSZWN0fSAqL1xuICAgIHRoaXMucmVjdF8gPSBudWxsO1xuICAgIC8vIFdlIHNldCB0aGlzIHRvIE5hTiBzaW5jZSB3ZSB3YW50IGl0IHRvIGJlIGEgbnVtYmVyLCBidXQgd2UgY2FuJ3QgdXNlICcwJyBvciAnLTEnXG4gICAgLy8gYmVjYXVzZSB0aG9zZSBjb3VsZCBiZSB2YWxpZCB0YWJpbmRpY2VzIHNldCBieSB0aGUgY2xpZW50IGNvZGUuXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IE5hTjtcbiAgICB0aGlzLmFjdGl2ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gZmFsc2U7XG4gICAgdGhpcy5oYXNUcmFja01hcmtlcl8gPSBmYWxzZTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5taW5fID0gMDtcbiAgICB0aGlzLm1heF8gPSAxMDA7XG4gICAgdGhpcy5zdGVwXyA9IDA7XG4gICAgdGhpcy52YWx1ZV8gPSAwO1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZmFsc2U7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gMDtcbiAgICB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlRG93bl8oZXZ0KTtcbiAgICB0aGlzLmtleWRvd25IYW5kbGVyXyA9IChldnQpID0+IHRoaXMuaGFuZGxlS2V5ZG93bl8oZXZ0KTtcbiAgICB0aGlzLmZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUZvY3VzXygpO1xuICAgIHRoaXMuYmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVCbHVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmxheW91dCgpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmlzRGlzY3JldGVfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLklTX0RJU0NSRVRFKTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5IQVNfVFJBQ0tfTUFSS0VSKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfKSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gICAgdGhpcy5sYXlvdXQoKTtcbiAgICAvLyBBdCBsYXN0IHN0ZXAsIHByb3ZpZGUgYSByZWFzb25hYmxlIGRlZmF1bHQgdmFsdWUgdG8gZGlzY3JldGUgc2xpZGVyXG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5nZXRTdGVwKCkgPT0gMCkge1xuICAgICAgdGhpcy5zdGVwXyA9IDE7XG4gICAgfVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pO1xuICAgIH0pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5ZG93bicsIHRoaXMua2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgRE9XTl9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy50aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIHNldHVwVHJhY2tNYXJrZXIoKSB7XG4gICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8gJiYgdGhpcy5oYXNUcmFja01hcmtlcl8mJiB0aGlzLmdldFN0ZXAoKSAhPSAwKSB7XG4gICAgICBjb25zdCBtaW4gPSB0aGlzLmdldE1pbigpO1xuICAgICAgY29uc3QgbWF4ID0gdGhpcy5nZXRNYXgoKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmdldFN0ZXAoKTtcbiAgICAgIGxldCBudW1NYXJrZXJzID0gKG1heCAtIG1pbikgLyBzdGVwO1xuXG4gICAgICAvLyBJbiBjYXNlIGRpc3RhbmNlIGJldHdlZW4gbWF4ICYgbWluIGlzIGluZGl2aXNpYmxlIHRvIHN0ZXAsXG4gICAgICAvLyB3ZSBwbGFjZSB0aGUgc2Vjb25kYXJ5IHRvIGxhc3QgbWFya2VyIHByb3BvcnRpb25hbGx5IGF0IHdoZXJlIHRodW1iXG4gICAgICAvLyBjb3VsZCByZWFjaCBhbmQgcGxhY2UgdGhlIGxhc3QgbWFya2VyIGF0IG1heCB2YWx1ZVxuICAgICAgY29uc3QgaW5kaXZpc2libGUgPSBNYXRoLmNlaWwobnVtTWFya2VycykgIT09IG51bU1hcmtlcnM7XG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgbnVtTWFya2VycyA9IE1hdGguY2VpbChudW1NYXJrZXJzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVUcmFja01hcmtlcnMoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpO1xuXG4gICAgICBpZiAoaW5kaXZpc2libGUpIHtcbiAgICAgICAgY29uc3QgbGFzdFN0ZXBSYXRpbyA9IChtYXggLSBudW1NYXJrZXJzICogc3RlcCkgLyBzdGVwICsgMTtcbiAgICAgICAgY29uc3QgZmxleCA9IGdldENvcnJlY3RQcm9wZXJ0eU5hbWUod2luZG93LCAnZmxleCcpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5KGZsZXgsIFN0cmluZyhsYXN0U3RlcFJhdGlvKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGF5b3V0KCkge1xuICAgIHRoaXMucmVjdF8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWVfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAqL1xuICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCBmYWxzZSk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNYXgoKSB7XG4gICAgcmV0dXJuIHRoaXMubWF4XztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWF4ICovXG4gIHNldE1heChtYXgpIHtcbiAgICBpZiAobWF4IDwgdGhpcy5taW5fKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWF4IHRvIGJlIGxlc3MgdGhhbiB0aGUgc2xpZGVyXFwncyBtaW5pbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWF4XyA9IG1heDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1BWCwgU3RyaW5nKHRoaXMubWF4XykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0TWluKCkge1xuICAgIHJldHVybiB0aGlzLm1pbl87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IG1pbiAqL1xuICBzZXRNaW4obWluKSB7XG4gICAgaWYgKG1pbiA+IHRoaXMubWF4Xykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IG1pbiB0byBiZSBncmVhdGVyIHRoYW4gdGhlIHNsaWRlclxcJ3MgbWF4aW11bSB2YWx1ZScpO1xuICAgIH1cbiAgICB0aGlzLm1pbl8gPSBtaW47XG4gICAgdGhpcy5zZXRWYWx1ZV8odGhpcy52YWx1ZV8sIGZhbHNlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfVkFMVUVNSU4sIFN0cmluZyh0aGlzLm1pbl8pKTtcbiAgICB0aGlzLnNldHVwVHJhY2tNYXJrZXIoKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFN0ZXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RlcF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHN0ZXAgKi9cbiAgc2V0U3RlcChzdGVwKSB7XG4gICAgaWYgKHN0ZXAgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0ZXAgY2Fubm90IGJlIHNldCB0byBhIG5lZ2F0aXZlIG51bWJlcicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiAodHlwZW9mKHN0ZXApICE9PSAnbnVtYmVyJyB8fCBzdGVwIDwgMSkpIHtcbiAgICAgIHN0ZXAgPSAxO1xuICAgIH1cbiAgICB0aGlzLnN0ZXBfID0gc3RlcDtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzRGlzYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWRfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmRpc2FibGVkXyA9IGRpc2FibGVkO1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuRElTQUJMRUQsIHRoaXMuZGlzYWJsZWRfKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkluZGV4KCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQsICd0cnVlJyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX0RJU0FCTEVEKTtcbiAgICAgIGlmICghaXNOYU4odGhpcy5zYXZlZFRhYkluZGV4XykpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgU3RyaW5nKHRoaXMuc2F2ZWRUYWJJbmRleF8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGludGVyYWN0aW5nIHdpdGggdGhlIHNsaWRlclxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoYW5kbGVEb3duXyhldnQpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IHRydWU7XG4gICAgdGhpcy5zZXRJblRyYW5zaXRfKCF0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfKTtcbiAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gZmFsc2U7XG4gICAgdGhpcy5zZXRBY3RpdmVfKHRydWUpO1xuXG4gICAgY29uc3QgbW92ZUhhbmRsZXIgPSAoZXZ0KSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZU1vdmVfKGV2dCk7XG4gICAgfTtcblxuICAgIC8vIE5vdGU6IHVwSGFuZGxlciBpcyBbZGVdcmVnaXN0ZXJlZCBvbiBBTEwgcG90ZW50aWFsIHBvaW50ZXItcmVsYXRlZCByZWxlYXNlIGV2ZW50IHR5cGVzLCBzaW5jZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gZG8gbm90IGFsd2F5cyBmaXJlIHRoZXNlIGNvbnNpc3RlbnRseSBpbiBwYWlycy5cbiAgICAvLyAoU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2lzc3Vlcy8xMTkyKVxuICAgIGNvbnN0IHVwSGFuZGxlciA9ICgpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlVXBfKCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdXBIYW5kbGVyKSk7XG4gICAgfTtcblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKE1PVkVfRVZFTlRfTUFQW2V2dC50eXBlXSwgbW92ZUhhbmRsZXIpO1xuICAgIFVQX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB0aGlzLnNldFZhbHVlRnJvbUV2dF8oZXZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBtb3ZlcyB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZU1vdmVfKGV2dCkge1xuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gd2l0aCB0aGUgc2xpZGVyIGVuZHNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZVVwXygpIHtcbiAgICB0aGlzLnNldEFjdGl2ZV8oZmFsc2UpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcGFnZVggb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGFnZVhfKGV2dCkge1xuICAgIGlmIChldnQudGFyZ2V0VG91Y2hlcyAmJiBldnQudGFyZ2V0VG91Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXZ0LnRhcmdldFRvdWNoZXNbMF0ucGFnZVg7XG4gICAgfVxuICAgIHJldHVybiBldnQucGFnZVg7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc2xpZGVyIHZhbHVlIGZyb20gYW4gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2V0VmFsdWVGcm9tRXZ0XyhldnQpIHtcbiAgICBjb25zdCBwYWdlWCA9IHRoaXMuZ2V0UGFnZVhfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgbmV3IHZhbHVlIGZyb20gdGhlIHBhZ2VYIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYWdlWFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlVmFsdWVGcm9tUGFnZVhfKHBhZ2VYKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWlufSA9IHRoaXM7XG4gICAgY29uc3QgeFBvcyA9IHBhZ2VYIC0gdGhpcy5yZWN0Xy5sZWZ0O1xuICAgIGxldCBwY3RDb21wbGV0ZSA9IHhQb3MgLyB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHBjdENvbXBsZXRlID0gMSAtIHBjdENvbXBsZXRlO1xuICAgIH1cbiAgICAvLyBGaXQgdGhlIHBlcmNlbnRhZ2UgY29tcGxldGUgYmV0d2VlbiB0aGUgcmFuZ2UgW21pbixtYXhdXG4gICAgLy8gYnkgcmVtYXBwaW5nIGZyb20gWzAsIDFdIHRvIFttaW4sIG1pbisobWF4LW1pbildLlxuICAgIHJldHVybiBtaW4gKyBwY3RDb21wbGV0ZSAqIChtYXggLSBtaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHNcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5ZG93bl8oZXZ0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmdldEtleUlkXyhldnQpO1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvcktleUlkXyhrZXlJZCk7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFByZXZlbnQgcGFnZSBmcm9tIHNjcm9sbGluZyBkdWUgdG8ga2V5IHByZXNzZXMgdGhhdCB3b3VsZCBub3JtYWxseSBzY3JvbGwgdGhlIHBhZ2VcbiAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICAgIHRoaXMuc2V0VmFsdWVfKHZhbHVlLCB0cnVlKTtcbiAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNoYW5nZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIG5hbWUgb2YgdGhlIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBrYmRFdnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0S2V5SWRfKGtiZEV2dCkge1xuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2JkRXZ0LmtleUNvZGUgPT09IDM3KSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19MRUZUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19SSUdIVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzkpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1JJR0hUO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX1VQO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5BUlJPV19ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSA0MCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfRE9XTjtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuSE9NRSB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzYpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkhPTUU7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkVORCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzUpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkVORDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9VUCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzMpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLlBBR0VfRE9XTiB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzQpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLlBBR0VfRE9XTjtcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHZhbHVlIGdpdmVuIGEga2V5Ym9hcmQga2V5IElEXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlJZFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRWYWx1ZUZvcktleUlkXyhrZXlJZCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgc3RlcF86IHN0ZXB9ID0gdGhpcztcbiAgICBsZXQgZGVsdGEgPSBzdGVwIHx8IChtYXggLSBtaW4pIC8gMTAwO1xuICAgIGNvbnN0IHZhbHVlTmVlZHNUb0JlRmxpcHBlZCA9IHRoaXMuYWRhcHRlcl8uaXNSVEwoKSAmJiAoXG4gICAgICBrZXlJZCA9PT0gS0VZX0lEUy5BUlJPV19MRUZUIHx8IGtleUlkID09PSBLRVlfSURTLkFSUk9XX1JJR0hUXG4gICAgKTtcbiAgICBpZiAodmFsdWVOZWVkc1RvQmVGbGlwcGVkKSB7XG4gICAgICBkZWx0YSA9IC1kZWx0YTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGtleUlkKSB7XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0xFRlQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfUklHSFQ6XG4gICAgY2FzZSBLRVlfSURTLkFSUk9XX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGE7XG4gICAgY2FzZSBLRVlfSURTLkhPTUU6XG4gICAgICByZXR1cm4gdGhpcy5taW5fO1xuICAgIGNhc2UgS0VZX0lEUy5FTkQ6XG4gICAgICByZXR1cm4gdGhpcy5tYXhfO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX1VQOlxuICAgICAgcmV0dXJuIHRoaXMudmFsdWVfICsgZGVsdGEgKiBudW1iZXJzLlBBR0VfRkFDVE9SO1xuICAgIGNhc2UgS0VZX0lEUy5QQUdFX0RPV046XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gLSBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlRm9jdXNfKCkge1xuICAgIGlmICh0aGlzLnByZXZlbnRGb2N1c1N0YXRlXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgaGFuZGxlQmx1cl8oKSB7XG4gICAgdGhpcy5wcmV2ZW50Rm9jdXNTdGF0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRk9DVVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmlyZUlucHV0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IGZvcmNlXG4gICAqL1xuICBzZXRWYWx1ZV8odmFsdWUsIHNob3VsZEZpcmVJbnB1dCwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gdGhpcy52YWx1ZV8gJiYgIWZvcmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge21pbl86IG1pbiwgbWF4XzogbWF4fSA9IHRoaXM7XG4gICAgY29uc3QgdmFsdWVTZXRUb0JvdW5kYXJ5ID0gdmFsdWUgPT09IG1pbiB8fCB2YWx1ZSA9PT0gbWF4O1xuICAgIGlmICh0aGlzLnN0ZXBfICYmICF2YWx1ZVNldFRvQm91bmRhcnkpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5xdWFudGl6ZV8odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgIHZhbHVlID0gbWluO1xuICAgIH0gZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cbiAgICB0aGlzLnZhbHVlXyA9IHZhbHVlO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU5PVywgU3RyaW5nKHRoaXMudmFsdWVfKSk7XG4gICAgdGhpcy51cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKTtcblxuICAgIGlmIChzaG91bGRGaXJlSW5wdXQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5SW5wdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzRGlzY3JldGVfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TWFya2VyVmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBxdWFudGl6ZWQgdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHF1YW50aXplXyh2YWx1ZSkge1xuICAgIGNvbnN0IG51bVN0ZXBzID0gTWF0aC5yb3VuZCh2YWx1ZSAvIHRoaXMuc3RlcF8pO1xuICAgIGNvbnN0IHF1YW50aXplZFZhbCA9IG51bVN0ZXBzICogdGhpcy5zdGVwXztcbiAgICByZXR1cm4gcXVhbnRpemVkVmFsO1xuICB9XG5cbiAgdXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCkge1xuICAgIGNvbnN0IHttYXhfOiBtYXgsIG1pbl86IG1pbiwgdmFsdWVfOiB2YWx1ZX0gPSB0aGlzO1xuICAgIGNvbnN0IHBjdENvbXBsZXRlID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIGxldCB0cmFuc2xhdGVQeCA9IHBjdENvbXBsZXRlICogdGhpcy5yZWN0Xy53aWR0aDtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5pc1JUTCgpKSB7XG4gICAgICB0cmFuc2xhdGVQeCA9IHRoaXMucmVjdF8ud2lkdGggLSB0cmFuc2xhdGVQeDtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1Qcm9wID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICd0cmFuc2Zvcm0nKTtcbiAgICBjb25zdCB0cmFuc2l0aW9uZW5kRXZ0TmFtZSA9IGdldENvcnJlY3RFdmVudE5hbWUod2luZG93LCAndHJhbnNpdGlvbmVuZCcpO1xuXG4gICAgaWYgKHRoaXMuaW5UcmFuc2l0Xykge1xuICAgICAgY29uc3Qgb25UcmFuc2l0aW9uRW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnNldEluVHJhbnNpdF8oZmFsc2UpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHJhbnNpdGlvbmVuZEV2dE5hbWUsIG9uVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVVSUZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAvLyBOT1RFKHRyYXZpc2thdWZtYW4pOiBJdCB3b3VsZCBiZSBuaWNlIHRvIHVzZSBjYWxjKCkgaGVyZSxcbiAgICAgIC8vIGJ1dCBJRSBjYW5ub3QgaGFuZGxlIGNhbGNzIGluIHRyYW5zZm9ybXMgY29ycmVjdGx5LlxuICAgICAgLy8gU2VlOiBodHRwczovL2dvby5nbC9OQzJpdGtcbiAgICAgIC8vIEFsc28gbm90ZSB0aGF0IHRoZSAtNTAlIG9mZnNldCBpcyB1c2VkIHRvIGNlbnRlciB0aGUgc2xpZGVyIHRodW1iLlxuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGVQeH1weCkgdHJhbnNsYXRlWCgtNTAlKWApO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFja1N0eWxlUHJvcGVydHkodHJhbnNmb3JtUHJvcCwgYHNjYWxlWCgke3BjdENvbXBsZXRlfSlgKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFjdGl2ZVxuICAgKi9cbiAgc2V0QWN0aXZlXyhhY3RpdmUpIHtcbiAgICB0aGlzLmFjdGl2ZV8gPSBhY3RpdmU7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5BQ1RJVkUsIHRoaXMuYWN0aXZlXyk7XG4gIH1cblxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgaW5UcmFuc2l0IHN0YXRlIG9mIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHtib29sZWFufSBpblRyYW5zaXRcbiAgICovXG4gIHNldEluVHJhbnNpdF8oaW5UcmFuc2l0KSB7XG4gICAgdGhpcy5pblRyYW5zaXRfID0gaW5UcmFuc2l0O1xuICAgIHRoaXMudG9nZ2xlQ2xhc3NfKGNzc0NsYXNzZXMuSU5fVFJBTlNJVCwgdGhpcy5pblRyYW5zaXRfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25kaXRpb25hbGx5IGFkZHMgb3IgcmVtb3ZlcyBhIGNsYXNzIGJhc2VkIG9uIHNob3VsZEJlUHJlc2VudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkQmVQcmVzZW50XG4gICAqL1xuICB0b2dnbGVDbGFzc18oY2xhc3NOYW1lLCBzaG91bGRCZVByZXNlbnQpIHtcbiAgICBpZiAoc2hvdWxkQmVQcmVzZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNsYXNzTmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGVyRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXNsaWRlclwiXG4gICAgdGFiaW5kZXg9XCIwXCJcbiAgICByb2xlPVwic2xpZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICA6c3R5bGU9XCJ0cmFja1N0eWxlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdHJhY2tcIi8+XG4gICAgICA8ZGl2XG4gICAgICAgIHYtaWY9XCJoYXNNYXJrZXJzXCJcbiAgICAgICAgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyXCI+XG4gICAgICAgIDxkaXZcbiAgICAgICAgICB2LWZvcj1cIm1hcmtlck51bSBpbiBudW1NYXJrZXJzXCJcbiAgICAgICAgICA6a2V5PVwibWFya2VyTnVtXCJcbiAgICAgICAgICA6c3R5bGU9XCIobWFya2VyTnVtID09IG51bU1hcmtlcnMpID8gbGFzdFRyYWNrTWFya2Vyc1N0eWxlcyA6IHt9XCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlclwiXG4gICAgICAgIC8+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgICA8ZGl2XG4gICAgICByZWY9XCJ0aHVtYkNvbnRhaW5lclwiXG4gICAgICA6c3R5bGU9XCJ0aHVtYlN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy1zbGlkZXJfX3RodW1iLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaXNEaXNjcmV0ZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwibWRjLXNsaWRlcl9fcGluLXZhbHVlLW1hcmtlclwiPnt7IG1hcmtlclZhbHVlIH19PC9zcGFuPlxuICAgICAgPC9kaXY+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzPVwibWRjLXNsaWRlcl9fdGh1bWJcIlxuICAgICAgICB3aWR0aD1cIjIxXCJcbiAgICAgICAgaGVpZ2h0PVwiMjFcIj5cbiAgICAgICAgPGNpcmNsZVxuICAgICAgICAgIGN4PVwiMTAuNVwiXG4gICAgICAgICAgY3k9XCIxMC41XCJcbiAgICAgICAgICByPVwiNy44NzVcIi8+XG4gICAgICA8L3N2Zz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19mb2N1cy1yaW5nXCIvPlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIGFwcGx5UGFzc2l2ZSB9IGZyb20gJy4uL2Jhc2UnXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgdmFsdWU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgbWluOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDAgfSxcbiAgICBtYXg6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMTAwIH0sXG4gICAgc3RlcDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgZGlzcGxheU1hcmtlcnM6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgbGF5b3V0T246IFN0cmluZyxcbiAgICBsYXlvdXRPblNvdXJjZTogeyB0eXBlOiBPYmplY3QsIHJlcXVpcmVkOiBmYWxzZSB9XG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc2NyZXRlJzogISF0aGlzLnN0ZXAsXG4gICAgICAgICdtZGMtc2xpZGVyLS1kaXNwbGF5LW1hcmtlcnMnOiB0aGlzLmRpc3BsYXlNYXJrZXJzXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIGlzRGlzY3JldGUoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXBcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnNcbiAgICB9XG4gIH0sXG4gIHdhdGNoOiB7XG4gICAgdmFsdWUoKSB7XG4gICAgICBpZiAodGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkgIT09IE51bWJlcih0aGlzLnZhbHVlKSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VmFsdWUodGhpcy52YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9LFxuICAgIG1heCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICB9LFxuICAgIHN0ZXAoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0U3RlcChOdW1iZXIodGhpcy5zdGVwKSlcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgZ2V0QXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLmdldEF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIHNldEF0dHJpYnV0ZTogKG5hbWUsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpLFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiBuYW1lID0+IHRoaXMuJGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IHRoaXMuJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgZ2V0VGFiSW5kZXg6ICgpID0+IHRoaXMuJGVsLnRhYkluZGV4LFxuICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBhcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLnRodW1iQ29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICBoYW5kbGVyLFxuICAgICAgICAgIGFwcGx5UGFzc2l2ZSgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICB0eXBlLFxuICAgICAgICAgIGhhbmRsZXIsXG4gICAgICAgICAgYXBwbHlQYXNzaXZlKClcbiAgICAgICAgKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgbm90aWZ5SW5wdXQ6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnaW5wdXQnLCB0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSlcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpXG4gICAgICB9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy50aHVtYlN0eWxlcywgcHJvcGVydHlOYW1lLCB2YWx1ZSlcbiAgICAgIH0sXG4gICAgICBzZXRUcmFja1N0eWxlUHJvcGVydHk6IChwcm9wZXJ0eU5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnRyYWNrU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZVxuICAgICAgfSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogbnVtTWFya2VycyA9PiB7XG4gICAgICAgIHRoaXMubnVtTWFya2VycyA9IG51bU1hcmtlcnNcbiAgICAgIH0sXG4gICAgICByZW1vdmVUcmFja01hcmtlcnM6ICgpID0+IHtcbiAgICAgICAgdGhpcy5udW1NYXJrZXJzID0gMFxuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGlzUlRMOiAoKSA9PiBmYWxzZVxuICAgIH0pXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpXG4gICAgaWYgKE51bWJlcih0aGlzLm1pbikgPD0gdGhpcy5mb3VuZGF0aW9uLmdldE1heCgpKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWluKE51bWJlcih0aGlzLm1pbikpXG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNYXgoTnVtYmVyKHRoaXMubWF4KSlcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSlcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKE51bWJlcih0aGlzLnZhbHVlKSlcbiAgICBpZiAodGhpcy5oYXNNYXJrZXJzKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0dXBUcmFja01hcmtlcigpXG4gICAgfVxuXG4gICAgdGhpcy4kcm9vdC4kb24oJ3ZtYTpsYXlvdXQnLCB0aGlzLmxheW91dClcblxuICAgIGlmICh0aGlzLmxheW91dE9uKSB7XG4gICAgICB0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UgPSB0aGlzLmxheW91dE9uU291cmNlIHx8IHRoaXMuJHJvb3RcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuJHJvb3QuJG9mZigndm1hOmxheW91dCcsIHRoaXMubGF5b3V0KVxuICAgIGlmICh0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb2ZmKHRoaXMubGF5b3V0T24sIHRoaXMubGF5b3V0KVxuICAgIH1cbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KClcbiAgICAgIH0pXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1NsaWRlciBmcm9tICcuL21kYy1zbGlkZXIudnVlJ1xuXG5leHBvcnQgeyBtZGNTbGlkZXIgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU2xpZGVyXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTbmFja2Jhci4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZzpcbiAqIC0gQ1NTIGNsYXNzZXNcbiAqIC0gRXZlbnQgaGFuZGxlcnNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1NuYWNrYmFyQWRhcHRlciB7XG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgYW5ub3VuY2UoKSB7fVxuXG4gIG5vdGlmeU9wZW5pbmcoKSB7fVxuICBub3RpZnlPcGVuZWQoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVhc29uXG4gICAqL1xuICBub3RpZnlDbG9zaW5nKHJlYXNvbikge31cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlYXNvblxuICAgKi9cbiAgbm90aWZ5Q2xvc2VkKHJlYXNvbikge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU25hY2tiYXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmNvbnN0IGNzc0NsYXNzZXMgPSB7XG4gIE9QRU5JTkc6ICdtZGMtc25hY2tiYXItLW9wZW5pbmcnLFxuICBPUEVOOiAnbWRjLXNuYWNrYmFyLS1vcGVuJyxcbiAgQ0xPU0lORzogJ21kYy1zbmFja2Jhci0tY2xvc2luZycsXG59O1xuXG5jb25zdCBzdHJpbmdzID0ge1xuICBTVVJGQUNFX1NFTEVDVE9SOiAnLm1kYy1zbmFja2Jhcl9fc3VyZmFjZScsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1zbmFja2Jhcl9fbGFiZWwnLFxuICBBQ1RJT05fU0VMRUNUT1I6ICcubWRjLXNuYWNrYmFyX19hY3Rpb24nLFxuICBESVNNSVNTX1NFTEVDVE9SOiAnLm1kYy1zbmFja2Jhcl9fZGlzbWlzcycsXG5cbiAgT1BFTklOR19FVkVOVDogJ01EQ1NuYWNrYmFyOm9wZW5pbmcnLFxuICBPUEVORURfRVZFTlQ6ICdNRENTbmFja2JhcjpvcGVuZWQnLFxuICBDTE9TSU5HX0VWRU5UOiAnTURDU25hY2tiYXI6Y2xvc2luZycsXG4gIENMT1NFRF9FVkVOVDogJ01EQ1NuYWNrYmFyOmNsb3NlZCcsXG5cbiAgUkVBU09OX0FDVElPTjogJ2FjdGlvbicsXG4gIFJFQVNPTl9ESVNNSVNTOiAnZGlzbWlzcycsXG5cbiAgQVJJQV9MSVZFX0xBQkVMX1RFWFRfQVRUUjogJ2RhdGEtbWRjLXNuYWNrYmFyLWxhYmVsLXRleHQnLFxufTtcblxuY29uc3QgbnVtYmVycyA9IHtcbiAgTUlOX0FVVE9fRElTTUlTU19USU1FT1VUX01TOiA0MDAwLFxuICBNQVhfQVVUT19ESVNNSVNTX1RJTUVPVVRfTVM6IDEwMDAwLFxuICBERUZBVUxUX0FVVE9fRElTTUlTU19USU1FT1VUX01TOiA1MDAwLFxuXG4gIC8vIFRoZXNlIHZhcmlhYmxlcyBuZWVkIHRvIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSB2YWx1ZXMgaW4gX3ZhcmlhYmxlcy5zY3NzLlxuICBTTkFDS0JBUl9BTklNQVRJT05fT1BFTl9USU1FX01TOiAxNTAsXG4gIFNOQUNLQkFSX0FOSU1BVElPTl9DTE9TRV9USU1FX01TOiA3NSxcblxuICAvKipcbiAgICogTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJldHdlZW4gdGVtcG9yYXJpbHkgY2xlYXJpbmcgdGhlIGxhYmVsIHRleHRcbiAgICogaW4gdGhlIERPTSBhbmQgc3Vic2VxdWVudGx5IHJlc3RvcmluZyBpdC4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gZm9yY2UgSUUgMTFcbiAgICogdG8gcGljayB1cCB0aGUgYGFyaWEtbGl2ZWAgY29udGVudCBjaGFuZ2UgYW5kIGFubm91bmNlIGl0IHRvIHRoZSB1c2VyLlxuICAgKi9cbiAgQVJJQV9MSVZFX0RFTEFZX01TOiAxMDAwLFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHtcImFyZ3NJZ25vcmVQYXR0ZXJuXCI6IFwiZXZ0XCIsIFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJBZGFwdGVyJFwifV0gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDU25hY2tiYXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIG51bWJlcnMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuY29uc3Qge09QRU5JTkcsIE9QRU4sIENMT1NJTkd9ID0gY3NzQ2xhc3NlcztcbmNvbnN0IHtSRUFTT05fQUNUSU9OLCBSRUFTT05fRElTTUlTU30gPSBzdHJpbmdzO1xuXG5jbGFzcyBNRENTbmFja2JhckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENTbmFja2JhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENTbmFja2JhckFkYXB0ZXJ9ICovICh7XG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgYW5ub3VuY2U6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5T3BlbmluZzogKCkgPT4ge30sXG4gICAgICBub3RpZnlPcGVuZWQ6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5Q2xvc2luZzogKC8qIHJlYXNvbjogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIG5vdGlmeUNsb3NlZDogKC8qIHJlYXNvbjogc3RyaW5nICovKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENTbmFja2JhckFkYXB0ZXI9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbmFja2JhckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzT3Blbl8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbWF0aW9uRnJhbWVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuYXV0b0Rpc21pc3NUaW1lcl8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hdXRvRGlzbWlzc1RpbWVvdXRNc18gPSBudW1iZXJzLkRFRkFVTFRfQVVUT19ESVNNSVNTX1RJTUVPVVRfTVM7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5jbG9zZU9uRXNjYXBlXyA9IHRydWU7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXJBdXRvRGlzbWlzc1RpbWVyXygpO1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVfKTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lXyA9IDA7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYW5pbWF0aW9uVGltZXJfKTtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVyXyA9IDA7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhPUEVOSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE9QRU4pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoQ0xPU0lORyk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuY2xlYXJBdXRvRGlzbWlzc1RpbWVyXygpO1xuICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlPcGVuaW5nKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhDTE9TSU5HKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9QRU5JTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYW5ub3VuY2UoKTtcblxuICAgIC8vIFdhaXQgYSBmcmFtZSBvbmNlIGRpc3BsYXkgaXMgbm8gbG9uZ2VyIFwibm9uZVwiLCB0byBlc3RhYmxpc2ggYmFzaXMgZm9yIGFuaW1hdGlvblxuICAgIHRoaXMucnVuTmV4dEFuaW1hdGlvbkZyYW1lXygoKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE9QRU4pO1xuXG4gICAgICB0aGlzLmFuaW1hdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpO1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeU9wZW5lZCgpO1xuICAgICAgICB0aGlzLmF1dG9EaXNtaXNzVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZShSRUFTT05fRElTTUlTUyk7XG4gICAgICAgIH0sIHRoaXMuZ2V0VGltZW91dE1zKCkpO1xuICAgICAgfSwgbnVtYmVycy5TTkFDS0JBUl9BTklNQVRJT05fT1BFTl9USU1FX01TKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHJlYXNvbiBXaHkgdGhlIHNuYWNrYmFyIHdhcyBjbG9zZWQuIFZhbHVlIHdpbGwgYmUgcGFzc2VkIHRvIENMT1NJTkdfRVZFTlQgYW5kIENMT1NFRF9FVkVOVCB2aWEgdGhlXG4gICAqICAgICBgZXZlbnQuZGV0YWlsLnJlYXNvbmAgcHJvcGVydHkuIFN0YW5kYXJkIHZhbHVlcyBhcmUgUkVBU09OX0FDVElPTiBhbmQgUkVBU09OX0RJU01JU1MsIGJ1dCBjdXN0b21cbiAgICogICAgIGNsaWVudC1zcGVjaWZpYyB2YWx1ZXMgbWF5IGFsc28gYmUgdXNlZCBpZiBkZXNpcmVkLlxuICAgKi9cbiAgY2xvc2UocmVhc29uID0gJycpIHtcbiAgICBpZiAoIXRoaXMuaXNPcGVuXykge1xuICAgICAgLy8gQXZvaWQgcmVkdW5kYW50IGNsb3NlIGNhbGxzIChhbmQgZXZlbnRzKSwgZS5nLiByZXBlYXRlZCBpbnRlcmFjdGlvbnMgYXMgdGhlIHNuYWNrYmFyIGlzIGFuaW1hdGluZyBjbG9zZWRcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1hdGlvbkZyYW1lXyk7XG4gICAgdGhpcy5hbmltYXRpb25GcmFtZV8gPSAwO1xuICAgIHRoaXMuY2xlYXJBdXRvRGlzbWlzc1RpbWVyXygpO1xuXG4gICAgdGhpcy5pc09wZW5fID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zaW5nKHJlYXNvbik7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLkNMT1NJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuT1BFTklORyk7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcl8pO1xuICAgIHRoaXMuYW5pbWF0aW9uVGltZXJfID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDbG9zZWQocmVhc29uKTtcbiAgICB9LCBudW1iZXJzLlNOQUNLQkFSX0FOSU1BVElPTl9DTE9TRV9USU1FX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGltZW91dE1zKCkge1xuICAgIHJldHVybiB0aGlzLmF1dG9EaXNtaXNzVGltZW91dE1zXztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZW91dE1zXG4gICAqL1xuICBzZXRUaW1lb3V0TXModGltZW91dE1zKSB7XG4gICAgLy8gVXNlIHNob3J0ZXIgdmFyaWFibGUgbmFtZXMgdG8gbWFrZSB0aGUgY29kZSBtb3JlIHJlYWRhYmxlXG4gICAgY29uc3QgbWluVmFsdWUgPSBudW1iZXJzLk1JTl9BVVRPX0RJU01JU1NfVElNRU9VVF9NUztcbiAgICBjb25zdCBtYXhWYWx1ZSA9IG51bWJlcnMuTUFYX0FVVE9fRElTTUlTU19USU1FT1VUX01TO1xuXG4gICAgaWYgKHRpbWVvdXRNcyA8PSBtYXhWYWx1ZSAmJiB0aW1lb3V0TXMgPj0gbWluVmFsdWUpIHtcbiAgICAgIHRoaXMuYXV0b0Rpc21pc3NUaW1lb3V0TXNfID0gdGltZW91dE1zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHRpbWVvdXRNcyBtdXN0IGJlIGFuIGludGVnZXIgaW4gdGhlIHJhbmdlICR7bWluVmFsdWV94oCTJHttYXhWYWx1ZX0sIGJ1dCBnb3QgJyR7dGltZW91dE1zfSdgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGdldENsb3NlT25Fc2NhcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvc2VPbkVzY2FwZV87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBjbG9zZU9uRXNjYXBlXG4gICAqL1xuICBzZXRDbG9zZU9uRXNjYXBlKGNsb3NlT25Fc2NhcGUpIHtcbiAgICB0aGlzLmNsb3NlT25Fc2NhcGVfID0gY2xvc2VPbkVzY2FwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUtleURvd24oZXZ0KSB7XG4gICAgaWYgKHRoaXMuZ2V0Q2xvc2VPbkVzY2FwZSgpICYmIChldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpKSB7XG4gICAgICB0aGlzLmNsb3NlKFJFQVNPTl9ESVNNSVNTKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTW91c2VFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVBY3Rpb25CdXR0b25DbGljayhldnQpIHtcbiAgICB0aGlzLmNsb3NlKFJFQVNPTl9BQ1RJT04pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1vdXNlRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlQWN0aW9uSWNvbkNsaWNrKGV2dCkge1xuICAgIHRoaXMuY2xvc2UoUkVBU09OX0RJU01JU1MpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGNsZWFyQXV0b0Rpc21pc3NUaW1lcl8oKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuYXV0b0Rpc21pc3NUaW1lcl8pO1xuICAgIHRoaXMuYXV0b0Rpc21pc3NUaW1lcl8gPSAwO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIGhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXygpIHtcbiAgICB0aGlzLmFuaW1hdGlvblRpbWVyXyA9IDA7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLk9QRU5JTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5DTE9TSU5HKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSBnaXZlbiBsb2dpYyBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUsIHVzaW5nIHNldFRpbWVvdXQgdG8gZmFjdG9yIGluIEZpcmVmb3ggcmVmbG93IGJlaGF2aW9yLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcnVuTmV4dEFuaW1hdGlvbkZyYW1lXyhjYWxsYmFjaykge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuYW5pbWF0aW9uRnJhbWVfKTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyYW1lXyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkZyYW1lXyA9IDA7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5hbmltYXRpb25UaW1lcl8pO1xuICAgICAgdGhpcy5hbmltYXRpb25UaW1lcl8gPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCAwKTtcbiAgICB9KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbmFja2JhckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgcmVmPVwicm9vdFwiIDpjbGFzcz1cImNsYXNzZXNcIiBjbGFzcz1cIm1kYy1zbmFja2JhclwiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtc25hY2tiYXJfX3N1cmZhY2VcIiBAY2xpY2s9XCJzdXJmYWNlQ2xpY2tIYW5kbGVyXCI+XG4gICAgICA8ZGl2XG4gICAgICAgIHJlZj1cImxhYmVsRWxcIlxuICAgICAgICBjbGFzcz1cIm1kYy1zbmFja2Jhcl9fbGFiZWxcIlxuICAgICAgICByb2xlPVwic3RhdHVzXCJcbiAgICAgICAgYXJpYS1saXZlPVwicG9saXRlXCJcbiAgICAgID5cbiAgICAgICAgPHRlbXBsYXRlIHYtaWY9XCJzaG93TGFiZWxUZXh0XCI+XG4gICAgICAgICAge3sgbGFiZWxUZXh0IH19XG4gICAgICAgIDwvdGVtcGxhdGU+XG4gICAgICAgIDxzcGFuIHN0eWxlPVwiZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMDsgaGVpZ2h0OiAxcHg7XCIgdi1lbHNlXG4gICAgICAgICAgPiZuYnNwOzwvc3BhblxuICAgICAgICA+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc25hY2tiYXJfX2FjdGlvbnNcIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIHJlZj1cImFjdGlvbkVsXCJcbiAgICAgICAgICB0eXBlPVwiYnV0dG9uXCJcbiAgICAgICAgICBjbGFzcz1cIm1kYy1idXR0b24gbWRjLXNuYWNrYmFyX19hY3Rpb25cIlxuICAgICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcbiAgICAgICAgPlxuICAgICAgICAgIHt7IGFjdGlvblRleHQgfX1cbiAgICAgICAgPC9idXR0b24+XG5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNsYXNzPVwibWRjLWljb24tYnV0dG9uIG1kYy1zbmFja2Jhcl9fZGlzbWlzcyBtYXRlcmlhbC1pY29uc1wiXG4gICAgICAgICAgdGl0bGU9XCJEaXNtaXNzXCJcbiAgICAgICAgICB2LWlmPVwic2hvd0Rpc21pc3NBY3Rpb25cIlxuICAgICAgICA+XG4gICAgICAgICAgY2xvc2VcbiAgICAgICAgPC9idXR0b24+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgPC9kaXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1NuYWNrYmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc25hY2tiYXIvZm91bmRhdGlvbidcbmltcG9ydCB7IGdldENvcnJlY3RFdmVudE5hbWUgfSBmcm9tICdAbWF0ZXJpYWwvYW5pbWF0aW9uL2luZGV4J1xuaW1wb3J0ICogYXMgcG9ueWZpbGwgZnJvbSAnQG1hdGVyaWFsL2RvbS9wb255ZmlsbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXNuYWNrYmFyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgb3BlbjogQm9vbGVhbixcbiAgICBzdGFja2VkOiBCb29sZWFuLFxuICAgIGxlYWRpbmc6IEJvb2xlYW4sXG4gICAgbGFiZWxUZXh0OiBTdHJpbmcsXG4gICAgYWN0aW9uVGV4dDogU3RyaW5nLFxuICAgIHRpbWVvdXRNczogW1N0cmluZywgTnVtYmVyXSxcblxuICAgIGRpc21pc3NBY3Rpb246IHsgdHlwZTogW1N0cmluZywgQm9vbGVhbl0sIGRlZmF1bHQ6IHRydWUgfVxuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7XG4gICAgICAgICdtZGMtc25hY2tiYXItLWxlYWRpbmcnOiB0aGlzLmxlYWRpbmcsXG5cbiAgICAgICAgJ21kYy1zbmFja2Jhci0tc3RhY2tlZCc6IHRoaXMuc3RhY2tlZFxuICAgICAgfSxcbiAgICAgIGhpZGRlbjogZmFsc2UsXG4gICAgICBhY3Rpb25IaWRkZW46IGZhbHNlLFxuICAgICAgc2hvd0xhYmVsVGV4dDogdHJ1ZVxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuOiAnb25PcGVuXycsXG5cbiAgICB0aW1lb3V0TXM6ICdvblRpbWVvdXRNc18nXG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleWRvd25FdmVudClcblxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbmFja2JhckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgYW5ub3VuY2U6ICgpID0+IHRoaXMuYW5ub3VuY2UodGhpcy4kcmVmcy5sYWJlbEVsKSxcbiAgICAgIG5vdGlmeU9wZW5pbmc6ICgpID0+XG4gICAgICAgIHRoaXMuJGVtaXQoTURDU25hY2tiYXJGb3VuZGF0aW9uLnN0cmluZ3MuT1BFTklOR19FVkVOVCwge30pLFxuICAgICAgbm90aWZ5T3BlbmVkOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoTURDU25hY2tiYXJGb3VuZGF0aW9uLnN0cmluZ3MuT1BFTkVEX0VWRU5ULCB7fSlcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdHJ1ZSlcbiAgICAgICAgdGhpcy4kZW1pdCgnc2hvdycsIHt9KVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3Npbmc6IHJlYXNvbiA9PlxuICAgICAgICB0aGlzLiRlbWl0KFxuICAgICAgICAgIE1EQ1NuYWNrYmFyRm91bmRhdGlvbi5zdHJpbmdzLkNMT1NJTkdfRVZFTlQsXG4gICAgICAgICAgcmVhc29uID8geyByZWFzb24gfSA6IHt9XG4gICAgICAgICksXG4gICAgICBub3RpZnlDbG9zZWQ6IHJlYXNvbiA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoXG4gICAgICAgICAgTURDU25hY2tiYXJGb3VuZGF0aW9uLnN0cmluZ3MuQ0xPU0VEX0VWRU5ULFxuICAgICAgICAgIHJlYXNvbiA/IHsgcmVhc29uIH0gOiB7fVxuICAgICAgICApXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGZhbHNlKVxuICAgICAgICB0aGlzLiRlbWl0KCdoaWRlJylcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcblxuICAgIGlmICh0aGlzLnRpbWVvdXRNcyAhPT0gdm9pZCAwKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VGltZW91dE1zKHRoaXMudGltZW91dE1zKVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzaG93RGlzbWlzc0FjdGlvbigpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5kaXNtaXNzQWN0aW9uID09PSAnc3RyaW5nJ1xuICAgICAgICA/IHRoaXMuZGlzbWlzc0FjdGlvbiAhPSAnZmFsc2UnXG4gICAgICAgIDogdGhpcy5kaXNtaXNzQWN0aW9uXG4gICAgfVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlkb3duRXZlbnQpXG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25UaW1lb3V0TXNfKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHZvaWQgMCkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uc2V0VGltZW91dE1zKHZhbHVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgb25PcGVuXyh2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5vcGVuKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpXG4gICAgICB9XG4gICAgfSxcbiAgICBzdXJmYWNlQ2xpY2tIYW5kbGVyKGV2dCkge1xuICAgICAgaWYgKHRoaXMuaXNBY3Rpb25CdXR0b25fKGV2dC50YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVBY3Rpb25CdXR0b25DbGljayhldnQpXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuaXNBY3Rpb25JY29uXyhldnQudGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQWN0aW9uSWNvbkNsaWNrKGV2dClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFuZGxlS2V5ZG93bkV2ZW50KGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUtleURvd24oZXZ0KVxuICAgIH0sXG5cbiAgICBpc0FjdGlvbkJ1dHRvbl8odGFyZ2V0KSB7XG4gICAgICByZXR1cm4gQm9vbGVhbihcbiAgICAgICAgcG9ueWZpbGwuY2xvc2VzdCh0YXJnZXQsIE1EQ1NuYWNrYmFyRm91bmRhdGlvbi5zdHJpbmdzLkFDVElPTl9TRUxFQ1RPUilcbiAgICAgIClcbiAgICB9LFxuXG4gICAgaXNBY3Rpb25JY29uXyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKFxuICAgICAgICBwb255ZmlsbC5jbG9zZXN0KHRhcmdldCwgTURDU25hY2tiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRElTTUlTU19TRUxFQ1RPUilcbiAgICAgIClcbiAgICB9LFxuXG4gICAgYW5ub3VuY2UoYXJpYUVsLCBsYWJlbEVsID0gYXJpYUVsKSB7XG4gICAgICBjb25zdCBwcmlvcml0eSA9IGFyaWFFbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScpXG5cbiAgICAgIGNvbnN0IHRleHQgPSB0aGlzLmxhYmVsVGV4dFxuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlIGBhcmlhLWxpdmVgIHRvIHByZXZlbnQgSkFXUytGaXJlZm94IGZyb20gYW5ub3VuY2luZyB0aGUgbWVzc2FnZSB0d2ljZS5cbiAgICAgIGFyaWFFbC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKVxuXG4gICAgICAvLyBUZW1wb3JhcmlseSBjbGVhciBgdGV4dENvbnRlbnRgIHRvIGZvcmNlIGEgRE9NIG11dGF0aW9uIGV2ZW50IHRoYXQgd2lsbCBiZSBkZXRlY3RlZCBieSBzY3JlZW4gcmVhZGVycy5cbiAgICAgIC8vIGBhcmlhLWxpdmVgIGVsZW1lbnRzIGFyZSBvbmx5IGFubm91bmNlZCB3aGVuIHRoZSBlbGVtZW50J3MgYHRleHRDb250ZW50YCAqY2hhbmdlcyosIHNvIHNuYWNrYmFyc1xuICAgICAgLy8gc2VudCB0byB0aGUgYnJvd3NlciBpbiB0aGUgaW5pdGlhbCBIVE1MIHJlc3BvbnNlIHdvbid0IGJlIHJlYWQgdW5sZXNzIHdlIGNsZWFyIHRoZSBlbGVtZW50J3MgYHRleHRDb250ZW50YCBmaXJzdC5cbiAgICAgIC8vIFNpbWlsYXJseSwgZGlzcGxheWluZyB0aGUgc2FtZSBzbmFja2JhciBtZXNzYWdlIHR3aWNlIGluIGEgcm93IGRvZXNuJ3QgdHJpZ2dlciBhIERPTSBtdXRhdGlvbiBldmVudCxcbiAgICAgIC8vIHNvIHNjcmVlbiByZWFkZXJzIHdvbid0IGFubm91bmNlIHRoZSBzZWNvbmQgbWVzc2FnZSB1bmxlc3Mgd2UgZmlyc3QgY2xlYXIgYHRleHRDb250ZW50YC5cbiAgICAgIC8vXG4gICAgICAvLyBXZSBoYXZlIHRvIGNsZWFyIHRoZSBsYWJlbCB0ZXh0IHR3byBkaWZmZXJlbnQgd2F5cyB0byBtYWtlIGl0IHdvcmsgaW4gYWxsIGJyb3dzZXJzIGFuZCBzY3JlZW4gcmVhZGVyczpcbiAgICAgIC8vXG4gICAgICAvLyAgIDEuIGB0ZXh0Q29udGVudCA9ICcnYCBpcyByZXF1aXJlZCBmb3IgSUUxMSArIEpBV1NcbiAgICAgIC8vICAgMi4gYGlubmVySFRNTCA9ICcmbmJzcDsnYCBpcyByZXF1aXJlZCBmb3IgQ2hyb21lICsgSkFXUyBhbmQgTlZEQVxuICAgICAgLy9cbiAgICAgIC8vIEFsbCBvdGhlciBicm93c2VyL3NjcmVlbiByZWFkZXIgY29tYmluYXRpb25zIHN1cHBvcnQgYm90aCBtZXRob2RzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSB3cmFwcGVyIGA8c3Bhbj5gIHZpc3VhbGx5IGhpZGVzIHRoZSBzcGFjZSBjaGFyYWN0ZXIgc28gdGhhdCBpdCBkb2Vzbid0IGNhdXNlIGphbmsgd2hlbiBhZGRlZC9yZW1vdmVkLlxuICAgICAgLy8gTi5CLjogU2V0dGluZyBgcG9zaXRpb246IGFic29sdXRlYCwgYG9wYWNpdHk6IDBgLCBvciBgaGVpZ2h0OiAwYCBwcmV2ZW50cyBDaHJvbWUgZnJvbSBkZXRlY3RpbmcgdGhlIERPTSBjaGFuZ2UuXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyB0ZWNobmlxdWUgaGFzIGJlZW4gdGVzdGVkIGluOlxuICAgICAgLy9cbiAgICAgIC8vICAgKiBKQVdTIDIwMTk6XG4gICAgICAvLyAgICAgICAtIENocm9tZSA3MFxuICAgICAgLy8gICAgICAgLSBGaXJlZm94IDYwIChFU1IpXG4gICAgICAvLyAgICAgICAtIElFIDExXG4gICAgICAvLyAgICogTlZEQSAyMDE4OlxuICAgICAgLy8gICAgICAgLSBDaHJvbWUgNzBcbiAgICAgIC8vICAgICAgIC0gRmlyZWZveCA2MCAoRVNSKVxuICAgICAgLy8gICAgICAgLSBJRSAxMVxuICAgICAgLy8gICAqIENocm9tZVZveCA1M1xuICAgICAgdGhpcy5zaG93TGFiZWxUZXh0ID0gZmFsc2VcblxuICAgICAgLy8gUHJldmVudCB2aXN1YWwgamFuayBieSB0ZW1wb3JhcmlseSBkaXNwbGF5aW5nIHRoZSBsYWJlbCB0ZXh0IGluIHRoZSA6OmJlZm9yZSBwc2V1ZG8tZWxlbWVudC5cbiAgICAgIC8vIENTUyBnZW5lcmF0ZWQgY29udGVudCBpcyBub3JtYWxseSBhbm5vdW5jZWQgYnkgc2NyZWVuIHJlYWRlcnNcbiAgICAgIC8vIChleGNlcHQgaW4gSUUgMTE7IHNlZSBodHRwczovL3RpbmsudWsvYWNjZXNzaWJpbGl0eS1zdXBwb3J0LWZvci1jc3MtZ2VuZXJhdGVkLWNvbnRlbnQvKTtcbiAgICAgIC8vIGhvd2V2ZXIsIGBhcmlhLWxpdmVgIGlzIHR1cm5lZCBvZmYsIHNvIHRoaXMgRE9NIHVwZGF0ZSB3aWxsIGJlIGlnbm9yZWQgYnkgc2NyZWVuIHJlYWRlcnMuXG4gICAgICBsYWJlbEVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgTURDU25hY2tiYXJGb3VuZGF0aW9uLnN0cmluZ3MuQVJJQV9MSVZFX0xBQkVMX1RFWFRfQVRUUixcbiAgICAgICAgdGhpcy5sYWJlbFRleHRcbiAgICAgIClcblxuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIC8vIEFsbG93IHNjcmVlbiByZWFkZXJzIHRvIGFubm91bmNlIGNoYW5nZXMgdG8gdGhlIERPTSBhZ2Fpbi5cbiAgICAgICAgYXJpYUVsLnNldEF0dHJpYnV0ZSgnYXJpYS1saXZlJywgcHJpb3JpdHkpXG5cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBtZXNzYWdlIGZyb20gdGhlIDo6YmVmb3JlIHBzZXVkby1lbGVtZW50LlxuICAgICAgICBsYWJlbEVsLnJlbW92ZUF0dHJpYnV0ZShcbiAgICAgICAgICBNRENTbmFja2JhckZvdW5kYXRpb24uc3RyaW5ncy5BUklBX0xJVkVfTEFCRUxfVEVYVF9BVFRSXG4gICAgICAgIClcblxuICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBsYWJlbCB0ZXh0LCB3aGljaCB3aWxsIGJlIGFubm91bmNlZCBieSBzY3JlZW4gcmVhZGVycy5cbiAgICAgICAgdGhpcy5zaG93TGFiZWxUZXh0ID0gdHJ1ZVxuICAgICAgfSwgTURDU25hY2tiYXJGb3VuZGF0aW9uLm51bWJlcnMuQVJJQV9MSVZFX0RFTEFZX01TKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTbmFja2JhciBmcm9tICcuL21kYy1zbmFja2Jhci52dWUnXG5cbmV4cG9ydCB7IG1kY1NuYWNrYmFyIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1NuYWNrYmFyXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBTd2l0Y2guIFByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgbWFuYWdpbmdcbiAqIC0gY2xhc3Nlc1xuICogLSBkb21cbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1N3aXRjaEFkYXB0ZXIge1xuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Jvb2xlYW59IGNoZWNrZWQgKi9cbiAgc2V0TmF0aXZlQ29udHJvbENoZWNrZWQoY2hlY2tlZCkge31cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXROYXRpdmVDb250cm9sRGlzYWJsZWQoZGlzYWJsZWQpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1N3aXRjaEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBDSEVDS0VEOiAnbWRjLXN3aXRjaC0tY2hlY2tlZCcsXG4gIERJU0FCTEVEOiAnbWRjLXN3aXRjaC0tZGlzYWJsZWQnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBOQVRJVkVfQ09OVFJPTF9TRUxFQ1RPUjogJy5tZGMtc3dpdGNoX19uYXRpdmUtY29udHJvbCcsXG4gIFJJUFBMRV9TVVJGQUNFX1NFTEVDVE9SOiAnLm1kYy1zd2l0Y2hfX3RodW1iLXVuZGVybGF5Jyxcbn07XG5cblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENTd2l0Y2hBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU3dpdGNoQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1N3aXRjaEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshTURDU3dpdGNoQWRhcHRlcn0gKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDU3dpdGNoQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXROYXRpdmVDb250cm9sQ2hlY2tlZDogKC8qIGNoZWNrZWQ6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgICAgc2V0TmF0aXZlQ29udHJvbERpc2FibGVkOiAoLyogZGlzYWJsZWQ6IGJvb2xlYW4gKi8pID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU3dpdGNoRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gY2hlY2tlZCAqL1xuICBzZXRDaGVja2VkKGNoZWNrZWQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE5hdGl2ZUNvbnRyb2xDaGVja2VkKGNoZWNrZWQpO1xuICAgIHRoaXMudXBkYXRlQ2hlY2tlZFN0eWxpbmdfKGNoZWNrZWQpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldE5hdGl2ZUNvbnRyb2xEaXNhYmxlZChkaXNhYmxlZCk7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuRElTQUJMRUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRElTQUJMRUQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBjaGFuZ2UgZXZlbnQgZm9yIHRoZSBzd2l0Y2ggbmF0aXZlIGNvbnRyb2wuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZUNoYW5nZShldnQpIHtcbiAgICB0aGlzLnVwZGF0ZUNoZWNrZWRTdHlsaW5nXyhldnQudGFyZ2V0LmNoZWNrZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0eWxpbmcgb2YgdGhlIHN3aXRjaCBiYXNlZCBvbiBpdHMgY2hlY2tlZCBzdGF0ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBjaGVja2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1cGRhdGVDaGVja2VkU3R5bGluZ18oY2hlY2tlZCkge1xuICAgIGlmIChjaGVja2VkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQ0hFQ0tFRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5DSEVDS0VEKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU3dpdGNoRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpjbGFzcz1cIntcbiAgICAgICdtZGMtZm9ybS1maWVsZCc6IGhhc0xhYmVsLFxuICAgICAgJ21kYy1mb3JtLWZpZWxkLS1hbGlnbi1lbmQnOiBoYXNMYWJlbCAmJiBhbGlnbkVuZFxuICAgIH1cIlxuICAgIGNsYXNzPVwibWRjLXN3aXRjaC13cmFwcGVyXCIgPlxuXG4gICAgPGRpdlxuICAgICAgOmNsYXNzPVwiY2xhc3Nlc1wiXG4gICAgICA6c3R5bGVzPVwic3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaFwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zd2l0Y2hfX3RyYWNrXCIgLz5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc3dpdGNoX190aHVtYi11bmRlcmxheVwiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwibWRjLXN3aXRjaF9fdGh1bWJcIj5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHJlZj1cImNvbnRyb2xcIlxuICAgICAgICAgICAgOm5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgICAgIDp2YWx1ZT1cInZhbHVlXCJcbiAgICAgICAgICAgIHR5cGU9XCJjaGVja2JveFwiXG4gICAgICAgICAgICByb2xlPVwic3dpdGNoXCJcbiAgICAgICAgICAgIGNsYXNzPVwibWRjLXN3aXRjaF9fbmF0aXZlLWNvbnRyb2xcIlxuICAgICAgICAgICAgQGNoYW5nZT1cIm9uQ2hhbmdlZFwiID5cblxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGxhYmVsXG4gICAgICB2LWlmPVwiaGFzTGFiZWxcIlxuICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgIGNsYXNzPVwibWRjLXN3aXRjaC1sYWJlbFwiPlxuICAgICAgPHNsb3Q+e3sgbGFiZWwgfX08L3Nsb3Q+XG4gICAgPC9sYWJlbD5cblxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHsgUmlwcGxlQmFzZSB9IGZyb20gJy4uL3JpcHBsZSdcbmltcG9ydCBNRENTd2l0Y2hGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9zd2l0Y2gvZm91bmRhdGlvbidcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXN3aXRjaCcsXG4gIG1peGluczogW0Rpc3BhdGNoRm9jdXNNaXhpbiwgVk1BVW5pcXVlSWRNaXhpbl0sXG4gIG1vZGVsOiB7XG4gICAgcHJvcDogJ2NoZWNrZWQnLFxuICAgIGV2ZW50OiAnY2hhbmdlJ1xuICB9LFxuICBwcm9wczoge1xuICAgIGNoZWNrZWQ6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgdmFsdWU6IFN0cmluZyxcbiAgICBsYWJlbDogU3RyaW5nLFxuICAgIGFsaWduRW5kOiBCb29sZWFuLFxuICAgIG5hbWU6IFN0cmluZ1xuICB9LFxuICBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYWJlbCB8fCB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGNoZWNrZWQodmFsdWUpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uc2V0Q2hlY2tlZCh2YWx1ZSlcbiAgICB9LFxuICAgIGRpc2FibGVkKHZhbHVlKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHZhbHVlKVxuICAgIH1cbiAgfSxcblxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTd2l0Y2hGb3VuZGF0aW9uKHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIHNldE5hdGl2ZUNvbnRyb2xDaGVja2VkOiBjaGVja2VkID0+XG4gICAgICAgICh0aGlzLiRyZWZzLmNvbnRyb2wuY2hlY2tlZCA9IGNoZWNrZWQpLFxuICAgICAgc2V0TmF0aXZlQ29udHJvbERpc2FibGVkOiBkaXNhYmxlZCA9PlxuICAgICAgICAodGhpcy4kcmVmcy5jb250cm9sLmRpc2FibGVkID0gZGlzYWJsZWQpXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldENoZWNrZWQodGhpcy5jaGVja2VkKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95KCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBvbkNoYW5nZWQoZXZlbnQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uaGFuZGxlQ2hhbmdlKGV2ZW50KVxuICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZlbnQudGFyZ2V0LmNoZWNrZWQpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1N3aXRjaCBmcm9tICcuL21kYy1zd2l0Y2gudnVlJ1xuXG5leHBvcnQgeyBtZGNTd2l0Y2ggfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjU3dpdGNoXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIE1EQ1RhYkRpbWVuc2lvbnMgcHJvdmlkZXMgZGV0YWlscyBhYm91dCB0aGUgbGVmdCBhbmQgcmlnaHQgZWRnZXMgb2YgdGhlIFRhYlxuICogcm9vdCBlbGVtZW50IGFuZCB0aGUgVGFiIGNvbnRlbnQgZWxlbWVudC4gVGhlc2UgdmFsdWVzIGFyZSB1c2VkIHRvIGRldGVybWluZVxuICogdGhlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgVGFiIHdpdGggcmVzcGVjdCBpdCdzIHBhcmVudCBjb250YWluZXIuXG4gKiBAdHlwZWRlZiB7e3Jvb3RMZWZ0OiBudW1iZXIsIHJvb3RSaWdodDogbnVtYmVyLCBjb250ZW50TGVmdDogbnVtYmVyLCBjb250ZW50UmlnaHQ6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJEaW1lbnNpb25zO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIGRldGFpbDoge1xuICogICAgIHRhYklkOiBzdHJpbmcsXG4gKiAgIH0sXG4gKiAgIGJ1YmJsZXM6IGJvb2xlYW4sXG4gKiB9fVxuICovXG5sZXQgTURDVGFiSW50ZXJhY3Rpb25FdmVudFR5cGU7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYi5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gYWRkXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzTmFtZSBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSByb290IGVsZW1lbnQgaGFzIHRoZSBnaXZlbiBjbGFzc05hbWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgZ2l2ZW4gYXR0ck5hbWUgb2YgdGhlIHJvb3QgZWxlbWVudCB0byB0aGUgZ2l2ZW4gdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSBzbyBnaXZlIHRoZSBhdHRyaWJ1dGVcbiAgICovXG4gIHNldEF0dHIoYXR0ciwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgaW5kaWNhdG9yIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QgVGhlIGNsaWVudCByZWN0IG9mIHRoZSBwcmV2aW91c2x5IGFjdGl2YXRlZCBpbmRpY2F0b3JcbiAgICovXG4gIGFjdGl2YXRlSW5kaWNhdG9yKHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCkge31cblxuICAvKiogRGVhY3RpdmF0ZXMgdGhlIGluZGljYXRvci4gKi9cbiAgZGVhY3RpdmF0ZUluZGljYXRvcigpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBNRENUYWI6aW50ZXJhY3RlZCBldmVudCBmb3IgdXNlIGJ5IHBhcmVudCBjb21wb25lbnRzXG4gICAqL1xuICBub3RpZnlJbnRlcmFjdGVkKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0TGVmdCB2YWx1ZSBvZiB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggdmFsdWUgb2YgdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXRMZWZ0IG9mIHRoZSBjb250ZW50IGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldENvbnRlbnRPZmZzZXRMZWZ0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgb2Zmc2V0V2lkdGggb2YgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0Q29udGVudE9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogQXBwbGllcyBmb2N1cyB0byB0aGUgcm9vdCBlbGVtZW50XG4gICAqL1xuICBmb2N1cygpIHt9XG59XG5cbmV4cG9ydCB7TURDVGFiRGltZW5zaW9ucywgTURDVGFiSW50ZXJhY3Rpb25FdmVudFR5cGUsIE1EQ1RhYkFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi0tYWN0aXZlJyxcbn07XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgQVJJQV9TRUxFQ1RFRDogJ2FyaWEtc2VsZWN0ZWQnLFxuICBSSVBQTEVfU0VMRUNUT1I6ICcubWRjLXRhYl9fcmlwcGxlJyxcbiAgQ09OVEVOVF9TRUxFQ1RPUjogJy5tZGMtdGFiX19jb250ZW50JyxcbiAgVEFCX0lORElDQVRPUl9TRUxFQ1RPUjogJy5tZGMtdGFiLWluZGljYXRvcicsXG4gIFRBQklOREVYOiAndGFiSW5kZXgnLFxuICBJTlRFUkFDVEVEX0VWRU5UOiAnTURDVGFiOmludGVyYWN0ZWQnLFxufTtcblxuZXhwb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYkFkYXB0ZXIsIE1EQ1RhYkRpbWVuc2lvbnN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbmltcG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgTURDVGFiQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJBZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiQWRhcHRlcn0gKi8gKHtcbiAgICAgIGFkZENsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoKSA9PiB7fSxcbiAgICAgIGhhc0NsYXNzOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVJbmRpY2F0b3I6ICgpID0+IHt9LFxuICAgICAgZGVhY3RpdmF0ZUluZGljYXRvcjogKCkgPT4ge30sXG4gICAgICBub3RpZnlJbnRlcmFjdGVkOiAoKSA9PiB7fSxcbiAgICAgIGdldE9mZnNldExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0T2Zmc2V0V2lkdGg6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29udGVudE9mZnNldExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0Q29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGZvY3VzOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENUYWJBZGFwdGVyfSBhZGFwdGVyICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmZvY3VzT25BY3RpdmF0ZV8gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIFwiY2xpY2tcIiBldmVudFxuICAgKi9cbiAgaGFuZGxlQ2xpY2soKSB7XG4gICAgLy8gSXQncyB1cCB0byB0aGUgcGFyZW50IGNvbXBvbmVudCB0byBrZWVwIHRyYWNrIG9mIHRoZSBhY3RpdmUgVGFiIGFuZFxuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCBhY3RpdmF0ZSBhIFRhYiB0aGF0J3MgYWxyZWFkeSBhY3RpdmUuXG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnRlcmFjdGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgVGFiJ3MgYWN0aXZlIHN0YXRlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB3aGV0aGVyIHRoZSB0YWIgc2hvdWxkIGZvY3VzIGl0c2VsZiB3aGVuIGFjdGl2YXRlZFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZvY3VzT25BY3RpdmF0ZVxuICAgKi9cbiAgc2V0Rm9jdXNPbkFjdGl2YXRlKGZvY3VzT25BY3RpdmF0ZSkge1xuICAgIHRoaXMuZm9jdXNPbkFjdGl2YXRlXyA9IGZvY3VzT25BY3RpdmF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIFRhYlxuICAgKiBAcGFyYW0geyFDbGllbnRSZWN0PX0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX1NFTEVDVEVELCAndHJ1ZScpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cihzdHJpbmdzLlRBQklOREVYLCAnMCcpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVJbmRpY2F0b3IocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KTtcbiAgICBpZiAodGhpcy5mb2N1c09uQWN0aXZhdGVfKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBUYWJcbiAgICovXG4gIGRlYWN0aXZhdGUoKSB7XG4gICAgLy8gRWFybHkgZXhpdFxuICAgIGlmICghdGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuQVJJQV9TRUxFQ1RFRCwgJ2ZhbHNlJyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuVEFCSU5ERVgsICctMScpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZUluZGljYXRvcigpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIFRhYlxuICAgKiBAcmV0dXJuIHshTURDVGFiRGltZW5zaW9uc31cbiAgICovXG4gIGNvbXB1dGVEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290TGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0T2Zmc2V0TGVmdCgpO1xuICAgIGNvbnN0IGNvbnRlbnRXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0Q29udGVudE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgY29udGVudExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldENvbnRlbnRPZmZzZXRMZWZ0KCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcm9vdExlZnQsXG4gICAgICByb290UmlnaHQ6IHJvb3RMZWZ0ICsgcm9vdFdpZHRoLFxuICAgICAgY29udGVudExlZnQ6IHJvb3RMZWZ0ICsgY29udGVudExlZnQsXG4gICAgICBjb250ZW50UmlnaHQ6IHJvb3RMZWZ0ICsgY29udGVudExlZnQgKyBjb250ZW50V2lkdGgsXG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGlua1xyXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiXHJcbiAgICA6c3R5bGU9XCJzdHlsZXNcIlxyXG4gICAgOmxpbms9XCJsaW5rXCJcclxuICAgIGNsYXNzPVwibWRjLXRhYlwiXHJcbiAgICBAY2xpY2s9XCJoYW5kbGVDbGlja1wiXHJcbiAgICByb2xlPVwidGFiXCJcclxuICAgIGFyaWEtc2VsZWN0ZWQ9XCJmYWxzZVwiXHJcbiAgICB0YWJpbmRleD1cIi0xXCJcclxuICA+XHJcbiAgICA8c3BhbiByZWY9XCJjb250ZW50XCIgY2xhc3M9XCJtZGMtdGFiX19jb250ZW50XCI+XHJcbiAgICAgIDxpXHJcbiAgICAgICAgdi1pZj1cIiEhaGFzSWNvblwiXHJcbiAgICAgICAgcmVmPVwiaWNvblwiXHJcbiAgICAgICAgOmNsYXNzPVwiaGFzSWNvbi5jbGFzc2VzXCJcclxuICAgICAgICB0YWJpbmRleD1cIjBcIlxyXG4gICAgICAgIGNsYXNzPVwibWRjLXRhYl9faWNvblwiXHJcbiAgICAgICAgYXJpYS1oaWRkZW49XCJ0cnVlXCJcclxuICAgICAgPlxyXG4gICAgICAgIDxzbG90IG5hbWU9XCJpY29uXCI+e3sgaGFzSWNvbi5jb250ZW50IH19PC9zbG90PlxyXG4gICAgICA8L2k+XHJcblxyXG4gICAgICA8c3BhbiB2LWlmPVwiaGFzVGV4dFwiIGNsYXNzPVwibWRjLXRhYl9fdGV4dC1sYWJlbFwiPiA8c2xvdCAvPiA8L3NwYW4+XHJcbiAgICA8L3NwYW4+XHJcblxyXG4gICAgPG1kYy10YWItaW5kaWNhdG9yIHJlZj1cInRhYkluZGljYXRvclwiPjwvbWRjLXRhYi1pbmRpY2F0b3I+XHJcbiAgICA8bWRjLXRhYi1yaXBwbGU+PC9tZGMtdGFiLXJpcHBsZT5cclxuICA8L2N1c3RvbS1saW5rPlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IE1EQ1RhYkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RhYi9mb3VuZGF0aW9uJ1xyXG5pbXBvcnQge1xyXG4gIEN1c3RvbUxpbmtNaXhpbixcclxuICBEaXNwYXRjaEV2ZW50TWl4aW4sXHJcbiAgZW1pdEN1c3RvbUV2ZW50LFxyXG4gIGV4dHJhY3RJY29uUHJvcFxyXG59IGZyb20gJy4uL2Jhc2UnXHJcbmltcG9ydCB7IFJpcHBsZUJhc2UgfSBmcm9tICcuLi9yaXBwbGUnXHJcblxyXG5leHBvcnQgZGVmYXVsdCB7XHJcbiAgbmFtZTogJ21kYy10YWInLFxyXG4gIG1peGluczogW0N1c3RvbUxpbmtNaXhpbiwgRGlzcGF0Y2hFdmVudE1peGluXSxcclxuICBwcm9wczoge1xyXG4gICAgYWN0aXZlOiBCb29sZWFuLFxyXG4gICAgaWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXHJcbiAgICBzdGFja2VkOiBCb29sZWFuLFxyXG4gICAgbWluV2lkdGg6IEJvb2xlYW5cclxuICB9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7XHJcbiAgICAgICAgJ21kYy10YWItLXN0YWNrZWQnOiB0aGlzLnN0YWNrZWQsXHJcbiAgICAgICAgJ21kYy10YWItLW1pbi13aWR0aCc6IHRoaXMubWluV2lkdGhcclxuICAgICAgfSxcclxuICAgICAgc3R5bGVzOiB7fVxyXG4gICAgfVxyXG4gIH0sXHJcblxyXG4gIGluamVjdDogWydtZGNUYWJCYXInXSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgaGFzSWNvbigpIHtcclxuICAgICAgaWYgKHRoaXMuaWNvbiB8fCB0aGlzLiRzbG90cy5pY29uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaWNvbiA/IGV4dHJhY3RJY29uUHJvcCh0aGlzLmljb24pIDoge31cclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZmFsc2VcclxuICAgIH0sXHJcbiAgICBoYXNUZXh0KCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLiRzbG90cy5kZWZhdWx0XHJcbiAgICB9XHJcbiAgfSxcclxuICB3YXRjaDoge1xyXG4gICAgYWN0aXZlKHZhbHVlKSB7fVxyXG4gIH0sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUYWJGb3VuZGF0aW9uKHtcclxuICAgICAgc2V0QXR0cjogKGF0dHIsIHZhbHVlKSA9PiB0aGlzLiRlbC5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxyXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXHJcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcclxuICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKSxcclxuICAgICAgYWN0aXZhdGVJbmRpY2F0b3I6IHByZXZpb3VzSW5kaWNhdG9yQ2xpZW50UmVjdCA9PiB7XHJcbiAgICAgICAgdGhpcy4kcmVmcy50YWJJbmRpY2F0b3IuYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KVxyXG4gICAgICB9LFxyXG4gICAgICBkZWFjdGl2YXRlSW5kaWNhdG9yOiAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy4kcmVmcy50YWJJbmRpY2F0b3IuZGVhY3RpdmF0ZSgpXHJcbiAgICAgIH0sXHJcbiAgICAgIG5vdGlmeUludGVyYWN0ZWQ6ICgpID0+XHJcbiAgICAgICAgZW1pdEN1c3RvbUV2ZW50KFxyXG4gICAgICAgICAgdGhpcy4kZWwsXHJcbiAgICAgICAgICBNRENUYWJGb3VuZGF0aW9uLnN0cmluZ3MuSU5URVJBQ1RFRF9FVkVOVCxcclxuICAgICAgICAgIHsgdGFiOiB0aGlzIH0sXHJcbiAgICAgICAgICB0cnVlIC8qIGJ1YmJsZSAqL1xyXG4gICAgICAgICksXHJcbiAgICAgIGdldE9mZnNldExlZnQ6ICgpID0+IHRoaXMuJGVsLm9mZnNldExlZnQsXHJcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLiRlbC5vZmZzZXRXaWR0aCxcclxuICAgICAgZ2V0Q29udGVudE9mZnNldExlZnQ6ICgpID0+IHRoaXMuJHJlZnMuY29udGVudC5vZmZzZXRMZWZ0LFxyXG4gICAgICBnZXRDb250ZW50T2Zmc2V0V2lkdGg6ICgpID0+IHRoaXMuJHJlZnMuY29udGVudC5vZmZzZXRXaWR0aCxcclxuICAgICAgZm9jdXM6ICgpID0+IHRoaXMuJGVsLmZvY3VzKClcclxuICAgIH0pXHJcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXHJcblxyXG4gICAgLy8gY29uc29sZS5sb2coJ3RhYiBtb3VudGVkJylcclxuXHJcbiAgICB0aGlzLm1kY1RhYkJhci50YWJMaXN0LnB1c2godGhpcylcclxuXHJcbiAgICAvLyB0aGlzLnNldEFjdGl2ZSh0aGlzLmFjdGl2ZSlcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXHJcbiAgfSxcclxuICBtZXRob2RzOiB7XHJcbiAgICBhY3RpdmF0ZShjb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCkge1xyXG4gICAgICB0aGlzLmZvdW5kYXRpb24uYWN0aXZhdGUoY29tcHV0ZUluZGljYXRvckNsaWVudFJlY3QpXHJcbiAgICB9LFxyXG5cclxuICAgIGRlYWN0aXZhdGUoKSB7XHJcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5kZWFjdGl2YXRlKClcclxuICAgIH0sXHJcbiAgICBoYW5kbGVDbGljayhldnQpIHtcclxuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUNsaWNrKGV2dClcclxuICAgIH0sXHJcbiAgICBpc0FjdGl2ZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5pc0FjdGl2ZSgpXHJcbiAgICB9LFxyXG4gICAgc2V0QWN0aXZlKGlzQWN0aXZlKSB7XHJcbiAgICAgIGlmIChpc0FjdGl2ZSkge1xyXG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsICdtZGMtdGFiLS1hY3RpdmUnLCB0cnVlKSxcclxuICAgICAgICAgIHRoaXMuJHJlZnMudGFiSW5kaWNhdG9yLmFjdGl2YXRlKClcclxuICAgICAgfVxyXG4gICAgfSxcclxuICAgIGNvbXB1dGVJbmRpY2F0b3JDbGllbnRSZWN0KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy50YWJJbmRpY2F0b3IuY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KClcclxuICAgIH0sXHJcblxyXG4gICAgY29tcHV0ZURpbWVuc2lvbnMoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmZvdW5kYXRpb24uY29tcHV0ZURpbWVuc2lvbnMoKVxyXG4gICAgfSxcclxuXHJcbiAgICBmb2N1cygpIHtcclxuICAgICAgdGhpcy4kZWwuZm9jdXMoKVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG48L3NjcmlwdD5cclxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVEFCX0FDVElWQVRFRF9FVkVOVDogJ01EQ1RhYkJhcjphY3RpdmF0ZWQnLFxuICBUQUJfU0NST0xMRVJfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcicsXG4gIFRBQl9TRUxFQ1RPUjogJy5tZGMtdGFiJyxcbiAgQVJST1dfTEVGVF9LRVk6ICdBcnJvd0xlZnQnLFxuICBBUlJPV19SSUdIVF9LRVk6ICdBcnJvd1JpZ2h0JyxcbiAgRU5EX0tFWTogJ0VuZCcsXG4gIEhPTUVfS0VZOiAnSG9tZScsXG4gIEVOVEVSX0tFWTogJ0VudGVyJyxcbiAgU1BBQ0VfS0VZOiAnU3BhY2UnLFxufTtcblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5jb25zdCBudW1iZXJzID0ge1xuICBFWFRSQV9TQ1JPTExfQU1PVU5UOiAyMCxcbiAgQVJST1dfTEVGVF9LRVlDT0RFOiAzNyxcbiAgQVJST1dfUklHSFRfS0VZQ09ERTogMzksXG4gIEVORF9LRVlDT0RFOiAzNSxcbiAgSE9NRV9LRVlDT0RFOiAzNixcbiAgRU5URVJfS0VZQ09ERTogMTMsXG4gIFNQQUNFX0tFWUNPREU6IDMyLFxufTtcblxuZXhwb3J0IHtcbiAgbnVtYmVycyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYkRpbWVuc2lvbnN9IGZyb20gJ0BtYXRlcmlhbC90YWIvYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYiBCYXIuXG4gKlxuICogRGVmaW5lcyB0aGUgc2hhcGUgb2YgdGhlIGFkYXB0ZXIgZXhwZWN0ZWQgYnkgdGhlIGZvdW5kYXRpb24uIEltcGxlbWVudCB0aGlzXG4gKiBhZGFwdGVyIHRvIGludGVncmF0ZSB0aGUgVGFiIEJhciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGFiQmFyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBTY3JvbGxzIHRvIHRoZSBnaXZlbiBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgcG9zaXRpb24gdG8gc2Nyb2xsIHRvXG4gICAqL1xuICBzY3JvbGxUbyhzY3JvbGxYKSB7fVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnRzIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBieSB0aGUgZ2l2ZW4gYW1vdW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYSW5jcmVtZW50IFRoZSBhbW91bnQgdG8gaW5jcmVtZW50IHNjcm9sbFxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbENvbnRlbnRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3QgZWxlbWVudCdzIG9mZnNldFdpZHRoXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldE9mZnNldFdpZHRoKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgVGFiIEJhciBsYW5ndWFnZSBkaXJlY3Rpb24gaXMgUlRMXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1JUTCgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggdG8gYmUgYWN0aXZhdGVkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBhY3RpdmF0ZVxuICAgKi9cbiAgc2V0QWN0aXZlVGFiKGluZGV4KSB7fVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggd2l0aCB0aGUgZ2l2ZW4gY2xpZW50IHJlY3RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiIHRvIGFjdGl2YXRlXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3R9IGNsaWVudFJlY3QgVGhlIGNsaWVudCByZWN0IG9mIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBUYWIgSW5kaWNhdG9yXG4gICAqL1xuICBhY3RpdmF0ZVRhYkF0SW5kZXgoaW5kZXgsIGNsaWVudFJlY3QpIHt9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSB0YWIgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYiB0byBkZWFjdGl2YXRlXG4gICAqL1xuICBkZWFjdGl2YXRlVGFiQXRJbmRleChpbmRleCkge31cblxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gZm9jdXNcbiAgICovXG4gIGZvY3VzVGFiQXRJbmRleChpbmRleCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xpZW50IHJlY3Qgb2YgdGhlIHRhYidzIGluZGljYXRvclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleChpbmRleCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGRpbWVuc2lvbnMgb2YgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEByZXR1cm4geyFNRENUYWJEaW1lbnNpb25zfVxuICAgKi9cbiAgZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgoaW5kZXgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgdGFiIGxpc3RcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0VGFiTGlzdExlbmd0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSB0YWJcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmb2N1c2VkIHRhYlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRGb2N1c2VkVGFiSW5kZXgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZ2l2ZW4gdGFiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHRhYiB3aG9zZSBpbmRleCB0byBkZXRlcm1pbmVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0SW5kZXhPZlRhYkJ5SWQoaWQpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIHRoZSBNRENUYWJCYXI6YWN0aXZhdGVkIGV2ZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIGFjdGl2YXRlZCB0YWJcbiAgICovXG4gIG5vdGlmeVRhYkFjdGl2YXRlZChpbmRleCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiQmFyQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuaW1wb3J0IHtzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgTURDVGFiQmFyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJEaW1lbnNpb25zfSBmcm9tICdAbWF0ZXJpYWwvdGFiL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAqL1xuY29uc3QgQUNDRVBUQUJMRV9LRVlTID0gbmV3IFNldCgpO1xuLy8gSUUxMSBoYXMgbm8gc3VwcG9ydCBmb3IgbmV3IFNldCB3aXRoIGl0ZXJhYmxlIHNvIHdlIG5lZWQgdG8gaW5pdGlhbGl6ZSB0aGlzIGJ5IGhhbmRcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5BUlJPV19MRUZUX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuQVJST1dfUklHSFRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5FTkRfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5IT01FX0tFWSk7XG5BQ0NFUFRBQkxFX0tFWVMuYWRkKHN0cmluZ3MuRU5URVJfS0VZKTtcbkFDQ0VQVEFCTEVfS0VZUy5hZGQoc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEB0eXBlIHtNYXA8bnVtYmVyLCBzdHJpbmc+fVxuICovXG5jb25zdCBLRVlDT0RFX01BUCA9IG5ldyBNYXAoKTtcbi8vIElFMTEgaGFzIG5vIHN1cHBvcnQgZm9yIG5ldyBNYXAgd2l0aCBpdGVyYWJsZSBzbyB3ZSBuZWVkIHRvIGluaXRpYWxpemUgdGhpcyBieSBoYW5kXG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5BUlJPV19MRUZUX0tFWUNPREUsIHN0cmluZ3MuQVJST1dfTEVGVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuQVJST1dfUklHSFRfS0VZQ09ERSwgc3RyaW5ncy5BUlJPV19SSUdIVF9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5EX0tFWUNPREUsIHN0cmluZ3MuRU5EX0tFWSk7XG5LRVlDT0RFX01BUC5zZXQobnVtYmVycy5IT01FX0tFWUNPREUsIHN0cmluZ3MuSE9NRV9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuRU5URVJfS0VZQ09ERSwgc3RyaW5ncy5FTlRFUl9LRVkpO1xuS0VZQ09ERV9NQVAuc2V0KG51bWJlcnMuU1BBQ0VfS0VZQ09ERSwgc3RyaW5ncy5TUEFDRV9LRVkpO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJCYXJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJCYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJCYXJBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkJhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgc2Nyb2xsVG86ICgpID0+IHt9LFxuICAgICAgaW5jcmVtZW50U2Nyb2xsOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbFBvc2l0aW9uOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbENvbnRlbnRXaWR0aDogKCkgPT4ge30sXG4gICAgICBnZXRPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBpc1JUTDogKCkgPT4ge30sXG4gICAgICBzZXRBY3RpdmVUYWI6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVUYWJBdEluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGZvY3VzVGFiQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRQcmV2aW91c0FjdGl2ZVRhYkluZGV4OiAoKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzZWRUYWJJbmRleDogKCkgPT4ge30sXG4gICAgICBnZXRJbmRleE9mVGFiQnlJZDogKCkgPT4ge30sXG4gICAgICBnZXRUYWJMaXN0TGVuZ3RoOiAoKSA9PiB7fSxcbiAgICAgIG5vdGlmeVRhYkFjdGl2YXRlZDogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGFiQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKiAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUYWJCYXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy51c2VBdXRvbWF0aWNBY3RpdmF0aW9uXyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGJldHdlZW4gYXV0b21hdGljIGFuZCBtYW51YWwgYWN0aXZhdGlvbiBtb2Rlcy5cbiAgICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93YWktYXJpYS1wcmFjdGljZXMvI3RhYnBhbmVsIGZvciBleGFtcGxlcy5cbiAgICogQHBhcmFtIHtib29sZWFufSB1c2VBdXRvbWF0aWNBY3RpdmF0aW9uXG4gICAqL1xuICBzZXRVc2VBdXRvbWF0aWNBY3RpdmF0aW9uKHVzZUF1dG9tYXRpY0FjdGl2YXRpb24pIHtcbiAgICB0aGlzLnVzZUF1dG9tYXRpY0FjdGl2YXRpb25fID0gdXNlQXV0b21hdGljQWN0aXZhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gICAqL1xuICBhY3RpdmF0ZVRhYihpbmRleCkge1xuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZlSW5kZXggPSB0aGlzLmFkYXB0ZXJfLmdldFByZXZpb3VzQWN0aXZlVGFiSW5kZXgoKTtcbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKGluZGV4KSB8fCBpbmRleCA9PT0gcHJldmlvdXNBY3RpdmVJbmRleCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8uZGVhY3RpdmF0ZVRhYkF0SW5kZXgocHJldmlvdXNBY3RpdmVJbmRleCk7XG4gICAgdGhpcy5hZGFwdGVyXy5hY3RpdmF0ZVRhYkF0SW5kZXgoaW5kZXgsIHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXgocHJldmlvdXNBY3RpdmVJbmRleCkpO1xuICAgIHRoaXMuc2Nyb2xsSW50b1ZpZXcoaW5kZXgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlUYWJBY3RpdmF0ZWQoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIGtleWRvd24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlS2V5RG93bihldnQpIHtcbiAgICAvLyBHZXQgdGhlIGtleSBmcm9tIHRoZSBldmVudFxuICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5RnJvbUV2ZW50XyhldnQpO1xuXG4gICAgLy8gRWFybHkgZXhpdCBpZiB0aGUgZXZlbnQga2V5IGlzbid0IG9uZSBvZiB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBrZXlzXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBkZWZhdWx0IGJlaGF2aW9yIGZvciBtb3ZlbWVudCBrZXlzLCBidXQgbm90IGZvciBhY3RpdmF0aW9uIGtleXMsIHNpbmNlIDphY3RpdmUgaXMgdXNlZCB0byBhcHBseSByaXBwbGVcbiAgICBpZiAoIXRoaXMuaXNBY3RpdmF0aW9uS2V5XyhrZXkpKSB7XG4gICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VBdXRvbWF0aWNBY3RpdmF0aW9uXykge1xuICAgICAgaWYgKHRoaXMuaXNBY3RpdmF0aW9uS2V5XyhrZXkpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmRldGVybWluZVRhcmdldEZyb21LZXlfKHRoaXMuYWRhcHRlcl8uZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCgpLCBrZXkpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIoaW5kZXgpO1xuICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvY3VzZWRUYWJJbmRleCA9IHRoaXMuYWRhcHRlcl8uZ2V0Rm9jdXNlZFRhYkluZGV4KCk7XG4gICAgICBpZiAodGhpcy5pc0FjdGl2YXRpb25LZXlfKGtleSkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBY3RpdmVUYWIoZm9jdXNlZFRhYkluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5kZXRlcm1pbmVUYXJnZXRGcm9tS2V5Xyhmb2N1c2VkVGFiSW5kZXgsIGtleSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZm9jdXNUYWJBdEluZGV4KGluZGV4KTtcbiAgICAgICAgdGhpcy5zY3JvbGxJbnRvVmlldyhpbmRleCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIE1EQ1RhYjppbnRlcmFjdGVkIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICovXG4gIGhhbmRsZVRhYkludGVyYWN0aW9uKGV2dCkge1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QWN0aXZlVGFiKHRoaXMuYWRhcHRlcl8uZ2V0SW5kZXhPZlRhYkJ5SWQoZXZ0LmRldGFpbC50YWJJZCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggaW50byB2aWV3XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGFiIGluZGV4IHRvIG1ha2UgdmlzaWJsZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXcoaW5kZXgpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHRoZSBpbmRleCBpcyBvdXQgb2YgcmFuZ2VcbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKGluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBzY3JvbGwgdG8gMCBpZiBzY3JvbGxpbmcgdG8gdGhlIDB0aCBpbmRleFxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uc2Nyb2xsVG8oMCk7XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIHNjcm9sbCB0byB0aGUgbWF4IHZhbHVlIGlmIHNjcm9sbGluZyB0byB0aGUgTnRoIGluZGV4XG4gICAgLy8gTURDVGFiU2Nyb2xsZXIuc2Nyb2xsVG8oKSB3aWxsIG5ldmVyIHNjcm9sbCBwYXN0IHRoZSBtYXggcG9zc2libGUgdmFsdWVcbiAgICBpZiAoaW5kZXggPT09IHRoaXMuYWRhcHRlcl8uZ2V0VGFiTGlzdExlbmd0aCgpIC0gMSkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uc2Nyb2xsVG8odGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50V2lkdGgoKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNjcm9sbEludG9WaWV3UlRMXyhpbmRleCk7XG4gICAgfVxuXG4gICAgdGhpcy5zY3JvbGxJbnRvVmlld18oaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kIGZvciBkZXRlcm1pbmluZyB0aGUgaW5kZXggb2YgdGhlIGRlc3RpbmF0aW9uIHRhYiBiYXNlZCBvbiB3aGF0IGtleSB3YXMgcHJlc3NlZFxuICAgKiBAcGFyYW0ge251bWJlcn0gb3JpZ2luIFRoZSBvcmlnaW5hbCBpbmRleCBmcm9tIHdoaWNoIHRvIGRldGVybWluZSB0aGUgZGVzdGluYXRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUga2V5XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRldGVybWluZVRhcmdldEZyb21LZXlfKG9yaWdpbiwga2V5KSB7XG4gICAgY29uc3QgaXNSVEwgPSB0aGlzLmlzUlRMXygpO1xuICAgIGNvbnN0IG1heEluZGV4ID0gdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCkgLSAxO1xuICAgIGNvbnN0IHNob3VsZEdvVG9FbmQgPSBrZXkgPT09IHN0cmluZ3MuRU5EX0tFWTtcbiAgICBjb25zdCBzaG91bGREZWNyZW1lbnQgPSBrZXkgPT09IHN0cmluZ3MuQVJST1dfTEVGVF9LRVkgJiYgIWlzUlRMIHx8IGtleSA9PT0gc3RyaW5ncy5BUlJPV19SSUdIVF9LRVkgJiYgaXNSVEw7XG4gICAgY29uc3Qgc2hvdWxkSW5jcmVtZW50ID0ga2V5ID09PSBzdHJpbmdzLkFSUk9XX1JJR0hUX0tFWSAmJiAhaXNSVEwgfHwga2V5ID09PSBzdHJpbmdzLkFSUk9XX0xFRlRfS0VZICYmIGlzUlRMO1xuICAgIGxldCBpbmRleCA9IG9yaWdpbjtcblxuICAgIGlmIChzaG91bGRHb1RvRW5kKSB7XG4gICAgICBpbmRleCA9IG1heEluZGV4O1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkRGVjcmVtZW50KSB7XG4gICAgICBpbmRleCAtPSAxO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSW5jcmVtZW50KSB7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbmRleCA9IDA7XG4gICAgfVxuXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgaW5kZXggPSBtYXhJbmRleDtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gbWF4SW5kZXgpIHtcbiAgICAgIGluZGV4ID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgc2Nyb2xsIGluY3JlbWVudCB0aGF0IHdpbGwgbWFrZSB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCB2aXNpYmxlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gbmV4dEluZGV4IFRoZSBpbmRleCBvZiB0aGUgbmV4dCB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSBUYWIgQmFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKSB7XG4gICAgY29uc3QgbmV4dFRhYkRpbWVuc2lvbnMgPSB0aGlzLmFkYXB0ZXJfLmdldFRhYkRpbWVuc2lvbnNBdEluZGV4KG5leHRJbmRleCk7XG4gICAgY29uc3QgcmVsYXRpdmVDb250ZW50TGVmdCA9IG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRMZWZ0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRSaWdodCA9IG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRSaWdodCAtIHNjcm9sbFBvc2l0aW9uO1xuICAgIGNvbnN0IGxlZnRJbmNyZW1lbnQgPSByZWxhdGl2ZUNvbnRlbnRSaWdodCAtIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcbiAgICBjb25zdCByaWdodEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudExlZnQgKyBudW1iZXJzLkVYVFJBX1NDUk9MTF9BTU9VTlQ7XG5cbiAgICBpZiAobmV4dEluZGV4IDwgaW5kZXgpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihsZWZ0SW5jcmVtZW50LCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5tYXgocmlnaHRJbmNyZW1lbnQsIDApO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHNjcm9sbCBpbmNyZW1lbnQgdGhhdCB3aWxsIG1ha2UgdGhlIHRhYiBhdCB0aGUgZ2l2ZW4gaW5kZXggdmlzaWJsZSBpbiBSVExcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXh0SW5kZXggVGhlIGluZGV4IG9mIHRoZSBuZXh0IHRhYlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsUG9zaXRpb24gVGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiYXJXaWR0aCBUaGUgd2lkdGggb2YgdGhlIFRhYiBCYXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbENvbnRlbnRXaWR0aCBUaGUgd2lkdGggb2YgdGhlIHNjcm9sbCBjb250ZW50XG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudFJUTF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxDb250ZW50V2lkdGgpIHtcbiAgICBjb25zdCBuZXh0VGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgobmV4dEluZGV4KTtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRMZWZ0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gbmV4dFRhYkRpbWVuc2lvbnMuY29udGVudExlZnQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByZWxhdGl2ZUNvbnRlbnRSaWdodCA9IHNjcm9sbENvbnRlbnRXaWR0aCAtIG5leHRUYWJEaW1lbnNpb25zLmNvbnRlbnRSaWdodCAtIHNjcm9sbFBvc2l0aW9uIC0gYmFyV2lkdGg7XG4gICAgY29uc3QgbGVmdEluY3JlbWVudCA9IHJlbGF0aXZlQ29udGVudFJpZ2h0ICsgbnVtYmVycy5FWFRSQV9TQ1JPTExfQU1PVU5UO1xuICAgIGNvbnN0IHJpZ2h0SW5jcmVtZW50ID0gcmVsYXRpdmVDb250ZW50TGVmdCAtIG51bWJlcnMuRVhUUkFfU0NST0xMX0FNT1VOVDtcblxuICAgIGlmIChuZXh0SW5kZXggPiBpbmRleCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KGxlZnRJbmNyZW1lbnQsIDApO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1pbihyaWdodEluY3JlbWVudCwgMCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5kZXggb2YgdGhlIGFkamFjZW50IHRhYiBjbG9zZXN0IHRvIGVpdGhlciBlZGdlIG9mIHRoZSBUYWIgQmFyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggb2YgdGhlIHRhYlxuICAgKiBAcGFyYW0geyFNRENUYWJEaW1lbnNpb25zfSB0YWJEaW1lbnNpb25zIFRoZSBkaW1lbnNpb25zIG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFBvc2l0aW9uIFRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gYmFyV2lkdGggVGhlIHdpZHRoIG9mIHRoZSB0YWIgYmFyXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZV8oaW5kZXgsIHRhYkRpbWVuc2lvbnMsIHNjcm9sbFBvc2l0aW9uLCBiYXJXaWR0aCkge1xuICAgIC8qKlxuICAgICAqIFRhYnMgYXJlIGxhaWQgb3V0IGluIHRoZSBUYWIgU2Nyb2xsZXIgbGlrZSB0aGlzOlxuICAgICAqXG4gICAgICogICAgU2Nyb2xsIFBvc2l0aW9uXG4gICAgICogICAgKy0tLStcbiAgICAgKiAgICB8ICAgfCAgIEJhciBXaWR0aFxuICAgICAqICAgIHwgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgfCAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICAgKiAgICB8ICAgViAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVlxuICAgICAqICAgIHwgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgViAgIHwgICAgICAgICAgICAgVGFiIFNjcm9sbGVyICAgICAgICAgIHxcbiAgICAgKiAgICArLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgfCAgICBUYWIgICAgIHwgICAgICBUYWIgICAgIHwgICAgICAgIFRhYiAgICAgICAgfFxuICAgICAqICAgICstLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgICAqICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICpcbiAgICAgKiBUbyBkZXRlcm1pbmUgdGhlIG5leHQgYWRqYWNlbnQgaW5kZXgsIHdlIGxvb2sgYXQgdGhlIFRhYiByb290IGxlZnQgYW5kXG4gICAgICogVGFiIHJvb3QgcmlnaHQsIGJvdGggcmVsYXRpdmUgdG8gdGhlIHNjcm9sbCBwb3NpdGlvbi4gSWYgdGhlIFRhYiByb290XG4gICAgICogbGVmdCBpcyBsZXNzIHRoYW4gMCwgdGhlbiB3ZSBrbm93IGl0J3Mgb3V0IG9mIHZpZXcgdG8gdGhlIGxlZnQuIElmIHRoZVxuICAgICAqIFRhYiByb290IHJpZ2h0IG1pbnVzIHRoZSBiYXIgd2lkdGggaXMgZ3JlYXRlciB0aGFuIDAsIHdlIGtub3cgdGhlIFRhYiBpc1xuICAgICAqIG91dCBvZiB2aWV3IHRvIHRoZSByaWdodC4gRnJvbSB0aGVyZSwgd2UgZWl0aGVyIGluY3JlbWVudCBvciBkZWNyZW1lbnRcbiAgICAgKiB0aGUgaW5kZXguXG4gICAgICovXG4gICAgY29uc3QgcmVsYXRpdmVSb290TGVmdCA9IHRhYkRpbWVuc2lvbnMucm9vdExlZnQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByZWxhdGl2ZVJvb3RSaWdodCA9IHRhYkRpbWVuc2lvbnMucm9vdFJpZ2h0IC0gc2Nyb2xsUG9zaXRpb24gLSBiYXJXaWR0aDtcbiAgICBjb25zdCByZWxhdGl2ZVJvb3REZWx0YSA9IHJlbGF0aXZlUm9vdExlZnQgKyByZWxhdGl2ZVJvb3RSaWdodDtcbiAgICBjb25zdCBsZWZ0RWRnZUlzQ2xvc2VyID0gcmVsYXRpdmVSb290TGVmdCA8IDAgfHwgcmVsYXRpdmVSb290RGVsdGEgPCAwO1xuICAgIGNvbnN0IHJpZ2h0RWRnZUlzQ2xvc2VyID0gcmVsYXRpdmVSb290UmlnaHQgPiAwIHx8IHJlbGF0aXZlUm9vdERlbHRhID4gMDtcblxuICAgIGlmIChsZWZ0RWRnZUlzQ2xvc2VyKSB7XG4gICAgICByZXR1cm4gaW5kZXggLSAxO1xuICAgIH1cblxuICAgIGlmIChyaWdodEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgaW5kZXggb2YgdGhlIGFkamFjZW50IHRhYiBjbG9zZXN0IHRvIGVpdGhlciBlZGdlIG9mIHRoZSBUYWIgQmFyIGluIFJUTFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWJcbiAgICogQHBhcmFtIHshTURDVGFiRGltZW5zaW9uc30gdGFiRGltZW5zaW9ucyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgdGFiXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxQb3NpdGlvbiBUaGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IGJhcldpZHRoIFRoZSB3aWR0aCBvZiB0aGUgdGFiIGJhclxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsQ29udGVudFdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgc2Nyb2xsZXIgY29udGVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmaW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VSVExfKGluZGV4LCB0YWJEaW1lbnNpb25zLCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgsIHNjcm9sbENvbnRlbnRXaWR0aCkge1xuICAgIGNvbnN0IHJvb3RMZWZ0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gdGFiRGltZW5zaW9ucy5yb290TGVmdCAtIGJhcldpZHRoIC0gc2Nyb2xsUG9zaXRpb247XG4gICAgY29uc3Qgcm9vdFJpZ2h0ID0gc2Nyb2xsQ29udGVudFdpZHRoIC0gdGFiRGltZW5zaW9ucy5yb290UmlnaHQgLSBzY3JvbGxQb3NpdGlvbjtcbiAgICBjb25zdCByb290RGVsdGEgPSByb290TGVmdCArIHJvb3RSaWdodDtcbiAgICBjb25zdCBsZWZ0RWRnZUlzQ2xvc2VyID0gcm9vdExlZnQgPiAwIHx8IHJvb3REZWx0YSA+IDA7XG4gICAgY29uc3QgcmlnaHRFZGdlSXNDbG9zZXIgPSByb290UmlnaHQgPCAwIHx8IHJvb3REZWx0YSA8IDA7XG5cbiAgICBpZiAobGVmdEVkZ2VJc0Nsb3Nlcikge1xuICAgICAgcmV0dXJuIGluZGV4ICsgMTtcbiAgICB9XG5cbiAgICBpZiAocmlnaHRFZGdlSXNDbG9zZXIpIHtcbiAgICAgIHJldHVybiBpbmRleCAtIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGtleSBhc3NvY2lhdGVkIHdpdGggYSBrZXlkb3duIGV2ZW50XG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnQgVGhlIGtleWRvd24gZXZlbnRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0S2V5RnJvbUV2ZW50XyhldnQpIHtcbiAgICBpZiAoQUNDRVBUQUJMRV9LRVlTLmhhcyhldnQua2V5KSkge1xuICAgICAgcmV0dXJuIGV2dC5rZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEtFWUNPREVfTUFQLmdldChldnQua2V5Q29kZSk7XG4gIH1cblxuICBpc0FjdGl2YXRpb25LZXlfKGtleSkge1xuICAgIHJldHVybiBrZXkgPT09IHN0cmluZ3MuU1BBQ0VfS0VZIHx8IGtleSA9PT0gc3RyaW5ncy5FTlRFUl9LRVk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIGEgZ2l2ZW4gaW5kZXggaXMgaW5jbHVzaXZlbHkgYmV0d2VlbiB0aGUgZW5kc1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IHRvIHRlc3RcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluZGV4SXNJblJhbmdlXyhpbmRleCkge1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5hZGFwdGVyXy5nZXRUYWJMaXN0TGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmlldydzIFJUTCBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaXNSVExfKCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzUlRMKCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXcgZm9yIGxlZnQtdG8tcmlnaHQgdXNlcmFnZW50c1xuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSB0YWIgdG8gc2Nyb2xsIGludG8gdmlld1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXdfKGluZGV4KSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgdGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IG5leHRJbmRleCA9IHRoaXMuZmluZEFkamFjZW50VGFiSW5kZXhDbG9zZXN0VG9FZGdlXyhpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoKTtcblxuICAgIGlmICghdGhpcy5pbmRleElzSW5SYW5nZV8obmV4dEluZGV4KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNjcm9sbEluY3JlbWVudCA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50XyhpbmRleCwgbmV4dEluZGV4LCBzY3JvbGxQb3NpdGlvbiwgYmFyV2lkdGgpO1xuICAgIHRoaXMuYWRhcHRlcl8uaW5jcmVtZW50U2Nyb2xsKHNjcm9sbEluY3JlbWVudCk7XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xscyB0aGUgdGFiIGF0IHRoZSBnaXZlbiBpbmRleCBpbnRvIHZpZXcgaW4gUlRMXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGFiIGluZGV4IHRvIG1ha2UgdmlzaWJsZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsSW50b1ZpZXdSVExfKGluZGV4KSB7XG4gICAgY29uc3Qgc2Nyb2xsUG9zaXRpb24gPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbFBvc2l0aW9uKCk7XG4gICAgY29uc3QgYmFyV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldFdpZHRoKCk7XG4gICAgY29uc3QgdGFiRGltZW5zaW9ucyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiRGltZW5zaW9uc0F0SW5kZXgoaW5kZXgpO1xuICAgIGNvbnN0IHNjcm9sbFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50V2lkdGgoKTtcbiAgICBjb25zdCBuZXh0SW5kZXggPSB0aGlzLmZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZVJUTF8oXG4gICAgICBpbmRleCwgdGFiRGltZW5zaW9ucywgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxXaWR0aCk7XG5cbiAgICBpZiAoIXRoaXMuaW5kZXhJc0luUmFuZ2VfKG5leHRJbmRleCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzY3JvbGxJbmNyZW1lbnQgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEluY3JlbWVudFJUTF8oaW5kZXgsIG5leHRJbmRleCwgc2Nyb2xsUG9zaXRpb24sIGJhcldpZHRoLCBzY3JvbGxXaWR0aCk7XG4gICAgdGhpcy5hZGFwdGVyXy5pbmNyZW1lbnRTY3JvbGwoc2Nyb2xsSW5jcmVtZW50KTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJCYXJGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IDpjbGFzcz1cImNsYXNzZXNcIiBjbGFzcz1cIm1kYy10YWItYmFyXCIgdi1vbj1cImxpc3RlbmVyc1wiIHJvbGU9XCJ0YWJsaXN0XCI+XG4gICAgPG1kYy10YWItc2Nyb2xsZXIgcmVmPVwic2Nyb2xsZXJcIj4gPHNsb3Q+PC9zbG90PiA8L21kYy10YWItc2Nyb2xsZXI+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUYWJCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90YWItYmFyL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBlbWl0Q3VzdG9tRXZlbnQgfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGFiLWJhcicsXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgaW5kaWNhdG9yU3R5bGVzOiB7fSxcbiAgICAgIHRhYkxpc3Q6IFtdXG4gICAgfVxuICB9LFxuICBwcm9wczogeyBhY3RpdmVUYWJJbmRleDogW051bWJlciwgU3RyaW5nXSB9LFxuICBwcm92aWRlKCkge1xuICAgIHJldHVybiB7IG1kY1RhYkJhcjogdGhpcyB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGFiQmFyRm91bmRhdGlvbih7XG4gICAgICBzY3JvbGxUbzogc2Nyb2xsWCA9PiB0aGlzLiRyZWZzLnNjcm9sbGVyLnNjcm9sbFRvKHNjcm9sbFgpLFxuICAgICAgaW5jcmVtZW50U2Nyb2xsOiBzY3JvbGxYSW5jcmVtZW50ID0+XG4gICAgICAgIHRoaXMuJHJlZnMuc2Nyb2xsZXIuaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpLFxuICAgICAgZ2V0U2Nyb2xsUG9zaXRpb246ICgpID0+IHRoaXMuJHJlZnMuc2Nyb2xsZXIuZ2V0U2Nyb2xsUG9zaXRpb24oKSxcbiAgICAgIGdldFNjcm9sbENvbnRlbnRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5zY3JvbGxlci5nZXRTY3JvbGxDb250ZW50V2lkdGgoKSxcbiAgICAgIGdldE9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLiRlbC5vZmZzZXRXaWR0aCxcbiAgICAgIGlzUlRMOiAoKSA9PlxuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09XG4gICAgICAgICdydGwnLFxuICAgICAgc2V0QWN0aXZlVGFiOiBpbmRleCA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5hY3RpdmF0ZVRhYihpbmRleClcbiAgICAgIH0sXG4gICAgICBhY3RpdmF0ZVRhYkF0SW5kZXg6IChpbmRleCwgY2xpZW50UmVjdCkgPT4ge1xuICAgICAgICB0aGlzLnRhYkxpc3RbaW5kZXhdLmFjdGl2YXRlKGNsaWVudFJlY3QpXG4gICAgICB9LFxuICAgICAgZGVhY3RpdmF0ZVRhYkF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgdGhpcy50YWJMaXN0W2luZGV4XSAmJiB0aGlzLnRhYkxpc3RbaW5kZXhdLmRlYWN0aXZhdGUoKVxuICAgICAgfSxcbiAgICAgIGZvY3VzVGFiQXRJbmRleDogaW5kZXggPT4gdGhpcy50YWJMaXN0W2luZGV4XS5mb2N1cygpLFxuICAgICAgZ2V0VGFiSW5kaWNhdG9yQ2xpZW50UmVjdEF0SW5kZXg6IGluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICB0aGlzLnRhYkxpc3RbaW5kZXhdICYmXG4gICAgICAgICAgdGhpcy50YWJMaXN0W2luZGV4XS5jb21wdXRlSW5kaWNhdG9yQ2xpZW50UmVjdCgpXG4gICAgICAgIClcbiAgICAgIH0sXG4gICAgICBnZXRUYWJEaW1lbnNpb25zQXRJbmRleDogaW5kZXggPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy50YWJMaXN0W2luZGV4XS5jb21wdXRlRGltZW5zaW9ucygpXG4gICAgICB9LFxuICAgICAgZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleDogKCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFiTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICh0aGlzLnRhYkxpc3RbaV0uaXNBY3RpdmUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNlZFRhYkluZGV4OiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhYkVsZW1lbnRzID0gdGhpcy5nZXRUYWJFbGVtZW50c18oKVxuICAgICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgICByZXR1cm4gdGFiRWxlbWVudHMuaW5kZXhPZihhY3RpdmVFbGVtZW50KVxuICAgICAgfSxcbiAgICAgIGdldEluZGV4T2ZUYWI6IHRhYlRvRmluZCA9PiB0aGlzLnRhYkxpc3QuaW5kZXhPZih0YWJUb0ZpbmQpLFxuICAgICAgZ2V0VGFiTGlzdExlbmd0aDogKCkgPT4gdGhpcy50YWJMaXN0Lmxlbmd0aCxcbiAgICAgIG5vdGlmeVRhYkFjdGl2YXRlZDogaW5kZXggPT4ge1xuICAgICAgICBlbWl0Q3VzdG9tRXZlbnQoXG4gICAgICAgICAgdGhpcy4kZWwsXG4gICAgICAgICAgTURDVGFiQmFyRm91bmRhdGlvbi5zdHJpbmdzLlRBQl9BQ1RJVkFURURfRVZFTlQsXG4gICAgICAgICAgeyBpbmRleCB9LFxuICAgICAgICAgIHRydWVcbiAgICAgICAgKVxuXG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsIGluZGV4KVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIC8vIGVuc3VyZSBhY3RpdmUgdGFiXG4gICAgdGhpcy5mb3VuZGF0aW9uLmFjdGl2YXRlVGFiKHRoaXMuYWN0aXZlVGFiSW5kZXggfHwgMClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICAnTURDVGFiOmludGVyYWN0ZWQnOiBldmVudCA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbWV0aG9kczoge1xuICAgIGhhbmRsZUludGVyYWN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZVRhYkludGVyYWN0aW9uKGV2dClcbiAgICB9XG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQU5JTUFUSU5HOiAnbWRjLXRhYi1zY3JvbGxlci0tYW5pbWF0aW5nJyxcbiAgU0NST0xMX1RFU1Q6ICdtZGMtdGFiLXNjcm9sbGVyX190ZXN0JyxcbiAgU0NST0xMX0FSRUFfU0NST0xMOiAnbWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEtLXNjcm9sbCcsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIEFSRUFfU0VMRUNUT1I6ICcubWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWFyZWEnLFxuICBDT05URU5UX1NFTEVDVE9SOiAnLm1kYy10YWItc2Nyb2xsZXJfX3Njcm9sbC1jb250ZW50Jyxcbn07XG5cbmV4cG9ydCB7XG4gIGNzc0NsYXNzZXMsXG4gIHN0cmluZ3MsXG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKipcbiAqIE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uIGNvbnRhaW5zIHRoZSB2YWx1ZXMgcmVxdWlyZWQgZm9yIGFuaW1hdGluZyBmcm9tIHRoZVxuICogY3VycmVudCBzY3JvbGwgcG9zaXRpb24gdG8gdGhlIG5ldyBzY3JvbGwgcG9zaXRpb24uIFRoZSBcImZpbmFsU2Nyb2xsUG9zaXRpb25cIlxuICogdmFsdWUgcmVwcmVzZW50cyB0aGUgbmV3IHNjcm9sbCBwb3NpdGlvbiB3aGlsZSB0aGUgXCJzY3JvbGxEZWx0YVwiIHZhbHVlIGlzIHRoZVxuICogY29ycmVzcG9uZGluZyB0cmFuc2Zvcm1hdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gdGhlIHNjcm9sbCBjb250ZW50LiBUb2dldGhlcixcbiAqIHRoZXkgY3JlYXRlIHRoZSBhbmltYXRpb24gYnkgZmlyc3QgdXBkYXRpbmcgdGhlIHNjcm9sbCB2YWx1ZSB0aGVuIGFwcGx5aW5nXG4gKiB0aGUgdHJhbnNmb3JtYXRpb24gYW5kIGFuaW1hdGluZyB0aGUgdHJhbnNpdGlvbi4gQm90aCBwaWVjZXMgYXJlIG5lY2Vzc2FyeVxuICogZm9yIHRoZSBzY3JvbGwgYW5pbWF0aW9uIHRvIHdvcmsuIFRoZSB2YWx1ZXMgYXJlIHVzZWQgYXMtaXMgYnkgdGhlIHRhYlxuICogc2Nyb2xsZXIgYW5pbWF0aW9uIG1ldGhvZCwgZW5zdXJpbmcgdGhhdCBhbGwgbG9naWMgZm9yIGRldGVybWluaW5nIHNjcm9sbFxuICogcG9zaXRpb24gb3IgdHJhbnNmb3JtYXRpb24gaXMgYWJzdHJhY3RlZCBhd2F5IGZyb20gdGhlIGFuaW1hdGlvbiBtZXRob2QuXG4gKiBAdHlwZWRlZiB7e2ZpbmFsU2Nyb2xsUG9zaXRpb246IG51bWJlciwgc2Nyb2xsRGVsdGE6IG51bWJlcn19XG4gKi9cbmxldCBNRENUYWJTY3JvbGxlckFuaW1hdGlvbjtcblxuLyoqXG4gKiBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlcyByZXByZXNlbnRzIHRoZSBsZWZ0IGFuZCByaWdodCBlZGdlcyBvZiB0aGVcbiAqIHNjcm9sbCBjb250ZW50LiBUaGVzZSB2YWx1ZXMgdmFyeSBkZXBlbmRpbmcgb24gaG93IHNjcm9sbGluZyBpbiBSVEwgaXNcbiAqIGltcGxlbWVudGVkIGJ5IHRoZSBicm93c2VyLiBPbmUgdmFsdWUgaXMgYWx3YXlzIDAgYW5kIG9uZSB2YWx1ZSBpcyBhbHdheXNcbiAqIHRoZSBtYXggc2Nyb2xsYWJsZSB2YWx1ZSBhcyBlaXRoZXIgYSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSBpbnRlZ2VyLlxuICogQHR5cGVkZWYge3tsZWZ0OiBudW1iZXIsIHJpZ2h0OiBudW1iZXJ9fVxuICovXG5sZXQgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXM7XG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFRhYiBTY3JvbGxlci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlckFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIHRvIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBhZGRcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gY2xhc3NOYW1lIGZyb20gdGhlIHJvb3QgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSBUaGUgY2xhc3NOYW1lIHRvIHJlbW92ZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBjbGFzc05hbWUgdG8gdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byBhZGRcbiAgICovXG4gIGFkZFNjcm9sbEFyZWFDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZXZlbnQgdGFyZ2V0IG1hdGNoZXMgZ2l2ZW4gY2xhc3NOYW1lLlxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBldnRUYXJnZXQgVGhlIGV2ZW50IHRhcmdldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgVGhlIHNlbGVjdG9yIHRvIGNoZWNrXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcihldnRUYXJnZXQsIHNlbGVjdG9yKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGFyZWEgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcE5hbWUgVGhlIHN0eWxlIHByb3BlcnR5IG5hbWUgdG8gc2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc3R5bGUgcHJvcGVydHkgdmFsdWVcbiAgICovXG4gIHNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5KHByb3BOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBjb250ZW50IGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BOYW1lIFRoZSBzdHlsZSBwcm9wZXJ0eSBuYW1lIHRvIHNldFxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHN0eWxlIHByb3BlcnR5IHZhbHVlXG4gICAqL1xuICBzZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eShwcm9wTmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjcm9sbCBjb250ZW50IGVsZW1lbnQncyBjb21wdXRlZCBzdHlsZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gY3NzIHByb3BlcnR5IGBwcm9wZXJ0eU5hbWVgLlxuICAgKiBXZSBhY2hpZXZlIHRoaXMgdmlhIGBnZXRDb21wdXRlZFN0eWxlKC4uLikuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eU5hbWUpYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZShwcm9wZXJ0eU5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHNjcm9sbExlZnQgdmFsdWUgb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbExlZnQgVGhlIG5ldyBzY3JvbGxMZWZ0IHZhbHVlXG4gICAqL1xuICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChzY3JvbGxMZWZ0KSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY3JvbGxMZWZ0IHZhbHVlIG9mIHRoZSBzY3JvbGwgYXJlYSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG9mZnNldFdpZHRoIG9mIHRoZSBzY3JvbGwgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBvZmZzZXRXaXRkdGggb2YgdGhlIHNjcm9sbCBhcmVhIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzY3JvbGwgYXJlYSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIHRoZSBzY3JvbGwgY29udGVudCBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHshQ2xpZW50UmVjdH1cbiAgICovXG4gIGNvbXB1dGVTY3JvbGxDb250ZW50Q2xpZW50UmVjdCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgYnJvd3NlcidzIGhvcml6b250YWwgc2Nyb2xsYmFycyAoaW4gcHgpLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjb21wdXRlSG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzLCBNRENUYWJTY3JvbGxlckFkYXB0ZXJ9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogWzIsIHtcImFyZ3NcIjogXCJub25lXCJ9XSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFkYXB0ZXIsIE1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTCB7XG4gIC8qKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgIHRoaXMuYWRhcHRlcl8gPSBhZGFwdGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYIFRoZSBjdXJyZW50IHRyYW5zbGF0ZVggcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAYWJzdHJhY3RcbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBjdXJyZW50IHNjcm9sbFggcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVggVGhlIGN1cnJlbnQgdHJhbnNsYXRlWCBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBhYnN0cmFjdFxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVEw7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMIGZyb20gJy4vcnRsLXNjcm9sbGVyJztcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCB7TURDVGFiU2Nyb2xsZXJBbmltYXRpb24sIE1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSBmcm9tICcuL2FkYXB0ZXInO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUYWJTY3JvbGxlclJUTH1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQgZXh0ZW5kcyBNRENUYWJTY3JvbGxlclJUTCB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRTY3JvbGxQb3NpdGlvblJUTCgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCB7cmlnaHR9ID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICAvLyBTY3JvbGwgdmFsdWVzIG9uIG1vc3QgYnJvd3NlcnMgYXJlIGludHMgaW5zdGVhZCBvZiBmbG9hdHMgc28gd2Ugcm91bmRcbiAgICByZXR1cm4gTWF0aC5yb3VuZChyaWdodCAtIGN1cnJlbnRTY3JvbGxMZWZ0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBzY3JvbGxUb1JUTChzY3JvbGxYKSB7XG4gICAgY29uc3QgZWRnZXMgPSB0aGlzLmNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpO1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhlZGdlcy5yaWdodCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCBjbGFtcGVkU2Nyb2xsTGVmdCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oY3VycmVudFNjcm9sbExlZnQgLSBzY3JvbGxYKTtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbERlbHRhOiBjbGFtcGVkU2Nyb2xsTGVmdCAtIGN1cnJlbnRTY3JvbGxMZWZ0LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldEFuaW1hdGluZ1Njcm9sbFBvc2l0aW9uKHNjcm9sbFgpIHtcbiAgICByZXR1cm4gc2Nyb2xsWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICByaWdodDogY29udGVudFdpZHRoIC0gcm9vdFdpZHRoLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGVkZ2VzLmxlZnQsIHNjcm9sbFgpLCBlZGdlcy5yaWdodCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExEZWZhdWx0O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQge01EQ1RhYlNjcm9sbGVyQW5pbWF0aW9uLCBNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gZnJvbSAnLi9hZGFwdGVyJztcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDVGFiU2Nyb2xsZXJSVEx9XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZSBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYIFRoZSBjdXJyZW50IHRyYW5zbGF0ZVggcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb25SVEwodHJhbnNsYXRlWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKHRyYW5zbGF0ZVggLSBjdXJyZW50U2Nyb2xsTGVmdCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufVxuICAgKi9cbiAgc2Nyb2xsVG9SVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXygtc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY2xhbXBlZFNjcm9sbExlZnQgLSBjdXJyZW50U2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCAtIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGNsYW1wZWRTY3JvbGxMZWZ0IC0gY3VycmVudFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zbGF0ZVhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge1xuICAgIHJldHVybiBzY3JvbGxYIC0gdHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IHJvb3RXaWR0aCAtIGNvbnRlbnRXaWR0aCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWF4KE1hdGgubWluKGVkZ2VzLnJpZ2h0LCBzY3JvbGxYKSwgZWRnZXMubGVmdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExOZWdhdGl2ZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVEwgZnJvbSAnLi9ydGwtc2Nyb2xsZXInO1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9IGZyb20gJy4vYWRhcHRlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYlNjcm9sbGVyUlRMfVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSBleHRlbmRzIE1EQ1RhYlNjcm9sbGVyUlRMIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0cmFuc2xhdGVYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICAvLyBTY3JvbGwgdmFsdWVzIG9uIG1vc3QgYnJvd3NlcnMgYXJlIGludHMgaW5zdGVhZCBvZiBmbG9hdHMgc28gd2Ugcm91bmRcbiAgICByZXR1cm4gTWF0aC5yb3VuZChjdXJyZW50U2Nyb2xsTGVmdCAtIHRyYW5zbGF0ZVgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn1cbiAgICovXG4gIHNjcm9sbFRvUlRMKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsTGVmdCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoKTtcbiAgICBjb25zdCBjbGFtcGVkU2Nyb2xsTGVmdCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgICBzY3JvbGxEZWx0YTogY3VycmVudFNjcm9sbExlZnQgLSBjbGFtcGVkU2Nyb2xsTGVmdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWFxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259XG4gICAqL1xuICBpbmNyZW1lbnRTY3JvbGxSVEwoc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIGNvbnN0IGNsYW1wZWRTY3JvbGxMZWZ0ID0gdGhpcy5jbGFtcFNjcm9sbFZhbHVlXyhjdXJyZW50U2Nyb2xsTGVmdCArIHNjcm9sbFgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFuaW1hdGlvbn0gKi8gKHtcbiAgICAgIGZpbmFsU2Nyb2xsUG9zaXRpb246IGNsYW1wZWRTY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsRGVsdGE6IGN1cnJlbnRTY3JvbGxMZWZ0IC0gY2xhbXBlZFNjcm9sbExlZnQsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsWCwgdHJhbnNsYXRlWCkge1xuICAgIHJldHVybiBzY3JvbGxYICsgdHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVTY3JvbGxFZGdlc18oKSB7XG4gICAgY29uc3QgY29udGVudFdpZHRoID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgoKTtcbiAgICBjb25zdCByb290V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aCgpO1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc30gKi8gKHtcbiAgICAgIGxlZnQ6IGNvbnRlbnRXaWR0aCAtIHJvb3RXaWR0aCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNsYW1wU2Nyb2xsVmFsdWVfKHNjcm9sbFgpIHtcbiAgICBjb25zdCBlZGdlcyA9IHRoaXMuY2FsY3VsYXRlU2Nyb2xsRWRnZXNfKCk7XG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGVkZ2VzLnJpZ2h0LCBzY3JvbGxYKSwgZWRnZXMubGVmdCk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUYWJTY3JvbGxlckFuaW1hdGlvbiwgTURDVGFiU2Nyb2xsZXJIb3Jpem9udGFsRWRnZXMsIE1EQ1RhYlNjcm9sbGVyQWRhcHRlcn0gZnJvbSAnLi9hZGFwdGVyJztcbmltcG9ydCBNRENUYWJTY3JvbGxlclJUTCBmcm9tICcuL3J0bC1zY3JvbGxlcic7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJSVExEZWZhdWx0IGZyb20gJy4vcnRsLWRlZmF1bHQtc2Nyb2xsZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMTmVnYXRpdmUgZnJvbSAnLi9ydGwtbmVnYXRpdmUtc2Nyb2xsZXInO1xuaW1wb3J0IE1EQ1RhYlNjcm9sbGVyUlRMUmV2ZXJzZSBmcm9tICcuL3J0bC1yZXZlcnNlLXNjcm9sbGVyJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGFiU2Nyb2xsZXJBZGFwdGVyPn1cbiAqIEBmaW5hbFxuICovXG5jbGFzcyBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAc2VlIE1EQ1RhYlNjcm9sbGVyQWRhcHRlciBmb3IgdHlwaW5nIGluZm9ybWF0aW9uXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9ICovICh7XG4gICAgICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcjogKCkgPT4ge30sXG4gICAgICBhZGRDbGFzczogKCkgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKCkgPT4ge30sXG4gICAgICBhZGRTY3JvbGxBcmVhQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHk6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWU6ICgpID0+IHt9LFxuICAgICAgc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQ6ICgpID0+IHt9LFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudE9mZnNldFdpZHRoOiAoKSA9PiB7fSxcbiAgICAgIGdldFNjcm9sbEFyZWFPZmZzZXRXaWR0aDogKCkgPT4ge30sXG4gICAgICBjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3Q6ICgpID0+IHt9LFxuICAgICAgY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENUYWJTY3JvbGxlckFkYXB0ZXJ9IGFkYXB0ZXIgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJvb2xlYW4gY29udHJvbHMgd2hldGhlciB3ZSBzaG91bGQgaGFuZGxlIHRoZSB0cmFuc2l0aW9uZW5kIGFuZCBpbnRlcmFjdGlvbiBldmVudHMgZHVyaW5nIHRoZSBhbmltYXRpb24uXG4gICAgICogQHByaXZhdGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5pc0FuaW1hdGluZ18gPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBNRENUYWJTY3JvbGxlclJUTCBpbnN0YW5jZSB2YXJpZXMgcGVyIGJyb3dzZXIgYW5kIGFsbG93cyB1cyB0byBlbmNhcHN1bGF0ZSB0aGUgcGVjdWxpYXIgYnJvd3NlciBiZWhhdmlvclxuICAgICAqIG9mIFJUTCBzY3JvbGxpbmcgaW4gaXQncyBvd24gY2xhc3MuXG4gICAgICogQHByaXZhdGUgez9NRENUYWJTY3JvbGxlclJUTH1cbiAgICAgKi9cbiAgICB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICAvLyBDb21wdXRlIGhvcml6b250YWwgc2Nyb2xsYmFyIGhlaWdodCBvbiBzY3JvbGxlciB3aXRoIG92ZXJmbG93IGluaXRpYWxseSBoaWRkZW4sIHRoZW4gdXBkYXRlIG92ZXJmbG93IHRvIHNjcm9sbFxuICAgIC8vIGFuZCBpbW1lZGlhdGVseSBhZGp1c3QgYm90dG9tIG1hcmdpbiB0byBhdm9pZCB0aGUgc2Nyb2xsYmFyIGluaXRpYWxseSBhcHBlYXJpbmcgYmVmb3JlIEpTIHJ1bnMuXG4gICAgY29uc3QgaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodCA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTdHlsZVByb3BlcnR5KCdtYXJnaW4tYm90dG9tJywgLWhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgKyAncHgnKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZFNjcm9sbEFyZWFDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5TQ1JPTExfQVJFQV9TQ1JPTEwpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBjdXJyZW50IHZpc3VhbCBzY3JvbGwgcG9zaXRpb25cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0U2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVDdXJyZW50U2Nyb2xsUG9zaXRpb25SVExfKCk7XG4gICAgfVxuXG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgcmV0dXJuIHNjcm9sbExlZnQgLSBjdXJyZW50VHJhbnNsYXRlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGludGVyYWN0aW9uIGV2ZW50cyB0aGF0IG9jY3VyIGR1cmluZyB0cmFuc2l0aW9uXG4gICAqL1xuICBoYW5kbGVJbnRlcmFjdGlvbigpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHdlIGFyZW4ndCBhbmltYXRpbmdcbiAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmdfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBvdGhlciBldmVudCBsaXN0ZW5lcnMgZnJvbSBoYW5kbGluZyB0aGlzIGV2ZW50XG4gICAgdGhpcy5zdG9wU2Nyb2xsQW5pbWF0aW9uXygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHdlIGFyZW4ndCBhbmltYXRpbmcgb3IgdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQgYnkgYSBkaWZmZXJlbnQgZWxlbWVudC5cbiAgICBpZiAoIXRoaXMuaXNBbmltYXRpbmdfXG4gICAgICB8fCAhdGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcihldnQudGFyZ2V0LCBNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uc3RyaW5ncy5DT05URU5UX1NFTEVDVE9SKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluY3JlbWVudCB0aGUgc2Nyb2xsIHZhbHVlIGJ5IHRoZSBzY3JvbGxYSW5jcmVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYSW5jcmVtZW50IFRoZSB2YWx1ZSBieSB3aGljaCB0byBpbmNyZW1lbnQgdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsKHNjcm9sbFhJbmNyZW1lbnQpIHtcbiAgICAvLyBFYXJseSBleGl0IGZvciBub24tb3BlcmF0aW9uYWwgaW5jcmVtZW50IHZhbHVlc1xuICAgIGlmIChzY3JvbGxYSW5jcmVtZW50ID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmluY3JlbWVudFNjcm9sbFJUTF8oc2Nyb2xsWEluY3JlbWVudCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbmNyZW1lbnRTY3JvbGxfKHNjcm9sbFhJbmNyZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbHMgdG8gdGhlIGdpdmVuIHNjcm9sbFggdmFsdWVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFhcbiAgICovXG4gIHNjcm9sbFRvKHNjcm9sbFgpIHtcbiAgICBpZiAodGhpcy5pc1JUTF8oKSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsVG9SVExfKHNjcm9sbFgpO1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsVG9fKHNjcm9sbFgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIHZlcnNpb24gb2YgdGhlIE1EQ1RhYlNjcm9sbGVyUlRMXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlclJUTH1cbiAgICovXG4gIGdldFJUTFNjcm9sbGVyKCkge1xuICAgIGlmICghdGhpcy5ydGxTY3JvbGxlckluc3RhbmNlXykge1xuICAgICAgdGhpcy5ydGxTY3JvbGxlckluc3RhbmNlXyA9IHRoaXMucnRsU2Nyb2xsZXJGYWN0b3J5XygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnJ0bFNjcm9sbGVySW5zdGFuY2VfO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRyYW5zbGF0ZVggdmFsdWUgZnJvbSBhIENTUyBtYXRyaXggdHJhbnNmb3JtIGZ1bmN0aW9uIHN0cmluZ1xuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWxjdWxhdGVDdXJyZW50VHJhbnNsYXRlWF8oKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtVmFsdWUgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRTdHlsZVZhbHVlKCd0cmFuc2Zvcm0nKTtcbiAgICAvLyBFYXJseSBleGl0IGlmIG5vIHRyYW5zZm9ybSBpcyBwcmVzZW50XG4gICAgaWYgKHRyYW5zZm9ybVZhbHVlID09PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIC8vIFRoZSB0cmFuc2Zvcm0gdmFsdWUgY29tZXMgYmFjayBhcyBhIG1hdHJpeCB0cmFuc2Zvcm1hdGlvbiBpbiB0aGUgZm9ybVxuICAgIC8vIG9mIGBtYXRyaXgoYSwgYiwgYywgZCwgdHgsIHR5KWAuIFdlIG9ubHkgY2FyZSBhYm91dCB0eCAodHJhbnNsYXRlWCkgc29cbiAgICAvLyB3ZSdyZSBnb2luZyB0byBncmFiIGFsbCB0aGUgcGFyZW50aGVzaXplZCB2YWx1ZXMsIHN0cmlwIG91dCB0eCwgYW5kXG4gICAgLy8gcGFyc2UgaXQuXG4gICAgY29uc3QgcmVzdWx0cyA9IC9cXCgoLispXFwpLy5leGVjKHRyYW5zZm9ybVZhbHVlKVsxXTtcbiAgICBjb25zdCBwYXJ0cyA9IHJlc3VsdHMuc3BsaXQoJywnKTtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJ0c1s0XSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyBhIHNhZmUgc2Nyb2xsIHZhbHVlIHRoYXQgaXMgPiAwIGFuZCA8IHRoZSBtYXggc2Nyb2xsIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzY3JvbGxYIFRoZSBkaXN0YW5jZSB0byBzY3JvbGxcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTY3JvbGxFZGdlc18oKTtcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZWRnZXMubGVmdCwgc2Nyb2xsWCksIGVkZ2VzLnJpZ2h0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb21wdXRlQ3VycmVudFNjcm9sbFBvc2l0aW9uUlRMXygpIHtcbiAgICBjb25zdCB0cmFuc2xhdGVYID0gdGhpcy5jYWxjdWxhdGVDdXJyZW50VHJhbnNsYXRlWF8oKTtcbiAgICByZXR1cm4gdGhpcy5nZXRSVExTY3JvbGxlcigpLmdldFNjcm9sbFBvc2l0aW9uUlRMKHRyYW5zbGF0ZVgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFNRENUYWJTY3JvbGxlckhvcml6b250YWxFZGdlc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNhbGN1bGF0ZVNjcm9sbEVkZ2VzXygpIHtcbiAgICBjb25zdCBjb250ZW50V2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aCgpO1xuICAgIGNvbnN0IHJvb3RXaWR0aCA9IHRoaXMuYWRhcHRlcl8uZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoKCk7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVySG9yaXpvbnRhbEVkZ2VzfSAqLyAoe1xuICAgICAgbGVmdDogMCxcbiAgICAgIHJpZ2h0OiBjb250ZW50V2lkdGggLSByb290V2lkdGgsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2Nyb2xsVG9fKHNjcm9sbFgpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsWCA9IHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb24oKTtcbiAgICBjb25zdCBzYWZlU2Nyb2xsWCA9IHRoaXMuY2xhbXBTY3JvbGxWYWx1ZV8oc2Nyb2xsWCk7XG4gICAgY29uc3Qgc2Nyb2xsRGVsdGEgPSBzYWZlU2Nyb2xsWCAtIGN1cnJlbnRTY3JvbGxYO1xuICAgIHRoaXMuYW5pbWF0ZV8oLyoqIEB0eXBlIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259ICovICh7XG4gICAgICBmaW5hbFNjcm9sbFBvc2l0aW9uOiBzYWZlU2Nyb2xsWCxcbiAgICAgIHNjcm9sbERlbHRhOiBzY3JvbGxEZWx0YSxcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWwgUlRMIHNjcm9sbCBtZXRob2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIG5ldyBzY3JvbGwgcG9zaXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNjcm9sbFRvUlRMXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5nZXRSVExTY3JvbGxlcigpLnNjcm9sbFRvUlRMKHNjcm9sbFgpO1xuICAgIHRoaXMuYW5pbWF0ZV8oYW5pbWF0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBpbmNyZW1lbnQgc2Nyb2xsIG1ldGhvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsWCBUaGUgbmV3IHNjcm9sbCBwb3NpdGlvbiBpbmNyZW1lbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGluY3JlbWVudFNjcm9sbF8oc2Nyb2xsWCkge1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxYID0gdGhpcy5nZXRTY3JvbGxQb3NpdGlvbigpO1xuICAgIGNvbnN0IHRhcmdldFNjcm9sbFggPSBzY3JvbGxYICsgY3VycmVudFNjcm9sbFg7XG4gICAgY29uc3Qgc2FmZVNjcm9sbFggPSB0aGlzLmNsYW1wU2Nyb2xsVmFsdWVfKHRhcmdldFNjcm9sbFgpO1xuICAgIGNvbnN0IHNjcm9sbERlbHRhID0gc2FmZVNjcm9sbFggLSBjdXJyZW50U2Nyb2xsWDtcbiAgICB0aGlzLmFuaW1hdGVfKC8qKiBAdHlwZSB7IU1EQ1RhYlNjcm9sbGVyQW5pbWF0aW9ufSAqLyAoe1xuICAgICAgZmluYWxTY3JvbGxQb3NpdGlvbjogc2FmZVNjcm9sbFgsXG4gICAgICBzY3JvbGxEZWx0YTogc2Nyb2xsRGVsdGEsXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIGluY3JlbWVuZXQgc2Nyb2xsIFJUTCBtZXRob2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNjcm9sbFggVGhlIG5ldyBzY3JvbGwgcG9zaXRpb24gUlRMIGluY3JlbWVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaW5jcmVtZW50U2Nyb2xsUlRMXyhzY3JvbGxYKSB7XG4gICAgY29uc3QgYW5pbWF0aW9uID0gdGhpcy5nZXRSVExTY3JvbGxlcigpLmluY3JlbWVudFNjcm9sbFJUTChzY3JvbGxYKTtcbiAgICB0aGlzLmFuaW1hdGVfKGFuaW1hdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogQW5pbWF0ZXMgdGhlIHRhYiBzY3JvbGxpbmdcbiAgICogQHBhcmFtIHshTURDVGFiU2Nyb2xsZXJBbmltYXRpb259IGFuaW1hdGlvbiBUaGUgYW5pbWF0aW9uIHRvIGFwcGx5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlXyhhbmltYXRpb24pIHtcbiAgICAvLyBFYXJseSBleGl0IGlmIHRyYW5zbGF0ZVggaXMgMCwgd2hpY2ggbWVhbnMgdGhlcmUncyBubyBhbmltYXRpb24gdG8gcGVyZm9ybVxuICAgIGlmIChhbmltYXRpb24uc2Nyb2xsRGVsdGEgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3BTY3JvbGxBbmltYXRpb25fKCk7XG4gICAgLy8gVGhpcyBhbmltYXRpb24gdXNlcyB0aGUgRkxJUCBhcHByb2FjaC5cbiAgICAvLyBSZWFkIG1vcmUgaGVyZTogaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvXG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdChhbmltYXRpb24uZmluYWxTY3JvbGxQb3NpdGlvbik7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgYHRyYW5zbGF0ZVgoJHthbmltYXRpb24uc2Nyb2xsRGVsdGF9cHgpYCk7XG4gICAgLy8gRm9yY2UgcmVwYWludFxuICAgIHRoaXMuYWRhcHRlcl8uY29tcHV0ZVNjcm9sbEFyZWFDbGllbnRSZWN0KCk7XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRTY3JvbGxDb250ZW50U3R5bGVQcm9wZXJ0eSgndHJhbnNmb3JtJywgJ25vbmUnKTtcbiAgICB9KTtcblxuICAgIHRoaXMuaXNBbmltYXRpbmdfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wcyBzY3JvbGwgYW5pbWF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzdG9wU2Nyb2xsQW5pbWF0aW9uXygpIHtcbiAgICB0aGlzLmlzQW5pbWF0aW5nXyA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnJlbnRTY3JvbGxQb3NpdGlvbiA9IHRoaXMuZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb25fKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJTY3JvbGxlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHkoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGVYKDBweCknKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KGN1cnJlbnRTY3JvbGxQb3NpdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBzY3JvbGwgcG9zaXRpb24gZHVyaW5nIGFuaW1hdGlvblxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8oKSB7XG4gICAgY29uc3QgY3VycmVudFRyYW5zbGF0ZVggPSB0aGlzLmNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXygpO1xuICAgIGNvbnN0IHNjcm9sbExlZnQgPSB0aGlzLmFkYXB0ZXJfLmdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0KCk7XG4gICAgaWYgKHRoaXMuaXNSVExfKCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJUTFNjcm9sbGVyKCkuZ2V0QW5pbWF0aW5nU2Nyb2xsUG9zaXRpb24oc2Nyb2xsTGVmdCwgY3VycmVudFRyYW5zbGF0ZVgpO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JvbGxMZWZ0IC0gY3VycmVudFRyYW5zbGF0ZVg7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyB0aGUgUlRMIFNjcm9sbGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHshTURDVGFiU2Nyb2xsZXJSVEx9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBydGxTY3JvbGxlckZhY3RvcnlfKCkge1xuICAgIC8vIEJyb3dzZXJzIGhhdmUgdGhyZWUgZGlmZmVyZW50IGltcGxlbWVudGF0aW9ucyBvZiBzY3JvbGxMZWZ0IGluIFJUTCBtb2RlLFxuICAgIC8vIGRlcGVuZGVudCBvbiB0aGUgYnJvd3Nlci4gVGhlIGJlaGF2aW9yIGlzIGJhc2VkIG9mZiB0aGUgbWF4IExUUlxuICAgIC8vIHNjcm9sbGxlZnQgdmFsdWUgYW5kIDAuXG4gICAgLy9cbiAgICAvLyAqIERlZmF1bHQgc2Nyb2xsaW5nIGluIFJUTCAqXG4gICAgLy8gICAgLSBMZWZ0LW1vc3QgdmFsdWU6IDBcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IE1heCBMVFIgc2Nyb2xsTGVmdCB2YWx1ZVxuICAgIC8vXG4gICAgLy8gKiBOZWdhdGl2ZSBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogTmVnYXRlZCBtYXggTFRSIHNjcm9sbExlZnQgdmFsdWVcbiAgICAvLyAgICAtIFJpZ2h0LW1vc3QgdmFsdWU6IDBcbiAgICAvL1xuICAgIC8vICogUmV2ZXJzZSBzY3JvbGxpbmcgaW4gUlRMICpcbiAgICAvLyAgICAtIExlZnQtbW9zdCB2YWx1ZTogTWF4IExUUiBzY3JvbGxMZWZ0IHZhbHVlXG4gICAgLy8gICAgLSBSaWdodC1tb3N0IHZhbHVlOiAwXG4gICAgLy9cbiAgICAvLyBXZSB1c2UgdGhvc2UgcHJpbmNpcGxlcyBiZWxvdyB0byBkZXRlcm1pbmUgd2hpY2ggUlRMIHNjcm9sbExlZnRcbiAgICAvLyBiZWhhdmlvciBpcyBpbXBsZW1lbnRlZCBpbiB0aGUgY3VycmVudCBicm93c2VyLlxuICAgIGNvbnN0IGluaXRpYWxTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQgLSAxKTtcbiAgICBjb25zdCBuZXdTY3JvbGxMZWZ0ID0gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCgpO1xuXG4gICAgLy8gSWYgdGhlIG5ld1Njcm9sbExlZnQgdmFsdWUgaXMgbmVnYXRpdmUsdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGJyb3dzZXIgaGFzXG4gICAgLy8gaW1wbGVtZW50ZWQgbmVnYXRpdmUgUlRMIHNjcm9sbGluZywgc2luY2UgYWxsIG90aGVyIGltcGxlbWVudGF0aW9ucyBoYXZlXG4gICAgLy8gb25seSBwb3NpdGl2ZSB2YWx1ZXMuXG4gICAgaWYgKG5ld1Njcm9sbExlZnQgPCAwKSB7XG4gICAgICAvLyBVbmRvIHRoZSBzY3JvbGxMZWZ0IHRlc3QgY2hlY2tcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQpO1xuICAgICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlKHRoaXMuYWRhcHRlcl8pO1xuICAgIH1cblxuICAgIGNvbnN0IHJvb3RDbGllbnRSZWN0ID0gdGhpcy5hZGFwdGVyXy5jb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3QoKTtcbiAgICBjb25zdCBjb250ZW50Q2xpZW50UmVjdCA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZVNjcm9sbENvbnRlbnRDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgcmlnaHRFZGdlRGVsdGEgPSBNYXRoLnJvdW5kKGNvbnRlbnRDbGllbnRSZWN0LnJpZ2h0IC0gcm9vdENsaWVudFJlY3QucmlnaHQpO1xuICAgIC8vIFVuZG8gdGhlIHNjcm9sbExlZnQgdGVzdCBjaGVja1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQoaW5pdGlhbFNjcm9sbExlZnQpO1xuXG4gICAgLy8gQnkgY2FsY3VsYXRpbmcgdGhlIGNsaWVudFJlY3Qgb2YgdGhlIHJvb3QgZWxlbWVudCBhbmQgdGhlIGNsaWVudFJlY3Qgb2ZcbiAgICAvLyB0aGUgY29udGVudCBlbGVtZW50LCB3ZSBjYW4gZGV0ZXJtaW5lIGhvdyBtdWNoIHRoZSBzY3JvbGwgdmFsdWUgY2hhbmdlZFxuICAgIC8vIHdoZW4gd2UgcGVyZm9ybWVkIHRoZSBzY3JvbGxMZWZ0IHN1YnRyYWN0aW9uIGFib3ZlLlxuICAgIGlmIChyaWdodEVkZ2VEZWx0YSA9PT0gbmV3U2Nyb2xsTGVmdCkge1xuICAgICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTFJldmVyc2UodGhpcy5hZGFwdGVyXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBNRENUYWJTY3JvbGxlclJUTERlZmF1bHQodGhpcy5hZGFwdGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGlzUlRMXygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRTY3JvbGxDb250ZW50U3R5bGVWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBTdG9yZXMgcmVzdWx0IGZyb20gY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcuXG4gKiBAcHJpdmF0ZSB7bnVtYmVyfHVuZGVmaW5lZH1cbiAqL1xubGV0IGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBoZWlnaHQgb2YgYnJvd3Nlci1yZW5kZXJlZCBob3Jpem9udGFsIHNjcm9sbGJhcnMgdXNpbmcgYSBzZWxmLWNyZWF0ZWQgdGVzdCBlbGVtZW50LlxuICogTWF5IHJldHVybiAwIChlLmcuIG9uIE9TIFggYnJvd3NlcnMgdW5kZXIgZGVmYXVsdCBjb25maWd1cmF0aW9uKS5cbiAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkQ2FjaGVSZXN1bHRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoZG9jdW1lbnRPYmosIHNob3VsZENhY2hlUmVzdWx0ID0gdHJ1ZSkge1xuICBpZiAoc2hvdWxkQ2FjaGVSZXN1bHQgJiYgdHlwZW9mIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0XztcbiAgfVxuXG4gIGNvbnN0IGVsID0gZG9jdW1lbnRPYmouY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGVsLmNsYXNzTGlzdC5hZGQoY3NzQ2xhc3Nlcy5TQ1JPTExfVEVTVCk7XG4gIGRvY3VtZW50T2JqLmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuXG4gIGNvbnN0IGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQgPSBlbC5vZmZzZXRIZWlnaHQgLSBlbC5jbGllbnRIZWlnaHQ7XG4gIGRvY3VtZW50T2JqLmJvZHkucmVtb3ZlQ2hpbGQoZWwpO1xuXG4gIGlmIChzaG91bGRDYWNoZVJlc3VsdCkge1xuICAgIGhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfID0gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbiAgfVxuICByZXR1cm4gaG9yaXpvbnRhbFNjcm9sbGJhckhlaWdodDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFPYmplY3R9IEhUTUxFbGVtZW50UHJvdG90eXBlXG4gKiBAcmV0dXJuIHshQXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50UHJvdG90eXBlKSB7XG4gIHJldHVybiBbXG4gICAgJ21zTWF0Y2hlc1NlbGVjdG9yJywgJ21hdGNoZXMnLFxuICBdLmZpbHRlcigocCkgPT4gcCBpbiBIVE1MRWxlbWVudFByb3RvdHlwZSkucG9wKCk7XG59XG5cbmV4cG9ydCB7Y29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQsIGdldE1hdGNoZXNQcm9wZXJ0eX07XG4iLCI8dGVtcGxhdGU+XG4gIDxkaXYgY2xhc3M9XCJtZGMtdGFiLXNjcm9sbGVyXCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxkaXZcbiAgICAgIHJlZj1cImFyZWFcIlxuICAgICAgY2xhc3M9XCJtZGMtdGFiLXNjcm9sbGVyX19zY3JvbGwtYXJlYVwiXG4gICAgICBAbW91c2Vkb3duPVwiaGFuZGxlSW50ZXJhY3Rpb25cIlxuICAgICAgQHdoZWVsPVwiaGFuZGxlSW50ZXJhY3Rpb25cIlxuICAgICAgQHBvaW50ZXJkb3duPVwiaGFuZGxlSW50ZXJhY3Rpb25cIlxuICAgICAgQHRvdWNoc3RhcnQ9XCJoYW5kbGVJbnRlcmFjdGlvblwiXG4gICAgICBAa2V5ZG93bj1cImhhbmRsZUludGVyYWN0aW9uXCJcbiAgICAgIDpjbGFzcz1cImFyZWFDbGFzc2VzXCJcbiAgICAgIDpzdHlsZT1cImFyZWFTdHlsZXNcIlxuICAgID5cbiAgICAgIDxkaXZcbiAgICAgICAgcmVmPVwiY29udGVudFwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRhYi1zY3JvbGxlcl9fc2Nyb2xsLWNvbnRlbnRcIlxuICAgICAgICA6c3R5bGU9XCJjb250ZW50U3R5bGVzXCJcbiAgICAgICAgQHRyYW5zaXRpb25lbmQ9XCJoYW5kbGVUcmFuc2l0aW9uRW5kXCJcbiAgICAgID5cbiAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90YWItc2Nyb2xsZXIvZm91bmRhdGlvbidcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnQG1hdGVyaWFsL3RhYi1zY3JvbGxlci91dGlsJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGFiLXNjcm9sbGVyJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBjbGFzc2VzOiB7fSwgYXJlYUNsYXNzZXM6IHt9LCBhcmVhU3R5bGVzOiB7fSwgY29udGVudFN0eWxlczoge30gfVxuICB9LFxuXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RhYlNjcm9sbGVyRm91bmRhdGlvbih7XG4gICAgICBldmVudFRhcmdldE1hdGNoZXNTZWxlY3RvcjogKGV2dFRhcmdldCwgc2VsZWN0b3IpID0+IHtcbiAgICAgICAgY29uc3QgTUFUQ0hFUyA9IHV0aWwuZ2V0TWF0Y2hlc1Byb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSlcbiAgICAgICAgcmV0dXJuIGV2dFRhcmdldFtNQVRDSEVTXShzZWxlY3RvcilcbiAgICAgIH0sXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHRoaXMuJHNldCh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSksXG5cbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKSxcbiAgICAgIGFkZFNjcm9sbEFyZWFDbGFzczogY2xhc3NOYW1lID0+XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLmFyZWFDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgc2V0U2Nyb2xsQXJlYVN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT5cbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuYXJlYVN0eWxlcywgcHJvcCwgdmFsdWUpLFxuICAgICAgc2V0U2Nyb2xsQ29udGVudFN0eWxlUHJvcGVydHk6IChwcm9wLCB2YWx1ZSkgPT5cbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY29udGVudFN0eWxlcywgcHJvcCwgdmFsdWUpLFxuICAgICAgZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWU6IHByb3BOYW1lID0+XG4gICAgICAgIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJHJlZnMuY29udGVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wTmFtZSksXG4gICAgICBzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdDogc2Nyb2xsWCA9PlxuICAgICAgICAodGhpcy4kcmVmcy5hcmVhLnNjcm9sbExlZnQgPSBzY3JvbGxYKSxcbiAgICAgIGdldFNjcm9sbEFyZWFTY3JvbGxMZWZ0OiAoKSA9PiB0aGlzLiRyZWZzLmFyZWEuc2Nyb2xsTGVmdCxcbiAgICAgIGdldFNjcm9sbENvbnRlbnRPZmZzZXRXaWR0aDogKCkgPT4gdGhpcy4kcmVmcy5jb250ZW50Lm9mZnNldFdpZHRoLFxuICAgICAgZ2V0U2Nyb2xsQXJlYU9mZnNldFdpZHRoOiAoKSA9PiB0aGlzLiRyZWZzLmFyZWEub2Zmc2V0V2lkdGgsXG4gICAgICBjb21wdXRlU2Nyb2xsQXJlYUNsaWVudFJlY3Q6ICgpID0+XG4gICAgICAgIHRoaXMuJHJlZnMuYXJlYS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgIGNvbXB1dGVTY3JvbGxDb250ZW50Q2xpZW50UmVjdDogKCkgPT5cbiAgICAgICAgdGhpcy4kcmVmcy5jb250ZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQ6ICgpID0+XG4gICAgICAgIHV0aWwuY29tcHV0ZUhvcml6b250YWxTY3JvbGxiYXJIZWlnaHQoZG9jdW1lbnQpXG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgaGFuZGxlVHJhbnNpdGlvbkVuZChldnQpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5oYW5kbGVUcmFuc2l0aW9uRW5kKGV2dClcbiAgICB9LFxuICAgIGhhbmRsZUludGVyYWN0aW9uKGV2dCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmhhbmRsZUludGVyYWN0aW9uKGV2dClcbiAgICB9LFxuICAgIGdldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5nZXRTY3JvbGxQb3NpdGlvbigpXG4gICAgfSxcbiAgICBnZXRTY3JvbGxDb250ZW50V2lkdGgoKSB7XG4gICAgICByZXR1cm4gdGhpcy4kcmVmcy5jb250ZW50Lm9mZnNldFdpZHRoXG4gICAgfSxcbiAgICBpbmNyZW1lbnRTY3JvbGwoc2Nyb2xsWEluY3JlbWVudCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmluY3JlbWVudFNjcm9sbChzY3JvbGxYSW5jcmVtZW50KVxuICAgIH0sXG4gICAgc2Nyb2xsVG8oc2Nyb2xsWCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNjcm9sbFRvKHNjcm9sbFgpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGFiIEluZGljYXRvci5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUYWIgSW5kaWNhdG9yIGludG8geW91ciBmcmFtZXdvcmsuIFNlZVxuICogaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvYmxvYi9tYXN0ZXIvZG9jcy9hdXRob3JpbmctY29tcG9uZW50cy5tZFxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHJlY29yZFxuICovXG5jbGFzcyBNRENUYWJJbmRpY2F0b3JBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgdGhlIGdpdmVuIGNsYXNzTmFtZSB0byB0aGUgcm9vdCBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIFRoZSBjbGFzc05hbWUgdG8gYWRkXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGdpdmVuIGNsYXNzTmFtZSBmcm9tIHRoZSByb290IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgVGhlIGNsYXNzTmFtZSB0byByZW1vdmVcbiAgICovXG4gIHJlbW92ZUNsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xpZW50IHJlY3Qgb2YgdGhlIGNvbnRlbnQgZWxlbWVudC5cbiAgICogQHJldHVybiB7IUNsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQ29udGVudENsaWVudFJlY3QoKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3R5bGUgcHJvcGVydHkgb2YgdGhlIGNvbnRlbnQgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wTmFtZSBUaGUgc3R5bGUgcHJvcGVydHkgbmFtZSB0byBzZXRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzdHlsZSBwcm9wZXJ0eSB2YWx1ZVxuICAgKi9cbiAgc2V0Q29udGVudFN0eWxlUHJvcGVydHkocHJvcE5hbWUsIHZhbHVlKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJJbmRpY2F0b3JBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXRhYi1pbmRpY2F0b3ItLWFjdGl2ZScsXG4gIEZBREU6ICdtZGMtdGFiLWluZGljYXRvci0tZmFkZScsXG4gIE5PX1RSQU5TSVRJT046ICdtZGMtdGFiLWluZGljYXRvci0tbm8tdHJhbnNpdGlvbicsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIENPTlRFTlRfU0VMRUNUT1I6ICcubWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQnLFxufTtcblxuZXhwb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGFiSW5kaWNhdG9yQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtcbiAgY3NzQ2xhc3NlcyxcbiAgc3RyaW5ncyxcbn0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUYWJJbmRpY2F0b3JBZGFwdGVyPn1cbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICAvKipcbiAgICogQHNlZSBNRENUYWJJbmRpY2F0b3JBZGFwdGVyIGZvciB0eXBpbmcgaW5mb3JtYXRpb25cbiAgICogQHJldHVybiB7IU1EQ1RhYkluZGljYXRvckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUYWJJbmRpY2F0b3JBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0OiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnRTdHlsZVByb3BlcnR5OiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcGFyYW0geyFNRENUYWJJbmRpY2F0b3JBZGFwdGVyfSBhZGFwdGVyICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshQ2xpZW50UmVjdH0gKi9cbiAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgaW5kaWNhdG9yXG4gICAqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3RcbiAgICogQGFic3RyYWN0XG4gICAqL1xuICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAvKiogQGFic3RyYWN0ICovXG4gIGRlYWN0aXZhdGUoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIGZyb20gJy4vZm91bmRhdGlvbic7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RhYkluZGljYXRvckZvdW5kYXRpb259XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDU2xpZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24gZXh0ZW5kcyBNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIHtcbiAgLyoqIEBwYXJhbSB7IUNsaWVudFJlY3Q9fSBwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QgKi9cbiAgYWN0aXZhdGUocHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0KSB7XG4gICAgLy8gRWFybHkgZXhpdCBpZiBubyBpbmRpY2F0b3IgaXMgcHJlc2VudCB0byBoYW5kbGUgY2FzZXMgd2hlcmUgYW4gaW5kaWNhdG9yXG4gICAgLy8gbWF5IGJlIGFjdGl2YXRlZCB3aXRob3V0IGEgcHJpb3IgaW5kaWNhdG9yIHN0YXRlXG4gICAgaWYgKCFwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFDVElWRSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBhbmltYXRpb24gdXNlcyB0aGUgRkxJUCBhcHByb2FjaC4gWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgaXQgYXQgdGhlIGxpbmsgYmVsb3c6XG4gICAgLy8gaHR0cHM6Ly9hZXJvdHdpc3QuY29tL2Jsb2cvZmxpcC15b3VyLWFuaW1hdGlvbnMvXG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIGRpbWVuc2lvbnMgYmFzZWQgb24gdGhlIGRpbWVuc2lvbnMgb2YgdGhlIHByZXZpb3VzIGluZGljYXRvclxuICAgIGNvbnN0IGN1cnJlbnRDbGllbnRSZWN0ID0gdGhpcy5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKTtcbiAgICBjb25zdCB3aWR0aERlbHRhID0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0LndpZHRoIC8gY3VycmVudENsaWVudFJlY3Qud2lkdGg7XG4gICAgY29uc3QgeFBvc2l0aW9uID0gcHJldmlvdXNJbmRpY2F0b3JDbGllbnRSZWN0LmxlZnQgLSBjdXJyZW50Q2xpZW50UmVjdC5sZWZ0O1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLk5PX1RSQU5TSVRJT04pO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0Q29udGVudFN0eWxlUHJvcGVydHkoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGVYKCR7eFBvc2l0aW9ufXB4KSBzY2FsZVgoJHt3aWR0aERlbHRhfSlgKTtcblxuICAgIC8vIEZvcmNlIHJlcGFpbnQgYmVmb3JlIHVwZGF0aW5nIGNsYXNzZXMgYW5kIHRyYW5zZm9ybSB0byBlbnN1cmUgdGhlIHRyYW5zZm9ybSBwcm9wZXJseSB0YWtlcyBlZmZlY3RcbiAgICB0aGlzLmNvbXB1dGVDb250ZW50Q2xpZW50UmVjdCgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuTk9fVFJBTlNJVElPTik7XG4gICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUYWJJbmRpY2F0b3JGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQUNUSVZFKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldENvbnRlbnRTdHlsZVByb3BlcnR5KCd0cmFuc2Zvcm0nLCAnJyk7XG4gIH1cblxuICBkZWFjdGl2YXRlKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoTURDVGFiSW5kaWNhdG9yRm91bmRhdGlvbi5jc3NDbGFzc2VzLkFDVElWRSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDU2xpZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb247XG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIGNsYXNzPVwibWRjLXRhYi1pbmRpY2F0b3JcIiA6Y2xhc3M9XCJjbGFzc2VzXCI+XG4gICAgPHNwYW5cbiAgICAgIHJlZj1cImNvbnRlbnRcIlxuICAgICAgOnN0eWxlPVwic3R5bGVzXCJcbiAgICAgIGNsYXNzPVwibWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQgbWRjLXRhYi1pbmRpY2F0b3JfX2NvbnRlbnQtLXVuZGVybGluZVwiXG4gICAgPjwvc3Bhbj5cbiAgPC9zcGFuPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENTbGlkaW5nVGFiSW5kaWNhdG9yRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGFiLWluZGljYXRvci9zbGlkaW5nLWZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10YWItaW5kaWNhdG9yJyxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBjbGFzc2VzOiB7fSwgc3R5bGVzOiB7fSB9XG4gIH0sXG5cbiAgbW91bnRlZCgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDU2xpZGluZ1RhYkluZGljYXRvckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpLFxuICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB0aGlzLiRkZWxldGUodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUpLFxuICAgICAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0OiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLmNvbnRlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBzZXRDb250ZW50U3R5bGVQcm9wZXJ0eTogKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgICAgIHRoaXMuJHNldCh0aGlzLnN0eWxlcywgcHJvcCwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHRoaXMuZm91bmRhdGlvbi5pbml0KClcbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBhY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5hY3RpdmF0ZShwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QpXG4gICAgfSxcbiAgICBkZWFjdGl2YXRlKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLmRlYWN0aXZhdGUoKVxuICAgIH0sXG4gICAgY29tcHV0ZUNvbnRlbnRDbGllbnRSZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuZm91bmRhdGlvbi5jb21wdXRlQ29udGVudENsaWVudFJlY3QoKVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCI8dGVtcGxhdGU+XG4gIDxzcGFuIGNsYXNzPVwibWRjLXRhYl9fcmlwcGxlXCIgOmNsYXNzPVwiY2xhc3Nlc1wiIDpzdHlsZT1cInN0eWxlc1wiPjwvc3Bhbj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGFiLXJpcHBsZScsXG5cbiAgZGF0YSgpIHtcbiAgICByZXR1cm4geyBjbGFzc2VzOiB7fSwgc3R5bGVzOiB7fSB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgbWRjVGFiIGZyb20gJy4vbWRjLXRhYi52dWUnXG5pbXBvcnQgbWRjVGFiQmFyIGZyb20gJy4vbWRjLXRhYi1iYXIudnVlJ1xuaW1wb3J0IG1kY1RhYlNjcm9sbGVyIGZyb20gJy4vbWRjLXRhYi1zY3JvbGxlci52dWUnXG5pbXBvcnQgbWRjVGFiSW5kaWNhdG9yIGZyb20gJy4vbWRjLXRhYi1pbmRpY2F0b3IudnVlJ1xuaW1wb3J0IG1kY1RhYlJpcHBsZSBmcm9tICcuL21kYy10YWItcmlwcGxlLnZ1ZSdcbmV4cG9ydCB7IG1kY1RhYiwgbWRjVGFiQmFyLCBtZGNUYWJTY3JvbGxlciwgbWRjVGFiSW5kaWNhdG9yLCBtZGNUYWJSaXBwbGUgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGFiLFxuICBtZGNUYWJCYXIsXG4gIG1kY1RhYlNjcm9sbGVyLFxuICBtZGNUYWJJbmRpY2F0b3IsXG4gIG1kY1RhYlJpcHBsZVxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBIZWxwZXIgVGV4dC5cbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUZXh0RmllbGQgaGVscGVyIHRleHQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIHtcbiAgLyoqXG4gICAqIEFkZHMgYSBjbGFzcyB0byB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBoZWxwZXIgdGV4dCBlbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIGFuIGF0dHJpYnV0ZSB3aXRoIGEgZ2l2ZW4gdmFsdWUgb24gdGhlIGhlbHBlciB0ZXh0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0QXR0cihhdHRyLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICovXG4gIHJlbW92ZUF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IGZvciB0aGUgaGVscGVyIHRleHQgZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnRcbiAgICovXG4gIHNldENvbnRlbnQoY29udGVudCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSGVscGVyVGV4dEFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0hJRERFTjogJ2FyaWEtaGlkZGVuJyxcbiAgUk9MRTogJ3JvbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBIRUxQRVJfVEVYVF9QRVJTSVNURU5UOiAnbWRjLXRleHQtZmllbGQtaGVscGVyLXRleHQtLXBlcnNpc3RlbnQnLFxuICBIRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRzogJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS12YWxpZGF0aW9uLW1zZycsXG59O1xuXG5leHBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXN9O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3N9IGZyb20gJy4vY29uc3RhbnRzJztcblxuXG4vKipcbiAqIEBleHRlbmRzIHtNRENGb3VuZGF0aW9uPCFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn0gZm9yIHR5cGluZyBpbmZvcm1hdGlvbiBvbiBwYXJhbWV0ZXJzIGFuZCByZXR1cm5cbiAgICogdHlwZXMuXG4gICAqIEByZXR1cm4geyFNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlcn1cbiAgICovXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgc2V0QXR0cjogKCkgPT4ge30sXG4gICAgICByZW1vdmVBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldENvbnRlbnQ6ICgpID0+IHt9LFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRBZGFwdGVyfSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlbHBlciB0ZXh0IGZpZWxkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gaXNQZXJzaXN0ZW50IFNldHMgdGhlIHBlcnNpc3RlbmN5IG9mIHRoZSBoZWxwZXIgdGV4dC4gKi9cbiAgc2V0UGVyc2lzdGVudChpc1BlcnNpc3RlbnQpIHtcbiAgICBpZiAoaXNQZXJzaXN0ZW50KSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9QRVJTSVNURU5UKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkYXRpb24gVHJ1ZSB0byBtYWtlIHRoZSBoZWxwZXIgdGV4dCBhY3QgYXMgYW5cbiAgICogICBlcnJvciB2YWxpZGF0aW9uIG1lc3NhZ2UuXG4gICAqL1xuICBzZXRWYWxpZGF0aW9uKGlzVmFsaWRhdGlvbikge1xuICAgIGlmIChpc1ZhbGlkYXRpb24pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5IRUxQRVJfVEVYVF9WQUxJREFUSU9OX01TRyk7XG4gICAgfVxuICB9XG5cbiAgLyoqIE1ha2VzIHRoZSBoZWxwZXIgdGV4dCB2aXNpYmxlIHRvIHRoZSBzY3JlZW4gcmVhZGVyLiAqL1xuICBzaG93VG9TY3JlZW5SZWFkZXIoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVBdHRyKHN0cmluZ3MuQVJJQV9ISURERU4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbGlkaXR5IG9mIHRoZSBoZWxwZXIgdGV4dCBiYXNlZCBvbiB0aGUgaW5wdXQgdmFsaWRpdHkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5wdXRJc1ZhbGlkXG4gICAqL1xuICBzZXRWYWxpZGl0eShpbnB1dElzVmFsaWQpIHtcbiAgICBjb25zdCBoZWxwZXJUZXh0SXNQZXJzaXN0ZW50ID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkhFTFBFUl9URVhUX1BFUlNJU1RFTlQpO1xuICAgIGNvbnN0IGhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2cgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSEVMUEVSX1RFWFRfVkFMSURBVElPTl9NU0cpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nc2dOZWVkc0Rpc3BsYXkgPSBoZWxwZXJUZXh0SXNWYWxpZGF0aW9uTXNnICYmICFpbnB1dElzVmFsaWQ7XG5cbiAgICBpZiAodmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyKHN0cmluZ3MuUk9MRSwgJ2FsZXJ0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cihzdHJpbmdzLlJPTEUpO1xuICAgIH1cblxuICAgIGlmICghaGVscGVyVGV4dElzUGVyc2lzdGVudCAmJiAhdmFsaWRhdGlvbk1zZ05lZWRzRGlzcGxheSkge1xuICAgICAgdGhpcy5oaWRlXygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgaGVscCB0ZXh0IGZyb20gc2NyZWVuIHJlYWRlcnMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBoaWRlXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoc3RyaW5ncy5BUklBX0hJRERFTiwgJ3RydWUnKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVGV4dCBGaWVsZCBJY29uLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIHRleHQgZmllbGQgaWNvbiBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIge1xuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIG9uIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldEF0dHIoYXR0cikge31cblxuICAvKipcbiAgICogU2V0cyBhbiBhdHRyaWJ1dGUgb24gdGhlIGljb24gZWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyKGF0dHIsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZSBmcm9tIHRoZSBpY29uIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyKGF0dHIpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHRleHQgY29udGVudCBvZiB0aGUgaWNvbiBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGxpc3RlbmVyIG9uIHRoZSBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEVtaXRzIGEgY3VzdG9tIGV2ZW50IFwiTURDVGV4dEZpZWxkOmljb25cIiBkZW5vdGluZyBhIHVzZXIgaGFzIGNsaWNrZWQgdGhlIGljb24uXG4gICAqL1xuICBub3RpZnlJY29uQWN0aW9uKCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBJQ09OX0VWRU5UOiAnTURDVGV4dEZpZWxkOmljb24nLFxuICBJQ09OX1JPTEU6ICdidXR0b24nLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENUZXh0RmllbGRJY29uQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXI+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAc2VlIE1EQ1RleHRGaWVsZEljb25BZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEljb25BZGFwdGVyfVxuICAgKi9cbiAgc3RhdGljIGdldCBkZWZhdWx0QWRhcHRlcigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9ICovICh7XG4gICAgICBnZXRBdHRyOiAoKSA9PiB7fSxcbiAgICAgIHNldEF0dHI6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQXR0cjogKCkgPT4ge30sXG4gICAgICBzZXRDb250ZW50OiAoKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4ge30sXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge3N0cmluZz99ICovXG4gICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IG51bGw7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZUludGVyYWN0aW9uKGV2dCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuc2F2ZWRUYWJJbmRleF8gPSB0aGlzLmFkYXB0ZXJfLmdldEF0dHIoJ3RhYmluZGV4Jyk7XG5cbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuaW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIFsnY2xpY2snLCAna2V5ZG93biddLmZvckVhY2goKGV2dFR5cGUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLmludGVyYWN0aW9uSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWQgKi9cbiAgc2V0RGlzYWJsZWQoZGlzYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuc2F2ZWRUYWJJbmRleF8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cigndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cigncm9sZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3RhYmluZGV4JywgdGhpcy5zYXZlZFRhYkluZGV4Xyk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ3JvbGUnLCBzdHJpbmdzLklDT05fUk9MRSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBsYWJlbCAqL1xuICBzZXRBcmlhTGFiZWwobGFiZWwpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHIoJ2FyaWEtbGFiZWwnLCBsYWJlbCk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgKi9cbiAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRDb250ZW50KGNvbnRlbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYW4gaW50ZXJhY3Rpb24gZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgaGFuZGxlSW50ZXJhY3Rpb24oZXZ0KSB7XG4gICAgaWYgKGV2dC50eXBlID09PSAnY2xpY2snIHx8IGV2dC5rZXkgPT09ICdFbnRlcicgfHwgZXZ0LmtleUNvZGUgPT09IDEzKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUljb25BY3Rpb24oKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICcuL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9uIGZyb20gJy4vaWNvbi9mb3VuZGF0aW9uJztcblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgdmFsdWU6IHN0cmluZyxcbiAqICAgZGlzYWJsZWQ6IGJvb2xlYW4sXG4gKiAgIGJhZElucHV0OiBib29sZWFuLFxuICogICB2YWxpZGl0eToge1xuICogICAgIGJhZElucHV0OiBib29sZWFuLFxuICogICAgIHZhbGlkOiBib29sZWFuLFxuICogICB9LFxuICogfX1cbiAqL1xubGV0IE5hdGl2ZUlucHV0VHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBoZWxwZXJUZXh0OiAoIU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIGxlYWRpbmdJY29uOiAoIU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZCksXG4gKiAgIHRyYWlsaW5nSWNvbjogKCFNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbnx1bmRlZmluZWQpLFxuICogfX1cbiAqL1xubGV0IEZvdW5kYXRpb25NYXBUeXBlO1xuXG4vKipcbiAqIEFkYXB0ZXIgZm9yIE1EQyBUZXh0IEZpZWxkLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFRleHQgRmllbGQgaW50byB5b3VyIGZyYW1ld29yay4gU2VlXG4gKiBodHRwczovL2dpdGh1Yi5jb20vbWF0ZXJpYWwtY29tcG9uZW50cy9tYXRlcmlhbC1jb21wb25lbnRzLXdlYi9ibG9iL21hc3Rlci9kb2NzL2F1dGhvcmluZy1jb21wb25lbnRzLm1kXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1RleHRGaWVsZEFkYXB0ZXIge1xuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSByb290IEVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGNsYXNzIGZyb20gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgcmVtb3ZlQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBjb250YWlucyB0aGUgZ2l2ZW4gY2xhc3MgbmFtZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgcm9vdCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgbGlzdGVuZXIgb24gdGhlIG5hdGl2ZSBpbnB1dCBlbGVtZW50IGZvciBhIGdpdmVuIGV2ZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBsaXN0ZW5lciBvbiB0aGUgbmF0aXZlIGlucHV0IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0VHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgY2hhbmdlIGxpc3RlbmVyIG9uIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiBIYW5kbGVyIGFjY2VwdHMgbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUFycmF5PHN0cmluZz4pOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICogQHJldHVybiB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAqL1xuICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGEgdmFsaWRhdGlvbiBhdHRyaWJ1dGUgb2JzZXJ2ZXIgb24gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IG9ic2VydmVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIob2JzZXJ2ZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZWxlbWVudCwgd2l0aCBhXG4gICAqIHNpbWlsYXIgQVBJIHNoYXBlLiBUaGUgb2JqZWN0IHJldHVybmVkIHNob3VsZCBpbmNsdWRlIHRoZSB2YWx1ZSwgZGlzYWJsZWRcbiAgICogYW5kIGJhZElucHV0IHByb3BlcnRpZXMsIGFzIHdlbGwgYXMgdGhlIGNoZWNrVmFsaWRpdHkoKSBmdW5jdGlvbi4gV2UgbmV2ZXJcbiAgICogYWx0ZXIgdGhlIHZhbHVlIHdpdGhpbiBvdXIgY29kZSwgaG93ZXZlciB3ZSBkbyB1cGRhdGUgdGhlIGRpc2FibGVkXG4gICAqIHByb3BlcnR5LCBzbyBpZiB5b3UgY2hvb3NlIHRvIGR1Y2stdHlwZSB0aGUgcmV0dXJuIHZhbHVlIGZvciB0aGlzIG1ldGhvZFxuICAgKiBpbiB5b3VyIGltcGxlbWVudGF0aW9uIGl0J3MgaW1wb3J0YW50IHRvIGtlZXAgdGhpcyBpbiBtaW5kLiBBbHNvIG5vdGUgdGhhdFxuICAgKiB0aGlzIG1ldGhvZCBjYW4gcmV0dXJuIG51bGwsIHdoaWNoIHRoZSBmb3VuZGF0aW9uIHdpbGwgaGFuZGxlIGdyYWNlZnVsbHkuXG4gICAqIEByZXR1cm4gez9FbGVtZW50fD9OYXRpdmVJbnB1dFR5cGV9XG4gICAqL1xuICBnZXROYXRpdmVJbnB1dCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGV4dGZpZWxkIGlzIGZvY3VzZWQuXG4gICAqIFdlIGFjaGlldmUgdGhpcyB2aWEgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMucm9vdF9gLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2VkKCkge31cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZS5cbiAgICovXG4gIGFjdGl2YXRlTGluZVJpcHBsZSgpIHt9XG5cbiAgLyoqXG4gICAqIERlYWN0aXZhdGVzIHRoZSBsaW5lIHJpcHBsZS5cbiAgICovXG4gIGRlYWN0aXZhdGVMaW5lUmlwcGxlKCkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgdHJhbnNmb3JtIG9yaWdpbiBvZiB0aGUgbGluZSByaXBwbGUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBub3JtYWxpemVkWFxuICAgKi9cbiAgc2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbihub3JtYWxpemVkWCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgbGFiZWwgZXhpc3RzLlxuICAgKiBTaGFrZXMgbGFiZWwgaWYgc2hvdWxkU2hha2UgaXMgdHJ1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRTaGFrZVxuICAgKi9cbiAgc2hha2VMYWJlbChzaG91bGRTaGFrZSkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgbGFiZWwgZXhpc3RzLlxuICAgKiBGbG9hdHMgdGhlIGxhYmVsIGFib3ZlIHRoZSBpbnB1dCBlbGVtZW50IGlmIHNob3VsZEZsb2F0IGlzIHRydWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkRmxvYXRcbiAgICovXG4gIGZsb2F0TGFiZWwoc2hvdWxkRmxvYXQpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBsYWJlbCBlbGVtZW50IGV4aXN0cywgZmFsc2UgaWYgaXQgZG9lc24ndC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0xhYmVsKCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgbGFiZWwgZXhpc3RzLlxuICAgKiBSZXR1cm5zIHdpZHRoIG9mIGxhYmVsIGluIHBpeGVscy5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGFiZWxXaWR0aCgpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBvdXRsaW5lIGVsZW1lbnQgZXhpc3RzLCBmYWxzZSBpZiBpdCBkb2Vzbid0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzT3V0bGluZSgpIHt9XG5cbiAgLyoqXG4gICAqIE9ubHkgaW1wbGVtZW50IGlmIG91dGxpbmUgZWxlbWVudCBleGlzdHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsYWJlbFdpZHRoXG4gICAqL1xuICBub3RjaE91dGxpbmUobGFiZWxXaWR0aCkge31cblxuICAvKipcbiAgICogT25seSBpbXBsZW1lbnQgaWYgb3V0bGluZSBlbGVtZW50IGV4aXN0cy5cbiAgICogQ2xvc2VzIG5vdGNoIGluIG91dGxpbmUgZWxlbWVudC5cbiAgICovXG4gIGNsb3NlT3V0bGluZSgpIHt9XG59XG5cbmV4cG9ydCB7TURDVGV4dEZpZWxkQWRhcHRlciwgTmF0aXZlSW5wdXRUeXBlLCBGb3VuZGF0aW9uTWFwVHlwZX07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBUklBX0NPTlRST0xTOiAnYXJpYS1jb250cm9scycsXG4gIElOUFVUX1NFTEVDVE9SOiAnLm1kYy10ZXh0LWZpZWxkX19pbnB1dCcsXG4gIExBQkVMX1NFTEVDVE9SOiAnLm1kYy1mbG9hdGluZy1sYWJlbCcsXG4gIElDT05fU0VMRUNUT1I6ICcubWRjLXRleHQtZmllbGRfX2ljb24nLFxuICBPVVRMSU5FX1NFTEVDVE9SOiAnLm1kYy1ub3RjaGVkLW91dGxpbmUnLFxuICBMSU5FX1JJUFBMRV9TRUxFQ1RPUjogJy5tZGMtbGluZS1yaXBwbGUnLFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLXRleHQtZmllbGQnLFxuICBESVNBQkxFRDogJ21kYy10ZXh0LWZpZWxkLS1kaXNhYmxlZCcsXG4gIERFTlNFOiAnbWRjLXRleHQtZmllbGQtLWRlbnNlJyxcbiAgRk9DVVNFRDogJ21kYy10ZXh0LWZpZWxkLS1mb2N1c2VkJyxcbiAgSU5WQUxJRDogJ21kYy10ZXh0LWZpZWxkLS1pbnZhbGlkJyxcbiAgVEVYVEFSRUE6ICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnLFxuICBPVVRMSU5FRDogJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCcsXG4gIFdJVEhfTEVBRElOR19JQ09OOiAnbWRjLXRleHQtZmllbGQtLXdpdGgtbGVhZGluZy1pY29uJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgTEFCRUxfU0NBTEU6IDAuNzUsXG4gIERFTlNFX0xBQkVMX1NDQUxFOiAwLjkyMyxcbn07XG5cbi8vIHdoaXRlbGlzdCBiYXNlZCBvZmYgb2YgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvSFRNTC9IVE1MNS9Db25zdHJhaW50X3ZhbGlkYXRpb25cbi8vIHVuZGVyIHNlY3Rpb246IGBWYWxpZGF0aW9uLXJlbGF0ZWQgYXR0cmlidXRlc2BcbmNvbnN0IFZBTElEQVRJT05fQVRUUl9XSElURUxJU1QgPSBbXG4gICdwYXR0ZXJuJywgJ21pbicsICdtYXgnLCAncmVxdWlyZWQnLCAnc3RlcCcsICdtaW5sZW5ndGgnLCAnbWF4bGVuZ3RoJyxcbl07XG5cbi8vIExhYmVsIHNob3VsZCBhbHdheXMgZmxvYXQgZm9yIHRoZXNlIHR5cGVzIGFzIHRoZXkgc2hvdyBzb21lIFVJIGV2ZW4gaWYgdmFsdWUgaXMgZW1wdHkuXG5jb25zdCBBTFdBWVNfRkxPQVRfVFlQRVMgPSBbXG4gICdjb2xvcicsICdkYXRlJywgJ2RhdGV0aW1lLWxvY2FsJywgJ21vbnRoJywgJ3JhbmdlJywgJ3RpbWUnLCAnd2VlaycsXG5dO1xuXG5leHBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnMsIFZBTElEQVRJT05fQVRUUl9XSElURUxJU1QsIEFMV0FZU19GTE9BVF9UWVBFU307XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IE1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIGZyb20gJy4vaGVscGVyLXRleHQvZm91bmRhdGlvbic7XG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnLi9pY29uL2ZvdW5kYXRpb24nO1xuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IHtNRENUZXh0RmllbGRBZGFwdGVyLCBOYXRpdmVJbnB1dFR5cGUsIEZvdW5kYXRpb25NYXBUeXBlfSBmcm9tICcuL2FkYXB0ZXInO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzLCBWQUxJREFUSU9OX0FUVFJfV0hJVEVMSVNULCBBTFdBWVNfRkxPQVRfVFlQRVN9IGZyb20gJy4vY29uc3RhbnRzJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVGV4dEZpZWxkQWRhcHRlcj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVGV4dEZpZWxkRm91bmRhdGlvbiBleHRlbmRzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVtIHtzdHJpbmd9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgcmV0dXJuIG51bWJlcnM7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgZ2V0IHNob3VsZFNoYWtlKCkge1xuICAgIHJldHVybiAhdGhpcy5pc1ZhbGlkKCkgJiYgIXRoaXMuaXNGb2N1c2VkXyAmJiAhIXRoaXMuZ2V0VmFsdWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0IHNob3VsZEFsd2F5c0Zsb2F0XygpIHtcbiAgICBjb25zdCB0eXBlID0gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS50eXBlO1xuICAgIHJldHVybiBBTFdBWVNfRkxPQVRfVFlQRVMuaW5kZXhPZih0eXBlKSA+PSAwO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGdldCBzaG91bGRGbG9hdCgpIHtcbiAgICByZXR1cm4gdGhpcy5zaG91bGRBbHdheXNGbG9hdF8gfHwgdGhpcy5pc0ZvY3VzZWRfIHx8ICEhdGhpcy5nZXRWYWx1ZSgpIHx8IHRoaXMuaXNCYWRJbnB1dF8oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUZXh0RmllbGRBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RleHRGaWVsZEFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUZXh0RmllbGRBZGFwdGVyfSAqLyAoe1xuICAgICAgYWRkQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgaGFzQ2xhc3M6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6ICgpID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICByZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiAoKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogKCkgPT4ge30sXG4gICAgICBnZXROYXRpdmVJbnB1dDogKCkgPT4ge30sXG4gICAgICBpc0ZvY3VzZWQ6ICgpID0+IHt9LFxuICAgICAgYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7fSxcbiAgICAgIHNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW46ICgpID0+IHt9LFxuICAgICAgc2hha2VMYWJlbDogKCkgPT4ge30sXG4gICAgICBmbG9hdExhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGhhc0xhYmVsOiAoKSA9PiB7fSxcbiAgICAgIGdldExhYmVsV2lkdGg6ICgpID0+IHt9LFxuICAgICAgaGFzT3V0bGluZTogKCkgPT4ge30sXG4gICAgICBub3RjaE91dGxpbmU6ICgpID0+IHt9LFxuICAgICAgY2xvc2VPdXRsaW5lOiAoKSA9PiB7fSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFNRENUZXh0RmllbGRBZGFwdGVyfSBhZGFwdGVyXG4gICAqIEBwYXJhbSB7IUZvdW5kYXRpb25NYXBUeXBlPX0gZm91bmRhdGlvbk1hcCBNYXAgZnJvbSBzdWJjb21wb25lbnQgbmFtZXMgdG8gdGhlaXIgc3ViZm91bmRhdGlvbnMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBmb3VuZGF0aW9uTWFwID0gLyoqIEB0eXBlIHshRm91bmRhdGlvbk1hcFR5cGV9ICovICh7fSkpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmhlbHBlclRleHRfID0gZm91bmRhdGlvbk1hcC5oZWxwZXJUZXh0O1xuICAgIC8qKiBAdHlwZSB7IU1EQ1RleHRGaWVsZEljb25Gb3VuZGF0aW9ufHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmxlYWRpbmdJY29uXyA9IGZvdW5kYXRpb25NYXAubGVhZGluZ0ljb247XG4gICAgLyoqIEB0eXBlIHshTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb258dW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudHJhaWxpbmdJY29uXyA9IGZvdW5kYXRpb25NYXAudHJhaWxpbmdJY29uO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNGb2N1c2VkXyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnJlY2VpdmVkVXNlcklucHV0XyA9IGZhbHNlO1xuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLnVzZUN1c3RvbVZhbGlkaXR5Q2hlY2tpbmdfID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMuaXNWYWxpZF8gPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtib29sZWFufSAqL1xuICAgIHRoaXMudXNlTmF0aXZlVmFsaWRhdGlvbl8gPSB0cnVlO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbigpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFjdGl2YXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0Qmx1ckhhbmRsZXJfID0gKCkgPT4gdGhpcy5kZWFjdGl2YXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLmlucHV0SW5wdXRIYW5kbGVyXyA9ICgpID0+IHRoaXMuYXV0b0NvbXBsZXRlRm9jdXMoKTtcbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0XyA9IChldnQpID0+IHRoaXMuc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCk7XG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9ICovXG4gICAgdGhpcy50ZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXJfID0gKCkgPT4gdGhpcy5oYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpO1xuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oIUFycmF5KTogdW5kZWZpbmVkfSAqL1xuICAgIHRoaXMudmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfID0gKGF0dHJpYnV0ZXNMaXN0KSA9PiB0aGlzLmhhbmRsZVZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2UoYXR0cmlidXRlc0xpc3QpO1xuXG4gICAgLyoqIEBwcml2YXRlIHshTXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLnZhbGlkYXRpb25PYnNlcnZlcl87XG4gIH1cblxuICBpbml0KCkge1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzRm9jdXNlZCgpKSB7XG4gICAgICB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXygpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpICYmIHRoaXMuc2hvdWxkRmxvYXQpIHtcbiAgICAgIHRoaXMubm90Y2hPdXRsaW5lKHRydWUpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5mbG9hdExhYmVsKHRydWUpO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmlucHV0Rm9jdXNIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdpbnB1dCcsIHRoaXMuaW5wdXRJbnB1dEhhbmRsZXJfKTtcbiAgICBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMuc2V0UG9pbnRlclhPZmZzZXRfKTtcbiAgICB9KTtcbiAgICBbJ2NsaWNrJywgJ2tleWRvd24nXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfID1cbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyKHRoaXMudmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5pbnB1dEZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlcklucHV0SW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5pbnB1dEJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW5wdXRJbnRlcmFjdGlvbkhhbmRsZXIoJ2lucHV0JywgdGhpcy5pbnB1dElucHV0SGFuZGxlcl8pO1xuICAgIFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXS5mb3JFYWNoKChldnRUeXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCB0aGlzLnNldFBvaW50ZXJYT2Zmc2V0Xyk7XG4gICAgfSk7XG4gICAgWydjbGljaycsICdrZXlkb3duJ10uZm9yRWFjaCgoZXZ0VHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIHRoaXMudGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIodGhpcy52YWxpZGF0aW9uT2JzZXJ2ZXJfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHVzZXIgaW50ZXJhY3Rpb25zIHdpdGggdGhlIFRleHQgRmllbGQuXG4gICAqL1xuICBoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbigpIHtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpLmRpc2FibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVjZWl2ZWRVc2VySW5wdXRfID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHZhbGlkYXRpb24gYXR0cmlidXRlIGNoYW5nZXNcbiAgICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc0xpc3RcbiAgICovXG4gIGhhbmRsZVZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2UoYXR0cmlidXRlc0xpc3QpIHtcbiAgICBhdHRyaWJ1dGVzTGlzdC5zb21lKChhdHRyaWJ1dGVOYW1lKSA9PiB7XG4gICAgICBpZiAoVkFMSURBVElPTl9BVFRSX1dISVRFTElTVC5pbmRleE9mKGF0dHJpYnV0ZU5hbWUpID4gLTEpIHtcbiAgICAgICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogT3BlbnMvY2xvc2VzIHRoZSBub3RjaGVkIG91dGxpbmUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3Blbk5vdGNoXG4gICAqL1xuICBub3RjaE91dGxpbmUob3Blbk5vdGNoKSB7XG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmhhc091dGxpbmUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChvcGVuTm90Y2gpIHtcbiAgICAgIGNvbnN0IGlzRGVuc2UgPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuREVOU0UpO1xuICAgICAgY29uc3QgbGFiZWxTY2FsZSA9IGlzRGVuc2UgPyBudW1iZXJzLkRFTlNFX0xBQkVMX1NDQUxFIDogbnVtYmVycy5MQUJFTF9TQ0FMRTtcbiAgICAgIGNvbnN0IGxhYmVsV2lkdGggPSB0aGlzLmFkYXB0ZXJfLmdldExhYmVsV2lkdGgoKSAqIGxhYmVsU2NhbGU7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGNoT3V0bGluZShsYWJlbFdpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5jbG9zZU91dGxpbmUoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIHRoZSB0ZXh0IGZpZWxkIGZvY3VzIHN0YXRlLlxuICAgKi9cbiAgYWN0aXZhdGVGb2N1cygpIHtcbiAgICB0aGlzLmlzRm9jdXNlZF8gPSB0cnVlO1xuICAgIHRoaXMuc3R5bGVGb2N1c2VkXyh0aGlzLmlzRm9jdXNlZF8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWN0aXZhdGVMaW5lUmlwcGxlKCk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNob3dUb1NjcmVlblJlYWRlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsaW5lIHJpcHBsZSdzIHRyYW5zZm9ybSBvcmlnaW4sIHNvIHRoYXQgdGhlIGxpbmUgcmlwcGxlIGFjdGl2YXRlXG4gICAqIGFuaW1hdGlvbiB3aWxsIGFuaW1hdGUgb3V0IGZyb20gdGhlIHVzZXIncyBjbGljayBsb2NhdGlvbi5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKi9cbiAgc2V0VHJhbnNmb3JtT3JpZ2luKGV2dCkge1xuICAgIGxldCB0YXJnZXRFdmVudDtcbiAgICBpZiAoZXZ0LnRvdWNoZXMpIHtcbiAgICAgIHRhcmdldEV2ZW50ID0gZXZ0LnRvdWNoZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldEV2ZW50ID0gZXZ0O1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDbGllbnRSZWN0ID0gdGFyZ2V0RXZlbnQudGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRYID0gdGFyZ2V0RXZlbnQuY2xpZW50WCAtIHRhcmdldENsaWVudFJlY3QubGVmdDtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldExpbmVSaXBwbGVUcmFuc2Zvcm1PcmlnaW4obm9ybWFsaXplZFgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRlcyB0aGUgVGV4dCBGaWVsZCdzIGZvY3VzIHN0YXRlIGluIGNhc2VzIHdoZW4gdGhlIGlucHV0IHZhbHVlXG4gICAqIGNoYW5nZXMgd2l0aG91dCB1c2VyIGlucHV0IChlLmcuIHByb2dyYW1hdGljYWxseSkuXG4gICAqL1xuICBhdXRvQ29tcGxldGVGb2N1cygpIHtcbiAgICBpZiAoIXRoaXMucmVjZWl2ZWRVc2VySW5wdXRfKSB7XG4gICAgICB0aGlzLmFjdGl2YXRlRm9jdXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIFRleHQgRmllbGQncyBmb2N1cyBzdGF0ZS5cbiAgICovXG4gIGRlYWN0aXZhdGVGb2N1cygpIHtcbiAgICB0aGlzLmlzRm9jdXNlZF8gPSBmYWxzZTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlYWN0aXZhdGVMaW5lUmlwcGxlKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IHRoaXMuaXNWYWxpZCgpO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG4gICAgdGhpcy5zdHlsZUZvY3VzZWRfKHRoaXMuaXNGb2N1c2VkXyk7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5ub3RjaE91dGxpbmUodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmZsb2F0TGFiZWwodGhpcy5zaG91bGRGbG9hdCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNoYWtlTGFiZWwodGhpcy5zaG91bGRTaGFrZSk7XG4gICAgfVxuICAgIGlmICghdGhpcy5zaG91bGRGbG9hdCkge1xuICAgICAgdGhpcy5yZWNlaXZlZFVzZXJJbnB1dF8gPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgdmFsdWUgb2YgdGhlIGlucHV0IEVsZW1lbnQuXG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCBvbiB0aGUgaW5wdXQgRWxlbWVudC5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgLy8gUHJldmVudCBTYWZhcmkgZnJvbSBtb3ZpbmcgdGhlIGNhcmV0IHRvIHRoZSBlbmQgb2YgdGhlIGlucHV0IHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cbiAgICBpZiAodGhpcy5nZXRWYWx1ZSgpICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpc1ZhbGlkID0gdGhpcy5pc1ZhbGlkKCk7XG4gICAgdGhpcy5zdHlsZVZhbGlkaXR5Xyhpc1ZhbGlkKTtcbiAgICBpZiAodGhpcy5hZGFwdGVyXy5oYXNMYWJlbCgpKSB7XG4gICAgICB0aGlzLm5vdGNoT3V0bGluZSh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZmxvYXRMYWJlbCh0aGlzLnNob3VsZEZsb2F0KTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2hha2VMYWJlbCh0aGlzLnNob3VsZFNoYWtlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gSWYgYSBjdXN0b20gdmFsaWRpdHkgaXMgc2V0LCByZXR1cm5zIHRoYXQgdmFsdWUuXG4gICAqICAgICBPdGhlcndpc2UsIHJldHVybnMgdGhlIHJlc3VsdCBvZiBuYXRpdmUgdmFsaWRpdHkgY2hlY2tzLlxuICAgKi9cbiAgaXNWYWxpZCgpIHtcbiAgICByZXR1cm4gdGhpcy51c2VOYXRpdmVWYWxpZGF0aW9uX1xuICAgICAgPyB0aGlzLmlzTmF0aXZlSW5wdXRWYWxpZF8oKSA6IHRoaXMuaXNWYWxpZF87XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1ZhbGlkIFNldHMgdGhlIHZhbGlkaXR5IHN0YXRlIG9mIHRoZSBUZXh0IEZpZWxkLlxuICAgKi9cbiAgc2V0VmFsaWQoaXNWYWxpZCkge1xuICAgIHRoaXMuaXNWYWxpZF8gPSBpc1ZhbGlkO1xuICAgIHRoaXMuc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCk7XG5cbiAgICBjb25zdCBzaG91bGRTaGFrZSA9ICFpc1ZhbGlkICYmICF0aGlzLmlzRm9jdXNlZF87XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzTGFiZWwoKSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5zaGFrZUxhYmVsKHNob3VsZFNoYWtlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5hYmxlcyBvciBkaXNhYmxlcyB0aGUgdXNlIG9mIG5hdGl2ZSB2YWxpZGF0aW9uLiBVc2UgdGhpcyBmb3IgY3VzdG9tIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlTmF0aXZlVmFsaWRhdGlvbiBTZXQgdGhpcyB0byBmYWxzZSB0byBpZ25vcmUgbmF0aXZlIGlucHV0IHZhbGlkYXRpb24uXG4gICAqL1xuICBzZXRVc2VOYXRpdmVWYWxpZGF0aW9uKHVzZU5hdGl2ZVZhbGlkYXRpb24pIHtcbiAgICB0aGlzLnVzZU5hdGl2ZVZhbGlkYXRpb25fID0gdXNlTmF0aXZlVmFsaWRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBUZXh0IEZpZWxkIGlzIGRpc2FibGVkLlxuICAgKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS5kaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRpc2FibGVkIFNldHMgdGhlIHRleHQtZmllbGQgZGlzYWJsZWQgb3IgZW5hYmxlZC5cbiAgICovXG4gIHNldERpc2FibGVkKGRpc2FibGVkKSB7XG4gICAgdGhpcy5nZXROYXRpdmVJbnB1dF8oKS5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIHRoaXMuc3R5bGVEaXNhYmxlZF8oZGlzYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IFNldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGhlbHBlciB0ZXh0LlxuICAgKi9cbiAgc2V0SGVscGVyVGV4dENvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLmhlbHBlclRleHRfKSB7XG4gICAgICB0aGlzLmhlbHBlclRleHRfLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFyaWEgbGFiZWwgb2YgdGhlIGxlYWRpbmcgaWNvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBzZXRMZWFkaW5nSWNvbkFyaWFMYWJlbChsYWJlbCkge1xuICAgIGlmICh0aGlzLmxlYWRpbmdJY29uXykge1xuICAgICAgdGhpcy5sZWFkaW5nSWNvbl8uc2V0QXJpYUxhYmVsKGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBsZWFkaW5nIGljb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50XG4gICAqL1xuICBzZXRMZWFkaW5nSWNvbkNvbnRlbnQoY29udGVudCkge1xuICAgIGlmICh0aGlzLmxlYWRpbmdJY29uXykge1xuICAgICAgdGhpcy5sZWFkaW5nSWNvbl8uc2V0Q29udGVudChjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgYXJpYSBsYWJlbCBvZiB0aGUgdHJhaWxpbmcgaWNvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsXG4gICAqL1xuICBzZXRUcmFpbGluZ0ljb25BcmlhTGFiZWwobGFiZWwpIHtcbiAgICBpZiAodGhpcy50cmFpbGluZ0ljb25fKSB7XG4gICAgICB0aGlzLnRyYWlsaW5nSWNvbl8uc2V0QXJpYUxhYmVsKGxhYmVsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSB0cmFpbGluZyBpY29uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudFxuICAgKi9cbiAgc2V0VHJhaWxpbmdJY29uQ29udGVudChjb250ZW50KSB7XG4gICAgaWYgKHRoaXMudHJhaWxpbmdJY29uXykge1xuICAgICAgdGhpcy50cmFpbGluZ0ljb25fLnNldENvbnRlbnQoY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIFRleHQgRmllbGQgaW5wdXQgZmFpbHMgaW4gY29udmVydGluZyB0aGVcbiAgICogICAgIHVzZXItc3VwcGxpZWQgdmFsdWUuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc0JhZElucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS5iYWRJbnB1dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgcmVzdWx0IG9mIG5hdGl2ZSB2YWxpZGl0eSBjaGVja2luZ1xuICAgKiAgICAgKFZhbGlkaXR5U3RhdGUudmFsaWQpLlxuICAgKi9cbiAgaXNOYXRpdmVJbnB1dFZhbGlkXygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROYXRpdmVJbnB1dF8oKS52YWxpZGl0eS52YWxpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdHlsZXMgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiB0aGUgdmFsaWRpdHkgc3RhdGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNWYWxpZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVWYWxpZGl0eV8oaXNWYWxpZCkge1xuICAgIGNvbnN0IHtJTlZBTElEfSA9IE1EQ1RleHRGaWVsZEZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhJTlZBTElEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhJTlZBTElEKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaGVscGVyVGV4dF8pIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dF8uc2V0VmFsaWRpdHkoaXNWYWxpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFN0eWxlcyB0aGUgY29tcG9uZW50IGJhc2VkIG9uIHRoZSBmb2N1c2VkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRm9jdXNlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3R5bGVGb2N1c2VkXyhpc0ZvY3VzZWQpIHtcbiAgICBjb25zdCB7Rk9DVVNFRH0gPSBNRENUZXh0RmllbGRGb3VuZGF0aW9uLmNzc0NsYXNzZXM7XG4gICAgaWYgKGlzRm9jdXNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGT0NVU0VEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGT0NVU0VEKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU3R5bGVzIHRoZSBjb21wb25lbnQgYmFzZWQgb24gdGhlIGRpc2FibGVkIHN0YXRlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzRGlzYWJsZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0eWxlRGlzYWJsZWRfKGlzRGlzYWJsZWQpIHtcbiAgICBjb25zdCB7RElTQUJMRUQsIElOVkFMSUR9ID0gTURDVGV4dEZpZWxkRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmIChpc0Rpc2FibGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKERJU0FCTEVEKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoSU5WQUxJRCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRElTQUJMRUQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlYWRpbmdJY29uXykge1xuICAgICAgdGhpcy5sZWFkaW5nSWNvbl8uc2V0RGlzYWJsZWQoaXNEaXNhYmxlZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHJhaWxpbmdJY29uXykge1xuICAgICAgdGhpcy50cmFpbGluZ0ljb25fLnNldERpc2FibGVkKGlzRGlzYWJsZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHshRWxlbWVudHwhTmF0aXZlSW5wdXRUeXBlfSBUaGUgbmF0aXZlIHRleHQgaW5wdXQgZnJvbSB0aGVcbiAgICogaG9zdCBlbnZpcm9ubWVudCwgb3IgYSBkdW1teSBpZiBub25lIGV4aXN0cy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE5hdGl2ZUlucHV0XygpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXROYXRpdmVJbnB1dCgpIHx8XG4gICAgLyoqIEB0eXBlIHshTmF0aXZlSW5wdXRUeXBlfSAqLyAoe1xuICAgICAgdmFsdWU6ICcnLFxuICAgICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgdmFsaWRpdHk6IHtcbiAgICAgICAgYmFkSW5wdXQ6IGZhbHNlLFxuICAgICAgICB2YWxpZDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDVGV4dEZpZWxkRm91bmRhdGlvbjtcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdlxuICAgIDpzdHlsZT1cInsgd2lkdGg6IGZ1bGx3aWR0aCA/ICcxMDAlJyA6IHVuZGVmaW5lZCB9XCJcbiAgICA6aWQ9XCJpZFwiXG4gICAgY2xhc3M9XCJtZGMtdGV4dGZpZWxkLXdyYXBwZXJcIlxuICA+XG4gICAgPGRpdiByZWY9XCJyb290XCIgOmNsYXNzPVwicm9vdENsYXNzZXNcIj5cbiAgICAgIDxpXG4gICAgICAgIHYtaWY9XCIhIWhhc0xlYWRpbmdJY29uXCJcbiAgICAgICAgcmVmPVwibGVhZGluZ0ljb25cIlxuICAgICAgICA6Y2xhc3M9XCJoYXNMZWFkaW5nSWNvbi5jbGFzc2VzXCJcbiAgICAgICAgOnRhYmluZGV4PVwibGVhZGluZ1RhYmluZGV4XCJcbiAgICAgICAgOnJvbGU9XCJsZWFkaW5nUm9sZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRleHQtZmllbGRfX2ljb25cIlxuICAgICAgPlxuICAgICAgICA8c2xvdCBuYW1lPVwibGVhZGluZy1pY29uXCI+e3sgaGFzTGVhZGluZ0ljb24uY29udGVudCB9fTwvc2xvdD5cbiAgICAgIDwvaT5cblxuICAgICAgPCEtLVxuICAgICAgICB3b3JrYXJyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3Z1ZWpzL3JvbGx1cC1wbHVnaW4tdnVlL2lzc3Vlcy8xNzRcbiAgICAgIC0tPlxuICAgICAgPCEtLSBlc2xpbnQtZGlzYWJsZSB2dWUvaHRtbC1zZWxmLWNsb3NpbmcgLS0+XG4gICAgICA8dGV4dGFyZWFcbiAgICAgICAgdi1pZj1cIm11bHRpbGluZVwiXG4gICAgICAgIHJlZj1cImlucHV0XCJcbiAgICAgICAgdi1iaW5kPVwiJGF0dHJzXCJcbiAgICAgICAgOmlkPVwidm1hX3VpZF9cIlxuICAgICAgICA6Y2xhc3M9XCJpbnB1dENsYXNzZXNcIlxuICAgICAgICA6bWlubGVuZ3RoPVwibWlubGVuZ3RoXCJcbiAgICAgICAgOm1heGxlbmd0aD1cIm1heGxlbmd0aFwiXG4gICAgICAgIDpwbGFjZWhvbGRlcj1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1sYWJlbD1cImlucHV0UGxhY2VIb2xkZXJcIlxuICAgICAgICA6YXJpYS1jb250cm9scz1cImlucHV0QXJpYUNvbnRyb2xzXCJcbiAgICAgICAgOnJvd3M9XCJyb3dzXCJcbiAgICAgICAgOmNvbHM9XCJjb2xzXCJcbiAgICAgICAgdi1vbj1cIiRsaXN0ZW5lcnNcIlxuICAgICAgICBAaW5wdXQ9XCJ1cGRhdGVWYWx1ZSgkZXZlbnQudGFyZ2V0LnZhbHVlKVwiXG4gICAgICA+PC90ZXh0YXJlYT5cblxuICAgICAgPGlucHV0XG4gICAgICAgIHYtZWxzZVxuICAgICAgICByZWY9XCJpbnB1dFwiXG4gICAgICAgIHYtYmluZD1cIiRhdHRyc1wiXG4gICAgICAgIDppZD1cInZtYV91aWRfXCJcbiAgICAgICAgOmNsYXNzPVwiaW5wdXRDbGFzc2VzXCJcbiAgICAgICAgOnR5cGU9XCJ0eXBlXCJcbiAgICAgICAgOm1pbmxlbmd0aD1cIm1pbmxlbmd0aFwiXG4gICAgICAgIDptYXhsZW5ndGg9XCJtYXhsZW5ndGhcIlxuICAgICAgICA6cGxhY2Vob2xkZXI9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtbGFiZWw9XCJpbnB1dFBsYWNlSG9sZGVyXCJcbiAgICAgICAgOmFyaWEtY29udHJvbHM9XCJpbnB1dEFyaWFDb250cm9sc1wiXG4gICAgICAgIHYtb249XCIkbGlzdGVuZXJzXCJcbiAgICAgICAgQGlucHV0PVwidXBkYXRlVmFsdWUoJGV2ZW50LnRhcmdldC52YWx1ZSlcIlxuICAgICAgLz5cblxuICAgICAgPGxhYmVsXG4gICAgICAgIHYtaWY9XCJoYXNMYWJlbFwiXG4gICAgICAgIHJlZj1cImxhYmVsXCJcbiAgICAgICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzVXBncmFkZWRcIlxuICAgICAgICA6Zm9yPVwidm1hX3VpZF9cIlxuICAgICAgPlxuICAgICAgICB7eyBsYWJlbCB9fVxuICAgICAgPC9sYWJlbD5cblxuICAgICAgPGlcbiAgICAgICAgdi1pZj1cIiEhaGFzVHJhaWxpbmdJY29uXCJcbiAgICAgICAgcmVmPVwidHJhaWxpbmdJY29uXCJcbiAgICAgICAgOmNsYXNzPVwiaGFzVHJhaWxpbmdJY29uLmNsYXNzZXNcIlxuICAgICAgICA6dGFiaW5kZXg9XCJ0cmFpbGluZ1RhYmluZGV4XCJcbiAgICAgICAgOnJvbGU9XCJ0cmFpbGluZ1JvbGVcIlxuICAgICAgICBjbGFzcz1cIm1kYy10ZXh0LWZpZWxkX19pY29uXCJcbiAgICAgID5cbiAgICAgICAgPHNsb3QgbmFtZT1cInRyYWlsaW5nLWljb25cIj57eyBoYXNUcmFpbGluZ0ljb24uY29udGVudCB9fTwvc2xvdD5cbiAgICAgIDwvaT5cblxuICAgICAgPGRpdlxuICAgICAgICB2LWlmPVwiaGFzT3V0bGluZVwiXG4gICAgICAgIHJlZj1cIm91dGxpbmVcIlxuICAgICAgICA6Y2xhc3M9XCJvdXRsaW5lQ2xhc3Nlc1wiXG4gICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZVwiXG4gICAgICA+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX19sZWFkaW5nXCI+PC9kaXY+XG4gICAgICAgIDxkaXYgOnN0eWxlPVwibm90Y2hTdHlsZXNcIiBjbGFzcz1cIm1kYy1ub3RjaGVkLW91dGxpbmVfX25vdGNoXCI+XG4gICAgICAgICAgPGxhYmVsXG4gICAgICAgICAgICB2LWlmPVwiaGFzT3V0bGluZUxhYmVsXCJcbiAgICAgICAgICAgIHJlZj1cImxhYmVsLW91dGxpbmVcIlxuICAgICAgICAgICAgOmNsYXNzPVwibGFiZWxDbGFzc2VzVXBncmFkZWRcIlxuICAgICAgICAgICAgOmZvcj1cInZtYV91aWRfXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7eyBsYWJlbCB9fVxuICAgICAgICAgIDwvbGFiZWw+XG4gICAgICAgICAgPGxhYmVsIGNsYXNzPVwibWRjLWZsb2F0aW5nLWxhYmVsXCI+PC9sYWJlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJtZGMtbm90Y2hlZC1vdXRsaW5lX190cmFpbGluZ1wiPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgICA8IS0tIDxkaXZcbiAgICAgICAgdi1pZj1cImhhc091dGxpbmVcIlxuICAgICAgICByZWY9XCJvdXRsaW5lSWRsZVwiXG4gICAgICAgIGNsYXNzPVwibWRjLW5vdGNoZWQtb3V0bGluZV9faWRsZVwiXG4gICAgICAvPiAtLT5cbiAgICAgIDxkaXZcbiAgICAgICAgdi1pZj1cImhhc0xpbmVSaXBwbGVcIlxuICAgICAgICByZWY9XCJsaW5lUmlwcGxlXCJcbiAgICAgICAgOmNsYXNzPVwibGluZVJpcHBsZUNsYXNzZXNcIlxuICAgICAgICA6c3R5bGU9XCJsaW5lUmlwcGxlU3R5bGVzXCJcbiAgICAgIC8+XG4gICAgPC9kaXY+XG5cbiAgICA8cFxuICAgICAgdi1pZj1cImhlbHB0ZXh0XCJcbiAgICAgIHJlZj1cImhlbHBcIlxuICAgICAgOmlkPVwiJ2hlbHAtJyArIHZtYV91aWRfXCJcbiAgICAgIDpjbGFzcz1cImhlbHBDbGFzc2VzXCJcbiAgICAgIGFyaWEtaGlkZGVuPVwidHJ1ZVwiXG4gICAgPlxuICAgICAge3sgaGVscHRleHQgfX1cbiAgICA8L3A+XG4gIDwvZGl2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUZXh0ZmllbGRGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90ZXh0ZmllbGQvZm91bmRhdGlvbidcbmltcG9ydCBNRENMaW5lUmlwcGxlRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvbGluZS1yaXBwbGUvZm91bmRhdGlvbidcbmltcG9ydCBNRENUZXh0RmllbGRIZWxwZXJUZXh0Rm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdGV4dGZpZWxkL2hlbHBlci10ZXh0L2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RleHRmaWVsZC9pY29uL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Zsb2F0aW5nLWxhYmVsL2ZvdW5kYXRpb24nXG5pbXBvcnQgTURDTm90Y2hlZE91dGxpbmVGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9ub3RjaGVkLW91dGxpbmUvZm91bmRhdGlvbidcblxuaW1wb3J0IHtcbiAgZXh0cmFjdEljb25Qcm9wLFxuICBEaXNwYXRjaEZvY3VzTWl4aW4sXG4gIEN1c3RvbUVsZW1lbnRNaXhpbixcbiAgVk1BVW5pcXVlSWRNaXhpbixcbiAgYXBwbHlQYXNzaXZlXG59IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdGV4dGZpZWxkJyxcbiAgbWl4aW5zOiBbQ3VzdG9tRWxlbWVudE1peGluLCBEaXNwYXRjaEZvY3VzTWl4aW4sIFZNQVVuaXF1ZUlkTWl4aW5dLFxuICBpbmhlcml0QXR0cnM6IGZhbHNlLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdtb2RlbCdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB2YWx1ZTogW1N0cmluZywgTnVtYmVyXSxcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndGV4dCcsXG4gICAgICB2YWxpZGF0b3I6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgW1xuICAgICAgICAgICAgJ3RleHQnLFxuICAgICAgICAgICAgJ2VtYWlsJyxcbiAgICAgICAgICAgICdzZWFyY2gnLFxuICAgICAgICAgICAgJ3Bhc3N3b3JkJyxcbiAgICAgICAgICAgICd0ZWwnLFxuICAgICAgICAgICAgJ3VybCcsXG4gICAgICAgICAgICAnbnVtYmVyJ1xuICAgICAgICAgIF0uaW5kZXhPZih2YWx1ZSkgIT09IC0xXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlbnNlOiBCb29sZWFuLFxuICAgIGxhYmVsOiBTdHJpbmcsXG4gICAgaGVscHRleHQ6IFN0cmluZyxcbiAgICBoZWxwdGV4dFBlcnNpc3RlbnQ6IEJvb2xlYW4sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uOiBCb29sZWFuLFxuICAgIG91dGxpbmU6IEJvb2xlYW4sXG4gICAgZGlzYWJsZWQ6IEJvb2xlYW4sXG4gICAgcmVxdWlyZWQ6IEJvb2xlYW4sXG4gICAgdmFsaWQ6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogdW5kZWZpbmVkIH0sXG4gICAgZnVsbHdpZHRoOiBCb29sZWFuLFxuICAgIG11bHRpbGluZTogQm9vbGVhbixcbiAgICBsZWFkaW5nSWNvbjogW1N0cmluZywgQXJyYXksIE9iamVjdF0sXG4gICAgdHJhaWxpbmdOb25JbnRlcmFjdGl2ZTogQm9vbGVhbixcbiAgICBsZWFkaW5nTm9uSW50ZXJhY3RpdmU6IEJvb2xlYW4sXG4gICAgdHJhaWxpbmdJY29uOiBbU3RyaW5nLCBBcnJheSwgT2JqZWN0XSxcbiAgICBzaXplOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDIwIH0sXG4gICAgbWlubGVuZ3RoOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IHVuZGVmaW5lZCB9LFxuICAgIG1heGxlbmd0aDogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiB1bmRlZmluZWQgfSxcbiAgICByb3dzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDggfSxcbiAgICBjb2xzOiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDQwIH0sXG4gICAgaWQ6IHsgdHlwZTogU3RyaW5nIH1cbiAgfSxcbiAgZGF0YTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHRoaXMudmFsdWUsXG4gICAgICByb290Q2xhc3Nlczoge1xuICAgICAgICAnbWRjLXRleHRmaWVsZCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZCc6IHRydWUsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdXBncmFkZWQnOiB0cnVlLFxuICAgICAgICAnbWRjLXRleHQtZmllbGQtLWRpc2FibGVkJzogdGhpcy5kaXNhYmxlZCxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tZnVsbHdpZHRoJzogdGhpcy5mdWxsd2lkdGgsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC0tdGV4dGFyZWEnOiB0aGlzLm11bHRpbGluZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLS1vdXRsaW5lZCc6ICF0aGlzLmZ1bGx3aWR0aCAmJiB0aGlzLm91dGxpbmVcbiAgICAgIH0sXG4gICAgICBpbnB1dENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkX19pbnB1dCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBsYWJlbENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1mbG9hdGluZy1sYWJlbCc6IHRydWVcbiAgICAgIH0sXG4gICAgICBsaW5lUmlwcGxlQ2xhc3Nlczoge1xuICAgICAgICAnbWRjLWxpbmUtcmlwcGxlJzogdHJ1ZVxuICAgICAgfSxcbiAgICAgIGxpbmVSaXBwbGVTdHlsZXM6IHt9LFxuICAgICAgaGVscENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0JzogdHJ1ZSxcbiAgICAgICAgJ21kYy10ZXh0LWZpZWxkLWhlbHBlci10ZXh0LS1wZXJzaXN0ZW50JzogdGhpcy5oZWxwdGV4dFBlcnNpc3RlbnQsXG4gICAgICAgICdtZGMtdGV4dC1maWVsZC1oZWxwZXItdGV4dC0tdmFsaWRhdGlvbi1tc2cnOiB0aGlzLmhlbHB0ZXh0VmFsaWRhdGlvblxuICAgICAgfSxcbiAgICAgIG91dGxpbmVDbGFzc2VzOiB7fSxcbiAgICAgIG5vdGNoU3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBsZWFkaW5nVGFiaW5kZXgoKSB7XG4gICAgICBpZiAoIXRoaXMubGVhZGluZ05vbkludGVyYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiAnMCdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGVhZGluZ1JvbGUoKSB7XG4gICAgICBpZiAoIXRoaXMubGVhZGluZ05vbkludGVyYWN0aXZlKSB7XG4gICAgICAgIHJldHVybiAnYnV0dG9uJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFpbGluZ1RhYmluZGV4KCkge1xuICAgICAgaWYgKCF0aGlzLnRyYWlsaW5nTm9uSW50ZXJhY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuICcwJ1xuICAgICAgfVxuICAgIH0sXG5cbiAgICB0cmFpbGluZ1JvbGUoKSB7XG4gICAgICBpZiAoIXRoaXMudHJhaWxpbmdOb25JbnRlcmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gJ2J1dHRvbidcbiAgICAgIH1cbiAgICB9LFxuICAgIGlucHV0UGxhY2VIb2xkZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5mdWxsd2lkdGggPyB0aGlzLmxhYmVsIDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBpbnB1dEFyaWFDb250cm9scygpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlbHAgPyAnaGVscC0nICsgdGhpcy52bWFfdWlkXyA6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgaGFzTGFiZWwoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmICF0aGlzLm91dGxpbmUgJiYgdGhpcy5sYWJlbFxuICAgIH0sXG5cbiAgICBoYXNPdXRsaW5lTGFiZWwoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oYXNPdXRsaW5lICYmIHRoaXMubGFiZWxcbiAgICB9LFxuICAgIGhhc091dGxpbmUoKSB7XG4gICAgICByZXR1cm4gIXRoaXMuZnVsbHdpZHRoICYmIHRoaXMub3V0bGluZVxuICAgIH0sXG4gICAgaGFzTGluZVJpcHBsZSgpIHtcbiAgICAgIHJldHVybiAhdGhpcy5oYXNPdXRsaW5lICYmICF0aGlzLm11bHRpbGluZVxuICAgIH0sXG4gICAgaGFzTGVhZGluZ0ljb24oKSB7XG4gICAgICBpZiAodGhpcy5sZWFkaW5nSWNvbiB8fCB0aGlzLiRzbG90c1snbGVhZGluZy1pY29uJ10pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVhZGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy5sZWFkaW5nSWNvbikgOiB7fVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSxcbiAgICBoYXNUcmFpbGluZ0ljb24oKSB7XG4gICAgICBpZiAodGhpcy50cmFpbGluZ0ljb24gfHwgdGhpcy4kc2xvdHNbJ3RyYWlsaW5nLWljb24nXSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmFpbGluZ0ljb24gPyBleHRyYWN0SWNvblByb3AodGhpcy50cmFpbGluZ0ljb24pIDoge31cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH0sXG4gICAgbGFiZWxDbGFzc2VzVXBncmFkZWQoKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih0aGlzLmxhYmVsQ2xhc3Nlcywge1xuICAgICAgICAnbWRjLWZsb2F0aW5nLWxhYmVsLS1mbG9hdC1hYm92ZSc6IHRoaXMudmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIH0sXG4gICAgcmVxdWlyZWQoKSB7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmICh0aGlzLiRyZWZzLmlucHV0LnJlcXVpcmVkID0gdGhpcy5yZXF1aXJlZClcbiAgICB9LFxuICAgIHZhbGlkKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLnZhbGlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLnNldFZhbGlkKHRoaXMudmFsaWQpXG4gICAgICB9XG4gICAgfSxcbiAgICBkZW5zZSgpIHtcbiAgICAgIHRoaXMuJHNldCh0aGlzLnJvb3RDbGFzc2VzLCAnbWRjLXRleHQtZmllbGQtLWRlbnNlJywgdGhpcy5kZW5zZSlcbiAgICB9LFxuICAgIGhlbHB0ZXh0UGVyc2lzdGVudCgpIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gJiZcbiAgICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5zZXRQZXJzaXN0ZW50KHRoaXMuaGVscHRleHRQZXJzaXN0ZW50KVxuICAgIH0sXG4gICAgaGVscHRleHRWYWxpZGF0aW9uKCkge1xuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbiAmJlxuICAgICAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uLnNldFZhbGlkYXRpb24odGhpcy5oZWxwdGV4dFZhbGlkYXRpb24pXG4gICAgfSxcbiAgICB2YWx1ZSh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuZm91bmRhdGlvbikge1xuICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKSB7XG4gICAgICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldFZhbHVlKHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIGlmICh0aGlzLiRyZWZzLmxpbmVSaXBwbGUpIHtcbiAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gPSBuZXcgTURDTGluZVJpcHBsZUZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5saW5lUmlwcGxlQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0U3R5bGU6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLmxpbmVSaXBwbGVTdHlsZXMsIG5hbWUsIHZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckV2ZW50SGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmxpbmVSaXBwbGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVyRXZlbnRIYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGluZVJpcHBsZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmxpbmVSaXBwbGVGb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLiRyZWZzLmhlbHApIHtcbiAgICAgIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSGVscGVyVGV4dEZvdW5kYXRpb24oe1xuICAgICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5oZWxwQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5oZWxwLmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldEF0dHI6IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUF0dHI6IG5hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMuaGVscC5yZW1vdmVBdHRyaWJ1dGUobmFtZSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0Q29udGVudDogKC8qY29udGVudCovKSA9PiB7XG4gICAgICAgICAgLy8gaGVscCB0ZXh0IGdldCdzIHVwZGF0ZWQgZnJvbSB7e2hlbHB0ZXh0fX1cbiAgICAgICAgICAvLyB0aGlzLiRyZWZzLmhlbHAudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNMZWFkaW5nSWNvbikge1xuICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC1sZWFkaW5nLWljb24nLCB0cnVlKVxuICAgICAgdGhpcy5sZWFkaW5nSWNvbkZvdW5kYXRpb24gPSBuZXcgTURDVGV4dEZpZWxkSWNvbkZvdW5kYXRpb24oe1xuICAgICAgICBzZXRBdHRyOiAoYXR0ciwgdmFsdWUpID0+XG4gICAgICAgICAgdGhpcy4kcmVmcy5sZWFkaW5nSWNvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgICBnZXRBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMubGVhZGluZ0ljb24uZ2V0QXR0cmlidXRlKGF0dHIpLFxuICAgICAgICByZW1vdmVBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMubGVhZGluZ0ljb24ucmVtb3ZlQXR0cmlidXRlKGF0dHIpLFxuICAgICAgICBzZXRDb250ZW50OiAoLypjb250ZW50Ki8pID0+IHtcbiAgICAgICAgICAvLyBpY29uIHRleHQgZ2V0J3MgdXBkYXRlZCBmcm9tIHt7e3sgaGFzVHJhaWxpbmdJY29uLmNvbnRlbnQgfX19fVxuICAgICAgICAgIC8vIHRoaXMuJHJlZnMuaWNvbi50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMubGVhZGluZ0ljb24ucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBub3RpZnlJY29uQWN0aW9uOiAoKSA9PiB0aGlzLiRlbWl0KCdsZWFkaW5naWNvbi1hY3Rpb24nKVxuICAgICAgfSlcbiAgICAgIHRoaXMubGVhZGluZ0ljb25Gb3VuZGF0aW9uLmluaXQoKVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhhc1RyYWlsaW5nSWNvbikge1xuICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsICdtZGMtdGV4dC1maWVsZC0td2l0aC10cmFpbGluZy1pY29uJywgdHJ1ZSlcbiAgICAgIHRoaXMudHJhaWxpbmdJY29uRm91bmRhdGlvbiA9IG5ldyBNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbih7XG4gICAgICAgIHNldEF0dHI6IChhdHRyLCB2YWx1ZSkgPT5cbiAgICAgICAgICB0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbi5zZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpLFxuICAgICAgICBnZXRBdHRyOiBhdHRyID0+IHRoaXMuJHJlZnMudHJhaWxpbmdJY29uLmdldEF0dHJpYnV0ZShhdHRyKSxcbiAgICAgICAgcmVtb3ZlQXR0cjogYXR0ciA9PiB0aGlzLiRyZWZzLnRyYWlsaW5nSWNvbi5yZW1vdmVBdHRyaWJ1dGUoYXR0ciksXG4gICAgICAgIHNldENvbnRlbnQ6ICgvKmNvbnRlbnQqLykgPT4ge1xuICAgICAgICAgIC8vIGljb24gdGV4dCBnZXQncyB1cGRhdGVkIGZyb20ge3t7eyBoYXNUcmFpbGluZ0ljb24uY29udGVudCB9fX19XG4gICAgICAgICAgLy8gdGhpcy4kcmVmcy5pY29uLnRleHRDb250ZW50ID0gY29udGVudDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgdGhpcy4kcmVmcy50cmFpbGluZ0ljb24uYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICB9LFxuICAgICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIHRoaXMuJHJlZnMudHJhaWxpbmdJY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgbm90aWZ5SWNvbkFjdGlvbjogKCkgPT4gdGhpcy4kZW1pdCgndHJhaW5saW5naWNvbi1hY3Rpb24nKVxuICAgICAgfSlcbiAgICAgIHRoaXMudHJhaWxpbmdJY29uRm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5sYWJlbCB8fCB0aGlzLiRyZWZzWydsYWJlbC1vdXRsaW5lJ10pIHtcbiAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy4kcmVmcy5sYWJlbCB8fCB0aGlzLiRyZWZzWydsYWJlbC1vdXRsaW5lJ11cbiAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uID0gbmV3IE1EQ0Zsb2F0aW5nTGFiZWxGb3VuZGF0aW9uKHtcbiAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgdGhpcy4kc2V0KHRoaXMubGFiZWxDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmxhYmVsQ2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICB9LFxuICAgICAgICBnZXRXaWR0aDogKCkgPT4gbGFiZWwub2Zmc2V0V2lkdGgsXG4gICAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgIGxhYmVsLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICBsYWJlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5pbml0KClcbiAgICB9XG5cbiAgICBpZiAodGhpcy4kcmVmcy5vdXRsaW5lKSB7XG4gICAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uID0gbmV3IE1EQ05vdGNoZWRPdXRsaW5lRm91bmRhdGlvbih7XG4gICAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJHNldCh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLm91dGxpbmVDbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICAgIH0sXG4gICAgICAgIHNldE5vdGNoV2lkdGhQcm9wZXJ0eTogd2lkdGggPT5cbiAgICAgICAgICB0aGlzLiRzZXQodGhpcy5ub3RjaFN0eWxlcywgJ3dpZHRoJywgd2lkdGggPiAwID8gd2lkdGggKyAncHgnIDogJzAnKVxuICAgICAgfSlcbiAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24uaW5pdCgpXG4gICAgfVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbmV3IE1EQ1RleHRmaWVsZEZvdW5kYXRpb24oXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7XG4gICAgICAgICAgYWRkQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVtb3ZlQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaGFzQ2xhc3M6IGNsYXNzTmFtZSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyOiAoZXZ0VHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICAgICAgdGhpcy4kcmVmcy5yb290LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlcilcbiAgICAgICAgICB9LFxuICAgICAgICAgIGRlcmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXI6IChldnRUeXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLiRyZWZzLnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBoYW5kbGVyKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNGb2N1c2VkOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy4kcmVmcy5pbnB1dFxuICAgICAgICAgIH0sXG4gICAgICAgICAgaXNSdGw6ICgpID0+XG4gICAgICAgICAgICB3aW5kb3dcbiAgICAgICAgICAgICAgLmdldENvbXB1dGVkU3R5bGUodGhpcy4kcmVmcy5yb290KVxuICAgICAgICAgICAgICAuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnLFxuXG4gICAgICAgICAgcmVnaXN0ZXJWYWxpZGF0aW9uQXR0cmlidXRlQ2hhbmdlSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgICAgICBjb25zdCBnZXRBdHRyaWJ1dGVzTGlzdCA9IG11dGF0aW9uc0xpc3QgPT5cbiAgICAgICAgICAgICAgbXV0YXRpb25zTGlzdC5tYXAobXV0YXRpb24gPT4gbXV0YXRpb24uYXR0cmlidXRlTmFtZSlcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobXV0YXRpb25zTGlzdCA9PlxuICAgICAgICAgICAgICBoYW5kbGVyKGdldEF0dHJpYnV0ZXNMaXN0KG11dGF0aW9uc0xpc3QpKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHsgYXR0cmlidXRlczogdHJ1ZSB9XG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRhcmdldE5vZGUsIGNvbmZpZylcbiAgICAgICAgICAgIHJldHVybiBvYnNlcnZlclxuICAgICAgICAgIH0sXG4gICAgICAgICAgZGVyZWdpc3RlclZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyOiBvYnNlcnZlciA9PiB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KClcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRoaXMuZ2V0SW5wdXRBZGFwdGVyTWV0aG9kcygpLFxuICAgICAgICB0aGlzLmdldExhYmVsQWRhcHRlck1ldGhvZHMoKSxcbiAgICAgICAgdGhpcy5nZXRMaW5lUmlwcGxlQWRhcHRlck1ldGhvZHMoKSxcbiAgICAgICAgdGhpcy5nZXRPdXRsaW5lQWRhcHRlck1ldGhvZHMoKVxuICAgICAgKSxcbiAgICAgIHtcbiAgICAgICAgaGVscGVyVGV4dDogdGhpcy5oZWxwZXJUZXh0Rm91bmRhdGlvbixcbiAgICAgICAgbGVhZGluZ0ljb246IHRoaXMubGVhZGluZ0ljb25Gb3VuZGF0aW9uLFxuICAgICAgICB0cmFpbGluZ0ljb246IHRoaXMudHJhaWxpbmdGb3VuZGF0aW9uXG4gICAgICB9XG4gICAgKVxuXG4gICAgdGhpcy5mb3VuZGF0aW9uLmluaXQoKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKVxuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKVxuICAgIHRoaXMuJHJlZnMuaW5wdXQgJiYgKHRoaXMuJHJlZnMuaW5wdXQucmVxdWlyZWQgPSB0aGlzLnJlcXVpcmVkKVxuICAgIGlmICh0eXBlb2YgdGhpcy52YWxpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWxpZCh0aGlzLnZhbGlkKVxuICAgIH1cblxuICAgIGlmICh0aGlzLnRleHRib3gpIHtcbiAgICAgIHRoaXMucmlwcGxlID0gbmV3IFJpcHBsZUJhc2UodGhpcylcbiAgICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24gJiYgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmhlbHBlclRleHRGb3VuZGF0aW9uICYmIHRoaXMuaGVscGVyVGV4dEZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5sZWFkaW5nSWNvbkZvdW5kYXRpb24gJiYgdGhpcy5sZWFkaW5nSWNvbkZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy50cmFpbGluZ0ljb25Gb3VuZGF0aW9uICYmIHRoaXMudHJhaWxpbmdJY29uRm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLmxhYmVsRm91bmRhdGlvbiAmJiB0aGlzLmxhYmVsRm91bmRhdGlvbi5kZXN0cm95KClcbiAgICB0aGlzLm91dGxpbmVGb3VuZGF0aW9uICYmIHRoaXMub3V0bGluZUZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5yaXBwbGUgJiYgdGhpcy5yaXBwbGUuZGVzdHJveSgpXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBnZXRJbnB1dEFkYXB0ZXJNZXRob2RzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgIH0sXG4gICAgICAgIGRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICB0aGlzLiRyZWZzLmlucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgaGFuZGxlciwgYXBwbHlQYXNzaXZlKCkpXG4gICAgICAgIH0sXG4gICAgICAgIGdldE5hdGl2ZUlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuaW5wdXRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0TGFiZWxBZGFwdGVyTWV0aG9kcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNoYWtlTGFiZWw6IHNob3VsZFNoYWtlID0+IHtcbiAgICAgICAgICB0aGlzLmxhYmVsRm91bmRhdGlvbi5zaGFrZShzaG91bGRTaGFrZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmxvYXRMYWJlbDogc2hvdWxkRmxvYXQgPT4ge1xuICAgICAgICAgIHRoaXMubGFiZWxGb3VuZGF0aW9uLmZsb2F0KHNob3VsZEZsb2F0KVxuICAgICAgICB9LFxuICAgICAgICBoYXNMYWJlbDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiAhIXRoaXMuJHJlZnMubGFiZWwgfHwgISF0aGlzLiRyZWZzWydsYWJlbC1vdXRsaW5lJ11cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0TGFiZWxXaWR0aDogKCkgPT4ge1xuICAgICAgICAgIHJldHVybiB0aGlzLmxhYmVsRm91bmRhdGlvbi5nZXRXaWR0aCgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdldExpbmVSaXBwbGVBZGFwdGVyTWV0aG9kcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRlYWN0aXZhdGVMaW5lUmlwcGxlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24uZGVhY3RpdmF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmF0ZUxpbmVSaXBwbGU6ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5saW5lUmlwcGxlRm91bmRhdGlvbi5hY3RpdmF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXRMaW5lUmlwcGxlVHJhbnNmb3JtT3JpZ2luOiBub3JtYWxpemVkWCA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubGluZVJpcHBsZUZvdW5kYXRpb24uc2V0UmlwcGxlQ2VudGVyKG5vcm1hbGl6ZWRYKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0T3V0bGluZUFkYXB0ZXJNZXRob2RzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaGFzT3V0bGluZTogKCkgPT4gISF0aGlzLmhhc091dGxpbmUsXG4gICAgICAgIG5vdGNoT3V0bGluZTogKG5vdGNoV2lkdGgsIGlzUnRsKSA9PlxuICAgICAgICAgIHRoaXMub3V0bGluZUZvdW5kYXRpb24ubm90Y2gobm90Y2hXaWR0aCwgaXNSdGwpLFxuICAgICAgICBjbG9zZU91dGxpbmU6ICgpID0+IHRoaXMub3V0bGluZUZvdW5kYXRpb24uY2xvc2VOb3RjaCgpXG4gICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVWYWx1ZSh2YWx1ZSkge1xuICAgICAgdGhpcy4kZW1pdCgnbW9kZWwnLCB2YWx1ZSlcbiAgICB9LFxuICAgIGZvY3VzKCkge1xuICAgICAgdGhpcy4kcmVmcy5pbnB1dCAmJiB0aGlzLiRyZWZzLmlucHV0LmZvY3VzKClcbiAgICB9LFxuICAgIGJsdXIoKSB7XG4gICAgICB0aGlzLiRyZWZzLmlucHV0ICYmIHRoaXMuJHJlZnMuaW5wdXQuYmx1cigpXG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7IEJhc2VQbHVnaW4gfSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IG1kY1RleHRGaWVsZCBmcm9tICcuL21kYy10ZXh0ZmllbGQudnVlJ1xuXG5leHBvcnQgeyBtZGNUZXh0RmllbGQgfVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVGV4dEZpZWxkXG59KVxuIiwiPHRlbXBsYXRlPlxuICA8Y3VzdG9tLWVsZW1lbnQgXG4gICAgOnRhZz1cInRhZ1wiIFxuICAgIDpjbGFzcz1cImNsYXNzZXNcIlxuICAgIGNsYXNzPVwibWRjLXRoZW1lXCI+XG4gICAgPHNsb3QgLz5cbiAgPC9jdXN0b20tZWxlbWVudD5cbjwvdGVtcGxhdGU+XG5cblxuPHNjcmlwdD5cbmltcG9ydCB7IEN1c3RvbUVsZW1lbnQgfSBmcm9tICcuLi9iYXNlJ1xuXG5jb25zdCBUSEVNRV9DT0xPUlMgPSBbXG4gICdwcmltYXJ5JyxcbiAgJ3NlY29uZGFyeScsXG4gICdiYWNrZ3JvdW5kJyxcbiAgJ3ByaW1hcnktbGlnaHQnLFxuICAnc2Vjb25kYXJ5LWxpZ2h0JyxcbiAgJ3NlY29uZGFyeS1kYXJrJyxcbiAgJ3ByaW1hcnktZGFyaydcbl1cblxuY29uc3QgVEhFTUVfU1RZTEVTID0gW1xuICAndGV4dC1wcmltYXJ5JyxcbiAgJ3RleHQtc2Vjb25kYXJ5JyxcbiAgJ3RleHQtaGludCcsXG4gICd0ZXh0LWljb24nLFxuICAndGV4dC1kaXNhYmxlZCdcbl1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRoZW1lJyxcbiAgY29tcG9uZW50czoge1xuICAgIEN1c3RvbUVsZW1lbnRcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICB0YWc6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnZGl2JyB9LFxuICAgIGNvbG9yOiBTdHJpbmcsXG4gICAgYmFja2dyb3VuZDogU3RyaW5nXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgY2xhc3NlcygpIHtcbiAgICAgIGxldCBjbGFzc2VzID0ge31cblxuICAgICAgaWYgKHRoaXMuY29sb3IgJiYgVEhFTUVfQ09MT1JTLmluZGV4T2YodGhpcy5jb2xvcikgIT09IC0xKSB7XG4gICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmNvbG9yfWBdID0gdHJ1ZVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kICYmIFRIRU1FX0NPTE9SUy5pbmRleE9mKHRoaXMuYmFja2dyb3VuZCkgIT09IC0xKSB7XG4gICAgICAgIGNsYXNzZXNbYG1kYy10aGVtZS0tJHt0aGlzLmJhY2tncm91bmR9LWJnYF0gPSB0cnVlXG5cbiAgICAgICAgaWYgKHRoaXMuY29sb3IgJiYgVEhFTUVfU1RZTEVTLmluZGV4T2YodGhpcy5jb2xvcikgIT09IC0xKSB7XG4gICAgICAgICAgY2xhc3Nlc1tgbWRjLXRoZW1lLS0ke3RoaXMuY29sb3J9LW9uLSR7dGhpcy5iYWNrZ3JvdW5kfWBdID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xhc3Nlc1xuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUaGVtZSBmcm9tICcuL21kYy10aGVtZS52dWUnXG5cbmV4cG9ydCB7IG1kY1RoZW1lIH1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RoZW1lXG59KVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRDogJ21kYy10b29sYmFyLS1maXhlZCcsXG4gIEZJWEVEX0xBU1RST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JyxcbiAgRklYRURfQVRfTEFTVF9ST1c6ICdtZGMtdG9vbGJhci0tZml4ZWQtYXQtbGFzdC1yb3cnLFxuICBUT09MQkFSX1JPV19GTEVYSUJMRTogJ21kYy10b29sYmFyLS1mbGV4aWJsZScsXG4gIEZMRVhJQkxFX0RFRkFVTFRfQkVIQVZJT1I6ICdtZGMtdG9vbGJhci0tZmxleGlibGUtZGVmYXVsdC1iZWhhdmlvcicsXG4gIEZMRVhJQkxFX01BWDogJ21kYy10b29sYmFyLS1mbGV4aWJsZS1zcGFjZS1tYXhpbWl6ZWQnLFxuICBGTEVYSUJMRV9NSU46ICdtZGMtdG9vbGJhci0tZmxleGlibGUtc3BhY2UtbWluaW1pemVkJyxcbn07XG5cbmV4cG9ydCBjb25zdCBzdHJpbmdzID0ge1xuICBUSVRMRV9TRUxFQ1RPUjogJy5tZGMtdG9vbGJhcl9fdGl0bGUnLFxuICBJQ09OX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19pY29uJyxcbiAgRklSU1RfUk9XX1NFTEVDVE9SOiAnLm1kYy10b29sYmFyX19yb3c6Zmlyc3QtY2hpbGQnLFxuICBDSEFOR0VfRVZFTlQ6ICdNRENUb29sYmFyOmNoYW5nZScsXG59O1xuXG5leHBvcnQgY29uc3QgbnVtYmVycyA9IHtcbiAgTUFYX1RJVExFX1NJWkU6IDIuMTI1LFxuICBNSU5fVElUTEVfU0laRTogMS4yNSxcbiAgVE9PTEJBUl9ST1dfSEVJR0hUOiA2NCxcbiAgVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVDogNTYsXG4gIFRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQ6IDYwMCxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbmltcG9ydCBNRENGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9iYXNlL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGhhc0NsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IC8qIGJvb2xlYW4gKi8gZmFsc2UsXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Vmlld3BvcnRXaWR0aDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBnZXRWaWV3cG9ydFNjcm9sbFk6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgICAgZ2V0T2Zmc2V0SGVpZ2h0OiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICBub3RpZnlDaGFuZ2U6ICgvKiBldnREYXRhOiB7ZmxleGlibGVFeHBhbnNpb25SYXRpbzogbnVtYmVyfSAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZTogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQ6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50OiAoLyogcHJvcGVydHk6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudDogKC8qIHByb3BlcnR5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENUb29sYmFyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmNoZWNrUm93SGVpZ2h0XygpO1xuICAgIHRoaXMuc2Nyb2xsSGFuZGxlcl8gPSAoKSA9PiB0aGlzLnVwZGF0ZVRvb2xiYXJTdHlsZXNfKCk7XG4gICAgdGhpcy5jaGVja1Jvd0hlaWdodEZyYW1lXyA9IDA7XG4gICAgdGhpcy5zY3JvbGxGcmFtZV8gPSAwO1xuICAgIHRoaXMuZXhlY3V0ZWRMYXN0Q2hhbmdlXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5jYWxjdWxhdGlvbnNfID0ge1xuICAgICAgdG9vbGJhclJvd0hlaWdodDogMCxcbiAgICAgIC8vIENhbGN1bGF0ZWQgSGVpZ2h0IHJhdGlvLiBXZSB1c2UgcmF0aW8gdG8gY2FsY3VsYXRlIGNvcnJlc3BvbmRpbmcgaGVpZ2h0cyBpbiByZXNpemUgZXZlbnQuXG4gICAgICB0b29sYmFyUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiB0b29sYmFyIGhlaWdodCB0byByb3cgaGVpZ2h0XG4gICAgICBmbGV4aWJsZUV4cGFuc2lvblJhdGlvOiAwLCAvLyBUaGUgcmF0aW8gb2YgZmxleGlibGUgc3BhY2UgaGVpZ2h0IHRvIHJvdyBoZWlnaHRcbiAgICAgIG1heFRyYW5zbGF0ZVlSYXRpbzogMCwgLy8gVGhlIHJhdGlvIG9mIG1heCB0b29sYmFyIG1vdmUgdXAgZGlzdGFuY2UgdG8gcm93IGhlaWdodFxuICAgICAgc2Nyb2xsVGhyZXNob2xkUmF0aW86IDAsIC8vIFRoZSByYXRpbyBvZiBtYXggc2Nyb2xsVG9wIHRoYXQgd2Ugc2hvdWxkIGxpc3RlbiB0byB0byByb3cgaGVpZ2h0XG4gICAgICAvLyBEZXJpdmVkIEhlaWdodHMgYmFzZWQgb24gdGhlIGFib3ZlIGtleSByYXRpb3MuXG4gICAgICB0b29sYmFySGVpZ2h0OiAwLFxuICAgICAgZmxleGlibGVFeHBhbnNpb25IZWlnaHQ6IDAsIC8vIEZsZXhpYmxlIHJvdyBtaW51cyB0b29sYmFyIGhlaWdodCAoZGVyaXZlZClcbiAgICAgIG1heFRyYW5zbGF0ZVlEaXN0YW5jZTogMCwgLy8gV2hlbiB0b29sYmFyIG9ubHkgZml4IGxhc3Qgcm93IChkZXJpdmVkKVxuICAgICAgc2Nyb2xsVGhyZXNob2xkOiAwLFxuICAgIH07XG4gICAgLy8gVG9vbGJhciBmaXhlZCBiZWhhdmlvclxuICAgIC8vIElmIHRvb2xiYXIgaXMgZml4ZWRcbiAgICB0aGlzLmZpeGVkXyA9IGZhbHNlO1xuICAgIC8vIElmIGZpeGVkIGlzIHRhcmdldGVkIG9ubHkgYXQgdGhlIGxhc3Qgcm93XG4gICAgdGhpcy5maXhlZExhc3Ryb3dfID0gZmFsc2U7XG4gICAgLy8gVG9vbGJhciBmbGV4aWJsZSBiZWhhdmlvclxuICAgIC8vIElmIHRoZSBmaXJzdCByb3cgaXMgZmxleGlibGVcbiAgICB0aGlzLmhhc0ZsZXhpYmxlUm93XyA9IGZhbHNlO1xuICAgIC8vIElmIHVzZSB0aGUgZGVmYXVsdCBiZWhhdmlvclxuICAgIHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8gPSBmYWxzZTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5maXhlZF8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRklYRUQpO1xuICAgIHRoaXMuZml4ZWRMYXN0cm93XyA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoTURDVG9vbGJhckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5GSVhFRF9MQVNUUk9XKSAmIHRoaXMuZml4ZWRfO1xuICAgIHRoaXMuaGFzRmxleGlibGVSb3dfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLlRPT0xCQVJfUk9XX0ZMRVhJQkxFKTtcbiAgICBpZiAodGhpcy5oYXNGbGV4aWJsZVJvd18pIHtcbiAgICAgIHRoaXMudXNlRmxleERlZmF1bHRCZWhhdmlvcl8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfREVGQVVMVF9CRUhBVklPUik7XG4gICAgfVxuICAgIHRoaXMuaW5pdEtleVJhdGlvXygpO1xuICAgIHRoaXMuc2V0S2V5SGVpZ2h0c18oKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgdXBkYXRlQWRqdXN0RWxlbWVudFN0eWxlcygpIHtcbiAgICBpZiAodGhpcy5maXhlZF8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQoJ21hcmdpbi10b3AnLCBgJHt0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhckhlaWdodH1weGApO1xuICAgIH1cbiAgfVxuXG4gIGdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fKHNjcm9sbFRvcCkge1xuICAgIC8vIFRvIHByZXZlbnQgZGl2aXNpb24gYnkgemVybyB3aGVuIHRoZXJlIGlzIG5vIGZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0XG4gICAgY29uc3QgZGVsdGEgPSAwLjAwMDE7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIDEgLSBzY3JvbGxUb3AgLyAodGhpcy5jYWxjdWxhdGlvbnNfLmZsZXhpYmxlRXhwYW5zaW9uSGVpZ2h0ICsgZGVsdGEpKTtcbiAgfVxuXG4gIGNoZWNrUm93SGVpZ2h0XygpIHtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfKTtcbiAgICB0aGlzLmNoZWNrUm93SGVpZ2h0RnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMuc2V0S2V5SGVpZ2h0c18oKSk7XG4gIH1cblxuICBzZXRLZXlIZWlnaHRzXygpIHtcbiAgICBjb25zdCBuZXdUb29sYmFyUm93SGVpZ2h0ID0gdGhpcy5nZXRSb3dIZWlnaHRfKCk7XG4gICAgaWYgKG5ld1Rvb2xiYXJSb3dIZWlnaHQgIT09IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0KSB7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodCA9IG5ld1Rvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhckhlaWdodCA9IHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gKiB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodDtcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvblJhdGlvICogdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSb3dIZWlnaHQ7XG4gICAgICB0aGlzLmNhbGN1bGF0aW9uc18ubWF4VHJhbnNsYXRlWURpc3RhbmNlID1cbiAgICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy5jYWxjdWxhdGlvbnNfLnNjcm9sbFRocmVzaG9sZCA9XG4gICAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGRSYXRpbyAqIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUm93SGVpZ2h0O1xuICAgICAgdGhpcy51cGRhdGVBZGp1c3RFbGVtZW50U3R5bGVzKCk7XG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJTdHlsZXNfKCk7XG4gICAgfVxuICB9XG5cbiAgdXBkYXRlVG9vbGJhclN0eWxlc18oKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY3JvbGxGcmFtZV8pO1xuICAgIHRoaXMuc2Nyb2xsRnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIGNvbnN0IHNjcm9sbFRvcCA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG4gICAgICBjb25zdCBoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkID0gdGhpcy5zY3JvbGxlZE91dE9mVGhyZXNob2xkXyhzY3JvbGxUb3ApO1xuXG4gICAgICBpZiAoaGFzU2Nyb2xsZWRPdXRPZlRocmVzaG9sZCAmJiB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBmbGV4aWJsZUV4cGFuc2lvblJhdGlvID0gdGhpcy5nZXRGbGV4aWJsZUV4cGFuc2lvblJhdGlvXyhzY3JvbGxUb3ApO1xuXG4gICAgICB0aGlzLnVwZGF0ZVRvb2xiYXJGbGV4aWJsZVN0YXRlXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICAgIGlmICh0aGlzLmZpeGVkTGFzdHJvd18pIHtcbiAgICAgICAgdGhpcy51cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8oc2Nyb2xsVG9wKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhhc0ZsZXhpYmxlUm93Xykge1xuICAgICAgICB0aGlzLnVwZGF0ZUZsZXhpYmxlUm93RWxlbWVudFN0eWxlc18oZmxleGlibGVFeHBhbnNpb25SYXRpbyk7XG4gICAgICB9XG4gICAgICB0aGlzLmV4ZWN1dGVkTGFzdENoYW5nZV8gPSBoYXNTY3JvbGxlZE91dE9mVGhyZXNob2xkO1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2Uoe2ZsZXhpYmxlRXhwYW5zaW9uUmF0aW86IGZsZXhpYmxlRXhwYW5zaW9uUmF0aW99KTtcbiAgICB9KTtcbiAgfVxuXG4gIHNjcm9sbGVkT3V0T2ZUaHJlc2hvbGRfKHNjcm9sbFRvcCkge1xuICAgIHJldHVybiBzY3JvbGxUb3AgPiB0aGlzLmNhbGN1bGF0aW9uc18uc2Nyb2xsVGhyZXNob2xkO1xuICB9XG5cbiAgaW5pdEtleVJhdGlvXygpIHtcbiAgICBjb25zdCB0b29sYmFyUm93SGVpZ2h0ID0gdGhpcy5nZXRSb3dIZWlnaHRfKCk7XG4gICAgY29uc3QgZmlyc3RSb3dNYXhSYXRpbyA9IHRoaXMuYWRhcHRlcl8uZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0KCkgLyB0b29sYmFyUm93SGVpZ2h0O1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy50b29sYmFyUmF0aW8gPSB0aGlzLmFkYXB0ZXJfLmdldE9mZnNldEhlaWdodCgpIC8gdG9vbGJhclJvd0hlaWdodDtcbiAgICB0aGlzLmNhbGN1bGF0aW9uc18uZmxleGlibGVFeHBhbnNpb25SYXRpbyA9IGZpcnN0Um93TWF4UmF0aW8gLSAxO1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZUmF0aW8gPVxuICAgICAgdGhpcy5maXhlZExhc3Ryb3dfID8gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyAtIGZpcnN0Um93TWF4UmF0aW8gOiAwO1xuICAgIHRoaXMuY2FsY3VsYXRpb25zXy5zY3JvbGxUaHJlc2hvbGRSYXRpbyA9XG4gICAgICAodGhpcy5maXhlZExhc3Ryb3dfID8gdGhpcy5jYWxjdWxhdGlvbnNfLnRvb2xiYXJSYXRpbyA6IGZpcnN0Um93TWF4UmF0aW8pIC0gMTtcbiAgfVxuXG4gIGdldFJvd0hlaWdodF8oKSB7XG4gICAgY29uc3QgYnJlYWtwb2ludCA9IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9NT0JJTEVfQlJFQUtQT0lOVDtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFdpZHRoKCkgPCBicmVha3BvaW50ID9cbiAgICAgIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVCA6IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLm51bWJlcnMuVE9PTEJBUl9ST1dfSEVJR0hUO1xuICB9XG5cbiAgdXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUFYKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUlOKTtcbiAgICBpZiAoZmxleGlibGVFeHBhbnNpb25SYXRpbyA9PT0gMSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZMRVhJQkxFX01BWCk7XG4gICAgfSBlbHNlIGlmIChmbGV4aWJsZUV4cGFuc2lvblJhdGlvID09PSAwKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuRkxFWElCTEVfTUlOKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVUb29sYmFyRml4ZWRTdGF0ZV8oc2Nyb2xsVG9wKSB7XG4gICAgY29uc3QgdHJhbnNsYXRlRGlzdGFuY2UgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihcbiAgICAgIHNjcm9sbFRvcCAtIHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCxcbiAgICAgIHRoaXMuY2FsY3VsYXRpb25zXy5tYXhUcmFuc2xhdGVZRGlzdGFuY2UpKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlWSgkey10cmFuc2xhdGVEaXN0YW5jZX1weClgKTtcblxuICAgIGlmICh0cmFuc2xhdGVEaXN0YW5jZSA9PT0gdGhpcy5jYWxjdWxhdGlvbnNfLm1heFRyYW5zbGF0ZVlEaXN0YW5jZSkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0FUX0xBU1RfUk9XKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhNRENUb29sYmFyRm91bmRhdGlvbi5jc3NDbGFzc2VzLkZJWEVEX0FUX0xBU1RfUk9XKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVGbGV4aWJsZVJvd0VsZW1lbnRTdHlsZXNfKGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8pIHtcbiAgICBpZiAodGhpcy5maXhlZF8pIHtcbiAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY2FsY3VsYXRpb25zXy5mbGV4aWJsZUV4cGFuc2lvbkhlaWdodCAqIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW87XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50KCdoZWlnaHQnLFxuICAgICAgICBgJHtoZWlnaHQgKyB0aGlzLmNhbGN1bGF0aW9uc18udG9vbGJhclJvd0hlaWdodH1weGApO1xuICAgIH1cbiAgICBpZiAodGhpcy51c2VGbGV4RGVmYXVsdEJlaGF2aW9yXykge1xuICAgICAgdGhpcy51cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKTtcbiAgICB9XG4gIH1cblxuICB1cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyhmbGV4aWJsZUV4cGFuc2lvblJhdGlvKSB7XG4gICAgY29uc3QgbWF4VGl0bGVTaXplID0gTURDVG9vbGJhckZvdW5kYXRpb24ubnVtYmVycy5NQVhfVElUTEVfU0laRTtcbiAgICBjb25zdCBtaW5UaXRsZVNpemUgPSBNRENUb29sYmFyRm91bmRhdGlvbi5udW1iZXJzLk1JTl9USVRMRV9TSVpFO1xuICAgIGNvbnN0IGN1cnJlbnRUaXRsZVNpemUgPSAobWF4VGl0bGVTaXplIC0gbWluVGl0bGVTaXplKSAqIGZsZXhpYmxlRXhwYW5zaW9uUmF0aW8gKyBtaW5UaXRsZVNpemU7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlRm9yVGl0bGVFbGVtZW50KCdmb250LXNpemUnLCBgJHtjdXJyZW50VGl0bGVTaXplfXJlbWApO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxoZWFkZXIgY2xhc3M9XCJtZGMtdG9vbGJhci13cmFwcGVyXCI+XG4gICAgPCEtLVRvb2xiYXItLT5cbiAgICA8ZGl2IFxuICAgICAgcmVmPVwicm9vdFwiIFxuICAgICAgOmNsYXNzPVwicm9vdENsYXNzZXNcIiBcbiAgICAgIDpzdHlsZT1cInJvb3RTdHlsZXNcIj5cbiAgICAgIDxzbG90Lz5cbiAgICA8L2Rpdj5cbiAgICA8IS0tIEZpeGVkIEFkanVzdCBFbGVtZW50LS0+XG4gICAgPGRpdiBcbiAgICAgIHYtaWY9XCJmaXhlZCB8fCB3YXRlcmZhbGwgfHwgZml4ZWRMYXN0cm93XCIgXG4gICAgICByZWY9XCJmaXhlZC1hZGp1c3RcIiBcbiAgICAgIDpzdHlsZT1cImFkanVzdFN0eWxlc1wiXG4gICAgICBjbGFzcz1cIm1kYy10b29sYmFyLWZpeGVkLWFkanVzdFwiLz5cbiAgPC9oZWFkZXI+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IE1EQ1Rvb2xiYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90b29sYmFyL2ZvdW5kYXRpb24nXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyJyxcbiAgcHJvcHM6IHtcbiAgICBmaXhlZDogQm9vbGVhbixcbiAgICB3YXRlcmZhbGw6IEJvb2xlYW4sXG4gICAgJ2ZpeGVkLWxhc3Ryb3cnOiBCb29sZWFuLFxuICAgIGZsZXhpYmxlOiBCb29sZWFuLFxuICAgICdmbGV4aWJsZS1kZWZhdWx0JzogeyB0eXBlOiBCb29sZWFuLCBkZWZhdWx0OiB0cnVlIH1cbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vdENsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10b29sYmFyJzogdHJ1ZSxcbiAgICAgICAgJ21kYy10b29sYmFyLS1maXhlZCc6IHRoaXMuZml4ZWQgfHwgdGhpcy53YXRlcmZhbGwgfHwgdGhpcy5maXhlZExhc3Ryb3csXG4gICAgICAgICdtZGMtdG9vbGJhci0td2F0ZXJmYWxsJzogdGhpcy53YXRlcmZhbGwsXG4gICAgICAgICdtZGMtdG9vbGJhci0tZml4ZWQtbGFzdHJvdy1vbmx5JzogdGhpcy5maXhlZExhc3Ryb3csXG4gICAgICAgICdtZGMtdG9vbGJhci0tZmxleGlibGUnOiB0aGlzLmZsZXhpYmxlLFxuICAgICAgICAnbWRjLXRvb2xiYXItLWZsZXhpYmxlLWRlZmF1bHQtYmVoYXZpb3InOlxuICAgICAgICAgIHRoaXMuZmxleGlibGUgJiYgdGhpcy5mbGV4aWJsZURlZmF1bHRcbiAgICAgIH0sXG4gICAgICByb290U3R5bGVzOiB7fSxcbiAgICAgIGFkanVzdFN0eWxlczoge1xuICAgICAgICAvLyB0byBhdm9pZCB0b3AgbWFyZ2luIGNvbGxhcHNlIHdpdGggOmFmdGVyIGVsXG4gICAgICAgIC8vIDAuMSBweCBzaG91bGQgYmUgcm91bmRlZCB0byAwcHhcbiAgICAgICAgLy8gVE9ETzogZmluZCBhIGJldHRlciB0cmlja1xuICAgICAgICAvLyBoZWlnaHQ6ICcwLjFweCdcbiAgICAgIH0sXG4gICAgICBmb3VuZGF0aW9uOiBudWxsXG4gICAgfVxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENUb29sYmFyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMucm9vdENsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMucm9vdC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6IGhhbmRsZXIgPT4ge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBnZXRWaWV3cG9ydFdpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgfSxcbiAgICAgIGdldFZpZXdwb3J0U2Nyb2xsWTogKCkgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICB9LFxuICAgICAgZ2V0T2Zmc2V0SGVpZ2h0OiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLnJvb3Qub2Zmc2V0SGVpZ2h0XG4gICAgICB9LFxuICAgICAgZ2V0Rmlyc3RSb3dFbGVtZW50T2Zmc2V0SGVpZ2h0OiAoKSA9PiB7XG4gICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgcmV0dXJuIGVsID8gZWwub2Zmc2V0SGVpZ2h0IDogdW5kZWZpbmVkXG4gICAgICB9LFxuICAgICAgbm90aWZ5Q2hhbmdlOiBldnREYXRhID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZXZ0RGF0YSlcbiAgICAgIH0sXG4gICAgICBzZXRTdHlsZTogKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290U3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JUaXRsZUVsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgbGV0IGVsID0gdGhpcy4kcmVmcy5yb290LnF1ZXJ5U2VsZWN0b3IoXG4gICAgICAgICAgTURDVG9vbGJhckZvdW5kYXRpb24uc3RyaW5ncy5USVRMRV9TRUxFQ1RPUlxuICAgICAgICApXG4gICAgICAgIGlmIChlbCkgZWwuc3R5bGUuc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIHNldFN0eWxlRm9yRmxleGlibGVSb3dFbGVtZW50OiAocHJvcGVydHksIHZhbHVlKSA9PiB7XG4gICAgICAgIGxldCBlbCA9IHRoaXMuJHJlZnMucm9vdC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICAgIE1EQ1Rvb2xiYXJGb3VuZGF0aW9uLnN0cmluZ3MuRklSU1RfUk9XX1NFTEVDVE9SXG4gICAgICAgIClcbiAgICAgICAgaWYgKGVsKSBlbC5zdHlsZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGVGb3JGaXhlZEFkanVzdEVsZW1lbnQ6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuYWRqdXN0U3R5bGVzLCBwcm9wZXJ0eSwgdmFsdWUpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy10b29sYmFyLXJvdyBtZGMtdG9vbGJhcl9fcm93XCI+XG4gICAgPHNsb3QvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1yb3cnXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPHNlY3Rpb24gXG4gICAgOmNsYXNzPVwiY2xhc3Nlc1wiIFxuICAgIGNsYXNzPVwibWRjLXRvb2xiYXItc2VjdGlvbiBtZGMtdG9vbGJhcl9fc2VjdGlvblwiPlxuICAgIDxzbG90Lz5cbiAgPC9zZWN0aW9uPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy10b29sYmFyLXNlY3Rpb24nLFxuICBwcm9wczoge1xuICAgICdhbGlnbi1zdGFydCc6IEJvb2xlYW4sXG4gICAgJ2FsaWduLWVuZCc6IEJvb2xlYW4sXG4gICAgJ3Nocmluay10by1maXQnOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydCc6IHRoaXMuYWxpZ25TdGFydCxcbiAgICAgICAgJ21kYy10b29sYmFyX19zZWN0aW9uLS1hbGlnbi1lbmQnOiB0aGlzLmFsaWduRW5kLFxuICAgICAgICAnbWRjLXRvb2xiYXJfX3NlY3Rpb24tLXNocmluay10by1maXQnOiB0aGlzLnNocmlua1RvRml0XG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGEgXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci1tZW51LWljb24gbWRjLXRvb2xiYXJfX21lbnUtaWNvblwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1tZW51LWljb24nLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnbWVudScgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGEgXG4gICAgY2xhc3M9XCJtZGMtdG9vbGJhci10aXRsZSBtZGMtdG9vbGJhcl9fdGl0bGVcIiBcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3QvPlxuICA8L2E+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuaW1wb3J0IHsgRGlzcGF0Y2hFdmVudE1peGluIH0gZnJvbSAnLi4vYmFzZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvb2xiYXItdGl0bGUnLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGEgXG4gICAgOmNsYXNzPVwieydtYXRlcmlhbC1pY29ucyc6ISFpY29ufVwiIFxuICAgIGNsYXNzPVwibWRjLXRvb2xiYXItaWNvbiBtZGMtdG9vbGJhcl9faWNvblwiXG4gICAgdi1vbj1cImxpc3RlbmVyc1wiPlxuICAgIDxzbG90Pnt7IGljb24gfX08L3Nsb3Q+XG4gIDwvYT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9vbGJhci1pY29uJyxcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluXSxcbiAgcHJvcHM6IHtcbiAgICBpY29uOiBTdHJpbmdcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUb29sYmFyIGZyb20gJy4vbWRjLXRvb2xiYXIudnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJSb3cgZnJvbSAnLi9tZGMtdG9vbGJhci1yb3cudnVlJ1xuaW1wb3J0IG1kY1Rvb2xiYXJTZWN0aW9uIGZyb20gJy4vbWRjLXRvb2xiYXItc2VjdGlvbi52dWUnXG5pbXBvcnQgbWRjVG9vbGJhck1lbnVJY29uIGZyb20gJy4vbWRjLXRvb2xiYXItbWVudS1pY29uLnZ1ZSdcbmltcG9ydCBtZGNUb29sYmFyVGl0bGUgZnJvbSAnLi9tZGMtdG9vbGJhci10aXRsZS52dWUnXG5pbXBvcnQgbWRjVG9vbGJhckljb24gZnJvbSAnLi9tZGMtdG9vbGJhci1pY29uLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjVG9vbGJhcixcbiAgbWRjVG9vbGJhclJvdyxcbiAgbWRjVG9vbGJhclNlY3Rpb24sXG4gIG1kY1Rvb2xiYXJNZW51SWNvbixcbiAgbWRjVG9vbGJhclRpdGxlLFxuICBtZGNUb29sYmFySWNvblxufVxuXG5leHBvcnQgZGVmYXVsdCBCYXNlUGx1Z2luKHtcbiAgbWRjVG9vbGJhcixcbiAgbWRjVG9vbGJhclJvdyxcbiAgbWRjVG9vbGJhclNlY3Rpb24sXG4gIG1kY1Rvb2xiYXJNZW51SWNvbixcbiAgbWRjVG9vbGJhclRpdGxlLFxuICBtZGNUb29sYmFySWNvblxufSlcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFsyLCB7XCJhcmdzXCI6IFwibm9uZVwifV0gKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgVG9wIEFwcCBCYXJcbiAqXG4gKiBEZWZpbmVzIHRoZSBzaGFwZSBvZiB0aGUgYWRhcHRlciBleHBlY3RlZCBieSB0aGUgZm91bmRhdGlvbi4gSW1wbGVtZW50IHRoaXNcbiAqIGFkYXB0ZXIgdG8gaW50ZWdyYXRlIHRoZSBUb3AgQXBwIEJhciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDVG9wQXBwQmFyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBBZGRzIGEgY2xhc3MgdG8gdGhlIHJvb3QgRWxlbWVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKi9cbiAgYWRkQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgcm9vdCBFbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcm9vdCBFbGVtZW50IGNvbnRhaW5zIHRoZSBnaXZlbiBjbGFzcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQ2xhc3MoY2xhc3NOYW1lKSB7fVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzcGVjaWZpZWQgaW5saW5lIHN0eWxlIHByb3BlcnR5IG9uIHRoZSByb290IEVsZW1lbnQgdG8gdGhlIGdpdmVuIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRTdHlsZShwcm9wZXJ0eSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGhlaWdodCBvZiB0aGUgdG9wIGFwcCBiYXIuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFRvcEFwcEJhckhlaWdodCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSBuYXZpZ2F0aW9uIGljb24gZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgbmF2aWdhdGlvbiBpY29uIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRW1pdHMgYW4gZXZlbnQgd2hlbiB0aGUgbmF2aWdhdGlvbiBpY29uIGlzIGNsaWNrZWQuXG4gICAqL1xuICBub3RpZnlOYXZpZ2F0aW9uSWNvbkNsaWNrZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCl9IGhhbmRsZXIgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KX0gaGFuZGxlciAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldFZpZXdwb3J0U2Nyb2xsWSgpIHt9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0VG90YWxBY3Rpb25JdGVtcygpIHt9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RvcEFwcEJhckFkYXB0ZXI7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICBGSVhFRF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQnLFxuICBGSVhFRF9TQ1JPTExFRF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tZml4ZWQtc2Nyb2xsZWQnLFxuICBTSE9SVF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQnLFxuICBTSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1M6ICdtZGMtdG9wLWFwcC1iYXItLXNob3J0LWhhcy1hY3Rpb24taXRlbScsXG4gIFNIT1JUX0NPTExBUFNFRF9DTEFTUzogJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJyxcbn07XG5cbi8qKiBAZW51bSB7bnVtYmVyfSAqL1xuY29uc3QgbnVtYmVycyA9IHtcbiAgREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVM6IDEwMCxcbiAgTUFYX1RPUF9BUFBfQkFSX0hFSUdIVDogMTI4LFxufTtcblxuLyoqIEBlbnVtIHtzdHJpbmd9ICovXG5jb25zdCBzdHJpbmdzID0ge1xuICBBQ1RJT05fSVRFTV9TRUxFQ1RPUjogJy5tZGMtdG9wLWFwcC1iYXJfX2FjdGlvbi1pdGVtJyxcbiAgTkFWSUdBVElPTl9FVkVOVDogJ01EQ1RvcEFwcEJhcjpuYXYnLFxuICBOQVZJR0FUSU9OX0lDT05fU0VMRUNUT1I6ICcubWRjLXRvcC1hcHAtYmFyX19uYXZpZ2F0aW9uLWljb24nLFxuICBST09UX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcicsXG4gIFRJVExFX1NFTEVDVE9SOiAnLm1kYy10b3AtYXBwLWJhcl9fdGl0bGUnLFxufTtcblxuZXhwb3J0IHtzdHJpbmdzLCBjc3NDbGFzc2VzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge3N0cmluZ3MsIGNzc0NsYXNzZXMsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCBNRENUb3BBcHBCYXJBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDVG9wQXBwQmFyQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIC8qKiBAcmV0dXJuIGVudW0ge3N0cmluZ30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nfSAqL1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICAvKiogQHJldHVybiBlbnVtIHtudW1iZXJ9ICovXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiB7QHNlZSBNRENUb3BBcHBCYXJBZGFwdGVyfSBmb3IgdHlwaW5nIGluZm9ybWF0aW9uIG9uIHBhcmFtZXRlcnMgYW5kIHJldHVyblxuICAgKiB0eXBlcy5cbiAgICogQHJldHVybiB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENUb3BBcHBCYXJBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBhZGRDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0U3R5bGU6ICgvKiBwcm9wZXJ0eTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGdldFRvcEFwcEJhckhlaWdodDogKCkgPT4ge30sXG4gICAgICByZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlOYXZpZ2F0aW9uSWNvbkNsaWNrZWQ6ICgpID0+IHt9LFxuICAgICAgcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICAgIGdldFRvdGFsQWN0aW9uSXRlbXM6ICgpID0+IC8qIG51bWJlciAqLyAwLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKC8qKiBAdHlwZSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9ICovIGFkYXB0ZXIpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICB0aGlzLm5hdkNsaWNrSGFuZGxlcl8gPSAoKSA9PiB0aGlzLmFkYXB0ZXJfLm5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZCgpO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHt9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5uYXZDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyTmF2aWdhdGlvbkljb25JbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5uYXZDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGluaXRTY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveVNjcm9sbEhhbmRsZXIoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQgTURDVG9wQXBwQmFyQWRhcHRlciBmcm9tICcuLi9hZGFwdGVyJztcbmltcG9ydCBNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbiBmcm9tICcuLi9mb3VuZGF0aW9uJztcbmltcG9ydCB7bnVtYmVyc30gZnJvbSAnLi4vY29uc3RhbnRzJztcblxuY29uc3QgSU5JVElBTF9WQUxVRSA9IDA7XG4vKipcbiAqIEBleHRlbmRzIHtNRENUb3BBcHBCYXJCYXNlRm91bmRhdGlvbjwhTURDVG9wQXBwQmFyRm91bmRhdGlvbj59XG4gKiBAZmluYWxcbiAqL1xuY2xhc3MgTURDVG9wQXBwQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihhZGFwdGVyKTtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciBkaWZmcyBvZiBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiB2cyBwcmV2aW91cyBzY3JvbGwgcG9zaXRpb25cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uXyA9IHRoaXMuYWRhcHRlcl8uZ2V0Vmlld3BvcnRTY3JvbGxZKCk7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHZlcmlmeSB3aGVuIHRoZSB0b3AgYXBwIGJhciBpcyBjb21wbGV0ZWx5IHNob3dpbmcgb3IgY29tcGxldGVseSBoaWRkZW5cbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMudG9wQXBwQmFySGVpZ2h0XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VG9wQXBwQmFySGVpZ2h0KCk7XG5cbiAgICAvKipcbiAgICAgKiB3YXNEb2NrZWRfIGlzIHVzZWQgdG8gaW5kaWNhdGUgaWYgdGhlIHRvcCBhcHAgYmFyIHdhcyBkb2NrZWQgaW4gdGhlIHByZXZpb3VzXG4gICAgICogc2Nyb2xsIGhhbmRsZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwcml2YXRlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMud2FzRG9ja2VkXyA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBpc0RvY2tlZFNob3dpbmdfIGlzIHVzZWQgdG8gaW5kaWNhdGUgaWYgdGhlIHRvcCBhcHAgYmFyIGlzIGRvY2tlZCBpbiB0aGUgZnVsbHlcbiAgICAgKiBzaG93biBwb3NpdGlvbi5cbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLmlzRG9ja2VkU2hvd2luZ18gPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVmFyaWFibGUgZm9yIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSB0b3AgYXBwIGJhclxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIHByZXZlbnQgdGhlIHRvcCBhcHAgYmFyIGZyb20gYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgZHVyaW5nIHJlc2l6ZSBldmVudHNcbiAgICAgKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmlzQ3VycmVudGx5QmVpbmdSZXNpemVkXyA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVvdXQgdGhhdCdzIHVzZWQgdG8gdGhyb3R0bGUgdGhlIHJlc2l6ZSBldmVudHNcbiAgICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucmVzaXplVGhyb3R0bGVJZF8gPSBJTklUSUFMX1ZBTFVFO1xuXG4gICAgLyoqXG4gICAgICogVGhlIHRpbWVvdXQgdGhhdCdzIHVzZWQgdG8gZGVib3VuY2UgdG9nZ2xpbmcgdGhlIGlzQ3VycmVudGx5QmVpbmdSZXNpemVkXyB2YXJpYWJsZSBhZnRlciBhIHJlc2l6ZVxuICAgICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5yZXNpemVEZWJvdW5jZUlkXyA9IElOSVRJQUxfVkFMVUU7XG5cbiAgICB0aGlzLnNjcm9sbEhhbmRsZXJfID0gKCkgPT4gdGhpcy50b3BBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICAgIHRoaXMucmVzaXplSGFuZGxlcl8gPSAoKSA9PiB0aGlzLnRvcEFwcEJhclJlc2l6ZUhhbmRsZXJfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyU2Nyb2xsSGFuZGxlcih0aGlzLnNjcm9sbEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0b3AnLCAnJyk7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBET00gbmVlZHMgdG8gdXBkYXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY2hlY2tGb3JVcGRhdGVfKCkge1xuICAgIGNvbnN0IG9mZnNjcmVlbkJvdW5kYXJ5VG9wID0gLXRoaXMudG9wQXBwQmFySGVpZ2h0XztcbiAgICBjb25zdCBoYXNBbnlQaXhlbHNPZmZzY3JlZW4gPSB0aGlzLmN1cnJlbnRBcHBCYXJPZmZzZXRUb3BfIDwgMDtcbiAgICBjb25zdCBoYXNBbnlQaXhlbHNPbnNjcmVlbiA9IHRoaXMuY3VycmVudEFwcEJhck9mZnNldFRvcF8gPiBvZmZzY3JlZW5Cb3VuZGFyeVRvcDtcbiAgICBjb25zdCBwYXJ0aWFsbHlTaG93aW5nID0gaGFzQW55UGl4ZWxzT2Zmc2NyZWVuICYmIGhhc0FueVBpeGVsc09uc2NyZWVuO1xuXG4gICAgLy8gSWYgaXQncyBwYXJ0aWFsbHkgc2hvd2luZywgaXQgY2FuJ3QgYmUgZG9ja2VkLlxuICAgIGlmIChwYXJ0aWFsbHlTaG93aW5nKSB7XG4gICAgICB0aGlzLndhc0RvY2tlZF8gPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm90IHByZXZpb3VzbHkgZG9ja2VkIGFuZCBub3QgcGFydGlhbGx5IHNob3dpbmcsIGl0J3Mgbm93IGRvY2tlZC5cbiAgICAgIGlmICghdGhpcy53YXNEb2NrZWRfKSB7XG4gICAgICAgIHRoaXMud2FzRG9ja2VkXyA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzRG9ja2VkU2hvd2luZ18gIT09IGhhc0FueVBpeGVsc09uc2NyZWVuKSB7XG4gICAgICAgIHRoaXMuaXNEb2NrZWRTaG93aW5nXyA9IGhhc0FueVBpeGVsc09uc2NyZWVuO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFydGlhbGx5U2hvd2luZztcbiAgfVxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0byBtb3ZlIHRoZSB0b3AgYXBwIGJhciBpZiBuZWVkZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBtb3ZlVG9wQXBwQmFyXygpIHtcbiAgICBpZiAodGhpcy5jaGVja0ZvclVwZGF0ZV8oKSkge1xuICAgICAgLy8gT25jZSB0aGUgdG9wIGFwcCBiYXIgaXMgZnVsbHkgaGlkZGVuIHdlIHVzZSB0aGUgbWF4IHBvdGVudGlhbCB0b3AgYXBwIGJhciBoZWlnaHQgYXMgb3VyIG9mZnNldFxuICAgICAgLy8gc28gdGhlIHRvcCBhcHAgYmFyIGRvZXNuJ3Qgc2hvdyBpZiB0aGUgd2luZG93IHJlc2l6ZXMgYW5kIHRoZSBuZXcgaGVpZ2h0ID4gdGhlIG9sZCBoZWlnaHQuXG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXztcbiAgICAgIGlmIChNYXRoLmFicyhvZmZzZXQpID49IHRoaXMudG9wQXBwQmFySGVpZ2h0Xykge1xuICAgICAgICBvZmZzZXQgPSAtbnVtYmVycy5NQVhfVE9QX0FQUF9CQVJfSEVJR0hUO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFN0eWxlKCd0b3AnLCBvZmZzZXQgKyAncHgnKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2Nyb2xsIGhhbmRsZXIgZm9yIHRoZSBkZWZhdWx0IHNjcm9sbCBiZWhhdmlvciBvZiB0aGUgdG9wIGFwcCBiYXIuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0b3BBcHBCYXJTY3JvbGxIYW5kbGVyXygpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsUG9zaXRpb24gPSBNYXRoLm1heCh0aGlzLmFkYXB0ZXJfLmdldFZpZXdwb3J0U2Nyb2xsWSgpLCAwKTtcbiAgICBjb25zdCBkaWZmID0gY3VycmVudFNjcm9sbFBvc2l0aW9uIC0gdGhpcy5sYXN0U2Nyb2xsUG9zaXRpb25fO1xuICAgIHRoaXMubGFzdFNjcm9sbFBvc2l0aW9uXyA9IGN1cnJlbnRTY3JvbGxQb3NpdGlvbjtcblxuICAgIC8vIElmIHRoZSB3aW5kb3cgaXMgYmVpbmcgcmVzaXplZCB0aGUgbGFzdFNjcm9sbFBvc2l0aW9uXyBuZWVkcyB0byBiZSB1cGRhdGVkIGJ1dCB0aGVcbiAgICAvLyBjdXJyZW50IHNjcm9sbCBvZiB0aGUgdG9wIGFwcCBiYXIgc2hvdWxkIHN0YXkgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gICAgaWYgKCF0aGlzLmlzQ3VycmVudGx5QmVpbmdSZXNpemVkXykge1xuICAgICAgdGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyAtPSBkaWZmO1xuXG4gICAgICBpZiAodGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyA+IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyA9IDA7XG4gICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKHRoaXMuY3VycmVudEFwcEJhck9mZnNldFRvcF8pID4gdGhpcy50b3BBcHBCYXJIZWlnaHRfKSB7XG4gICAgICAgIHRoaXMuY3VycmVudEFwcEJhck9mZnNldFRvcF8gPSAtdGhpcy50b3BBcHBCYXJIZWlnaHRfO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vdmVUb3BBcHBCYXJfKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRvcCBhcHAgYmFyIHJlc2l6ZSBoYW5kbGVyIHRoYXQgdGhyb3R0bGUvZGVib3VuY2UgZnVuY3Rpb25zIHRoYXQgZXhlY3V0ZSB1cGRhdGVzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdG9wQXBwQmFyUmVzaXplSGFuZGxlcl8oKSB7XG4gICAgLy8gVGhyb3R0bGUgcmVzaXplIGV2ZW50cyAxMCBwL3NcbiAgICBpZiAoIXRoaXMucmVzaXplVGhyb3R0bGVJZF8pIHtcbiAgICAgIHRoaXMucmVzaXplVGhyb3R0bGVJZF8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5yZXNpemVUaHJvdHRsZUlkXyA9IElOSVRJQUxfVkFMVUU7XG4gICAgICAgIHRoaXMudGhyb3R0bGVkUmVzaXplSGFuZGxlcl8oKTtcbiAgICAgIH0sIG51bWJlcnMuREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVMpO1xuICAgIH1cblxuICAgIHRoaXMuaXNDdXJyZW50bHlCZWluZ1Jlc2l6ZWRfID0gdHJ1ZTtcblxuICAgIGlmICh0aGlzLnJlc2l6ZURlYm91bmNlSWRfKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVEZWJvdW5jZUlkXyk7XG4gICAgfVxuXG4gICAgdGhpcy5yZXNpemVEZWJvdW5jZUlkXyA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy50b3BBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICAgICAgdGhpcy5pc0N1cnJlbnRseUJlaW5nUmVzaXplZF8gPSBmYWxzZTtcbiAgICAgIHRoaXMucmVzaXplRGVib3VuY2VJZF8gPSBJTklUSUFMX1ZBTFVFO1xuICAgIH0sIG51bWJlcnMuREVCT1VOQ0VfVEhST1RUTEVfUkVTSVpFX1RJTUVfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRocm90dGxlZCBmdW5jdGlvbiB0aGF0IHVwZGF0ZXMgdGhlIHRvcCBhcHAgYmFyIHNjcm9sbGVkIHZhbHVlcyBpZiB0aGVcbiAgICogdG9wIGFwcCBiYXIgaGVpZ2h0IGNoYW5nZXMuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aHJvdHRsZWRSZXNpemVIYW5kbGVyXygpIHtcbiAgICBjb25zdCBjdXJyZW50SGVpZ2h0ID0gdGhpcy5hZGFwdGVyXy5nZXRUb3BBcHBCYXJIZWlnaHQoKTtcbiAgICBpZiAodGhpcy50b3BBcHBCYXJIZWlnaHRfICE9PSBjdXJyZW50SGVpZ2h0KSB7XG4gICAgICB0aGlzLndhc0RvY2tlZF8gPSBmYWxzZTtcblxuICAgICAgLy8gU2luY2UgdGhlIHRvcCBhcHAgYmFyIGhhcyBhIGRpZmZlcmVudCBoZWlnaHQgZGVwZW5kaW5nIG9uIHRoZSBzY3JlZW4gd2lkdGgsIHRoaXNcbiAgICAgIC8vIHdpbGwgZW5zdXJlIHRoYXQgdGhlIHRvcCBhcHAgYmFyIHJlbWFpbnMgaW4gdGhlIGNvcnJlY3QgbG9jYXRpb24gaWZcbiAgICAgIC8vIGNvbXBsZXRlbHkgaGlkZGVuIGFuZCBhIHJlc2l6ZSBtYWtlcyB0aGUgdG9wIGFwcCBiYXIgYSBkaWZmZXJlbnQgaGVpZ2h0LlxuICAgICAgdGhpcy5jdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyAtPSB0aGlzLnRvcEFwcEJhckhlaWdodF8gLSBjdXJyZW50SGVpZ2h0O1xuICAgICAgdGhpcy50b3BBcHBCYXJIZWlnaHRfID0gY3VycmVudEhlaWdodDtcbiAgICB9XG4gICAgdGhpcy50b3BBcHBCYXJTY3JvbGxIYW5kbGVyXygpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1RvcEFwcEJhckZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IE1EQ1RvcEFwcEJhckFkYXB0ZXIgZnJvbSAnLi4vYWRhcHRlcic7XG5pbXBvcnQgTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24gZnJvbSAnLi4vZm91bmRhdGlvbic7XG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uPCFNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RvcEFwcEJhckJhc2VGb3VuZGF0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IU1EQ1RvcEFwcEJhckFkYXB0ZXJ9IGFkYXB0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihhZGFwdGVyKTtcbiAgICAvLyBTdGF0ZSB2YXJpYWJsZSBmb3IgdGhlIGN1cnJlbnQgdG9wIGFwcCBiYXIgc3RhdGVcbiAgICB0aGlzLmlzQ29sbGFwc2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLnNjcm9sbEhhbmRsZXJfID0gKCkgPT4gdGhpcy5zaG9ydEFwcEJhclNjcm9sbEhhbmRsZXJfKCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHN1cGVyLmluaXQoKTtcbiAgICBjb25zdCBpc0Fsd2F5c0NvbGxhcHNlZCA9IHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9DT0xMQVBTRURfQ0xBU1MpO1xuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uZ2V0VG90YWxBY3Rpb25JdGVtcygpID4gMCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhjc3NDbGFzc2VzLlNIT1JUX0hBU19BQ1RJT05fSVRFTV9DTEFTUyk7XG4gICAgfVxuXG4gICAgaWYgKCFpc0Fsd2F5c0NvbGxhcHNlZCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gICAgICB0aGlzLnNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8oKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cblxuICAvKipcbiAgICogU2Nyb2xsIGhhbmRsZXIgZm9yIGFwcGx5aW5nL3JlbW92aW5nIHRoZSBjb2xsYXBzZWQgbW9kaWZpZXIgY2xhc3NcbiAgICogb24gdGhlIHNob3J0IHRvcCBhcHAgYmFyLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc2hvcnRBcHBCYXJTY3JvbGxIYW5kbGVyXygpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsID0gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFNjcm9sbFkoKTtcblxuICAgIGlmIChjdXJyZW50U2Nyb2xsIDw9IDApIHtcbiAgICAgIGlmICh0aGlzLmlzQ29sbGFwc2VkKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5TSE9SVF9DT0xMQVBTRURfQ0xBU1MpO1xuICAgICAgICB0aGlzLmlzQ29sbGFwc2VkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghdGhpcy5pc0NvbGxhcHNlZCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKGNzc0NsYXNzZXMuU0hPUlRfQ09MTEFQU0VEX0NMQVNTKTtcbiAgICAgICAgdGhpcy5pc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG5pbXBvcnQge2Nzc0NsYXNzZXN9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgTURDVG9wQXBwQmFyQWRhcHRlciBmcm9tICcuLi9hZGFwdGVyJztcbmltcG9ydCBNRENUb3BBcHBCYXJGb3VuZGF0aW9uIGZyb20gJy4uL2ZvdW5kYXRpb24nO1xuXG4vKipcbiAqIEBleHRlbmRzIHtNRENUb3BBcHBCYXJGb3VuZGF0aW9uPCFNRENGaXhlZFRvcEFwcEJhckZvdW5kYXRpb24+fVxuICogQGZpbmFsXG4gKi9cbmNsYXNzIE1EQ0ZpeGVkVG9wQXBwQmFyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1RvcEFwcEJhckZvdW5kYXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHshTURDVG9wQXBwQmFyQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKGFkYXB0ZXIpO1xuICAgIC8qKiBTdGF0ZSB2YXJpYWJsZSBmb3IgdGhlIHByZXZpb3VzIHNjcm9sbCBpdGVyYXRpb24gdG9wIGFwcCBiYXIgc3RhdGUgKi9cbiAgICB0aGlzLndhc1Njcm9sbGVkXyA9IGZhbHNlO1xuXG4gICAgdGhpcy5zY3JvbGxIYW5kbGVyXyA9ICgpID0+IHRoaXMuZml4ZWRTY3JvbGxIYW5kbGVyXygpO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclNjcm9sbEhhbmRsZXIodGhpcy5zY3JvbGxIYW5kbGVyXyk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyKHRoaXMuc2Nyb2xsSGFuZGxlcl8pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNjcm9sbCBoYW5kbGVyIGZvciBhcHBseWluZy9yZW1vdmluZyB0aGUgbW9kaWZpZXIgY2xhc3NcbiAgICogb24gdGhlIGZpeGVkIHRvcCBhcHAgYmFyLlxuICAgKi9cbiAgZml4ZWRTY3JvbGxIYW5kbGVyXygpIHtcbiAgICBjb25zdCBjdXJyZW50U2Nyb2xsID0gdGhpcy5hZGFwdGVyXy5nZXRWaWV3cG9ydFNjcm9sbFkoKTtcblxuICAgIGlmIChjdXJyZW50U2Nyb2xsIDw9IDApIHtcbiAgICAgIGlmICh0aGlzLndhc1Njcm9sbGVkXykge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKGNzc0NsYXNzZXMuRklYRURfU0NST0xMRURfQ0xBU1MpO1xuICAgICAgICB0aGlzLndhc1Njcm9sbGVkXyA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXRoaXMud2FzU2Nyb2xsZWRfKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5GSVhFRF9TQ1JPTExFRF9DTEFTUyk7XG4gICAgICAgIHRoaXMud2FzU2Nyb2xsZWRfID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDRml4ZWRUb3BBcHBCYXJGb3VuZGF0aW9uO1xuIiwiPHRlbXBsYXRlPlxuICA8aGVhZGVyIHJlZj1cInJvb3RcIiA6Y2xhc3M9XCJyb290Q2xhc3Nlc1wiIDpzdHlsZT1cInJvb3RTdHlsZXNcIiB2LW9uPVwiJGxpc3RlbmVyc1wiPlxuICAgIDxkaXYgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3Jvd1wiPlxuICAgICAgPHNlY3Rpb25cbiAgICAgICAgY2xhc3M9XCJtZGMtdG9wLWFwcC1iYXJfX3NlY3Rpb24gbWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uLS1hbGlnbi1zdGFydFwiXG4gICAgICA+XG4gICAgICAgIDxidXR0b25cbiAgICAgICAgICB2LWlmPVwiaGF2ZU5hdmlnYXRpb25JY29uXCJcbiAgICAgICAgICByZWY9XCJuYXZpZ2F0aW9uSWNvblwiXG4gICAgICAgICAgOmNsYXNzPVwibmF2aWNvbkNsYXNzZXNcIlxuICAgICAgICAgIHYtb249XCJsaXN0ZW5lcnNcIlxuICAgICAgICA+XG4gICAgICAgICAge3sgaWNvbiB9fVxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPHNwYW4gdi1pZj1cIiEhdGl0bGVcIiBjbGFzcz1cIm1kYy10b3AtYXBwLWJhcl9fdGl0bGVcIj57eyB0aXRsZSB9fTwvc3Bhbj5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICAgIDxzZWN0aW9uXG4gICAgICAgIHYtaWY9XCIkc2xvdHMuZGVmYXVsdFwiXG4gICAgICAgIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyX19zZWN0aW9uIG1kYy10b3AtYXBwLWJhcl9fc2VjdGlvbi0tYWxpZ24tZW5kXCJcbiAgICAgID5cbiAgICAgICAgPHNsb3QgLz5cbiAgICAgIDwvc2VjdGlvbj5cbiAgICA8L2Rpdj5cbiAgICA8c2xvdCBuYW1lPVwidGFic1wiIC8+XG4gIDwvaGVhZGVyPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUb3BBcHBCYXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC90b3AtYXBwLWJhci9zdGFuZGFyZC9mb3VuZGF0aW9uJ1xuaW1wb3J0IE1EQ1Nob3J0VG9wQXBwQmFyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvdG9wLWFwcC1iYXIvc2hvcnQvZm91bmRhdGlvbidcbmltcG9ydCBNRENGaXhlZFRvcEFwcEJhckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3RvcC1hcHAtYmFyL2ZpeGVkL2ZvdW5kYXRpb24nXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4gfSBmcm9tICcuLi9iYXNlJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtdG9wLWFwcC1iYXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEV2ZW50TWl4aW5dLFxuICBwcm9wczoge1xuICAgIHNob3J0OiBCb29sZWFuLFxuICAgIHNob3J0Q29sbGFwc2VkOiBCb29sZWFuLFxuICAgIHByb21pbmVudDogQm9vbGVhbixcbiAgICBmaXhlZDogQm9vbGVhbixcbiAgICB0aXRsZTogU3RyaW5nLFxuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFtTdHJpbmcsIEJvb2xlYW5dLFxuICAgICAgZGVmYXVsdDogJ21lbnUnXG4gICAgfSxcbiAgICBpY29uQ2xhc3NlczogT2JqZWN0LFxuICAgIGRlbnNlOiBCb29sZWFuXG4gIH0sXG4gIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJvb3RTdHlsZXM6IHsgdG9wOiAnMCcgfSxcbiAgICAgIHJvb3RDbGFzc2VzOiB7XG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXInOiB0cnVlLFxuICAgICAgICAnbWRjLXRvcC1hcHAtYmFyLS1kZW5zZSc6IHRoaXMuZGVuc2UsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLXNob3J0JzogdGhpcy5zaG9ydCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tc2hvcnQtY29sbGFwc2VkJzogdGhpcy5zaG9ydENvbGxhcHNlZCxcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhci0tcHJvbWluZW50JzogdGhpcy5wcm9taW5lbnQsXG4gICAgICAgICdtZGMtdG9wLWFwcC1iYXItLWZpeGVkJzogdGhpcy5maXhlZFxuICAgICAgfSxcbiAgICAgIGZvdW5kYXRpb246IG51bGxcbiAgICB9XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaGF2ZU5hdmlnYXRpb25JY29uKCkge1xuICAgICAgcmV0dXJuICEhdGhpcy5pY29uIHx8IHRoaXMuaWNvbkNsYXNzZXNcbiAgICB9LFxuICAgIG5hdmljb25DbGFzc2VzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ21kYy10b3AtYXBwLWJhcl9fbmF2aWdhdGlvbi1pY29uJzogdHJ1ZSxcbiAgICAgICAgJ21hdGVyaWFsLWljb25zJzogISF0aGlzLmljb24sXG4gICAgICAgIC4uLnRoaXMuaWNvbkNsYXNzZXNcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQoKSB7XG4gICAgY29uc3QgYWRhcHRlciA9IHtcbiAgICAgIGFkZENsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5yb290Q2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kcmVmcy5yb290LmNsYXNzTGlzdC5jb250YWlucyhjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgc2V0U3R5bGU6IChwcm9wZXJ0eSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMucm9vdFN0eWxlcywgcHJvcGVydHksIHZhbHVlKVxuICAgICAgfSxcbiAgICAgIGdldFRvcEFwcEJhckhlaWdodDogKCkgPT4gdGhpcy4kZWwuY2xpZW50SGVpZ2h0LFxuICAgICAgcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm5hdmlnYXRpb25JY29uLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJOYXZpZ2F0aW9uSWNvbkludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuJHJlZnMubmF2aWdhdGlvbkljb24pIHtcbiAgICAgICAgICB0aGlzLiRyZWZzLm5hdmlnYXRpb25JY29uLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcilcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG5vdGlmeU5hdmlnYXRpb25JY29uQ2xpY2tlZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCduYXYnKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyU2Nyb2xsSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyOiBoYW5kbGVyID0+IHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiBoYW5kbGVyID0+XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKSxcblxuICAgICAgZ2V0Vmlld3BvcnRTY3JvbGxZOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVlPZmZzZXRcbiAgICAgIH0sXG4gICAgICBnZXRUb3RhbEFjdGlvbkl0ZW1zOiAoKSA9PlxuICAgICAgICB0aGlzLiRyZWZzLnJvb3QucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICAgICBNRENUb3BBcHBCYXJGb3VuZGF0aW9uLnN0cmluZ3MuQUNUSU9OX0lURU1fU0VMRUNUT1JcbiAgICAgICAgKS5sZW5ndGhcbiAgICB9XG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSB0aGlzLnNob3J0XG4gICAgICA/IG5ldyBNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24oYWRhcHRlcilcbiAgICAgIDogdGhpcy5maXhlZFxuICAgICAgPyBuZXcgTURDRml4ZWRUb3BBcHBCYXJGb3VuZGF0aW9uKGFkYXB0ZXIpXG4gICAgICA6IG5ldyBNRENUb3BBcHBCYXJGb3VuZGF0aW9uKGFkYXB0ZXIpXG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFcbiAgICA6Y2xhc3M9XCJhY3Rpb25pY29uQ2xhc3Nlc1wiXG4gICAgaHJlZj1cIiNcIlxuICAgIGNsYXNzPVwibWRjLXRvcC1hcHAtYmFyLWFjdGlvbiBtZGMtdG9wLWFwcC1iYXItLWFjdGlvbiBtZGMtdG9wLWFwcC1iYXJfX2FjdGlvbi1pdGVtXCJcbiAgICB2LW9uPVwibGlzdGVuZXJzXCI+XG4gICAgPHNsb3Q+e3sgaWNvbiB9fTwvc2xvdD5cbiAgPC9hPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCB7IERpc3BhdGNoRXZlbnRNaXhpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgeyBSaXBwbGVNaXhpbiB9IGZyb20gJy4uL3JpcHBsZSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRvcC1hcHAtYmFyLWFjdGlvbicsXG4gIG1peGluczogW0Rpc3BhdGNoRXZlbnRNaXhpbiwgUmlwcGxlTWl4aW5dLFxuICBwcm9wczoge1xuICAgIGljb246IFN0cmluZyxcbiAgICBpY29uQ2xhc3NlczogT2JqZWN0XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgYWN0aW9uaWNvbkNsYXNzZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnbWF0ZXJpYWwtaWNvbnMnOiAhIXRoaXMuaWNvbixcbiAgICAgICAgLi4udGhpcy5pY29uQ2xhc3Nlc1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJpbXBvcnQgeyBCYXNlUGx1Z2luIH0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNUb3BBcHBCYXIgZnJvbSAnLi9tZGMtdG9wLWFwcC1iYXIudnVlJ1xuaW1wb3J0IG1kY1RvcEFwcEJhckFjdGlvbiBmcm9tICcuL21kYy10b3AtYXBwLWJhci1hY3Rpb24udnVlJ1xuXG5leHBvcnQgeyBtZGNUb3BBcHBCYXIsIG1kY1RvcEFwcEJhckFjdGlvbiB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNUb3BBcHBCYXIsXG4gIG1kY1RvcEFwcEJhckFjdGlvblxufSlcbiIsImNvbnN0IHR5cG9zID0gW1xuICAnaGVhZGxpbmUxJyxcbiAgJ2hlYWRsaW5lMicsXG4gICdoZWFkbGluZTMnLFxuICAnaGVhZGxpbmU0JyxcbiAgJ2hlYWRsaW5lNScsXG4gICdoZWFkbGluZTYnLFxuICAnc3VidGl0bGUxJyxcbiAgJ3N1YnRpdGxlMicsXG4gICdib2R5MScsXG4gICdib2R5MicsXG4gICdjYXB0aW9uJyxcbiAgJ2J1dHRvbicsXG4gICdvdmVybGluZSdcbl1cblxuZXhwb3J0IGNvbnN0IG1kY1R5cG9NaXhpbiA9IG5hbWUgPT4ge1xuICByZXR1cm4ge1xuICAgIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChcbiAgICAgICAgdGhpcy50YWcsXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzczoge1xuICAgICAgICAgICAgJ21kYy10eXBvJzogdHJ1ZSxcbiAgICAgICAgICAgIFtuYW1lXTogdHJ1ZSxcbiAgICAgICAgICAgIFtgbWRjLXR5cG9ncmFwaHktLSR7dGhpcy50eXBvfWBdOiB0cnVlXG4gICAgICAgICAgfSxcbiAgICAgICAgICBhdHRyczogdGhpcy4kYXR0cnMsXG4gICAgICAgICAgb246IHRoaXMuJGxpc3RlbmVyc1xuICAgICAgICB9LFxuICAgICAgICB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgICApXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZGNUeXBvUHJvcE1peGluKGRlZmF1bHRUYWcsIGRlZmF1bHRUeXBvLCB2YWxpZFR5cG9zKSB7XG4gIHJldHVybiB7XG4gICAgcHJvcHM6IHtcbiAgICAgIHRhZzoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHQ6IGRlZmF1bHRUYWdcbiAgICAgIH0sXG4gICAgICB0eXBvOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgZGVmYXVsdDogZGVmYXVsdFR5cG8sXG4gICAgICAgIHZhbGlkYXRvcjogdmFsdWUgPT4gdmFsaWRUeXBvcy5pbmRleE9mKHZhbHVlKSAhPT0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1RleHRTZWN0aW9uID0ge1xuICBuYW1lOiAnbWRjLXRleHQtc2VjdGlvbicsXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnc2VjdGlvbidcbiAgICB9XG4gIH0sXG4gIHJlbmRlcihjcmVhdGVFbGVtZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgICB0aGlzLnRhZyxcbiAgICAgIHtcbiAgICAgICAgY2xhc3M6IHtcbiAgICAgICAgICAnbWRjLXR5cG9ncmFwaHknOiB0cnVlLFxuICAgICAgICAgICdtZGMtdGV4dC1zZWN0aW9uJzogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBhdHRyczogdGhpcy4kYXR0cnMsXG4gICAgICAgIG9uOiB0aGlzLiRsaXN0ZW5lcnNcbiAgICAgIH0sXG4gICAgICB0aGlzLiRzbG90cy5kZWZhdWx0XG4gICAgKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBtZGNUZXh0ID0ge1xuICBuYW1lOiAnbWRjLXRleHQnLFxuICBtaXhpbnM6IFttZGNUeXBvTWl4aW4oJ21kYy10ZXh0JyksIG1kY1R5cG9Qcm9wTWl4aW4oJ3AnLCAnYm9keTEnLCB0eXBvcyldXG59XG5cbmV4cG9ydCBjb25zdCBtZGNEaXNwbGF5ID0ge1xuICBuYW1lOiAnbWRjLWRpc3BsYXknLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy1kaXNwbGF5JyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDEnLCAnaGVhZGxpbmU0JywgW1xuICAgICAgJ2hlYWRsaW5lNCcsXG4gICAgICAnaGVhZGxpbmUzJyxcbiAgICAgICdoZWFkbGluZTInLFxuICAgICAgJ2hlYWRsaW5lMSdcbiAgICBdKVxuICBdXG59XG5cbmV4cG9ydCBjb25zdCBtZGNIZWFkbGluZSA9IHtcbiAgbmFtZTogJ21kYy1oZWFkbGluZScsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWhlYWRsaW5lJyksXG4gICAgbWRjVHlwb1Byb3BNaXhpbignaDInLCAnaGVhZGxpbmU1JywgWydoZWFkbGluZTUnXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjVGl0bGUgPSB7XG4gIG5hbWU6ICdtZGMtdGl0bGUnLFxuICBtaXhpbnM6IFtcbiAgICBtZGNUeXBvTWl4aW4oJ21kYy10aXRsZScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ2gzJywgJ2hlYWRsaW5lNicsIFsnaGVhZGxpbmU2J10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY1N1YkhlYWRpbmcgPSB7XG4gIG5hbWU6ICdtZGMtc3ViaGVhZGluZycsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLXN1YmhlYWRpbmcnKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdoNCcsICdzdWJ0aXRsZTInLCBbJ3N1YnRpdGxlMScsICdzdWJ0aXRsZTInXSlcbiAgXVxufVxuXG5leHBvcnQgY29uc3QgbWRjQm9keSA9IHtcbiAgbmFtZTogJ21kYy1ib2R5JyxcbiAgbWl4aW5zOiBbXG4gICAgbWRjVHlwb01peGluKCdtZGMtYm9keScpLFxuICAgIG1kY1R5cG9Qcm9wTWl4aW4oJ3AnLCAnYm9keTEnLCBbJ2JvZHkxJywgJ2JvZHkyJ10pXG4gIF1cbn1cblxuZXhwb3J0IGNvbnN0IG1kY0NhcHRpb24gPSB7XG4gIG5hbWU6ICdtZGMtY2FwdGlvbicsXG4gIG1peGluczogW1xuICAgIG1kY1R5cG9NaXhpbignbWRjLWNhcHRpb24nKSxcbiAgICBtZGNUeXBvUHJvcE1peGluKCdzcGFuJywgJ2NhcHRpb24nLCBbJ2NhcHRpb24nXSlcbiAgXVxufVxuIiwiaW1wb3J0IHsgQmFzZVBsdWdpbiB9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQge1xuICBtZGNUZXh0U2VjdGlvbixcbiAgbWRjVGV4dCxcbiAgbWRjQm9keSxcbiAgbWRjQ2FwdGlvbixcbiAgbWRjRGlzcGxheSxcbiAgbWRjSGVhZGxpbmUsXG4gIG1kY1N1YkhlYWRpbmcsXG4gIG1kY1RpdGxlXG59IGZyb20gJy4vbWRjLXR5cG9ncmFwaHkuanMnXG5cbmV4cG9ydCB7XG4gIG1kY1RleHRTZWN0aW9uLFxuICBtZGNUZXh0LFxuICBtZGNCb2R5LFxuICBtZGNDYXB0aW9uLFxuICBtZGNEaXNwbGF5LFxuICBtZGNIZWFkbGluZSxcbiAgbWRjU3ViSGVhZGluZyxcbiAgbWRjVGl0bGVcbn1cblxuZXhwb3J0IGRlZmF1bHQgQmFzZVBsdWdpbih7XG4gIG1kY1RleHRTZWN0aW9uLFxuICBtZGNUZXh0LFxuICBtZGNCb2R5LFxuICBtZGNDYXB0aW9uLFxuICBtZGNEaXNwbGF5LFxuICBtZGNIZWFkbGluZSxcbiAgbWRjU3ViSGVhZGluZyxcbiAgbWRjVGl0bGVcbn0pXG4iLCIvL1xuLy8gdnVlIFBsdWdJblxuLy9cbmltcG9ydCBWdWVNRENCdXR0b24gZnJvbSAnLi9idXR0b24nXG5pbXBvcnQgVnVlTURDQ2FyZCBmcm9tICcuL2NhcmQnXG5pbXBvcnQgVnVlTURDQ2hlY2tib3ggZnJvbSAnLi9jaGVja2JveCdcbmltcG9ydCBWdWVNRENDaGlwU2V0IGZyb20gJy4vY2hpcHMnXG5pbXBvcnQgVnVlTURDRGlhbG9nIGZyb20gJy4vZGlhbG9nJ1xuaW1wb3J0IFZ1ZU1EQ0RyYXdlciBmcm9tICcuL2RyYXdlcidcbmltcG9ydCBWdWVNRENFbGV2YXRpb24gZnJvbSAnLi9lbGV2YXRpb24nXG5pbXBvcnQgVnVlTURDRmFiIGZyb20gJy4vZmFiJ1xuaW1wb3J0IFZ1ZU1EQ0dyaWRMaXN0IGZyb20gJy4vZ3JpZC1saXN0J1xuaW1wb3J0IFZ1ZU1EQ0ljb24gZnJvbSAnLi9pY29uJ1xuaW1wb3J0IFZ1ZU1EQ0ljb25CdXR0b24gZnJvbSAnLi9pY29uLWJ1dHRvbidcbmltcG9ydCBWdWVNRENJY29uVG9nZ2xlIGZyb20gJy4vaWNvbi10b2dnbGUnXG5pbXBvcnQgVnVlTURDTGF5b3V0QXBwIGZyb20gJy4vbGF5b3V0LWFwcCdcbmltcG9ydCBWdWVNRENMYXlvdXRHcmlkIGZyb20gJy4vbGF5b3V0LWdyaWQnXG5pbXBvcnQgVnVlTURDTGluZWFyUHJvZ3Jlc3MgZnJvbSAnLi9saW5lYXItcHJvZ3Jlc3MnXG5pbXBvcnQgVnVlTURDTGlzdCBmcm9tICcuL2xpc3QnXG5pbXBvcnQgVnVlTURDTWVudSBmcm9tICcuL21lbnUnXG5pbXBvcnQgVnVlTURDUmFkaW8gZnJvbSAnLi9yYWRpbydcbmltcG9ydCBWdWVNRENSaXBwbGUgZnJvbSAnLi9yaXBwbGUnXG5pbXBvcnQgVnVlTURDU2VsZWN0IGZyb20gJy4vc2VsZWN0J1xuaW1wb3J0IFZ1ZU1EQ1NsaWRlciBmcm9tICcuL3NsaWRlcidcbmltcG9ydCBWdWVNRENTbmFja2JhciBmcm9tICcuL3NuYWNrYmFyJ1xuaW1wb3J0IFZ1ZU1EQ1N3aXRjaCBmcm9tICcuL3N3aXRjaCdcbmltcG9ydCBWdWVNRENUYWJzIGZyb20gJy4vdGFicydcbmltcG9ydCBWdWVNRENUZXh0ZmllbGQgZnJvbSAnLi90ZXh0ZmllbGQnXG5pbXBvcnQgVnVlTURDVGhlbWUgZnJvbSAnLi90aGVtZSdcbmltcG9ydCBWdWVNRENUb29sYmFyIGZyb20gJy4vdG9vbGJhcidcbmltcG9ydCBWdWVNRENUb3BBcHBCYXIgZnJvbSAnLi90b3AtYXBwLWJhcidcbmltcG9ydCBWdWVNRENUeXBvZ3JhcGh5IGZyb20gJy4vdHlwb2dyYXBoeSdcblxuZXhwb3J0IGRlZmF1bHQge1xuICB2ZXJzaW9uOiAnX19WRVJTSU9OX18nLFxuICBpbnN0YWxsKHZtKSB7XG4gICAgdm0udXNlKFZ1ZU1EQ0J1dHRvbilcbiAgICB2bS51c2UoVnVlTURDQ2FyZClcbiAgICB2bS51c2UoVnVlTURDQ2hlY2tib3gpXG4gICAgdm0udXNlKFZ1ZU1EQ0NoaXBTZXQpXG4gICAgdm0udXNlKFZ1ZU1EQ0VsZXZhdGlvbilcbiAgICB2bS51c2UoVnVlTURDRGlhbG9nKVxuICAgIHZtLnVzZShWdWVNRENEcmF3ZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ0VsZXZhdGlvbilcbiAgICB2bS51c2UoVnVlTURDRmFiKVxuICAgIHZtLnVzZShWdWVNRENHcmlkTGlzdClcbiAgICB2bS51c2UoVnVlTURDSWNvbilcbiAgICB2bS51c2UoVnVlTURDSWNvbkJ1dHRvbilcbiAgICB2bS51c2UoVnVlTURDSWNvblRvZ2dsZSlcbiAgICB2bS51c2UoVnVlTURDTGF5b3V0QXBwKVxuICAgIHZtLnVzZShWdWVNRENMYXlvdXRHcmlkKVxuICAgIHZtLnVzZShWdWVNRENMaW5lYXJQcm9ncmVzcylcbiAgICB2bS51c2UoVnVlTURDTGlzdClcbiAgICB2bS51c2UoVnVlTURDTWVudSlcbiAgICB2bS51c2UoVnVlTURDUmFkaW8pXG4gICAgdm0udXNlKFZ1ZU1EQ1JpcHBsZSlcbiAgICB2bS51c2UoVnVlTURDU2VsZWN0KVxuICAgIHZtLnVzZShWdWVNRENTbGlkZXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1NuYWNrYmFyKVxuICAgIHZtLnVzZShWdWVNRENTd2l0Y2gpXG4gICAgdm0udXNlKFZ1ZU1EQ1RhYnMpXG4gICAgdm0udXNlKFZ1ZU1EQ1RleHRmaWVsZClcbiAgICB2bS51c2UoVnVlTURDVGhlbWUpXG4gICAgdm0udXNlKFZ1ZU1EQ1Rvb2xiYXIpXG4gICAgdm0udXNlKFZ1ZU1EQ1RvcEFwcEJhcilcbiAgICB2bS51c2UoVnVlTURDVHlwb2dyYXBoeSlcbiAgfVxufVxuIiwiaW1wb3J0ICcuL3N0eWxlcy5zY3NzJ1xuaW1wb3J0IHsgYXV0b0luaXQgfSBmcm9tICcuL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbInN1cHBvcnRzUGFzc2l2ZV8iLCJhcHBseVBhc3NpdmUiLCJnbG9iYWxPYmoiLCJ3aW5kb3ciLCJmb3JjZVJlZnJlc2giLCJ1bmRlZmluZWQiLCJpc1N1cHBvcnRlZCIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhc3NpdmUiLCJlIiwiYXV0b0luaXQiLCJwbHVnaW4iLCJfVnVlIiwiVnVlIiwiZ2xvYmFsIiwidXNlIiwiQmFzZVBsdWdpbiIsImNvbXBvbmVudHMiLCJ2ZXJzaW9uIiwiaW5zdGFsbCIsInZtIiwia2V5IiwiY29tcG9uZW50IiwibmFtZSIsIkN1c3RvbUVsZW1lbnQiLCJmdW5jdGlvbmFsIiwicmVuZGVyIiwiY3JlYXRlRWxlbWVudCIsImNvbnRleHQiLCJwcm9wcyIsImlzIiwidGFnIiwiZGF0YSIsImNoaWxkcmVuIiwiQ3VzdG9tRWxlbWVudE1peGluIiwiQ3VzdG9tTGluayIsInR5cGUiLCJTdHJpbmciLCJkZWZhdWx0IiwibGluayIsIk9iamVjdCIsImgiLCJlbGVtZW50IiwicGFyZW50IiwiJHJvdXRlciIsIiRyb290IiwiJG9wdGlvbnMiLCJvbiIsImNsaWNrIiwibmF0aXZlT24iLCJDdXN0b21MaW5rTWl4aW4iLCJ0byIsImV4YWN0IiwiQm9vbGVhbiIsImFwcGVuZCIsInJlcGxhY2UiLCJhY3RpdmVDbGFzcyIsImV4YWN0QWN0aXZlQ2xhc3MiLCJjb21wdXRlZCIsImVtaXRDdXN0b21FdmVudCIsImVsIiwiZXZ0VHlwZSIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJldnQiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJjcmVhdGVFdmVudCIsImluaXRDdXN0b21FdmVudCIsImRpc3BhdGNoRXZlbnQiLCJDdXN0b21CdXR0b24iLCJhdHRycyIsInJvbGUiLCJocmVmIiwiQ3VzdG9tQnV0dG9uTWl4aW4iLCJkaXNhYmxlZCIsImV4dHJhY3RJY29uUHJvcCIsImljb25Qcm9wIiwiY2xhc3NlcyIsImNvbnRlbnQiLCJBcnJheSIsInJlZHVjZSIsInJlc3VsdCIsInZhbHVlIiwiY2xhc3NOYW1lIiwic3BsaXQiLCJ0ZXh0Q29udGVudCIsIkRpc3BhdGNoRXZlbnRNaXhpbiIsImV2ZW50IiwibWV0aG9kcyIsIiRlbWl0IiwidGFyZ2V0IiwiZXZlbnRUYXJnZXQiLCJhcmdzIiwiZXZlbnRBcmdzIiwibGlzdGVuZXJzIiwiJGxpc3RlbmVycyIsIkRpc3BhdGNoRm9jdXNNaXhpbiIsImhhc0ZvY3VzIiwib25Nb3VzZURvd24iLCJfYWN0aXZlIiwib25Nb3VzZVVwIiwib25Gb2N1c0V2ZW50Iiwic2V0VGltZW91dCIsImRpc3BhdGNoRm9jdXNFdmVudCIsIm9uQmx1ckV2ZW50IiwiJGVsIiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwibW91bnRlZCIsImJlZm9yZURlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2NvcGUiLCJNYXRoIiwiZmxvb3IiLCJyYW5kb20iLCJ0b1N0cmluZyIsIlZNQVVuaXF1ZUlkTWl4aW4iLCJiZWZvcmVDcmVhdGUiLCJ2bWFfdWlkXyIsIl91aWQiLCJNRENGb3VuZGF0aW9uIiwiYWRhcHRlciIsImFkYXB0ZXJfIiwiTURDQ29tcG9uZW50Iiwicm9vdCIsImZvdW5kYXRpb24iLCJyb290XyIsImluaXRpYWxpemUiLCJmb3VuZGF0aW9uXyIsImdldERlZmF1bHRGb3VuZGF0aW9uIiwiaW5pdCIsImluaXRpYWxTeW5jV2l0aERPTSIsIkVycm9yIiwiZGVzdHJveSIsImhhbmRsZXIiLCJNRENSaXBwbGVBZGFwdGVyIiwidmFyTmFtZSIsImNzc0NsYXNzZXMiLCJST09UIiwiVU5CT1VOREVEIiwiQkdfRk9DVVNFRCIsIkZHX0FDVElWQVRJT04iLCJGR19ERUFDVElWQVRJT04iLCJzdHJpbmdzIiwiVkFSX0xFRlQiLCJWQVJfVE9QIiwiVkFSX0ZHX1NJWkUiLCJWQVJfRkdfU0NBTEUiLCJWQVJfRkdfVFJBTlNMQVRFX1NUQVJUIiwiVkFSX0ZHX1RSQU5TTEFURV9FTkQiLCJudW1iZXJzIiwiUEFERElORyIsIklOSVRJQUxfT1JJR0lOX1NDQUxFIiwiREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMiLCJGR19ERUFDVElWQVRJT05fTVMiLCJUQVBfREVMQVlfTVMiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlc18iLCJkZXRlY3RFZGdlUHNldWRvVmFyQnVnIiwid2luZG93T2JqIiwibm9kZSIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJnZXRDb21wdXRlZFN0eWxlIiwiaGFzUHNldWRvVmFyQnVnIiwiYm9yZGVyVG9wU3R5bGUiLCJyZW1vdmUiLCJzdXBwb3J0c0Nzc1ZhcmlhYmxlcyIsInN1cHBvcnRzRnVuY3Rpb25QcmVzZW50IiwiQ1NTIiwic3VwcG9ydHMiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiZ2V0TWF0Y2hlc1Byb3BlcnR5IiwiSFRNTEVsZW1lbnRQcm90b3R5cGUiLCJtYXRjaGVzTWV0aG9kcyIsIm1ldGhvZCIsImkiLCJsZW5ndGgiLCJtYXRjaGVzTWV0aG9kIiwiZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzIiwiZXYiLCJwYWdlT2Zmc2V0IiwiY2xpZW50UmVjdCIsIngiLCJ5IiwiZG9jdW1lbnRYIiwibGVmdCIsImRvY3VtZW50WSIsInRvcCIsIm5vcm1hbGl6ZWRYIiwibm9ybWFsaXplZFkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VYIiwicGFnZVkiLCJBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMiLCJhY3RpdmF0ZWRUYXJnZXRzIiwiTURDUmlwcGxlRm91bmRhdGlvbiIsImJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnMiLCJpc1VuYm91bmRlZCIsImlzU3VyZmFjZUFjdGl2ZSIsImlzU3VyZmFjZURpc2FibGVkIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJ1cGRhdGVDc3NWYXJpYWJsZSIsImNvbXB1dGVCb3VuZGluZ1JlY3QiLCJnZXRXaW5kb3dQYWdlT2Zmc2V0IiwiZGVmYXVsdEFkYXB0ZXIiLCJsYXlvdXRGcmFtZV8iLCJmcmFtZV8iLCJ3aWR0aCIsImhlaWdodCIsImFjdGl2YXRpb25TdGF0ZV8iLCJkZWZhdWx0QWN0aXZhdGlvblN0YXRlXyIsImluaXRpYWxTaXplXyIsIm1heFJhZGl1c18iLCJhY3RpdmF0ZUhhbmRsZXJfIiwiYWN0aXZhdGVfIiwiZGVhY3RpdmF0ZUhhbmRsZXJfIiwiZGVhY3RpdmF0ZV8iLCJmb2N1c0hhbmRsZXJfIiwiaGFuZGxlRm9jdXMiLCJibHVySGFuZGxlcl8iLCJoYW5kbGVCbHVyIiwicmVzaXplSGFuZGxlcl8iLCJsYXlvdXQiLCJ1bmJvdW5kZWRDb29yZHNfIiwiZmdTY2FsZV8iLCJhY3RpdmF0aW9uVGltZXJfIiwiZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfIiwiYWN0aXZhdGlvbkFuaW1hdGlvbkhhc0VuZGVkXyIsImFjdGl2YXRpb25UaW1lckNhbGxiYWNrXyIsInJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XyIsInByZXZpb3VzQWN0aXZhdGlvbkV2ZW50XyIsImlzQWN0aXZhdGVkIiwiaGFzRGVhY3RpdmF0aW9uVVhSdW4iLCJ3YXNBY3RpdmF0ZWRCeVBvaW50ZXIiLCJ3YXNFbGVtZW50TWFkZUFjdGl2ZSIsImFjdGl2YXRpb25FdmVudCIsImlzUHJvZ3JhbW1hdGljIiwic3VwcG9ydHNQcmVzc1JpcHBsZSIsInN1cHBvcnRzUHJlc3NSaXBwbGVfIiwicmVnaXN0ZXJSb290SGFuZGxlcnNfIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwibGF5b3V0SW50ZXJuYWxfIiwiY2xlYXJUaW1lb3V0IiwicmVtb3ZlQ3NzVmFyc18iLCJkZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJmb3JFYWNoIiwia2V5cyIsImsiLCJpbmRleE9mIiwiYWN0aXZhdGlvblN0YXRlIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnQiLCJpc1NhbWVJbnRlcmFjdGlvbiIsImhhc0FjdGl2YXRlZENoaWxkIiwic29tZSIsInJlc2V0QWN0aXZhdGlvblN0YXRlXyIsInB1c2giLCJyZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyIsImNoZWNrRWxlbWVudE1hZGVBY3RpdmVfIiwiYW5pbWF0ZUFjdGl2YXRpb25fIiwia2V5Q29kZSIsInRyYW5zbGF0ZVN0YXJ0IiwidHJhbnNsYXRlRW5kIiwiZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXyIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsInJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXyIsImFjdGl2YXRpb25IYXNFbmRlZCIsInN0YXRlIiwiYW5pbWF0ZURlYWN0aXZhdGlvbl8iLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsIm1heERpbSIsIm1heCIsImdldEJvdW5kZWRSYWRpdXMiLCJoeXBvdGVudXNlIiwic3FydCIsInBvdyIsInVwZGF0ZUxheW91dENzc1ZhcnNfIiwicm91bmQiLCJ1bmJvdW5kZWQiLCJNRENSaXBwbGUiLCJ1bmJvdW5kZWRfIiwic2V0VW5ib3VuZGVkIiwiYWN0aXZhdGUiLCJkZWFjdGl2YXRlIiwiY3JlYXRlQWRhcHRlciIsImRhdGFzZXQiLCJzZXRVbmJvdW5kZWRfIiwicmlwcGxlIiwiaW5zdGFuY2UiLCJNQVRDSEVTIiwidXRpbCIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwiY2xhc3NMaXN0IiwiYWRkIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJzZXRQcm9wZXJ0eSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJSaXBwbGVDYXBhYmxlU3VyZmFjZSIsIlJpcHBsZUJhc2UiLCJyZWYiLCJfbWF0Y2hlcyIsIm9wdGlvbnMiLCIkc2V0IiwiJGRlbGV0ZSIsInN0eWxlcyIsIlJpcHBsZU1peGluIiwibm9ybWFsaXplQ29tcG9uZW50IiwiY29tcGlsZWRUZW1wbGF0ZSIsImluamVjdFN0eWxlIiwiZGVmYXVsdEV4cG9ydCIsInNjb3BlSWQiLCJpc0Z1bmN0aW9uYWxUZW1wbGF0ZSIsIm1vZHVsZUlkZW50aWZpZXIiLCJpc1NoYWRvd01vZGUiLCJjcmVhdGVJbmplY3RvciIsImNyZWF0ZUluamVjdG9yU1NSIiwiY3JlYXRlSW5qZWN0b3JTaGFkb3ciLCJzdGF0aWNSZW5kZXJGbnMiLCJfY29tcGlsZWQiLCJfc2NvcGVJZCIsImhvb2siLCIkdm5vZGUiLCJzc3JDb250ZXh0IiwiX19WVUVfU1NSX0NPTlRFWFRfXyIsImNhbGwiLCJfcmVnaXN0ZXJlZENvbXBvbmVudHMiLCJfc3NyUmVnaXN0ZXIiLCJzaGFkb3dSb290Iiwib3JpZ2luYWxSZW5kZXIiLCJyZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24iLCJleGlzdGluZyIsImNvbmNhdCIsIm1kY1JpcHBsZSIsInNjcmlwdCIsIm1kY0J1dHRvbiIsIm1kY0NhcmQiLCJtZGNDYXJkUHJpbWFyeUFjdGlvbiIsIm1kY0NhcmRNZWRpYSIsIm1kY0NhcmRIZWFkZXIiLCJtZGNDYXJkVGl0bGUiLCJtZGNDYXJkU3VidGl0bGUiLCJtZGNDYXJkVGV4dCIsIm1kY0NhcmRBY3Rpb25zIiwibWRjQ2FyZEFjdGlvbkJ1dHRvbnMiLCJtZGNDYXJkQWN0aW9uQnV0dG9uIiwibWRjQ2FyZEFjdGlvbkljb25zIiwibWRjQ2FyZEFjdGlvbkljb24iLCJNRENTZWxlY3Rpb25Db250cm9sIiwiTURDQ2hlY2tib3hBZGFwdGVyIiwiYXR0ciIsIlVQR1JBREVEIiwiQ0hFQ0tFRCIsIklOREVURVJNSU5BVEUiLCJESVNBQkxFRCIsIkFOSU1fVU5DSEVDS0VEX0NIRUNLRUQiLCJBTklNX1VOQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiQU5JTV9DSEVDS0VEX1VOQ0hFQ0tFRCIsIkFOSU1fQ0hFQ0tFRF9JTkRFVEVSTUlOQVRFIiwiQU5JTV9JTkRFVEVSTUlOQVRFX0NIRUNLRUQiLCJBTklNX0lOREVURVJNSU5BVEVfVU5DSEVDS0VEIiwiTkFUSVZFX0NPTlRST0xfU0VMRUNUT1IiLCJUUkFOU0lUSU9OX1NUQVRFX0lOSVQiLCJUUkFOU0lUSU9OX1NUQVRFX0NIRUNLRUQiLCJUUkFOU0lUSU9OX1NUQVRFX1VOQ0hFQ0tFRCIsIlRSQU5TSVRJT05fU1RBVEVfSU5ERVRFUk1JTkFURSIsIkFSSUFfQ0hFQ0tFRF9BVFRSIiwiQVJJQV9DSEVDS0VEX0lOREVURVJNSU5BVEVfVkFMVUUiLCJBTklNX0VORF9MQVRDSF9NUyIsIk1EQ0NoZWNrYm94Rm91bmRhdGlvbiIsInNldE5hdGl2ZUNvbnRyb2xBdHRyIiwicmVtb3ZlTmF0aXZlQ29udHJvbEF0dHIiLCJmb3JjZUxheW91dCIsImlzQXR0YWNoZWRUb0RPTSIsImlzSW5kZXRlcm1pbmF0ZSIsImlzQ2hlY2tlZCIsImhhc05hdGl2ZUNvbnRyb2wiLCJzZXROYXRpdmVDb250cm9sRGlzYWJsZWQiLCJjdXJyZW50Q2hlY2tTdGF0ZV8iLCJjdXJyZW50QW5pbWF0aW9uQ2xhc3NfIiwiYW5pbUVuZExhdGNoVGltZXJfIiwiZW5hYmxlQW5pbWF0aW9uRW5kSGFuZGxlcl8iLCJkZXRlcm1pbmVDaGVja1N0YXRlXyIsInVwZGF0ZUFyaWFDaGVja2VkXyIsInRyYW5zaXRpb25DaGVja1N0YXRlXyIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJnZXRUcmFuc2l0aW9uQW5pbWF0aW9uQ2xhc3NfIiwiTURDRm9ybUZpZWxkQWRhcHRlciIsIkxBQkVMX1NFTEVDVE9SIiwiTURDRm9ybUZpZWxkRm91bmRhdGlvbiIsImFjdGl2YXRlSW5wdXRSaXBwbGUiLCJkZWFjdGl2YXRlSW5wdXRSaXBwbGUiLCJjbGlja0hhbmRsZXJfIiwiaGFuZGxlQ2xpY2tfIiwiZXZlbnRUeXBlTWFwIiwibm9QcmVmaXgiLCJ3ZWJraXRQcmVmaXgiLCJzdHlsZVByb3BlcnR5IiwiY3NzUHJvcGVydHlNYXAiLCJoYXNQcm9wZXJTaGFwZSIsImV2ZW50Rm91bmRJbk1hcHMiLCJldmVudFR5cGUiLCJnZXRKYXZhU2NyaXB0RXZlbnROYW1lIiwibWFwIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImV2ZW50TmFtZSIsInRyYW5zZm9ybVN0eWxlUHJvcGVydGllcyIsImdldENvcnJlY3RFdmVudE5hbWUiLCJnZXRDb3JyZWN0UHJvcGVydHlOYW1lIiwibWRjQ2hlY2tib3giLCJNRENDaGlwQWRhcHRlciIsInNlbGVjdGVkIiwicHJvcGVydHlOYW1lIiwiRU5UUllfQU5JTUFUSU9OX05BTUUiLCJJTlRFUkFDVElPTl9FVkVOVCIsIlNFTEVDVElPTl9FVkVOVCIsIlRSQUlMSU5HX0lDT05fSU5URVJBQ1RJT05fRVZFTlQiLCJSRU1PVkFMX0VWRU5UIiwiQ0hFQ0tNQVJLX1NFTEVDVE9SIiwiTEVBRElOR19JQ09OX1NFTEVDVE9SIiwiVFJBSUxJTkdfSUNPTl9TRUxFQ1RPUiIsIkNIRUNLTUFSSyIsIkNISVBfRVhJVCIsIkhJRERFTl9MRUFESU5HX0lDT04iLCJMRUFESU5HX0lDT04iLCJUUkFJTElOR19JQ09OIiwiU0VMRUNURUQiLCJNRENDaGlwRm91bmRhdGlvbiIsImhhc0NsYXNzIiwiYWRkQ2xhc3NUb0xlYWRpbmdJY29uIiwicmVtb3ZlQ2xhc3NGcm9tTGVhZGluZ0ljb24iLCJldmVudFRhcmdldEhhc0NsYXNzIiwibm90aWZ5SW50ZXJhY3Rpb24iLCJub3RpZnlTZWxlY3Rpb24iLCJub3RpZnlUcmFpbGluZ0ljb25JbnRlcmFjdGlvbiIsIm5vdGlmeVJlbW92YWwiLCJnZXRDb21wdXRlZFN0eWxlVmFsdWUiLCJzZXRTdHlsZVByb3BlcnR5Iiwic2hvdWxkUmVtb3ZlT25UcmFpbGluZ0ljb25DbGlja18iLCJzaG91bGRSZW1vdmUiLCJjaGlwV2lkdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJiZWdpbkV4aXQiLCJNRENDaGlwU2V0QWRhcHRlciIsImNoaXBJZCIsIkNISVBfU0VMRUNUT1IiLCJDSE9JQ0UiLCJGSUxURVIiLCJNRENDaGlwU2V0Rm91bmRhdGlvbiIsInJlbW92ZUNoaXAiLCJzZXRTZWxlY3RlZCIsInNlbGVjdGVkQ2hpcElkc18iLCJkZXNlbGVjdF8iLCJzZWxlY3QiLCJwcmV2aW91c2x5U2VsZWN0ZWRDaGlwIiwiaW5kZXgiLCJzcGxpY2UiLCJ0b2dnbGVTZWxlY3RfIiwiY2hpcElzU2VsZWN0ZWQiLCJtZGNDaGlwIiwibWRjQ2hpcFNldCIsIk1EQ0RpYWxvZ0FkYXB0ZXIiLCJzZWxlY3RvciIsImFjdGlvbiIsIk9QRU4iLCJPUEVOSU5HIiwiQ0xPU0lORyIsIlNDUk9MTEFCTEUiLCJTVEFDS0VEIiwiU0NST0xMX0xPQ0siLCJTQ1JJTV9TRUxFQ1RPUiIsIkNPTlRBSU5FUl9TRUxFQ1RPUiIsIlNVUkZBQ0VfU0VMRUNUT1IiLCJDT05URU5UX1NFTEVDVE9SIiwiQlVUVE9OX1NFTEVDVE9SIiwiREVGQVVMVF9CVVRUT05fU0VMRUNUT1IiLCJTVVBQUkVTU19ERUZBVUxUX1BSRVNTX1NFTEVDVE9SIiwiam9pbiIsIk9QRU5JTkdfRVZFTlQiLCJPUEVORURfRVZFTlQiLCJDTE9TSU5HX0VWRU5UIiwiQ0xPU0VEX0VWRU5UIiwiQUNUSU9OX0FUVFJJQlVURSIsIkNMT1NFX0FDVElPTiIsIkRFU1RST1lfQUNUSU9OIiwiRElBTE9HX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJESUFMT0dfQU5JTUFUSU9OX0NMT1NFX1RJTUVfTVMiLCJNRENEaWFsb2dGb3VuZGF0aW9uIiwiYWRkQm9keUNsYXNzIiwicmVtb3ZlQm9keUNsYXNzIiwiZXZlbnRUYXJnZXRNYXRjaGVzIiwidHJhcEZvY3VzIiwicmVsZWFzZUZvY3VzIiwiaXNDb250ZW50U2Nyb2xsYWJsZSIsImFyZUJ1dHRvbnNTdGFja2VkIiwiZ2V0QWN0aW9uRnJvbUV2ZW50IiwiY2xpY2tEZWZhdWx0QnV0dG9uIiwicmV2ZXJzZUJ1dHRvbnMiLCJub3RpZnlPcGVuaW5nIiwibm90aWZ5T3BlbmVkIiwibm90aWZ5Q2xvc2luZyIsIm5vdGlmeUNsb3NlZCIsImlzT3Blbl8iLCJhbmltYXRpb25GcmFtZV8iLCJhbmltYXRpb25UaW1lcl8iLCJlc2NhcGVLZXlBY3Rpb25fIiwic2NyaW1DbGlja0FjdGlvbl8iLCJhdXRvU3RhY2tCdXR0b25zXyIsImFyZUJ1dHRvbnNTdGFja2VkXyIsInNldEF1dG9TdGFja0J1dHRvbnMiLCJjbG9zZSIsImhhbmRsZUFuaW1hdGlvblRpbWVyRW5kXyIsInJ1bk5leHRBbmltYXRpb25GcmFtZV8iLCJhdXRvU3RhY2siLCJkZXRlY3RTdGFja2VkQnV0dG9uc18iLCJkZXRlY3RTY3JvbGxhYmxlQ29udGVudF8iLCJpc0NsaWNrIiwiaXNFbnRlciIsImNhbGxiYWNrIiwiY2FuZGlkYXRlU2VsZWN0b3JzIiwiY2FuZGlkYXRlU2VsZWN0b3IiLCJtYXRjaGVzIiwiRWxlbWVudCIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwidGFiYmFibGUiLCJlbGVtZW50RG9jdW1lbnQiLCJvd25lckRvY3VtZW50IiwicmVndWxhclRhYmJhYmxlcyIsIm9yZGVyZWRUYWJiYWJsZXMiLCJ1bnRvdWNoYWJpbGl0eUNoZWNrZXIiLCJVbnRvdWNoYWJpbGl0eUNoZWNrZXIiLCJjYW5kaWRhdGVzIiwicXVlcnlTZWxlY3RvckFsbCIsImluY2x1ZGVDb250YWluZXIiLCJzbGljZSIsImFwcGx5IiwidW5zaGlmdCIsImNhbmRpZGF0ZSIsImNhbmRpZGF0ZVRhYmluZGV4IiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlIiwiZ2V0VGFiaW5kZXgiLCJkb2N1bWVudE9yZGVyIiwidGFiSW5kZXgiLCJ0YWJiYWJsZU5vZGVzIiwic29ydCIsInNvcnRPcmRlcmVkVGFiYmFibGVzIiwiYSIsImlzVGFiYmFibGUiLCJpc0ZvY3VzYWJsZSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUiLCJpc05vblRhYmJhYmxlUmFkaW8iLCJpc0hpZGRlbklucHV0IiwiaXNVbnRvdWNoYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwidGFiaW5kZXhBdHRyIiwicGFyc2VJbnQiLCJnZXRBdHRyaWJ1dGUiLCJpc05hTiIsImlzQ29udGVudEVkaXRhYmxlIiwiYiIsImZpbmQiLCJsaXN0IiwicHJlZGljYXRlIiwiY29udGVudEVkaXRhYmxlIiwiaXNJbnB1dCIsInRhZ05hbWUiLCJpc1JhZGlvIiwiaXNUYWJiYWJsZVJhZGlvIiwiZ2V0Q2hlY2tlZFJhZGlvIiwibm9kZXMiLCJjaGVja2VkIiwicmFkaW9TZXQiLCJkb2MiLCJjYWNoZSIsImhhc0Rpc3BsYXlOb25lIiwibm9kZUNvbXB1dGVkU3R5bGUiLCJub2RlVHlwZSIsIk5vZGUiLCJFTEVNRU5UX05PREUiLCJjYWNoZWQiLCJpdGVtIiwiZGVmYXVsdFZpZXciLCJkaXNwbGF5IiwicGFyZW50Tm9kZSIsInZpc2liaWxpdHkiLCJtb2R1bGUiLCJleHRlbmQiLCJoYXNPd25Qcm9wZXJ0eSIsImFyZ3VtZW50cyIsInNvdXJjZSIsImFjdGl2ZUZvY3VzVHJhcHMiLCJ0cmFwUXVldWUiLCJhY3RpdmF0ZVRyYXAiLCJ0cmFwIiwiYWN0aXZlVHJhcCIsInBhdXNlIiwidHJhcEluZGV4IiwiZGVhY3RpdmF0ZVRyYXAiLCJ1bnBhdXNlIiwiZm9jdXNUcmFwIiwidXNlck9wdGlvbnMiLCJjb250YWluZXIiLCJxdWVyeVNlbGVjdG9yIiwiY29uZmlnIiwieHRlbmQiLCJyZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZSIsImVzY2FwZURlYWN0aXZhdGVzIiwiZmlyc3RUYWJiYWJsZU5vZGUiLCJsYXN0VGFiYmFibGVOb2RlIiwibm9kZUZvY3VzZWRCZWZvcmVBY3RpdmF0aW9uIiwibW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUiLCJhY3RpdmUiLCJwYXVzZWQiLCJhY3RpdmF0ZU9wdGlvbnMiLCJ1cGRhdGVUYWJiYWJsZU5vZGVzIiwib25BY3RpdmF0ZSIsImFkZExpc3RlbmVycyIsImRlYWN0aXZhdGVPcHRpb25zIiwicmVtb3ZlTGlzdGVuZXJzIiwib25EZWFjdGl2YXRlIiwicmV0dXJuRm9jdXMiLCJkZWxheSIsInRyeUZvY3VzIiwiZ2V0SW5pdGlhbEZvY3VzTm9kZSIsImNoZWNrRm9jdXNJbiIsImNoZWNrUG9pbnRlckRvd24iLCJjaGVja0NsaWNrIiwiY2hlY2tLZXkiLCJnZXROb2RlRm9yT3B0aW9uIiwib3B0aW9uTmFtZSIsIm9wdGlvblZhbHVlIiwiY2xpY2tPdXRzaWRlRGVhY3RpdmF0ZXMiLCJwcmV2ZW50RGVmYXVsdCIsIkRvY3VtZW50Iiwic3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uIiwiaXNFc2NhcGVFdmVudCIsImlzVGFiRXZlbnQiLCJjaGVja1RhYiIsInNoaWZ0S2V5IiwiZm9jdXMiLCJpc1NlbGVjdGFibGVJbnB1dCIsInRvTG93ZXJDYXNlIiwiZm4iLCJjcmVhdGVGb2N1c1RyYXBJbnN0YW5jZSIsInN1cmZhY2VFbCIsImZvY3VzVHJhcEZhY3RvcnkiLCJjcmVhdGVGb2N1c1RyYXAiLCJpbml0aWFsRm9jdXNFbCIsImluaXRpYWxGb2N1cyIsImlzU2Nyb2xsYWJsZSIsInNjcm9sbEhlaWdodCIsIm9mZnNldEhlaWdodCIsImFyZVRvcHNNaXNhbGlnbmVkIiwiZWxzIiwidG9wcyIsIlNldCIsIm9mZnNldFRvcCIsInNpemUiLCJjbG9zZXN0IiwicGFyZW50RWxlbWVudCIsIm5hdGl2ZU1hdGNoZXMiLCJtZGNEaWFsb2ciLCJNRENEcmF3ZXJBZGFwdGVyIiwiRElTTUlTU0lCTEUiLCJNT0RBTCIsIkFOSU1BVEUiLCJBUFBfQ09OVEVOVF9TRUxFQ1RPUiIsIkNMT1NFX0VWRU5UIiwiT1BFTl9FVkVOVCIsIk1EQ0Rpc21pc3NpYmxlRHJhd2VyRm91bmRhdGlvbiIsImVsZW1lbnRIYXNDbGFzcyIsIm5vdGlmeUNsb3NlIiwibm90aWZ5T3BlbiIsInNhdmVGb2N1cyIsInJlc3RvcmVGb2N1cyIsImZvY3VzQWN0aXZlTmF2aWdhdGlvbkl0ZW0iLCJpc09wZW4iLCJpc09wZW5pbmciLCJpc0Nsb3NpbmciLCJpc0VzY2FwZSIsImlzRWxlbWVudCIsImNsb3NlZCIsIm9wZW5lZCIsIk1EQ01vZGFsRHJhd2VyRm91bmRhdGlvbiIsIk1EQ0xpc3RBZGFwdGVyIiwiYXR0cmlidXRlIiwibGlzdEl0ZW1JbmRleCIsInRhYkluZGV4VmFsdWUiLCJlbGUiLCJMSVNUX0lURU1fQ0xBU1MiLCJMSVNUX0lURU1fU0VMRUNURURfQ0xBU1MiLCJMSVNUX0lURU1fQUNUSVZBVEVEX0NMQVNTIiwiQVJJQV9PUklFTlRBVElPTiIsIkFSSUFfT1JJRU5UQVRJT05fSE9SSVpPTlRBTCIsIkFSSUFfU0VMRUNURUQiLCJBUklBX0NIRUNLRUQiLCJBUklBX0NIRUNLRURfUkFESU9fU0VMRUNUT1IiLCJBUklBX1JPTEVfQ0hFQ0tCT1hfU0VMRUNUT1IiLCJBUklBX0NIRUNLRURfQ0hFQ0tCT1hfU0VMRUNUT1IiLCJSQURJT19TRUxFQ1RPUiIsIkNIRUNLQk9YX1NFTEVDVE9SIiwiQ0hFQ0tCT1hfUkFESU9fU0VMRUNUT1IiLCJDSElMRF9FTEVNRU5UU19UT19UT0dHTEVfVEFCSU5ERVgiLCJGT0NVU0FCTEVfQ0hJTERfRUxFTUVOVFMiLCJFTkFCTEVEX0lURU1TX1NFTEVDVE9SIiwiRUxFTUVOVFNfS0VZX0FMTE9XRURfSU4iLCJNRENMaXN0Rm91bmRhdGlvbiIsImdldExpc3RJdGVtQ291bnQiLCJnZXRGb2N1c2VkRWxlbWVudEluZGV4Iiwic2V0QXR0cmlidXRlRm9yRWxlbWVudEluZGV4IiwicmVtb3ZlQXR0cmlidXRlRm9yRWxlbWVudEluZGV4IiwiYWRkQ2xhc3NGb3JFbGVtZW50SW5kZXgiLCJyZW1vdmVDbGFzc0ZvckVsZW1lbnRJbmRleCIsImZvY3VzSXRlbUF0SW5kZXgiLCJzZXRUYWJJbmRleEZvckxpc3RJdGVtQ2hpbGRyZW4iLCJmb2xsb3dIcmVmIiwiaGFzUmFkaW9BdEluZGV4IiwiaGFzQ2hlY2tib3hBdEluZGV4IiwiaXNDaGVja2JveENoZWNrZWRBdEluZGV4Iiwic2V0Q2hlY2tlZENoZWNrYm94T3JSYWRpb0F0SW5kZXgiLCJpc0ZvY3VzSW5zaWRlTGlzdCIsIndyYXBGb2N1c18iLCJpc1ZlcnRpY2FsXyIsImlzU2luZ2xlU2VsZWN0aW9uTGlzdF8iLCJzZWxlY3RlZEluZGV4XyIsImZvY3VzZWRJdGVtSW5kZXhfIiwidXNlQWN0aXZhdGVkQ2xhc3NfIiwiaXNDaGVja2JveExpc3RfIiwiaXNSYWRpb0xpc3RfIiwidXNlQWN0aXZhdGVkIiwiaXNJbmRleFZhbGlkXyIsInNldENoZWNrYm94QXRJbmRleF8iLCJzZXRSYWRpb0F0SW5kZXhfIiwic2V0U2luZ2xlU2VsZWN0aW9uQXRJbmRleF8iLCJzZXRUYWJpbmRleFRvRmlyc3RTZWxlY3RlZEl0ZW1fIiwiaXNSb290TGlzdEl0ZW0iLCJhcnJvd0xlZnQiLCJhcnJvd1VwIiwiYXJyb3dSaWdodCIsImFycm93RG93biIsImlzSG9tZSIsImlzRW5kIiwiaXNTcGFjZSIsImN1cnJlbnRJbmRleCIsIm5leHRJbmRleCIsInByZXZlbnREZWZhdWx0RXZlbnRfIiwiZm9jdXNOZXh0RWxlbWVudCIsImZvY3VzUHJldkVsZW1lbnQiLCJmb2N1c0ZpcnN0RWxlbWVudCIsImZvY3VzTGFzdEVsZW1lbnQiLCJpc1NlbGVjdGFibGVMaXN0XyIsInNldFNlbGVjdGVkSW5kZXhPbkFjdGlvbl8iLCJzZXRUYWJpbmRleEF0SW5kZXhfIiwidG9nZ2xlQ2hlY2tib3giLCJjb3VudCIsInByZXZJbmRleCIsImxhc3RJbmRleCIsInNlbGVjdGVkQ2xhc3NOYW1lIiwidGFyZ2V0SW5kZXgiLCJtaW5JbmRleCIsIm1pbiIsImlzSW5kZXhJblJhbmdlXyIsImxpc3RTaXplIiwidG9nZ2xlQ2hlY2tib3hBdEluZGV4XyIsInNldFNlbGVjdGVkSW5kZXgiLCJmaWx0ZXIiLCJNRENMaXN0IiwiaGFuZGxlS2V5ZG93bl8iLCJmb2N1c0luRXZlbnRMaXN0ZW5lcl8iLCJmb2N1c091dEV2ZW50TGlzdGVuZXJfIiwiaGFuZGxlQ2xpY2tFdmVudF8iLCJiaW5kIiwiaGFuZGxlS2V5ZG93bkV2ZW50XyIsImhhbmRsZUZvY3VzSW5FdmVudF8iLCJoYW5kbGVGb2N1c091dEV2ZW50XyIsImluaXRpYWxpemVMaXN0VHlwZSIsImRpcmVjdGlvbiIsInZlcnRpY2FsIiwic2V0QXR0cmlidXRlIiwibGlzdEVsZW1lbnRzIiwiZ2V0TGlzdEl0ZW1JbmRleF8iLCJoYW5kbGVGb2N1c0luIiwiaGFuZGxlRm9jdXNPdXQiLCJoYW5kbGVLZXlkb3duIiwiaGFuZGxlQ2xpY2siLCJjaGVja2JveExpc3RJdGVtcyIsInNpbmdsZVNlbGVjdGVkTGlzdEl0ZW0iLCJyYWRpb1NlbGVjdGVkTGlzdEl0ZW0iLCJwcmVzZWxlY3RlZEl0ZW1zIiwic2VsZWN0ZWRJbmRleCIsImxpc3RJdGVtIiwic2V0VXNlQWN0aXZhdGVkQ2xhc3MiLCJzaW5nbGVTZWxlY3Rpb24iLCJyZW1vdmVBdHRyaWJ1dGUiLCJsaXN0SXRlbUNoaWxkcmVuIiwidG9nZ2xlRWwiLCJpbml0RXZlbnQiLCJzZXRWZXJ0aWNhbE9yaWVudGF0aW9uIiwic2V0V3JhcEZvY3VzIiwiaXNTaW5nbGVTZWxlY3Rpb25MaXN0Iiwic2V0U2luZ2xlU2VsZWN0aW9uIiwiZ2V0U2VsZWN0ZWRJbmRleCIsIm1kY0RyYXdlciIsIm1kY0RyYXdlckhlYWRlciIsIm1kY0RyYXdlckxpc3QiLCJtZGNEcmF3ZXJJdGVtIiwibWRjRHJhd2VyRGl2aWRlciIsIm1kY0VsZXZhdGlvbiIsIm1kY0ZBQiIsIlRJTEVTX1NFTEVDVE9SIiwiVElMRV9TRUxFQ1RPUiIsIk1EQ0dyaWRMaXN0Rm91bmRhdGlvbiIsImdldE9mZnNldFdpZHRoIiwiZ2V0TnVtYmVyT2ZUaWxlcyIsImdldE9mZnNldFdpZHRoRm9yVGlsZUF0SW5kZXgiLCJzZXRTdHlsZUZvclRpbGVzRWxlbWVudCIsImFsaWduQ2VudGVyIiwicmVzaXplRnJhbWVfIiwiYWxpZ25DZW50ZXJfIiwiZ3JpZFdpZHRoIiwiaXRlbVdpZHRoIiwidGlsZXNXaWR0aCIsIm1kY0dyaWRMaXN0IiwibWRjR3JpZFRpbGUiLCJtZGNJY29uIiwiTURDSWNvbkJ1dHRvblRvZ2dsZUFkYXB0ZXIiLCJhdHRyTmFtZSIsImF0dHJWYWx1ZSIsIklDT05fQlVUVE9OX09OIiwiQVJJQV9QUkVTU0VEIiwiQ0hBTkdFX0VWRU5UIiwiTURDSWNvbkJ1dHRvblRvZ2dsZUZvdW5kYXRpb24iLCJzZXRBdHRyIiwibm90aWZ5Q2hhbmdlIiwiZGlzYWJsZWRfIiwiaXNPbiIsInRvZ2dsZSIsIm1kY0ljb25CdXR0b24iLCJNRENJY29uVG9nZ2xlQWRhcHRlciIsInRleHQiLCJEQVRBX1RPR0dMRV9PTiIsIkRBVEFfVE9HR0xFX09GRiIsIkFSSUFfRElTQUJMRUQiLCJBUklBX0xBQkVMIiwiTURDSWNvblRvZ2dsZUZvdW5kYXRpb24iLCJzZXRUZXh0IiwiZ2V0VGFiSW5kZXgiLCJzZXRUYWJJbmRleCIsImdldEF0dHIiLCJybUF0dHIiLCJvbl8iLCJzYXZlZFRhYkluZGV4XyIsInRvZ2dsZU9uRGF0YV8iLCJ0b2dnbGVPZmZEYXRhXyIsInRvZ2dsZUZyb21FdnRfIiwiaXNIYW5kbGluZ0tleWRvd25fIiwia2V5ZG93bkhhbmRsZXJfIiwia2V5dXBIYW5kbGVyXyIsInJlZnJlc2hUb2dnbGVEYXRhIiwicGFyc2VKc29uRGF0YUF0dHJfIiwiY2xhc3NUb1JlbW92ZSIsImNzc0NsYXNzIiwibGFiZWwiLCJkYXRhQXR0ciIsInZhbCIsIkpTT04iLCJwYXJzZSIsImlzRGlzYWJsZWQiLCJrZXlib2FyZEtleSIsIkljb25Ub2dnbGVTdGF0ZSIsIm1kY0lDb25Ub2dnbGUiLCJtZGNMYXlvdXRBcHAiLCJtZGNMYXlvdXRHcmlkIiwibWRjTGF5b3V0Q2VsbCIsIm1kY0xheW91dElubmVyR3JpZCIsIkNMT1NFRF9DTEFTUyIsIklOREVURVJNSU5BVEVfQ0xBU1MiLCJSRVZFUlNFRF9DTEFTUyIsIlBSSU1BUllfQkFSX1NFTEVDVE9SIiwiQlVGRkVSX1NFTEVDVE9SIiwiTURDTGluZWFyUHJvZ3Jlc3NGb3VuZGF0aW9uIiwiZ2V0UHJpbWFyeUJhciIsImdldEJ1ZmZlciIsInNldFN0eWxlIiwiZGV0ZXJtaW5hdGVfIiwicmV2ZXJzZV8iLCJwcm9ncmVzc18iLCJpc0RldGVybWluYXRlIiwic2V0U2NhbGVfIiwiaXNSZXZlcnNlZCIsInNjYWxlVmFsdWUiLCJ0cmFuc2Zvcm1TdHlsZVByb3BlcnR5IiwibWRjTGluZWFyUHJvZ3Jlc3MiLCJtZGNMaXN0IiwibWRjTGlzdEl0ZW0iLCJtZGNMaXN0RGl2aWRlciIsIm1kY0xpc3RHcm91cCIsIm1kY0xpc3RHcm91cEhlYWRlciIsIm1kY0xpc3RHcm91cERpdmlkZXIiLCJNRENNZW51QWRhcHRlciIsInNlbGVjdGlvbkdyb3VwIiwiTUVOVV9TRUxFQ1RFRF9MSVNUX0lURU0iLCJNRU5VX1NFTEVDVElPTl9HUk9VUCIsIlNFTEVDVEVEX0VWRU5UIiwiQVJJQV9TRUxFQ1RFRF9BVFRSIiwiTElTVF9TRUxFQ1RPUiIsIk1EQ01lbnVTdXJmYWNlQWRhcHRlciIsIm9yaWdpbiIsInBvc2l0aW9uIiwiQU5DSE9SIiwiQU5JTUFUSU5HX0NMT1NFRCIsIkFOSU1BVElOR19PUEVOIiwiRklYRUQiLCJGT0NVU0FCTEVfRUxFTUVOVFMiLCJUUkFOU0lUSU9OX09QRU5fRFVSQVRJT04iLCJUUkFOU0lUSU9OX0NMT1NFX0RVUkFUSU9OIiwiTUFSR0lOX1RPX0VER0UiLCJBTkNIT1JfVE9fTUVOVV9TVVJGQUNFX1dJRFRIX1JBVElPIiwiQ29ybmVyQml0IiwiQk9UVE9NIiwiQ0VOVEVSIiwiUklHSFQiLCJGTElQX1JUTCIsIkNvcm5lciIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJUT1BfU1RBUlQiLCJUT1BfRU5EIiwiQk9UVE9NX1NUQVJUIiwiQk9UVE9NX0VORCIsIk1EQ01lbnVTdXJmYWNlRm91bmRhdGlvbiIsImhhc0FuY2hvciIsImlzRWxlbWVudEluQ29udGFpbmVyIiwiaXNSdGwiLCJzZXRUcmFuc2Zvcm1PcmlnaW4iLCJpc0ZvY3VzZWQiLCJpc0ZpcnN0RWxlbWVudEZvY3VzZWQiLCJpc0xhc3RFbGVtZW50Rm9jdXNlZCIsImdldElubmVyRGltZW5zaW9ucyIsImdldEFuY2hvckRpbWVuc2lvbnMiLCJnZXRXaW5kb3dEaW1lbnNpb25zIiwiZ2V0Qm9keURpbWVuc2lvbnMiLCJnZXRXaW5kb3dTY3JvbGwiLCJzZXRQb3NpdGlvbiIsInNldE1heEhlaWdodCIsIm9wZW5BbmltYXRpb25FbmRUaW1lcklkXyIsImNsb3NlQW5pbWF0aW9uRW5kVGltZXJJZF8iLCJhbmltYXRpb25SZXF1ZXN0SWRfIiwiZGltZW5zaW9uc18iLCJhbmNob3JDb3JuZXJfIiwiYW5jaG9yTWFyZ2luXyIsInJpZ2h0IiwiYm90dG9tIiwibWVhc3VyZXNfIiwicXVpY2tPcGVuXyIsImhvaXN0ZWRFbGVtZW50XyIsImlzRml4ZWRQb3NpdGlvbl8iLCJwb3NpdGlvbl8iLCJjb3JuZXIiLCJtYXJnaW4iLCJpc0hvaXN0ZWQiLCJpc0ZpeGVkUG9zaXRpb24iLCJ0eXBlQ2hlY2tpc0Zpbml0ZV8iLCJxdWlja09wZW4iLCJpc1RhYiIsImFuY2hvclJlY3QiLCJ2aWV3cG9ydCIsImJvZHlEaW1lbnNpb25zIiwid2luZG93U2Nyb2xsIiwidmlld3BvcnREaXN0YW5jZSIsImFuY2hvckhlaWdodCIsImFuY2hvcldpZHRoIiwic3VyZmFjZUhlaWdodCIsInN1cmZhY2VXaWR0aCIsImlzQm90dG9tQWxpZ25lZCIsImF2YWlsYWJsZVRvcCIsImF2YWlsYWJsZUJvdHRvbSIsInRvcE92ZXJmbG93IiwiYm90dG9tT3ZlcmZsb3ciLCJpc0ZsaXBSdGwiLCJhdm9pZEhvcml6b250YWxPdmVybGFwIiwiaXNBbGlnbmVkUmlnaHQiLCJhdmFpbGFibGVMZWZ0IiwiYXZhaWxhYmxlUmlnaHQiLCJsZWZ0T3ZlcmZsb3ciLCJyaWdodE92ZXJmbG93IiwiaXNSaWdodEFsaWduZWQiLCJyaWdodE9mZnNldCIsImF2b2lkVmVydGljYWxPdmVybGFwIiwibWF4SGVpZ2h0IiwiZ2V0QXV0b0xheW91dE1lYXN1cmVtZW50c18iLCJnZXRPcmlnaW5Db3JuZXJfIiwibWF4TWVudVN1cmZhY2VIZWlnaHQiLCJnZXRNZW51U3VyZmFjZU1heEhlaWdodF8iLCJ2ZXJ0aWNhbEFsaWdubWVudCIsImhvcml6b250YWxBbGlnbm1lbnQiLCJob3Jpem9udGFsT2Zmc2V0IiwiZ2V0SG9yaXpvbnRhbE9yaWdpbk9mZnNldF8iLCJ2ZXJ0aWNhbE9mZnNldCIsImdldFZlcnRpY2FsT3JpZ2luT2Zmc2V0XyIsImFkanVzdFBvc2l0aW9uRm9ySG9pc3RlZEVsZW1lbnRfIiwicHJvcCIsImF1dG9Qb3NpdGlvbl8iLCJtYXliZVJlc3RvcmVGb2N1c18iLCJudW0iLCJpc0Zpbml0ZSIsIk1EQ01lbnVGb3VuZGF0aW9uIiwiYWRkQ2xhc3NUb0VsZW1lbnRBdEluZGV4IiwicmVtb3ZlQ2xhc3NGcm9tRWxlbWVudEF0SW5kZXgiLCJhZGRBdHRyaWJ1dGVUb0VsZW1lbnRBdEluZGV4IiwicmVtb3ZlQXR0cmlidXRlRnJvbUVsZW1lbnRBdEluZGV4IiwiZWxlbWVudENvbnRhaW5zQ2xhc3MiLCJjbG9zZVN1cmZhY2UiLCJnZXRFbGVtZW50SW5kZXgiLCJnZXRQYXJlbnRFbGVtZW50IiwiZ2V0U2VsZWN0ZWRFbGVtZW50SW5kZXgiLCJub3RpZnlTZWxlY3RlZCIsImhhbmRsZUFjdGlvbl8iLCJnZXRMaXN0SXRlbV8iLCJoYW5kbGVTZWxlY3Rpb24iLCJnZXRTZWxlY3Rpb25Hcm91cF8iLCJoYW5kbGVTZWxlY3Rpb25Hcm91cF8iLCJpc0dyb3VwIiwiaXNMaXN0SXRlbSIsInN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV8iLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJ0cmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJtZGNNZW51IiwibWRjTWVudVN1cmZhY2UiLCJtZGNNZW51SXRlbSIsIm1kY01lbnVEaXZpZGVyIiwibWRjTWVudUFuY2hvciIsIk1EQ1JhZGlvQWRhcHRlciIsIk1EQ1JhZGlvRm91bmRhdGlvbiIsIm1kY1JhZGlvIiwiTURDU2VsZWN0SWNvbkFkYXB0ZXIiLCJJQ09OX0VWRU5UIiwiSUNPTl9ST0xFIiwiTURDU2VsZWN0SWNvbkZvdW5kYXRpb24iLCJyZW1vdmVBdHRyIiwic2V0Q29udGVudCIsIm5vdGlmeUljb25BY3Rpb24iLCJpbnRlcmFjdGlvbkhhbmRsZXJfIiwiaGFuZGxlSW50ZXJhY3Rpb24iLCJNRENTZWxlY3RJY29uIiwiZW1pdCIsIk1EQ1NlbGVjdEhlbHBlclRleHRBZGFwdGVyIiwiQVJJQV9ISURERU4iLCJST0xFIiwiSEVMUEVSX1RFWFRfUEVSU0lTVEVOVCIsIkhFTFBFUl9URVhUX1ZBTElEQVRJT05fTVNHIiwiTURDU2VsZWN0SGVscGVyVGV4dEZvdW5kYXRpb24iLCJpc1BlcnNpc3RlbnQiLCJpc1ZhbGlkYXRpb24iLCJzZWxlY3RJc1ZhbGlkIiwiaGVscGVyVGV4dElzUGVyc2lzdGVudCIsImhlbHBlclRleHRJc1ZhbGlkYXRpb25Nc2ciLCJ2YWxpZGF0aW9uTXNnTmVlZHNEaXNwbGF5IiwiaGlkZV8iLCJNRENTZWxlY3RIZWxwZXJUZXh0IiwiTURDU2VsZWN0QWRhcHRlciIsInNob3VsZEZsb2F0IiwibGFiZWxXaWR0aCIsImlzVmFsaWQiLCJPVVRMSU5FRCIsIkZPQ1VTRUQiLCJTRUxFQ1RFRF9JVEVNX0NMQVNTIiwiV0lUSF9MRUFESU5HX0lDT04iLCJJTlZBTElEIiwiUkVRVUlSRUQiLCJBUklBX0NPTlRST0xTIiwiU0VMRUNURURfSVRFTV9TRUxFQ1RPUiIsIlNFTEVDVEVEX1RFWFRfU0VMRUNUT1IiLCJISURERU5fSU5QVVRfU0VMRUNUT1IiLCJNRU5VX1NFTEVDVE9SIiwiTElORV9SSVBQTEVfU0VMRUNUT1IiLCJPVVRMSU5FX1NFTEVDVE9SIiwiRU5IQU5DRURfVkFMVUVfQVRUUiIsIkxBQkVMX1NDQUxFIiwiTURDU2VsZWN0Rm91bmRhdGlvbiIsImFjdGl2YXRlQm90dG9tTGluZSIsImRlYWN0aXZhdGVCb3R0b21MaW5lIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImZsb2F0TGFiZWwiLCJnZXRMYWJlbFdpZHRoIiwiaGFzT3V0bGluZSIsIm5vdGNoT3V0bGluZSIsImNsb3NlT3V0bGluZSIsIm9wZW5NZW51IiwiY2xvc2VNZW51IiwiaXNNZW51T3BlbiIsInNldERpc2FibGVkIiwic2V0UmlwcGxlQ2VudGVyIiwiY2hlY2tWYWxpZGl0eSIsInNldFZhbGlkIiwiZm91bmRhdGlvbk1hcCIsImxlYWRpbmdJY29uXyIsImxlYWRpbmdJY29uIiwiaGVscGVyVGV4dF8iLCJoZWxwZXJUZXh0IiwiZGlkQ2hhbmdlIiwiaGFuZGxlQ2hhbmdlIiwib3Blbk5vdGNoIiwib3B0aW9uSGFzVmFsdWUiLCJpc1JlcXVpcmVkIiwic2V0VmFsaWRpdHkiLCJzaG93VG9TY3JlZW5SZWFkZXIiLCJsYWJlbFNjYWxlIiwic2V0QXJpYUxhYmVsIiwiTURDRmxvYXRpbmdMYWJlbEFkYXB0ZXIiLCJMQUJFTF9GTE9BVF9BQk9WRSIsIkxBQkVMX1NIQUtFIiwiTURDRmxvYXRpbmdMYWJlbEZvdW5kYXRpb24iLCJnZXRXaWR0aCIsInNoYWtlQW5pbWF0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVTaGFrZUFuaW1hdGlvbkVuZF8iLCJzaG91bGRTaGFrZSIsIk1EQ0xpbmVSaXBwbGVBZGFwdGVyIiwiTElORV9SSVBQTEVfQUNUSVZFIiwiTElORV9SSVBQTEVfREVBQ1RJVkFUSU5HIiwiTURDTGluZVJpcHBsZUZvdW5kYXRpb24iLCJyZWdpc3RlckV2ZW50SGFuZGxlciIsImRlcmVnaXN0ZXJFdmVudEhhbmRsZXIiLCJ0cmFuc2l0aW9uRW5kSGFuZGxlcl8iLCJoYW5kbGVUcmFuc2l0aW9uRW5kIiwieENvb3JkaW5hdGUiLCJpc0RlYWN0aXZhdGluZyIsIk1EQ05vdGNoZWRPdXRsaW5lQWRhcHRlciIsIk5PVENIX0VMRU1FTlRfU0VMRUNUT1IiLCJOT1RDSF9FTEVNRU5UX1BBRERJTkciLCJPVVRMSU5FX05PVENIRUQiLCJPVVRMSU5FX1VQR1JBREVEIiwiTk9fTEFCRUwiLCJNRENOb3RjaGVkT3V0bGluZUZvdW5kYXRpb24iLCJzZXROb3RjaFdpZHRoUHJvcGVydHkiLCJyZW1vdmVOb3RjaFdpZHRoUHJvcGVydHkiLCJub3RjaFdpZHRoIiwibWRjU2VsZWN0IiwiQUNUSVZFIiwiRElTQ1JFVEUiLCJGT0NVUyIsIklOX1RSQU5TSVQiLCJJU19ESVNDUkVURSIsIkhBU19UUkFDS19NQVJLRVIiLCJUUkFDS19TRUxFQ1RPUiIsIlRSQUNLX01BUktFUl9DT05UQUlORVJfU0VMRUNUT1IiLCJMQVNUX1RSQUNLX01BUktFUl9TRUxFQ1RPUiIsIlRIVU1CX0NPTlRBSU5FUl9TRUxFQ1RPUiIsIlBJTl9WQUxVRV9NQVJLRVJfU0VMRUNUT1IiLCJBUklBX1ZBTFVFTUlOIiwiQVJJQV9WQUxVRU1BWCIsIkFSSUFfVkFMVUVOT1ciLCJTVEVQX0RBVEFfQVRUUiIsIklOUFVUX0VWRU5UIiwiUEFHRV9GQUNUT1IiLCJNRENTbGlkZXJBZGFwdGVyIiwibnVtTWFya2VycyIsIktFWV9JRFMiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIk1PVkVfRVZFTlRfTUFQIiwiRE9XTl9FVkVOVFMiLCJVUF9FVkVOVFMiLCJNRENTbGlkZXJGb3VuZGF0aW9uIiwicmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwibm90aWZ5SW5wdXQiLCJzZXRUaHVtYkNvbnRhaW5lclN0eWxlUHJvcGVydHkiLCJzZXRUcmFja1N0eWxlUHJvcGVydHkiLCJzZXRNYXJrZXJWYWx1ZSIsImFwcGVuZFRyYWNrTWFya2VycyIsInJlbW92ZVRyYWNrTWFya2VycyIsInNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5IiwiaXNSVEwiLCJyZWN0XyIsIk5hTiIsImFjdGl2ZV8iLCJpblRyYW5zaXRfIiwiaXNEaXNjcmV0ZV8iLCJoYXNUcmFja01hcmtlcl8iLCJoYW5kbGluZ1RodW1iVGFyZ2V0RXZ0XyIsIm1pbl8iLCJtYXhfIiwic3RlcF8iLCJ2YWx1ZV8iLCJwcmV2ZW50Rm9jdXNTdGF0ZV8iLCJ1cGRhdGVVSUZyYW1lXyIsInRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfIiwiaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfIiwiaGFuZGxlRG93bl8iLCJoYW5kbGVGb2N1c18iLCJoYW5kbGVCbHVyXyIsImV2dE5hbWUiLCJnZXRTdGVwIiwiZ2V0TWluIiwiZ2V0TWF4Iiwic3RlcCIsImluZGl2aXNpYmxlIiwiY2VpbCIsImxhc3RTdGVwUmF0aW8iLCJmbGV4IiwidXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfIiwic2V0VmFsdWVfIiwic2V0dXBUcmFja01hcmtlciIsInRvZ2dsZUNsYXNzXyIsInNldEluVHJhbnNpdF8iLCJzZXRBY3RpdmVfIiwibW92ZUhhbmRsZXIiLCJoYW5kbGVNb3ZlXyIsInVwSGFuZGxlciIsImhhbmRsZVVwXyIsInNldFZhbHVlRnJvbUV2dF8iLCJ0YXJnZXRUb3VjaGVzIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImtleUlkIiwiZ2V0S2V5SWRfIiwiZ2V0VmFsdWVGb3JLZXlJZF8iLCJrYmRFdnQiLCJkZWx0YSIsInZhbHVlTmVlZHNUb0JlRmxpcHBlZCIsInNob3VsZEZpcmVJbnB1dCIsImZvcmNlIiwidmFsdWVTZXRUb0JvdW5kYXJ5IiwicXVhbnRpemVfIiwibnVtU3RlcHMiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsImluVHJhbnNpdCIsInNob3VsZEJlUHJlc2VudCIsIm1kY1NsaWRlciIsIk1EQ1NuYWNrYmFyQWRhcHRlciIsInJlYXNvbiIsIkFDVElPTl9TRUxFQ1RPUiIsIkRJU01JU1NfU0VMRUNUT1IiLCJSRUFTT05fQUNUSU9OIiwiUkVBU09OX0RJU01JU1MiLCJBUklBX0xJVkVfTEFCRUxfVEVYVF9BVFRSIiwiTUlOX0FVVE9fRElTTUlTU19USU1FT1VUX01TIiwiTUFYX0FVVE9fRElTTUlTU19USU1FT1VUX01TIiwiREVGQVVMVF9BVVRPX0RJU01JU1NfVElNRU9VVF9NUyIsIlNOQUNLQkFSX0FOSU1BVElPTl9PUEVOX1RJTUVfTVMiLCJTTkFDS0JBUl9BTklNQVRJT05fQ0xPU0VfVElNRV9NUyIsIkFSSUFfTElWRV9ERUxBWV9NUyIsIk1EQ1NuYWNrYmFyRm91bmRhdGlvbiIsImFubm91bmNlIiwiYXV0b0Rpc21pc3NUaW1lcl8iLCJhdXRvRGlzbWlzc1RpbWVvdXRNc18iLCJjbG9zZU9uRXNjYXBlXyIsImNsZWFyQXV0b0Rpc21pc3NUaW1lcl8iLCJnZXRUaW1lb3V0TXMiLCJ0aW1lb3V0TXMiLCJtaW5WYWx1ZSIsIm1heFZhbHVlIiwiY2xvc2VPbkVzY2FwZSIsImdldENsb3NlT25Fc2NhcGUiLCJtZGNTbmFja2JhciIsIk1EQ1N3aXRjaEFkYXB0ZXIiLCJSSVBQTEVfU1VSRkFDRV9TRUxFQ1RPUiIsIk1EQ1N3aXRjaEZvdW5kYXRpb24iLCJzZXROYXRpdmVDb250cm9sQ2hlY2tlZCIsInVwZGF0ZUNoZWNrZWRTdHlsaW5nXyIsIm1kY1N3aXRjaCIsIk1EQ1RhYkFkYXB0ZXIiLCJwcmV2aW91c0luZGljYXRvckNsaWVudFJlY3QiLCJSSVBQTEVfU0VMRUNUT1IiLCJUQUJfSU5ESUNBVE9SX1NFTEVDVE9SIiwiVEFCSU5ERVgiLCJJTlRFUkFDVEVEX0VWRU5UIiwiTURDVGFiRm91bmRhdGlvbiIsImFjdGl2YXRlSW5kaWNhdG9yIiwiZGVhY3RpdmF0ZUluZGljYXRvciIsIm5vdGlmeUludGVyYWN0ZWQiLCJnZXRPZmZzZXRMZWZ0IiwiZ2V0Q29udGVudE9mZnNldExlZnQiLCJnZXRDb250ZW50T2Zmc2V0V2lkdGgiLCJmb2N1c09uQWN0aXZhdGVfIiwiZm9jdXNPbkFjdGl2YXRlIiwiaXNBY3RpdmUiLCJyb290V2lkdGgiLCJyb290TGVmdCIsImNvbnRlbnRXaWR0aCIsImNvbnRlbnRMZWZ0Iiwicm9vdFJpZ2h0IiwiY29udGVudFJpZ2h0IiwiVEFCX0FDVElWQVRFRF9FVkVOVCIsIlRBQl9TQ1JPTExFUl9TRUxFQ1RPUiIsIlRBQl9TRUxFQ1RPUiIsIkFSUk9XX0xFRlRfS0VZIiwiQVJST1dfUklHSFRfS0VZIiwiRU5EX0tFWSIsIkhPTUVfS0VZIiwiRU5URVJfS0VZIiwiU1BBQ0VfS0VZIiwiRVhUUkFfU0NST0xMX0FNT1VOVCIsIkFSUk9XX0xFRlRfS0VZQ09ERSIsIkFSUk9XX1JJR0hUX0tFWUNPREUiLCJFTkRfS0VZQ09ERSIsIkhPTUVfS0VZQ09ERSIsIkVOVEVSX0tFWUNPREUiLCJTUEFDRV9LRVlDT0RFIiwiTURDVGFiQmFyQWRhcHRlciIsInNjcm9sbFgiLCJzY3JvbGxYSW5jcmVtZW50IiwiaWQiLCJBQ0NFUFRBQkxFX0tFWVMiLCJLRVlDT0RFX01BUCIsIk1hcCIsInNldCIsIk1EQ1RhYkJhckZvdW5kYXRpb24iLCJzY3JvbGxUbyIsImluY3JlbWVudFNjcm9sbCIsImdldFNjcm9sbFBvc2l0aW9uIiwiZ2V0U2Nyb2xsQ29udGVudFdpZHRoIiwic2V0QWN0aXZlVGFiIiwiYWN0aXZhdGVUYWJBdEluZGV4IiwiZGVhY3RpdmF0ZVRhYkF0SW5kZXgiLCJmb2N1c1RhYkF0SW5kZXgiLCJnZXRUYWJJbmRpY2F0b3JDbGllbnRSZWN0QXRJbmRleCIsImdldFRhYkRpbWVuc2lvbnNBdEluZGV4IiwiZ2V0UHJldmlvdXNBY3RpdmVUYWJJbmRleCIsImdldEZvY3VzZWRUYWJJbmRleCIsImdldEluZGV4T2ZUYWJCeUlkIiwiZ2V0VGFiTGlzdExlbmd0aCIsIm5vdGlmeVRhYkFjdGl2YXRlZCIsInVzZUF1dG9tYXRpY0FjdGl2YXRpb25fIiwidXNlQXV0b21hdGljQWN0aXZhdGlvbiIsInByZXZpb3VzQWN0aXZlSW5kZXgiLCJpbmRleElzSW5SYW5nZV8iLCJzY3JvbGxJbnRvVmlldyIsImdldEtleUZyb21FdmVudF8iLCJpc0FjdGl2YXRpb25LZXlfIiwiZGV0ZXJtaW5lVGFyZ2V0RnJvbUtleV8iLCJmb2N1c2VkVGFiSW5kZXgiLCJ0YWJJZCIsImlzUlRMXyIsInNjcm9sbEludG9WaWV3UlRMXyIsInNjcm9sbEludG9WaWV3XyIsIm1heEluZGV4Iiwic2hvdWxkR29Ub0VuZCIsInNob3VsZERlY3JlbWVudCIsInNob3VsZEluY3JlbWVudCIsInNjcm9sbFBvc2l0aW9uIiwiYmFyV2lkdGgiLCJuZXh0VGFiRGltZW5zaW9ucyIsInJlbGF0aXZlQ29udGVudExlZnQiLCJyZWxhdGl2ZUNvbnRlbnRSaWdodCIsImxlZnRJbmNyZW1lbnQiLCJyaWdodEluY3JlbWVudCIsInNjcm9sbENvbnRlbnRXaWR0aCIsInRhYkRpbWVuc2lvbnMiLCJyZWxhdGl2ZVJvb3RMZWZ0IiwicmVsYXRpdmVSb290UmlnaHQiLCJyZWxhdGl2ZVJvb3REZWx0YSIsImxlZnRFZGdlSXNDbG9zZXIiLCJyaWdodEVkZ2VJc0Nsb3NlciIsInJvb3REZWx0YSIsImhhcyIsImdldCIsImZpbmRBZGphY2VudFRhYkluZGV4Q2xvc2VzdFRvRWRnZV8iLCJzY3JvbGxJbmNyZW1lbnQiLCJjYWxjdWxhdGVTY3JvbGxJbmNyZW1lbnRfIiwic2Nyb2xsV2lkdGgiLCJmaW5kQWRqYWNlbnRUYWJJbmRleENsb3Nlc3RUb0VkZ2VSVExfIiwiY2FsY3VsYXRlU2Nyb2xsSW5jcmVtZW50UlRMXyIsIkFOSU1BVElORyIsIlNDUk9MTF9URVNUIiwiU0NST0xMX0FSRUFfU0NST0xMIiwiQVJFQV9TRUxFQ1RPUiIsIk1EQ1RhYlNjcm9sbGVyQWRhcHRlciIsImV2dFRhcmdldCIsInByb3BOYW1lIiwic2Nyb2xsTGVmdCIsIk1EQ1RhYlNjcm9sbGVyUlRMIiwidHJhbnNsYXRlWCIsIk1EQ1RhYlNjcm9sbGVyUlRMRGVmYXVsdCIsImN1cnJlbnRTY3JvbGxMZWZ0IiwiZ2V0U2Nyb2xsQXJlYVNjcm9sbExlZnQiLCJjYWxjdWxhdGVTY3JvbGxFZGdlc18iLCJlZGdlcyIsImNsYW1wZWRTY3JvbGxMZWZ0IiwiY2xhbXBTY3JvbGxWYWx1ZV8iLCJmaW5hbFNjcm9sbFBvc2l0aW9uIiwic2Nyb2xsRGVsdGEiLCJnZXRTY3JvbGxDb250ZW50T2Zmc2V0V2lkdGgiLCJnZXRTY3JvbGxBcmVhT2Zmc2V0V2lkdGgiLCJNRENUYWJTY3JvbGxlclJUTE5lZ2F0aXZlIiwiTURDVGFiU2Nyb2xsZXJSVExSZXZlcnNlIiwiTURDVGFiU2Nyb2xsZXJGb3VuZGF0aW9uIiwiZXZlbnRUYXJnZXRNYXRjaGVzU2VsZWN0b3IiLCJhZGRTY3JvbGxBcmVhQ2xhc3MiLCJzZXRTY3JvbGxBcmVhU3R5bGVQcm9wZXJ0eSIsInNldFNjcm9sbENvbnRlbnRTdHlsZVByb3BlcnR5IiwiZ2V0U2Nyb2xsQ29udGVudFN0eWxlVmFsdWUiLCJzZXRTY3JvbGxBcmVhU2Nyb2xsTGVmdCIsImNvbXB1dGVTY3JvbGxBcmVhQ2xpZW50UmVjdCIsImNvbXB1dGVTY3JvbGxDb250ZW50Q2xpZW50UmVjdCIsImNvbXB1dGVIb3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0IiwiaXNBbmltYXRpbmdfIiwicnRsU2Nyb2xsZXJJbnN0YW5jZV8iLCJob3Jpem9udGFsU2Nyb2xsYmFySGVpZ2h0IiwiY29tcHV0ZUN1cnJlbnRTY3JvbGxQb3NpdGlvblJUTF8iLCJjdXJyZW50VHJhbnNsYXRlWCIsImNhbGN1bGF0ZUN1cnJlbnRUcmFuc2xhdGVYXyIsInN0b3BTY3JvbGxBbmltYXRpb25fIiwiaW5jcmVtZW50U2Nyb2xsUlRMXyIsImluY3JlbWVudFNjcm9sbF8iLCJzY3JvbGxUb1JUTF8iLCJzY3JvbGxUb18iLCJydGxTY3JvbGxlckZhY3RvcnlfIiwidHJhbnNmb3JtVmFsdWUiLCJyZXN1bHRzIiwiZXhlYyIsInBhcnRzIiwicGFyc2VGbG9hdCIsImdldFJUTFNjcm9sbGVyIiwiZ2V0U2Nyb2xsUG9zaXRpb25SVEwiLCJjdXJyZW50U2Nyb2xsWCIsInNhZmVTY3JvbGxYIiwiYW5pbWF0ZV8iLCJhbmltYXRpb24iLCJzY3JvbGxUb1JUTCIsInRhcmdldFNjcm9sbFgiLCJpbmNyZW1lbnRTY3JvbGxSVEwiLCJjdXJyZW50U2Nyb2xsUG9zaXRpb24iLCJnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbl8iLCJnZXRBbmltYXRpbmdTY3JvbGxQb3NpdGlvbiIsImluaXRpYWxTY3JvbGxMZWZ0IiwibmV3U2Nyb2xsTGVmdCIsInJvb3RDbGllbnRSZWN0IiwiY29udGVudENsaWVudFJlY3QiLCJyaWdodEVkZ2VEZWx0YSIsImhvcml6b250YWxTY3JvbGxiYXJIZWlnaHRfIiwiZG9jdW1lbnRPYmoiLCJzaG91bGRDYWNoZVJlc3VsdCIsImNsaWVudEhlaWdodCIsInJlbW92ZUNoaWxkIiwicCIsInBvcCIsIk1EQ1RhYkluZGljYXRvckFkYXB0ZXIiLCJGQURFIiwiTk9fVFJBTlNJVElPTiIsIk1EQ1RhYkluZGljYXRvckZvdW5kYXRpb24iLCJjb21wdXRlQ29udGVudENsaWVudFJlY3QiLCJzZXRDb250ZW50U3R5bGVQcm9wZXJ0eSIsIk1EQ1NsaWRpbmdUYWJJbmRpY2F0b3JGb3VuZGF0aW9uIiwiY3VycmVudENsaWVudFJlY3QiLCJ3aWR0aERlbHRhIiwieFBvc2l0aW9uIiwibWRjVGFiIiwibWRjVGFiQmFyIiwibWRjVGFiU2Nyb2xsZXIiLCJtZGNUYWJJbmRpY2F0b3IiLCJtZGNUYWJSaXBwbGUiLCJNRENUZXh0RmllbGRIZWxwZXJUZXh0QWRhcHRlciIsIk1EQ1RleHRGaWVsZEhlbHBlclRleHRGb3VuZGF0aW9uIiwiaW5wdXRJc1ZhbGlkIiwiTURDVGV4dEZpZWxkSWNvbkFkYXB0ZXIiLCJNRENUZXh0RmllbGRJY29uRm91bmRhdGlvbiIsIk1EQ1RleHRGaWVsZEFkYXB0ZXIiLCJvYnNlcnZlciIsIklOUFVUX1NFTEVDVE9SIiwiSUNPTl9TRUxFQ1RPUiIsIkRFTlNFIiwiVEVYVEFSRUEiLCJERU5TRV9MQUJFTF9TQ0FMRSIsIlZBTElEQVRJT05fQVRUUl9XSElURUxJU1QiLCJBTFdBWVNfRkxPQVRfVFlQRVMiLCJNRENUZXh0RmllbGRGb3VuZGF0aW9uIiwiaXNGb2N1c2VkXyIsImdldE5hdGl2ZUlucHV0XyIsInNob3VsZEFsd2F5c0Zsb2F0XyIsImlzQmFkSW5wdXRfIiwicmVnaXN0ZXJUZXh0RmllbGRJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyVGV4dEZpZWxkSW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnB1dEludGVyYWN0aW9uSGFuZGxlciIsInJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJkZXJlZ2lzdGVyVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZUhhbmRsZXIiLCJnZXROYXRpdmVJbnB1dCIsImFjdGl2YXRlTGluZVJpcHBsZSIsImRlYWN0aXZhdGVMaW5lUmlwcGxlIiwic2V0TGluZVJpcHBsZVRyYW5zZm9ybU9yaWdpbiIsInNoYWtlTGFiZWwiLCJoYXNMYWJlbCIsInRyYWlsaW5nSWNvbl8iLCJ0cmFpbGluZ0ljb24iLCJyZWNlaXZlZFVzZXJJbnB1dF8iLCJ1c2VDdXN0b21WYWxpZGl0eUNoZWNraW5nXyIsImlzVmFsaWRfIiwidXNlTmF0aXZlVmFsaWRhdGlvbl8iLCJpbnB1dEZvY3VzSGFuZGxlcl8iLCJhY3RpdmF0ZUZvY3VzIiwiaW5wdXRCbHVySGFuZGxlcl8iLCJkZWFjdGl2YXRlRm9jdXMiLCJpbnB1dElucHV0SGFuZGxlcl8iLCJhdXRvQ29tcGxldGVGb2N1cyIsInNldFBvaW50ZXJYT2Zmc2V0XyIsInRleHRGaWVsZEludGVyYWN0aW9uSGFuZGxlcl8iLCJoYW5kbGVUZXh0RmllbGRJbnRlcmFjdGlvbiIsInZhbGlkYXRpb25BdHRyaWJ1dGVDaGFuZ2VIYW5kbGVyXyIsImF0dHJpYnV0ZXNMaXN0IiwiaGFuZGxlVmFsaWRhdGlvbkF0dHJpYnV0ZUNoYW5nZSIsInZhbGlkYXRpb25PYnNlcnZlcl8iLCJhdHRyaWJ1dGVOYW1lIiwic3R5bGVWYWxpZGl0eV8iLCJpc0RlbnNlIiwic3R5bGVGb2N1c2VkXyIsInRhcmdldEV2ZW50IiwidG91Y2hlcyIsInRhcmdldENsaWVudFJlY3QiLCJjbGllbnRYIiwiaXNOYXRpdmVJbnB1dFZhbGlkXyIsInVzZU5hdGl2ZVZhbGlkYXRpb24iLCJzdHlsZURpc2FibGVkXyIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJ2YWxpZCIsIm1kY1RleHRGaWVsZCIsIm1kY1RoZW1lIiwiRklYRURfTEFTVFJPVyIsIkZJWEVEX0FUX0xBU1RfUk9XIiwiVE9PTEJBUl9ST1dfRkxFWElCTEUiLCJGTEVYSUJMRV9ERUZBVUxUX0JFSEFWSU9SIiwiRkxFWElCTEVfTUFYIiwiRkxFWElCTEVfTUlOIiwiVElUTEVfU0VMRUNUT1IiLCJGSVJTVF9ST1dfU0VMRUNUT1IiLCJNQVhfVElUTEVfU0laRSIsIk1JTl9USVRMRV9TSVpFIiwiVE9PTEJBUl9ST1dfSEVJR0hUIiwiVE9PTEJBUl9ST1dfTU9CSUxFX0hFSUdIVCIsIlRPT0xCQVJfTU9CSUxFX0JSRUFLUE9JTlQiLCJNRENUb29sYmFyRm91bmRhdGlvbiIsInJlZ2lzdGVyU2Nyb2xsSGFuZGxlciIsImRlcmVnaXN0ZXJTY3JvbGxIYW5kbGVyIiwiZ2V0Vmlld3BvcnRXaWR0aCIsImdldFZpZXdwb3J0U2Nyb2xsWSIsImdldE9mZnNldEhlaWdodCIsImdldEZpcnN0Um93RWxlbWVudE9mZnNldEhlaWdodCIsInNldFN0eWxlRm9yVGl0bGVFbGVtZW50Iiwic2V0U3R5bGVGb3JGbGV4aWJsZVJvd0VsZW1lbnQiLCJzZXRTdHlsZUZvckZpeGVkQWRqdXN0RWxlbWVudCIsImNoZWNrUm93SGVpZ2h0XyIsInNjcm9sbEhhbmRsZXJfIiwidXBkYXRlVG9vbGJhclN0eWxlc18iLCJjaGVja1Jvd0hlaWdodEZyYW1lXyIsInNjcm9sbEZyYW1lXyIsImV4ZWN1dGVkTGFzdENoYW5nZV8iLCJjYWxjdWxhdGlvbnNfIiwidG9vbGJhclJvd0hlaWdodCIsInRvb2xiYXJSYXRpbyIsImZsZXhpYmxlRXhwYW5zaW9uUmF0aW8iLCJtYXhUcmFuc2xhdGVZUmF0aW8iLCJzY3JvbGxUaHJlc2hvbGRSYXRpbyIsInRvb2xiYXJIZWlnaHQiLCJmbGV4aWJsZUV4cGFuc2lvbkhlaWdodCIsIm1heFRyYW5zbGF0ZVlEaXN0YW5jZSIsInNjcm9sbFRocmVzaG9sZCIsImZpeGVkXyIsImZpeGVkTGFzdHJvd18iLCJoYXNGbGV4aWJsZVJvd18iLCJ1c2VGbGV4RGVmYXVsdEJlaGF2aW9yXyIsImluaXRLZXlSYXRpb18iLCJzZXRLZXlIZWlnaHRzXyIsInNjcm9sbFRvcCIsIm5ld1Rvb2xiYXJSb3dIZWlnaHQiLCJnZXRSb3dIZWlnaHRfIiwidXBkYXRlQWRqdXN0RWxlbWVudFN0eWxlcyIsImhhc1Njcm9sbGVkT3V0T2ZUaHJlc2hvbGQiLCJzY3JvbGxlZE91dE9mVGhyZXNob2xkXyIsImdldEZsZXhpYmxlRXhwYW5zaW9uUmF0aW9fIiwidXBkYXRlVG9vbGJhckZsZXhpYmxlU3RhdGVfIiwidXBkYXRlVG9vbGJhckZpeGVkU3RhdGVfIiwidXBkYXRlRmxleGlibGVSb3dFbGVtZW50U3R5bGVzXyIsImZpcnN0Um93TWF4UmF0aW8iLCJicmVha3BvaW50IiwidHJhbnNsYXRlRGlzdGFuY2UiLCJ1cGRhdGVFbGVtZW50U3R5bGVzRGVmYXVsdEJlaGF2aW9yXyIsIm1heFRpdGxlU2l6ZSIsIm1pblRpdGxlU2l6ZSIsImN1cnJlbnRUaXRsZVNpemUiLCJtZGNUb29sYmFyIiwibWRjVG9vbGJhclJvdyIsIm1kY1Rvb2xiYXJTZWN0aW9uIiwibWRjVG9vbGJhck1lbnVJY29uIiwibWRjVG9vbGJhclRpdGxlIiwibWRjVG9vbGJhckljb24iLCJNRENUb3BBcHBCYXJBZGFwdGVyIiwicHJvcGVydHkiLCJGSVhFRF9DTEFTUyIsIkZJWEVEX1NDUk9MTEVEX0NMQVNTIiwiU0hPUlRfQ0xBU1MiLCJTSE9SVF9IQVNfQUNUSU9OX0lURU1fQ0xBU1MiLCJTSE9SVF9DT0xMQVBTRURfQ0xBU1MiLCJERUJPVU5DRV9USFJPVFRMRV9SRVNJWkVfVElNRV9NUyIsIk1BWF9UT1BfQVBQX0JBUl9IRUlHSFQiLCJBQ1RJT05fSVRFTV9TRUxFQ1RPUiIsIk5BVklHQVRJT05fRVZFTlQiLCJOQVZJR0FUSU9OX0lDT05fU0VMRUNUT1IiLCJST09UX1NFTEVDVE9SIiwiTURDVG9wQXBwQmFyQmFzZUZvdW5kYXRpb24iLCJnZXRUb3BBcHBCYXJIZWlnaHQiLCJyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3Rlck5hdmlnYXRpb25JY29uSW50ZXJhY3Rpb25IYW5kbGVyIiwibm90aWZ5TmF2aWdhdGlvbkljb25DbGlja2VkIiwiZ2V0VG90YWxBY3Rpb25JdGVtcyIsIm5hdkNsaWNrSGFuZGxlcl8iLCJJTklUSUFMX1ZBTFVFIiwiTURDVG9wQXBwQmFyRm91bmRhdGlvbiIsImxhc3RTY3JvbGxQb3NpdGlvbl8iLCJ0b3BBcHBCYXJIZWlnaHRfIiwid2FzRG9ja2VkXyIsImlzRG9ja2VkU2hvd2luZ18iLCJjdXJyZW50QXBwQmFyT2Zmc2V0VG9wXyIsImlzQ3VycmVudGx5QmVpbmdSZXNpemVkXyIsInJlc2l6ZVRocm90dGxlSWRfIiwicmVzaXplRGVib3VuY2VJZF8iLCJ0b3BBcHBCYXJTY3JvbGxIYW5kbGVyXyIsInRvcEFwcEJhclJlc2l6ZUhhbmRsZXJfIiwib2Zmc2NyZWVuQm91bmRhcnlUb3AiLCJoYXNBbnlQaXhlbHNPZmZzY3JlZW4iLCJoYXNBbnlQaXhlbHNPbnNjcmVlbiIsInBhcnRpYWxseVNob3dpbmciLCJjaGVja0ZvclVwZGF0ZV8iLCJvZmZzZXQiLCJhYnMiLCJkaWZmIiwibW92ZVRvcEFwcEJhcl8iLCJ0aHJvdHRsZWRSZXNpemVIYW5kbGVyXyIsImN1cnJlbnRIZWlnaHQiLCJNRENTaG9ydFRvcEFwcEJhckZvdW5kYXRpb24iLCJpc0NvbGxhcHNlZCIsInNob3J0QXBwQmFyU2Nyb2xsSGFuZGxlcl8iLCJpc0Fsd2F5c0NvbGxhcHNlZCIsImN1cnJlbnRTY3JvbGwiLCJNRENGaXhlZFRvcEFwcEJhckZvdW5kYXRpb24iLCJ3YXNTY3JvbGxlZF8iLCJmaXhlZFNjcm9sbEhhbmRsZXJfIiwibWRjVG9wQXBwQmFyIiwibWRjVG9wQXBwQmFyQWN0aW9uIiwidHlwb3MiLCJtZGNUeXBvTWl4aW4iLCJjbGFzcyIsInR5cG8iLCIkYXR0cnMiLCIkc2xvdHMiLCJtZGNUeXBvUHJvcE1peGluIiwiZGVmYXVsdFRhZyIsImRlZmF1bHRUeXBvIiwidmFsaWRUeXBvcyIsInZhbGlkYXRvciIsIm1kY1RleHRTZWN0aW9uIiwibWRjVGV4dCIsIm1peGlucyIsIm1kY0Rpc3BsYXkiLCJtZGNIZWFkbGluZSIsIm1kY1RpdGxlIiwibWRjU3ViSGVhZGluZyIsIm1kY0JvZHkiLCJtZGNDYXB0aW9uIiwiVnVlTURDQnV0dG9uIiwiVnVlTURDQ2FyZCIsIlZ1ZU1EQ0NoZWNrYm94IiwiVnVlTURDQ2hpcFNldCIsIlZ1ZU1EQ0VsZXZhdGlvbiIsIlZ1ZU1EQ0RpYWxvZyIsIlZ1ZU1EQ0RyYXdlciIsIlZ1ZU1EQ0ZhYiIsIlZ1ZU1EQ0dyaWRMaXN0IiwiVnVlTURDSWNvbiIsIlZ1ZU1EQ0ljb25CdXR0b24iLCJWdWVNRENJY29uVG9nZ2xlIiwiVnVlTURDTGF5b3V0QXBwIiwiVnVlTURDTGF5b3V0R3JpZCIsIlZ1ZU1EQ0xpbmVhclByb2dyZXNzIiwiVnVlTURDTGlzdCIsIlZ1ZU1EQ01lbnUiLCJWdWVNRENSYWRpbyIsIlZ1ZU1EQ1JpcHBsZSIsIlZ1ZU1EQ1NlbGVjdCIsIlZ1ZU1EQ1NsaWRlciIsIlZ1ZU1EQ1NuYWNrYmFyIiwiVnVlTURDU3dpdGNoIiwiVnVlTURDVGFicyIsIlZ1ZU1EQ1RleHRmaWVsZCIsIlZ1ZU1EQ1RoZW1lIiwiVnVlTURDVG9vbGJhciIsIlZ1ZU1EQ1RvcEFwcEJhciIsIlZ1ZU1EQ1R5cG9ncmFwaHkiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7RUFBQSxJQUFJQSxnQkFBSjtFQUVBOzs7Ozs7O0FBTUEsRUFBTyxTQUFTQyxZQUFULEdBQWdFO0VBQUEsTUFBMUNDLFNBQTBDLHVFQUE5QkMsTUFBOEI7RUFBQSxNQUF0QkMsWUFBc0IsdUVBQVAsS0FBTzs7RUFDckUsTUFBSUosZ0JBQWdCLEtBQUtLLFNBQXJCLElBQWtDRCxZQUF0QyxFQUFvRDtFQUNsRCxRQUFJRSxXQUFXLEdBQUcsS0FBbEI7O0VBQ0EsUUFBSTtFQUNGSixNQUFBQSxTQUFTLENBQUNLLFFBQVYsQ0FBbUJDLGdCQUFuQixDQUFvQyxNQUFwQyxFQUE0QyxJQUE1QyxFQUFrRDtFQUNoRCxZQUFJQyxPQUFKLEdBQWM7RUFDWkgsVUFBQUEsV0FBVyxHQUFHO0VBQUVHLFlBQUFBLE9BQU8sRUFBRTtFQUFYLFdBQWQ7RUFDRDs7RUFIK0MsT0FBbEQ7RUFLRCxLQU5ELENBTUUsT0FBT0MsQ0FBUCxFQUFVO0VBRVg7O0VBRURWLElBQUFBLGdCQUFnQixHQUFHTSxXQUFuQjtFQUNEOztFQUVELFNBQU9OLGdCQUFQO0VBQ0Q7O0VDekJNLFNBQVNXLFFBQVQsQ0FBa0JDLE1BQWxCLEVBQTBCO0VBQy9CO0VBQ0EsTUFBSUMsSUFBSSxHQUFHLElBQVg7O0VBQ0EsTUFBSSxPQUFPVixNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0VBQ2pDVSxJQUFBQSxJQUFJLEdBQUdWLE1BQU0sQ0FBQ1csR0FBZDtFQUNELEdBRkQsTUFFTyxJQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7RUFDeEM7RUFDQUYsSUFBQUEsSUFBSSxHQUFHRSxNQUFNLENBQUNELEdBQWQ7RUFDRDs7RUFDRCxNQUFJRCxJQUFKLEVBQVU7RUFDUkEsSUFBQUEsSUFBSSxDQUFDRyxHQUFMLENBQVNKLE1BQVQ7RUFDRDtFQUNGOztFQ1pNLFNBQVNLLFVBQVQsQ0FBb0JDLFVBQXBCLEVBQWdDO0VBQ3JDLFNBQU87RUFDTEMsSUFBQUEsT0FBTyxFQUFFLGFBREo7RUFFTEMsSUFBQUEsT0FBTyxFQUFFLGlCQUFBQyxFQUFFLEVBQUk7RUFDYixXQUFLLElBQUlDLEdBQVQsSUFBZ0JKLFVBQWhCLEVBQTRCO0VBQzFCLFlBQUlLLFNBQVMsR0FBR0wsVUFBVSxDQUFDSSxHQUFELENBQTFCO0VBQ0FELFFBQUFBLEVBQUUsQ0FBQ0UsU0FBSCxDQUFhQSxTQUFTLENBQUNDLElBQXZCLEVBQTZCRCxTQUE3QjtFQUNEO0VBQ0YsS0FQSTtFQVFMTCxJQUFBQSxVQUFVLEVBQVZBO0VBUkssR0FBUDtFQVVEOztFQ1hNLElBQU1PLGFBQWEsR0FBRztFQUMzQkMsRUFBQUEsVUFBVSxFQUFFLElBRGU7RUFFM0JDLEVBQUFBLE1BRjJCLGtCQUVwQkMsYUFGb0IsRUFFTEMsT0FGSyxFQUVJO0VBQzdCLFdBQU9ELGFBQWEsQ0FDbEJDLE9BQU8sQ0FBQ0MsS0FBUixDQUFjQyxFQUFkLElBQW9CRixPQUFPLENBQUNDLEtBQVIsQ0FBY0UsR0FBbEMsSUFBeUMsS0FEdkIsRUFFbEJILE9BQU8sQ0FBQ0ksSUFGVSxFQUdsQkosT0FBTyxDQUFDSyxRQUhVLENBQXBCO0VBS0Q7RUFSMEIsQ0FBdEI7QUFXUCxFQUFPLElBQU1DLGtCQUFrQixHQUFHO0VBQ2hDakIsRUFBQUEsVUFBVSxFQUFFO0VBQ1ZPLElBQUFBLGFBQWEsRUFBYkE7RUFEVTtFQURvQixDQUEzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQ1hBLElBQU1XLFVBQVUsR0FBRztFQUN4QlosRUFBQUEsSUFBSSxFQUFFLGFBRGtCO0VBRXhCRSxFQUFBQSxVQUFVLEVBQUUsSUFGWTtFQUd4QkksRUFBQUEsS0FBSyxFQUFFO0VBQ0xFLElBQUFBLEdBQUcsRUFBRTtFQUFFSyxNQUFBQSxJQUFJLEVBQUVDLE1BQVI7RUFBZ0JDLE1BQUFBLE9BQU8sRUFBRTtFQUF6QixLQURBO0VBRUxDLElBQUFBLElBQUksRUFBRUM7RUFGRCxHQUhpQjtFQU94QmQsRUFBQUEsTUFQd0Isa0JBT2pCZSxDQVBpQixFQU9kYixPQVBjLEVBT0w7RUFDakIsUUFBSWMsT0FBSjs7RUFDQSxRQUFJVixJQUFJLEdBQUcsU0FBYyxFQUFkLEVBQWtCSixPQUFPLENBQUNJLElBQTFCLENBQVg7O0VBRUEsUUFBSUosT0FBTyxDQUFDQyxLQUFSLENBQWNVLElBQWQsSUFBc0JYLE9BQU8sQ0FBQ2UsTUFBUixDQUFlQyxPQUF6QyxFQUFrRDtFQUNoRDtFQUNBRixNQUFBQSxPQUFPLEdBQUdkLE9BQU8sQ0FBQ2UsTUFBUixDQUFlRSxLQUFmLENBQXFCQyxRQUFyQixDQUE4QjdCLFVBQTlCLENBQXlDLGFBQXpDLENBQVY7RUFDQWUsTUFBQUEsSUFBSSxDQUFDSCxLQUFMLEdBQWEsU0FBYztFQUFFRSxRQUFBQSxHQUFHLEVBQUVILE9BQU8sQ0FBQ0MsS0FBUixDQUFjRTtFQUFyQixPQUFkLEVBQTBDSCxPQUFPLENBQUNDLEtBQVIsQ0FBY1UsSUFBeEQsQ0FBYjs7RUFDQSxVQUFJUCxJQUFJLENBQUNlLEVBQUwsQ0FBUUMsS0FBWixFQUFtQjtFQUNqQmhCLFFBQUFBLElBQUksQ0FBQ2lCLFFBQUwsR0FBZ0I7RUFBRUQsVUFBQUEsS0FBSyxFQUFFaEIsSUFBSSxDQUFDZSxFQUFMLENBQVFDO0VBQWpCLFNBQWhCO0VBQ0Q7RUFDRixLQVBELE1BT087RUFDTDtFQUNBTixNQUFBQSxPQUFPLEdBQUdkLE9BQU8sQ0FBQ0MsS0FBUixDQUFjRSxHQUF4QjtFQUNEOztFQUVELFdBQU9VLENBQUMsQ0FBQ0MsT0FBRCxFQUFVVixJQUFWLEVBQWdCSixPQUFPLENBQUNLLFFBQXhCLENBQVI7RUFDRDtFQXhCdUIsQ0FBbkI7QUEyQlAsRUFBTyxJQUFNaUIsZUFBZSxHQUFHO0VBQzdCckIsRUFBQUEsS0FBSyxFQUFFO0VBQ0xzQixJQUFBQSxFQUFFLEVBQUUsQ0FBQ2QsTUFBRCxFQUFTRyxNQUFULENBREM7RUFFTFksSUFBQUEsS0FBSyxFQUFFQyxPQUZGO0VBR0xDLElBQUFBLE1BQU0sRUFBRUQsT0FISDtFQUlMRSxJQUFBQSxPQUFPLEVBQUVGLE9BSko7RUFLTEcsSUFBQUEsV0FBVyxFQUFFbkIsTUFMUjtFQU1Mb0IsSUFBQUEsZ0JBQWdCLEVBQUVwQjtFQU5iLEdBRHNCO0VBUzdCcUIsRUFBQUEsUUFBUSxFQUFFO0VBQ1JuQixJQUFBQSxJQURRLGtCQUNEO0VBQ0wsYUFDRSxLQUFLWSxFQUFMLElBQVc7RUFDVEEsUUFBQUEsRUFBRSxFQUFFLEtBQUtBLEVBREE7RUFFVEMsUUFBQUEsS0FBSyxFQUFFLEtBQUtBLEtBRkg7RUFHVEUsUUFBQUEsTUFBTSxFQUFFLEtBQUtBLE1BSEo7RUFJVEMsUUFBQUEsT0FBTyxFQUFFLEtBQUtBLE9BSkw7RUFLVEMsUUFBQUEsV0FBVyxFQUFFLEtBQUtBLFdBTFQ7RUFNVEMsUUFBQUEsZ0JBQWdCLEVBQUUsS0FBS0E7RUFOZCxPQURiO0VBVUQ7RUFaTyxHQVRtQjtFQXVCN0J4QyxFQUFBQSxVQUFVLEVBQUU7RUFDVmtCLElBQUFBLFVBQVUsRUFBVkE7RUFEVTtFQXZCaUIsQ0FBeEI7O0VDM0JQO0FBRUEsRUFBTyxTQUFTd0IsZUFBVCxDQUF5QkMsRUFBekIsRUFBNkJDLE9BQTdCLEVBQXNDQyxPQUF0QyxFQUFxRTtFQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPO0VBQzFFLE1BQUlDLEdBQUo7O0VBQ0EsTUFBSSxPQUFPQyxXQUFQLEtBQXVCLFVBQTNCLEVBQXVDO0VBQ3JDRCxJQUFBQSxHQUFHLEdBQUcsSUFBSUMsV0FBSixDQUFnQkosT0FBaEIsRUFBeUI7RUFDN0JLLE1BQUFBLE1BQU0sRUFBRUosT0FEcUI7RUFFN0JLLE1BQUFBLE9BQU8sRUFBRUo7RUFGb0IsS0FBekIsQ0FBTjtFQUlELEdBTEQsTUFLTztFQUNMQyxJQUFBQSxHQUFHLEdBQUcxRCxRQUFRLENBQUM4RCxXQUFULENBQXFCLGFBQXJCLENBQU47RUFDQUosSUFBQUEsR0FBRyxDQUFDSyxlQUFKLENBQW9CUixPQUFwQixFQUE2QkUsWUFBN0IsRUFBMkMsS0FBM0MsRUFBa0RELE9BQWxEO0VBQ0Q7O0VBQ0RGLEVBQUFBLEVBQUUsQ0FBQ1UsYUFBSCxDQUFpQk4sR0FBakI7RUFDRDs7RUNkTSxJQUFNTyxZQUFZLEdBQUc7RUFDMUJoRCxFQUFBQSxJQUFJLEVBQUUsZUFEb0I7RUFFMUJFLEVBQUFBLFVBQVUsRUFBRSxJQUZjO0VBRzFCSSxFQUFBQSxLQUFLLEVBQUU7RUFDTFUsSUFBQUEsSUFBSSxFQUFFQztFQURELEdBSG1CO0VBTTFCZCxFQUFBQSxNQU4wQixrQkFNbkJlLENBTm1CLEVBTWhCYixPQU5nQixFQU1QO0VBQ2pCLFFBQUljLE9BQUo7O0VBQ0EsUUFBSVYsSUFBSSxHQUFHLFNBQWMsRUFBZCxFQUFrQkosT0FBTyxDQUFDSSxJQUExQixDQUFYOztFQUVBLFFBQUlKLE9BQU8sQ0FBQ0MsS0FBUixDQUFjVSxJQUFkLElBQXNCWCxPQUFPLENBQUNlLE1BQVIsQ0FBZUMsT0FBekMsRUFBa0Q7RUFDaEQ7RUFDQUYsTUFBQUEsT0FBTyxHQUFHZCxPQUFPLENBQUNlLE1BQVIsQ0FBZUUsS0FBZixDQUFxQkMsUUFBckIsQ0FBOEI3QixVQUE5QixDQUF5QyxhQUF6QyxDQUFWO0VBQ0FlLE1BQUFBLElBQUksQ0FBQ0gsS0FBTCxHQUFhLFNBQWM7RUFBRUUsUUFBQUEsR0FBRyxFQUFFSCxPQUFPLENBQUNDLEtBQVIsQ0FBY0U7RUFBckIsT0FBZCxFQUEwQ0gsT0FBTyxDQUFDQyxLQUFSLENBQWNVLElBQXhELENBQWI7RUFDQVAsTUFBQUEsSUFBSSxDQUFDd0MsS0FBTCxDQUFXQyxJQUFYLEdBQWtCLFFBQWxCOztFQUNBLFVBQUl6QyxJQUFJLENBQUNlLEVBQUwsQ0FBUUMsS0FBWixFQUFtQjtFQUNqQmhCLFFBQUFBLElBQUksQ0FBQ2lCLFFBQUwsR0FBZ0I7RUFBRUQsVUFBQUEsS0FBSyxFQUFFaEIsSUFBSSxDQUFDZSxFQUFMLENBQVFDO0VBQWpCLFNBQWhCO0VBQ0Q7RUFDRixLQVJELE1BUU8sSUFBSWhCLElBQUksQ0FBQ3dDLEtBQUwsSUFBY3hDLElBQUksQ0FBQ3dDLEtBQUwsQ0FBV0UsSUFBN0IsRUFBbUM7RUFDeEM7RUFDQWhDLE1BQUFBLE9BQU8sR0FBRyxHQUFWO0VBQ0FWLE1BQUFBLElBQUksQ0FBQ3dDLEtBQUwsQ0FBV0MsSUFBWCxHQUFrQixRQUFsQjtFQUNELEtBSk0sTUFJQTtFQUNMO0VBQ0EvQixNQUFBQSxPQUFPLEdBQUcsUUFBVjtFQUNEOztFQUVELFdBQU9ELENBQUMsQ0FBQ0MsT0FBRCxFQUFVVixJQUFWLEVBQWdCSixPQUFPLENBQUNLLFFBQXhCLENBQVI7RUFDRDtFQTVCeUIsQ0FBckI7QUErQlAsRUFBTyxJQUFNMEMsaUJBQWlCLEdBQUc7RUFDL0I5QyxFQUFBQSxLQUFLLEVBQUU7RUFDTDZDLElBQUFBLElBQUksRUFBRXJDLE1BREQ7RUFFTHVDLElBQUFBLFFBQVEsRUFBRXZCLE9BRkw7RUFHTEYsSUFBQUEsRUFBRSxFQUFFLENBQUNkLE1BQUQsRUFBU0csTUFBVCxDQUhDO0VBSUxZLElBQUFBLEtBQUssRUFBRUMsT0FKRjtFQUtMQyxJQUFBQSxNQUFNLEVBQUVELE9BTEg7RUFNTEUsSUFBQUEsT0FBTyxFQUFFRixPQU5KO0VBT0xHLElBQUFBLFdBQVcsRUFBRW5CLE1BUFI7RUFRTG9CLElBQUFBLGdCQUFnQixFQUFFcEI7RUFSYixHQUR3QjtFQVcvQnFCLEVBQUFBLFFBQVEsRUFBRTtFQUNSbkIsSUFBQUEsSUFEUSxrQkFDRDtFQUNMLGFBQ0UsS0FBS1ksRUFBTCxJQUFXO0VBQ1RBLFFBQUFBLEVBQUUsRUFBRSxLQUFLQSxFQURBO0VBRVRDLFFBQUFBLEtBQUssRUFBRSxLQUFLQSxLQUZIO0VBR1RFLFFBQUFBLE1BQU0sRUFBRSxLQUFLQSxNQUhKO0VBSVRDLFFBQUFBLE9BQU8sRUFBRSxLQUFLQSxPQUpMO0VBS1RDLFFBQUFBLFdBQVcsRUFBRSxLQUFLQSxXQUxUO0VBTVRDLFFBQUFBLGdCQUFnQixFQUFFLEtBQUtBO0VBTmQsT0FEYjtFQVVEO0VBWk8sR0FYcUI7RUF5Qi9CeEMsRUFBQUEsVUFBVSxFQUFFO0VBQ1ZzRCxJQUFBQSxZQUFZLEVBQVpBO0VBRFU7RUF6Qm1CLENBQTFCOztFQy9CQSxTQUFTTSxlQUFULENBQXlCQyxRQUF6QixFQUFtQztFQUN4QyxNQUFJLE9BQU9BLFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7RUFDaEMsV0FBTztFQUNMQyxNQUFBQSxPQUFPLEVBQUU7RUFBRSwwQkFBa0I7RUFBcEIsT0FESjtFQUVMQyxNQUFBQSxPQUFPLEVBQUVGO0VBRkosS0FBUDtFQUlELEdBTEQsTUFLTyxJQUFJQSxRQUFRLFlBQVlHLEtBQXhCLEVBQStCO0VBQ3BDLFdBQU87RUFDTEYsTUFBQUEsT0FBTyxFQUFFRCxRQUFRLENBQUNJLE1BQVQsQ0FDUCxVQUFDQyxNQUFELEVBQVNDLEtBQVQ7RUFBQSxlQUFtQixTQUFjRCxNQUFkLHNCQUF5QkMsS0FBekIsRUFBaUMsSUFBakMsRUFBbkI7RUFBQSxPQURPLEVBRVAsRUFGTztFQURKLEtBQVA7RUFNRCxHQVBNLE1BT0EsSUFBSSxRQUFPTixRQUFQLE1BQW9CLFFBQXhCLEVBQWtDO0VBQ3ZDLFdBQU87RUFDTEMsTUFBQUEsT0FBTyxFQUFFRCxRQUFRLENBQUNPLFNBQVQsQ0FDTkMsS0FETSxDQUNBLEdBREEsRUFFTkosTUFGTSxDQUdMLFVBQUNDLE1BQUQsRUFBU0MsS0FBVDtFQUFBLGVBQW1CLFNBQWNELE1BQWQsc0JBQXlCQyxLQUF6QixFQUFpQyxJQUFqQyxFQUFuQjtFQUFBLE9BSEssRUFJTCxFQUpLLENBREo7RUFPTEosTUFBQUEsT0FBTyxFQUFFRixRQUFRLENBQUNTO0VBUGIsS0FBUDtFQVNEO0VBQ0Y7O0VDeEJNLElBQU1DLGtCQUFrQixHQUFHO0VBQ2hDM0QsRUFBQUEsS0FBSyxFQUFFO0VBQ0w0RCxJQUFBQSxLQUFLLEVBQUVwRCxNQURGO0VBRUwsb0JBQWdCRyxNQUZYO0VBR0wsa0JBQWN5QztFQUhULEdBRHlCO0VBTWhDUyxFQUFBQSxPQUFPLEVBQUU7RUFDUHBCLElBQUFBLGFBRE8seUJBQ09OLEdBRFAsRUFDWTtFQUNqQkEsTUFBQUEsR0FBRyxJQUFJLEtBQUsyQixLQUFMLENBQVczQixHQUFHLENBQUM1QixJQUFmLEVBQXFCNEIsR0FBckIsQ0FBUDs7RUFDQSxVQUFJLEtBQUt5QixLQUFULEVBQWdCO0VBQ2QsWUFBSUcsTUFBTSxHQUFHLEtBQUtDLFdBQUwsSUFBb0IsS0FBS2hELEtBQXRDO0VBQ0EsWUFBSWlELElBQUksR0FBRyxLQUFLQyxTQUFMLElBQWtCLEVBQTdCO0VBQ0FILFFBQUFBLE1BQU0sQ0FBQ0QsS0FBUCxPQUFBQyxNQUFNLEdBQU8sS0FBS0gsS0FBWiw0QkFBc0JLLElBQXRCLEdBQU47RUFDRDtFQUNGO0VBUk0sR0FOdUI7RUFnQmhDcEMsRUFBQUEsUUFBUSxFQUFFO0VBQ1JzQyxJQUFBQSxTQURRLHVCQUNJO0VBQUE7O0VBQ1YsK0JBQ0ssS0FBS0MsVUFEVjtFQUVFakQsUUFBQUEsS0FBSyxFQUFFLGVBQUF2QyxDQUFDO0VBQUEsaUJBQUksS0FBSSxDQUFDNkQsYUFBTCxDQUFtQjdELENBQW5CLENBQUo7RUFBQTtFQUZWO0VBSUQ7RUFOTztFQWhCc0IsQ0FBM0I7O0VDQUEsSUFBTXlGLGtCQUFrQixHQUFHO0VBQ2hDbEUsRUFBQUEsSUFEZ0Msa0JBQ3pCO0VBQ0wsV0FBTztFQUFFbUUsTUFBQUEsUUFBUSxFQUFFO0VBQVosS0FBUDtFQUNELEdBSCtCO0VBSWhDVCxFQUFBQSxPQUFPLEVBQUU7RUFDUFUsSUFBQUEsV0FETyx5QkFDTztFQUNaLFdBQUtDLE9BQUwsR0FBZSxJQUFmO0VBQ0QsS0FITTtFQUlQQyxJQUFBQSxTQUpPLHVCQUlLO0VBQ1YsV0FBS0QsT0FBTCxHQUFlLEtBQWY7RUFDRCxLQU5NO0VBT1BFLElBQUFBLFlBUE8sMEJBT1E7RUFBQTs7RUFDYjtFQUNBQyxNQUFBQSxVQUFVLENBQUM7RUFBQSxlQUFNLEtBQUksQ0FBQ0Msa0JBQUwsRUFBTjtFQUFBLE9BQUQsRUFBa0MsQ0FBbEMsQ0FBVjtFQUNELEtBVk07RUFXUEMsSUFBQUEsV0FYTyx5QkFXTztFQUFBOztFQUNaO0VBQ0E7RUFDQSxXQUFLTCxPQUFMLElBQWdCRyxVQUFVLENBQUM7RUFBQSxlQUFNLE1BQUksQ0FBQ0Msa0JBQUwsRUFBTjtFQUFBLE9BQUQsRUFBa0MsQ0FBbEMsQ0FBMUI7RUFDRCxLQWZNO0VBZ0JQQSxJQUFBQSxrQkFoQk8sZ0NBZ0JjO0VBQ25CLFVBQUlOLFFBQVEsR0FDVixLQUFLUSxHQUFMLEtBQWFyRyxRQUFRLENBQUNzRyxhQUF0QixJQUNBLEtBQUtELEdBQUwsQ0FBU0UsUUFBVCxDQUFrQnZHLFFBQVEsQ0FBQ3NHLGFBQTNCLENBRkY7O0VBR0EsVUFBSVQsUUFBUSxJQUFJLEtBQUtBLFFBQXJCLEVBQStCO0VBQzdCLGFBQUtSLEtBQUwsQ0FBV1EsUUFBUSxHQUFHLE9BQUgsR0FBYSxNQUFoQztFQUNBLGFBQUtBLFFBQUwsR0FBZ0JBLFFBQWhCO0VBQ0Q7RUFDRjtFQXhCTSxHQUp1QjtFQThCaENXLEVBQUFBLE9BOUJnQyxxQkE4QnRCO0VBQ1IsU0FBS0gsR0FBTCxDQUFTcEcsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUMsS0FBS2dHLFlBQTFDO0VBQ0EsU0FBS0ksR0FBTCxDQUFTcEcsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBS21HLFdBQTNDO0VBQ0EsU0FBS0MsR0FBTCxDQUFTcEcsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsS0FBSzZGLFdBQTVDO0VBQ0EsU0FBS08sR0FBTCxDQUFTcEcsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUMsS0FBSytGLFNBQTFDO0VBQ0QsR0FuQytCO0VBb0NoQ1MsRUFBQUEsYUFwQ2dDLDJCQW9DaEI7RUFDZCxTQUFLSixHQUFMLENBQVNLLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUtULFlBQTdDO0VBQ0EsU0FBS0ksR0FBTCxDQUFTSyxtQkFBVCxDQUE2QixVQUE3QixFQUF5QyxLQUFLTixXQUE5QztFQUNBLFNBQUtDLEdBQUwsQ0FBU0ssbUJBQVQsQ0FBNkIsV0FBN0IsRUFBMEMsS0FBS1osV0FBL0M7RUFDQSxTQUFLTyxHQUFMLENBQVNLLG1CQUFULENBQTZCLFNBQTdCLEVBQXdDLEtBQUtWLFNBQTdDO0VBQ0Q7RUF6QytCLENBQTNCOztFQ0FQLElBQU1XLEtBQUssR0FDVEMsSUFBSSxDQUFDQyxLQUFMLENBQVdELElBQUksQ0FBQ0UsTUFBTCxLQUFnQkYsSUFBSSxDQUFDQyxLQUFMLENBQVcsVUFBWCxDQUEzQixFQUFtREUsUUFBbkQsS0FBZ0UsR0FEbEU7QUFHQSxFQUFPLElBQU1DLGdCQUFnQixHQUFHO0VBQzlCQyxFQUFBQSxZQUQ4QiwwQkFDZjtFQUNiLFNBQUtDLFFBQUwsR0FBZ0JQLEtBQUssR0FBRyxLQUFLUSxJQUE3QjtFQUNEO0VBSDZCLENBQXpCOztFQ0hQOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCQTs7O01BR01DOzs7Ozs7RUFDSjswQkFDd0I7RUFDdEI7RUFDQTtFQUNBLGFBQU8sRUFBUDtFQUNEO0VBRUQ7Ozs7MEJBQ3FCO0VBQ25CO0VBQ0E7RUFDQSxhQUFPLEVBQVA7RUFDRDtFQUVEOzs7OzBCQUNxQjtFQUNuQjtFQUNBO0VBQ0EsYUFBTyxFQUFQO0VBQ0Q7RUFFRDs7OzswQkFDNEI7RUFDMUI7RUFDQTtFQUNBO0VBQ0EsYUFBTyxFQUFQO0VBQ0Q7RUFFRDs7Ozs7O0VBR0EsMkJBQTBCO0VBQUEsUUFBZEMsT0FBYyx1RUFBSixFQUFJOztFQUFBOztFQUN4QjtFQUNBLFNBQUtDLFFBQUwsR0FBZ0JELE9BQWhCO0VBQ0Q7Ozs7NkJBRU07RUFFTjs7O2dDQUVTO0VBRVQ7Ozs7OztFQzdDSDs7OztNQUdNRTs7Ozs7O0VBQ0o7Ozs7K0JBSWdCQyxNQUFNO0VBQ3BCO0VBQ0E7RUFDQTtFQUNBO0VBQ0EsYUFBTyxJQUFJRCxZQUFKLENBQWlCQyxJQUFqQixFQUF1QixJQUFJSixhQUFKLEVBQXZCLENBQVA7RUFDRDtFQUVEOzs7Ozs7OztFQUtBLHdCQUFZSSxJQUFaLEVBQW1EO0VBQUEsUUFBakNDLFVBQWlDLHVFQUFwQjNILFNBQW9COztFQUFBOztFQUNqRDtFQUNBLFNBQUs0SCxLQUFMLEdBQWFGLElBQWI7O0VBRmlELHNDQUFOaEMsSUFBTTtFQUFOQSxNQUFBQSxJQUFNO0VBQUE7O0VBR2pELFNBQUttQyxVQUFMLGFBQW1CbkMsSUFBbkIsRUFIaUQ7RUFLakQ7O0VBQ0E7O0VBQ0EsU0FBS29DLFdBQUwsR0FBbUJILFVBQVUsS0FBSzNILFNBQWYsR0FBMkIsS0FBSytILG9CQUFMLEVBQTNCLEdBQXlESixVQUE1RTtFQUNBLFNBQUtHLFdBQUwsQ0FBaUJFLElBQWpCO0VBQ0EsU0FBS0Msa0JBQUw7RUFDRDs7Ozs7RUFFVTtFQUFlO0VBRXhCO0VBQ0E7O0VBR0Y7Ozs7Ozs2Q0FHdUI7RUFDckI7RUFDQTtFQUNBLFlBQU0sSUFBSUMsS0FBSixDQUFVLG1GQUNkLGtCQURJLENBQU47RUFFRDs7OzJDQUVvQjtFQUVuQjtFQUNBO0VBQ0E7RUFDRDs7O2dDQUVTO0VBQ1I7RUFDQTtFQUNBLFdBQUtKLFdBQUwsQ0FBaUJLLE9BQWpCO0VBQ0Q7RUFFRDs7Ozs7Ozs7OzZCQU1PMUUsU0FBUzJFLFNBQVM7RUFDdkIsV0FBS1IsS0FBTCxDQUFXekgsZ0JBQVgsQ0FBNEJzRCxPQUE1QixFQUFxQzJFLE9BQXJDO0VBQ0Q7RUFFRDs7Ozs7Ozs7OytCQU1TM0UsU0FBUzJFLFNBQVM7RUFDekIsV0FBS1IsS0FBTCxDQUFXaEIsbUJBQVgsQ0FBK0JuRCxPQUEvQixFQUF3QzJFLE9BQXhDO0VBQ0Q7RUFFRDs7Ozs7Ozs7OzsyQkFPSzNFLFNBQVNDLFNBQStCO0VBQUEsVUFBdEJDLFlBQXNCLHVFQUFQLEtBQU87RUFDM0MsVUFBSUMsR0FBSjs7RUFDQSxVQUFJLE9BQU9DLFdBQVAsS0FBdUIsVUFBM0IsRUFBdUM7RUFDckNELFFBQUFBLEdBQUcsR0FBRyxJQUFJQyxXQUFKLENBQWdCSixPQUFoQixFQUF5QjtFQUM3QkssVUFBQUEsTUFBTSxFQUFFSixPQURxQjtFQUU3QkssVUFBQUEsT0FBTyxFQUFFSjtFQUZvQixTQUF6QixDQUFOO0VBSUQsT0FMRCxNQUtPO0VBQ0xDLFFBQUFBLEdBQUcsR0FBRzFELFFBQVEsQ0FBQzhELFdBQVQsQ0FBcUIsYUFBckIsQ0FBTjtFQUNBSixRQUFBQSxHQUFHLENBQUNLLGVBQUosQ0FBb0JSLE9BQXBCLEVBQTZCRSxZQUE3QixFQUEyQyxLQUEzQyxFQUFrREQsT0FBbEQ7RUFDRDs7RUFFRCxXQUFLa0UsS0FBTCxDQUFXMUQsYUFBWCxDQUF5Qk4sR0FBekI7RUFDRDs7Ozs7O0VDL0hIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCQTs7RUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O01BcUJNeUU7Ozs7Ozs7Ozs7RUFDSjsrQ0FDeUI7RUFFekI7Ozs7b0NBQ2M7RUFFZDs7Ozt3Q0FDa0I7RUFFbEI7Ozs7MENBQ29CO0VBRXBCOzs7OytCQUNTcEQsV0FBVztFQUVwQjs7OztrQ0FDWUEsV0FBVztFQUV2Qjs7OzswQ0FDb0JPLFFBQVE7RUFFNUI7Ozs7Ozs7aURBSTJCL0IsU0FBUzJFLFNBQVM7RUFFN0M7Ozs7Ozs7bURBSTZCM0UsU0FBUzJFLFNBQVM7RUFFL0M7Ozs7Ozs7eURBSW1DM0UsU0FBUzJFLFNBQVM7RUFFckQ7Ozs7Ozs7MkRBSXFDM0UsU0FBUzJFLFNBQVM7RUFFdkQ7Ozs7Ozs0Q0FHc0JBLFNBQVM7RUFFL0I7Ozs7Ozs4Q0FHd0JBLFNBQVM7RUFFakM7Ozs7Ozs7d0NBSWtCRSxTQUFTdEQsT0FBTztFQUVsQzs7Ozs0Q0FDc0I7RUFFdEI7Ozs7NENBQ3NCOzs7Ozs7RUNoSHhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBdUJBLElBQU11RCxZQUFVLEdBQUc7RUFDakI7RUFDQTtFQUNBO0VBQ0FDLEVBQUFBLElBQUksRUFBRSxxQkFKVztFQUtqQkMsRUFBQUEsU0FBUyxFQUFFLGdDQUxNO0VBTWpCQyxFQUFBQSxVQUFVLEVBQUUseUNBTks7RUFPakJDLEVBQUFBLGFBQWEsRUFBRSw0Q0FQRTtFQVFqQkMsRUFBQUEsZUFBZSxFQUFFO0VBUkEsQ0FBbkI7RUFXQSxJQUFNQyxPQUFPLEdBQUc7RUFDZEMsRUFBQUEsUUFBUSxFQUFFLG1CQURJO0VBRWRDLEVBQUFBLE9BQU8sRUFBRSxrQkFGSztFQUdkQyxFQUFBQSxXQUFXLEVBQUUsc0JBSEM7RUFJZEMsRUFBQUEsWUFBWSxFQUFFLHVCQUpBO0VBS2RDLEVBQUFBLHNCQUFzQixFQUFFLGlDQUxWO0VBTWRDLEVBQUFBLG9CQUFvQixFQUFFO0VBTlIsQ0FBaEI7RUFTQSxJQUFNQyxPQUFPLEdBQUc7RUFDZEMsRUFBQUEsT0FBTyxFQUFFLEVBREs7RUFFZEMsRUFBQUEsb0JBQW9CLEVBQUUsR0FGUjtFQUdkQyxFQUFBQSx1QkFBdUIsRUFBRSxHQUhYO0VBR2dCO0VBQzlCQyxFQUFBQSxrQkFBa0IsRUFBRSxHQUpOO0VBSVc7RUFDekJDLEVBQUFBLFlBQVksRUFBRSxHQUxBOztFQUFBLENBQWhCOztFQzNDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF1QkE7Ozs7RUFJQSxJQUFJQyxxQkFBSjtFQUVBOzs7OztFQUlBLElBQUkvSixrQkFBSjtFQUVBOzs7OztFQUlBLFNBQVNnSyxzQkFBVCxDQUFnQ0MsU0FBaEMsRUFBMkM7RUFDekM7RUFDQTtFQUNBLE1BQU0xSixRQUFRLEdBQUcwSixTQUFTLENBQUMxSixRQUEzQjtFQUNBLE1BQU0ySixJQUFJLEdBQUczSixRQUFRLENBQUNxQixhQUFULENBQXVCLEtBQXZCLENBQWI7RUFDQXNJLEVBQUFBLElBQUksQ0FBQzVFLFNBQUwsR0FBaUIsdUNBQWpCO0VBQ0EvRSxFQUFBQSxRQUFRLENBQUM0SixJQUFULENBQWNDLFdBQWQsQ0FBMEJGLElBQTFCLEVBTnlDO0VBU3pDO0VBQ0E7RUFDQTs7RUFDQSxNQUFNRyxhQUFhLEdBQUdKLFNBQVMsQ0FBQ0ssZ0JBQVYsQ0FBMkJKLElBQTNCLENBQXRCO0VBQ0EsTUFBTUssZUFBZSxHQUFHRixhQUFhLEtBQUssSUFBbEIsSUFBMEJBLGFBQWEsQ0FBQ0csY0FBZCxLQUFpQyxPQUFuRjtFQUNBTixFQUFBQSxJQUFJLENBQUNPLE1BQUw7RUFDQSxTQUFPRixlQUFQO0VBQ0Q7RUFFRDs7Ozs7OztFQU1BLFNBQVNHLG9CQUFULENBQThCVCxTQUE5QixFQUErRDtFQUFBLE1BQXRCN0osWUFBc0IsdUVBQVAsS0FBTztFQUM3RCxNQUFJc0ssb0JBQW9CLEdBQUdYLHFCQUEzQjs7RUFDQSxNQUFJLE9BQU9BLHFCQUFQLEtBQWlDLFNBQWpDLElBQThDLENBQUMzSixZQUFuRCxFQUFpRTtFQUMvRCxXQUFPc0ssb0JBQVA7RUFDRDs7RUFFRCxNQUFNQyx1QkFBdUIsR0FBR1YsU0FBUyxDQUFDVyxHQUFWLElBQWlCLE9BQU9YLFNBQVMsQ0FBQ1csR0FBVixDQUFjQyxRQUFyQixLQUFrQyxVQUFuRjs7RUFDQSxNQUFJLENBQUNGLHVCQUFMLEVBQThCO0VBQzVCO0VBQ0Q7O0VBRUQsTUFBTUcseUJBQXlCLEdBQUdiLFNBQVMsQ0FBQ1csR0FBVixDQUFjQyxRQUFkLENBQXVCLFlBQXZCLEVBQXFDLEtBQXJDLENBQWxDLENBWDZEO0VBYTdEOztFQUNBLE1BQU1FLGlDQUFpQyxHQUNyQ2QsU0FBUyxDQUFDVyxHQUFWLENBQWNDLFFBQWQsQ0FBdUIsbUJBQXZCLEtBQ0FaLFNBQVMsQ0FBQ1csR0FBVixDQUFjQyxRQUFkLENBQXVCLE9BQXZCLEVBQWdDLFdBQWhDLENBRkY7O0VBS0EsTUFBSUMseUJBQXlCLElBQUlDLGlDQUFqQyxFQUFvRTtFQUNsRUwsSUFBQUEsb0JBQW9CLEdBQUcsQ0FBQ1Ysc0JBQXNCLENBQUNDLFNBQUQsQ0FBOUM7RUFDRCxHQUZELE1BRU87RUFDTFMsSUFBQUEsb0JBQW9CLEdBQUcsS0FBdkI7RUFDRDs7RUFFRCxNQUFJLENBQUN0SyxZQUFMLEVBQW1CO0VBQ2pCMkosSUFBQUEscUJBQXFCLEdBQUdXLG9CQUF4QjtFQUNEOztFQUNELFNBQU9BLG9CQUFQO0VBQ0Q7O0VBR0Q7Ozs7Ozs7O0VBTUEsU0FBU3pLLGNBQVQsR0FBZ0U7RUFBQSxNQUExQ0MsU0FBMEMsdUVBQTlCQyxNQUE4QjtFQUFBLE1BQXRCQyxZQUFzQix1RUFBUCxLQUFPOztFQUM5RCxNQUFJSixrQkFBZ0IsS0FBS0ssU0FBckIsSUFBa0NELFlBQXRDLEVBQW9EO0VBQ2xELFFBQUlFLFdBQVcsR0FBRyxLQUFsQjs7RUFDQSxRQUFJO0VBQ0ZKLE1BQUFBLFNBQVMsQ0FBQ0ssUUFBVixDQUFtQkMsZ0JBQW5CLENBQW9DLE1BQXBDLEVBQTRDLElBQTVDLEVBQWtEO0VBQUMsWUFBSUMsT0FBSixHQUFjO0VBQy9ESCxVQUFBQSxXQUFXLEdBQUcsSUFBZDtFQUNBLGlCQUFPQSxXQUFQO0VBQ0Q7O0VBSGlELE9BQWxEO0VBSUQsS0FMRCxDQUtFLE9BQU9JLENBQVAsRUFBVTs7RUFFWlYsSUFBQUEsa0JBQWdCLEdBQUdNLFdBQW5CO0VBQ0Q7O0VBRUQsU0FBT04sa0JBQWdCO0VBQ25CO0VBQXNDO0VBQUNTLElBQUFBLE9BQU8sRUFBRTtFQUFWLEdBRG5CLEdBRW5CLEtBRko7RUFHRDtFQUVEOzs7Ozs7RUFJQSxTQUFTdUssa0JBQVQsQ0FBNEJDLG9CQUE1QixFQUFrRDtFQUNoRDs7OztFQUlBLE1BQU1DLGNBQWMsR0FBRyxDQUFDLFNBQUQsRUFBWSx1QkFBWixFQUFxQyxtQkFBckMsQ0FBdkI7RUFDQSxNQUFJQyxNQUFNLEdBQUcsU0FBYjs7RUFDQSxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLGNBQWMsQ0FBQ0csTUFBbkMsRUFBMkNELENBQUMsRUFBNUMsRUFBZ0Q7RUFDOUMsUUFBTUUsYUFBYSxHQUFHSixjQUFjLENBQUNFLENBQUQsQ0FBcEM7O0VBQ0EsUUFBSUUsYUFBYSxJQUFJTCxvQkFBckIsRUFBMkM7RUFDekNFLE1BQUFBLE1BQU0sR0FBR0csYUFBVDtFQUNBO0VBQ0Q7RUFDRjs7RUFFRCxTQUFPSCxNQUFQO0VBQ0Q7RUFFRDs7Ozs7Ozs7RUFNQSxTQUFTSSx3QkFBVCxDQUFrQ0MsRUFBbEMsRUFBc0NDLFVBQXRDLEVBQWtEQyxVQUFsRCxFQUE4RDtFQUFBLE1BQ3JEQyxDQURxRCxHQUM3Q0YsVUFENkMsQ0FDckRFLENBRHFEO0VBQUEsTUFDbERDLENBRGtELEdBQzdDSCxVQUQ2QyxDQUNsREcsQ0FEa0Q7RUFFNUQsTUFBTUMsU0FBUyxHQUFHRixDQUFDLEdBQUdELFVBQVUsQ0FBQ0ksSUFBakM7RUFDQSxNQUFNQyxTQUFTLEdBQUdILENBQUMsR0FBR0YsVUFBVSxDQUFDTSxHQUFqQztFQUVBLE1BQUlDLFdBQUo7RUFDQSxNQUFJQyxXQUFKLENBTjREOztFQVE1RCxNQUFJVixFQUFFLENBQUNuSixJQUFILEtBQVksWUFBaEIsRUFBOEI7RUFDNUJtSixJQUFBQSxFQUFFO0VBQUc7RUFBNEJBLElBQUFBLEVBQWpDO0VBQ0FTLElBQUFBLFdBQVcsR0FBR1QsRUFBRSxDQUFDVyxjQUFILENBQWtCLENBQWxCLEVBQXFCQyxLQUFyQixHQUE2QlAsU0FBM0M7RUFDQUssSUFBQUEsV0FBVyxHQUFHVixFQUFFLENBQUNXLGNBQUgsQ0FBa0IsQ0FBbEIsRUFBcUJFLEtBQXJCLEdBQTZCTixTQUEzQztFQUNELEdBSkQsTUFJTztFQUNMUCxJQUFBQSxFQUFFO0VBQUc7RUFBNEJBLElBQUFBLEVBQWpDO0VBQ0FTLElBQUFBLFdBQVcsR0FBR1QsRUFBRSxDQUFDWSxLQUFILEdBQVdQLFNBQXpCO0VBQ0FLLElBQUFBLFdBQVcsR0FBR1YsRUFBRSxDQUFDYSxLQUFILEdBQVdOLFNBQXpCO0VBQ0Q7O0VBRUQsU0FBTztFQUFDSixJQUFBQSxDQUFDLEVBQUVNLFdBQUo7RUFBaUJMLElBQUFBLENBQUMsRUFBRU07RUFBcEIsR0FBUDtFQUNEOztFQ2pHRCxJQUFNSSxzQkFBc0IsR0FBRyxDQUFDLFlBQUQsRUFBZSxhQUFmLEVBQThCLFdBQTlCLEVBQTJDLFNBQTNDLENBQS9COztFQUdBLElBQU1DLGdDQUFnQyxHQUFHLENBQUMsVUFBRCxFQUFhLFdBQWIsRUFBMEIsU0FBMUIsRUFBcUMsYUFBckMsQ0FBekM7O0VBR0E7O0VBQ0EsSUFBSUMsZ0JBQWdCLEdBQUcsRUFBdkI7RUFFQTs7OztNQUdNQzs7Ozs7OzswQkFDb0I7RUFDdEIsYUFBTzdELFlBQVA7RUFDRDs7OzBCQUVvQjtFQUNuQixhQUFPTSxPQUFQO0VBQ0Q7OzswQkFFb0I7RUFDbkIsYUFBT08sT0FBUDtFQUNEOzs7MEJBRTJCO0VBQzFCLGFBQU87RUFDTGlELFFBQUFBLHNCQUFzQixFQUFFO0VBQU07RUFBdUIsVUFEaEQ7RUFFTEMsUUFBQUEsV0FBVyxFQUFFO0VBQU07RUFBYyxVQUY1QjtFQUdMQyxRQUFBQSxlQUFlLEVBQUU7RUFBTTtFQUFjLFVBSGhDO0VBSUxDLFFBQUFBLGlCQUFpQixFQUFFO0VBQU07RUFBYyxVQUpsQztFQUtMQyxRQUFBQSxRQUFRLEVBQUU7RUFBQztFQUE0QixVQUxsQztFQU1MQyxRQUFBQSxXQUFXLEVBQUU7RUFBQztFQUE0QixVQU5yQztFQU9MQyxRQUFBQSxtQkFBbUIsRUFBRTtFQUFDO0VBQStCLFVBUGhEO0VBUUxDLFFBQUFBLDBCQUEwQixFQUFFO0VBQUM7RUFBa0QsVUFSMUU7RUFTTEMsUUFBQUEsNEJBQTRCLEVBQUU7RUFBQztFQUFrRCxVQVQ1RTtFQVVMQyxRQUFBQSxrQ0FBa0MsRUFBRTtFQUFDO0VBQWtELFVBVmxGO0VBV0xDLFFBQUFBLG9DQUFvQyxFQUFFO0VBQUM7RUFBa0QsVUFYcEY7RUFZTEMsUUFBQUEscUJBQXFCLEVBQUU7RUFBQztFQUFpQyxVQVpwRDtFQWFMQyxRQUFBQSx1QkFBdUIsRUFBRTtFQUFDO0VBQWlDLFVBYnREO0VBY0xDLFFBQUFBLGlCQUFpQixFQUFFO0VBQUM7RUFBeUMsVUFkeEQ7RUFlTEMsUUFBQUEsbUJBQW1CLEVBQUU7RUFBTTtFQUFpQixVQWZ2QztFQWdCTEMsUUFBQUEsbUJBQW1CLEVBQUU7RUFBTTtFQUE2QjtFQWhCbkQsT0FBUDtFQWtCRDs7O0VBRUQsK0JBQVk3RixPQUFaLEVBQXFCO0VBQUE7O0VBQUE7O0VBQ25CLDZGQUFNLFNBQWM2RSxtQkFBbUIsQ0FBQ2lCLGNBQWxDLEVBQWtEOUYsT0FBbEQsQ0FBTjtFQUVBOztFQUNBLFVBQUsrRixZQUFMLEdBQW9CLENBQXBCO0VBRUE7O0VBQ0EsVUFBS0MsTUFBTDtFQUFjO0VBQTRCO0VBQUNDLE1BQUFBLEtBQUssRUFBRSxDQUFSO0VBQVdDLE1BQUFBLE1BQU0sRUFBRTtFQUFuQixLQUExQztFQUVBOztFQUNBLFVBQUtDLGdCQUFMLEdBQXdCLE1BQUtDLHVCQUFMLEVBQXhCO0VBRUE7O0VBQ0EsVUFBS0MsWUFBTCxHQUFvQixDQUFwQjtFQUVBOztFQUNBLFVBQUtDLFVBQUwsR0FBa0IsQ0FBbEI7RUFFQTs7RUFDQSxVQUFLQyxnQkFBTCxHQUF3QixVQUFDek4sQ0FBRDtFQUFBLGFBQU8sTUFBSzBOLFNBQUwsQ0FBZTFOLENBQWYsQ0FBUDtFQUFBLEtBQXhCO0VBRUE7OztFQUNBLFVBQUsyTixrQkFBTCxHQUEwQjtFQUFBLGFBQU0sTUFBS0MsV0FBTCxFQUFOO0VBQUEsS0FBMUI7RUFFQTs7O0VBQ0EsVUFBS0MsYUFBTCxHQUFxQjtFQUFBLGFBQU0sTUFBS0MsV0FBTCxFQUFOO0VBQUEsS0FBckI7RUFFQTs7O0VBQ0EsVUFBS0MsWUFBTCxHQUFvQjtFQUFBLGFBQU0sTUFBS0MsVUFBTCxFQUFOO0VBQUEsS0FBcEI7RUFFQTs7O0VBQ0EsVUFBS0MsY0FBTCxHQUFzQjtFQUFBLGFBQU0sTUFBS0MsTUFBTCxFQUFOO0VBQUEsS0FBdEI7RUFFQTs7O0VBQ0EsVUFBS0MsZ0JBQUwsR0FBd0I7RUFDdEIvQyxNQUFBQSxJQUFJLEVBQUUsQ0FEZ0I7RUFFdEJFLE1BQUFBLEdBQUcsRUFBRTtFQUZpQixLQUF4QjtFQUtBOztFQUNBLFVBQUs4QyxRQUFMLEdBQWdCLENBQWhCO0VBRUE7O0VBQ0EsVUFBS0MsZ0JBQUwsR0FBd0IsQ0FBeEI7RUFFQTs7RUFDQSxVQUFLQywyQkFBTCxHQUFtQyxDQUFuQztFQUVBOztFQUNBLFVBQUtDLDRCQUFMLEdBQW9DLEtBQXBDO0VBRUE7O0VBQ0EsVUFBS0Msd0JBQUwsR0FBZ0MsWUFBTTtFQUNwQyxZQUFLRCw0QkFBTCxHQUFvQyxJQUFwQzs7RUFDQSxZQUFLRSw4QkFBTDtFQUNELEtBSEQ7RUFLQTs7O0VBQ0EsVUFBS0Msd0JBQUw7RUExRG1CO0VBMkRwQjtFQUVEOzs7Ozs7Ozs7Ozs7NkNBUXVCO0VBQ3JCLGFBQU8sS0FBS3ZILFFBQUwsQ0FBYzZFLHNCQUFkLEVBQVA7RUFDRDtFQUVEOzs7Ozs7Z0RBRzBCO0VBQ3hCLGFBQU87RUFDTDJDLFFBQUFBLFdBQVcsRUFBRSxLQURSO0VBRUxDLFFBQUFBLG9CQUFvQixFQUFFLEtBRmpCO0VBR0xDLFFBQUFBLHFCQUFxQixFQUFFLEtBSGxCO0VBSUxDLFFBQUFBLG9CQUFvQixFQUFFLEtBSmpCO0VBS0xDLFFBQUFBLGVBQWUsRUFBRXBQLFNBTFo7RUFNTHFQLFFBQUFBLGNBQWMsRUFBRTtFQU5YLE9BQVA7RUFRRDtFQUVEOzs7OzZCQUNPO0VBQUE7O0VBQ0wsVUFBTUMsbUJBQW1CLEdBQUcsS0FBS0Msb0JBQUwsRUFBNUI7RUFFQSxXQUFLQyxxQkFBTCxDQUEyQkYsbUJBQTNCOztFQUVBLFVBQUlBLG1CQUFKLEVBQXlCO0VBQUEsb0NBQ0dsRCxtQkFBbUIsQ0FBQzdELFVBRHZCO0VBQUEsWUFDaEJDLElBRGdCLHlCQUNoQkEsSUFEZ0I7RUFBQSxZQUNWQyxTQURVLHlCQUNWQSxTQURVO0VBRXZCZ0gsUUFBQUEscUJBQXFCLENBQUMsWUFBTTtFQUMxQixVQUFBLE1BQUksQ0FBQ2pJLFFBQUwsQ0FBY2lGLFFBQWQsQ0FBdUJqRSxJQUF2Qjs7RUFDQSxjQUFJLE1BQUksQ0FBQ2hCLFFBQUwsQ0FBYzhFLFdBQWQsRUFBSixFQUFpQztFQUMvQixZQUFBLE1BQUksQ0FBQzlFLFFBQUwsQ0FBY2lGLFFBQWQsQ0FBdUJoRSxTQUF2QixFQUQrQjs7O0VBRy9CLFlBQUEsTUFBSSxDQUFDaUgsZUFBTDtFQUNEO0VBQ0YsU0FQb0IsQ0FBckI7RUFRRDtFQUNGO0VBRUQ7Ozs7Z0NBQ1U7RUFBQTs7RUFDUixVQUFJLEtBQUtILG9CQUFMLEVBQUosRUFBaUM7RUFDL0IsWUFBSSxLQUFLYixnQkFBVCxFQUEyQjtFQUN6QmlCLFVBQUFBLFlBQVksQ0FBQyxLQUFLakIsZ0JBQU4sQ0FBWjtFQUNBLGVBQUtBLGdCQUFMLEdBQXdCLENBQXhCO0VBQ0EsZUFBS2xILFFBQUwsQ0FBY2tGLFdBQWQsQ0FBMEJOLG1CQUFtQixDQUFDN0QsVUFBcEIsQ0FBK0JJLGFBQXpEO0VBQ0Q7O0VBRUQsWUFBSSxLQUFLZ0csMkJBQVQsRUFBc0M7RUFDcENnQixVQUFBQSxZQUFZLENBQUMsS0FBS2hCLDJCQUFOLENBQVo7RUFDQSxlQUFLQSwyQkFBTCxHQUFtQyxDQUFuQztFQUNBLGVBQUtuSCxRQUFMLENBQWNrRixXQUFkLENBQTBCTixtQkFBbUIsQ0FBQzdELFVBQXBCLENBQStCSyxlQUF6RDtFQUNEOztFQVg4QixxQ0FhTHdELG1CQUFtQixDQUFDN0QsVUFiZjtFQUFBLFlBYXhCQyxJQWJ3QiwwQkFheEJBLElBYndCO0VBQUEsWUFhbEJDLFNBYmtCLDBCQWFsQkEsU0Fia0I7RUFjL0JnSCxRQUFBQSxxQkFBcUIsQ0FBQyxZQUFNO0VBQzFCLFVBQUEsTUFBSSxDQUFDakksUUFBTCxDQUFja0YsV0FBZCxDQUEwQmxFLElBQTFCOztFQUNBLFVBQUEsTUFBSSxDQUFDaEIsUUFBTCxDQUFja0YsV0FBZCxDQUEwQmpFLFNBQTFCOztFQUNBLFVBQUEsTUFBSSxDQUFDbUgsY0FBTDtFQUNELFNBSm9CLENBQXJCO0VBS0Q7O0VBRUQsV0FBS0MsdUJBQUw7RUFDQSxXQUFLQywrQkFBTDtFQUNEO0VBRUQ7Ozs7Ozs7NENBSXNCUixxQkFBcUI7RUFBQTs7RUFDekMsVUFBSUEsbUJBQUosRUFBeUI7RUFDdkJyRCxRQUFBQSxzQkFBc0IsQ0FBQzhELE9BQXZCLENBQStCLFVBQUMvTixJQUFELEVBQVU7RUFDdkMsVUFBQSxNQUFJLENBQUN3RixRQUFMLENBQWNvRiwwQkFBZCxDQUF5QzVLLElBQXpDLEVBQStDLE1BQUksQ0FBQzhMLGdCQUFwRDtFQUNELFNBRkQ7O0VBR0EsWUFBSSxLQUFLdEcsUUFBTCxDQUFjOEUsV0FBZCxFQUFKLEVBQWlDO0VBQy9CLGVBQUs5RSxRQUFMLENBQWN3RixxQkFBZCxDQUFvQyxLQUFLc0IsY0FBekM7RUFDRDtFQUNGOztFQUVELFdBQUs5RyxRQUFMLENBQWNvRiwwQkFBZCxDQUF5QyxPQUF6QyxFQUFrRCxLQUFLc0IsYUFBdkQ7RUFDQSxXQUFLMUcsUUFBTCxDQUFjb0YsMEJBQWQsQ0FBeUMsTUFBekMsRUFBaUQsS0FBS3dCLFlBQXREO0VBQ0Q7RUFFRDs7Ozs7OztvREFJOEIvTixHQUFHO0VBQUE7O0VBQy9CLFVBQUlBLENBQUMsQ0FBQzJCLElBQUYsS0FBVyxTQUFmLEVBQTBCO0VBQ3hCLGFBQUt3RixRQUFMLENBQWNvRiwwQkFBZCxDQUF5QyxPQUF6QyxFQUFrRCxLQUFLb0Isa0JBQXZEO0VBQ0QsT0FGRCxNQUVPO0VBQ0w5QixRQUFBQSxnQ0FBZ0MsQ0FBQzZELE9BQWpDLENBQXlDLFVBQUMvTixJQUFELEVBQVU7RUFDakQsVUFBQSxNQUFJLENBQUN3RixRQUFMLENBQWNzRixrQ0FBZCxDQUFpRDlLLElBQWpELEVBQXVELE1BQUksQ0FBQ2dNLGtCQUE1RDtFQUNELFNBRkQ7RUFHRDtFQUNGO0VBRUQ7Ozs7Z0RBQzBCO0VBQUE7O0VBQ3hCL0IsTUFBQUEsc0JBQXNCLENBQUM4RCxPQUF2QixDQUErQixVQUFDL04sSUFBRCxFQUFVO0VBQ3ZDLFFBQUEsTUFBSSxDQUFDd0YsUUFBTCxDQUFjcUYsNEJBQWQsQ0FBMkM3SyxJQUEzQyxFQUFpRCxNQUFJLENBQUM4TCxnQkFBdEQ7RUFDRCxPQUZEO0VBR0EsV0FBS3RHLFFBQUwsQ0FBY3FGLDRCQUFkLENBQTJDLE9BQTNDLEVBQW9ELEtBQUtxQixhQUF6RDtFQUNBLFdBQUsxRyxRQUFMLENBQWNxRiw0QkFBZCxDQUEyQyxNQUEzQyxFQUFtRCxLQUFLdUIsWUFBeEQ7O0VBRUEsVUFBSSxLQUFLNUcsUUFBTCxDQUFjOEUsV0FBZCxFQUFKLEVBQWlDO0VBQy9CLGFBQUs5RSxRQUFMLENBQWN5Rix1QkFBZCxDQUFzQyxLQUFLcUIsY0FBM0M7RUFDRDtFQUNGO0VBRUQ7Ozs7d0RBQ2tDO0VBQUE7O0VBQ2hDLFdBQUs5RyxRQUFMLENBQWNxRiw0QkFBZCxDQUEyQyxPQUEzQyxFQUFvRCxLQUFLbUIsa0JBQXpEO0VBQ0E5QixNQUFBQSxnQ0FBZ0MsQ0FBQzZELE9BQWpDLENBQXlDLFVBQUMvTixJQUFELEVBQVU7RUFDakQsUUFBQSxNQUFJLENBQUN3RixRQUFMLENBQWN1RixvQ0FBZCxDQUFtRC9LLElBQW5ELEVBQXlELE1BQUksQ0FBQ2dNLGtCQUE5RDtFQUNELE9BRkQ7RUFHRDtFQUVEOzs7O3VDQUNpQjtFQUFBOztFQUFBLFVBQ1JuRixVQURRLEdBQ0d1RCxtQkFESCxDQUNSdkQsT0FEUTtFQUVmekcsTUFBQUEsTUFBTSxDQUFDNE4sSUFBUCxDQUFZbkgsVUFBWixFQUFxQmtILE9BQXJCLENBQTZCLFVBQUNFLENBQUQsRUFBTztFQUNsQyxZQUFJQSxDQUFDLENBQUNDLE9BQUYsQ0FBVSxNQUFWLE1BQXNCLENBQTFCLEVBQTZCO0VBQzNCLFVBQUEsTUFBSSxDQUFDMUksUUFBTCxDQUFjMEYsaUJBQWQsQ0FBZ0NyRSxVQUFPLENBQUNvSCxDQUFELENBQXZDLEVBQTRDLElBQTVDO0VBQ0Q7RUFDRixPQUpEO0VBS0Q7RUFFRDs7Ozs7OztnQ0FJVTVQLEdBQUc7RUFBQTs7RUFDWCxVQUFJLEtBQUttSCxRQUFMLENBQWNnRixpQkFBZCxFQUFKLEVBQXVDO0VBQ3JDO0VBQ0Q7O0VBRUQsVUFBTTJELGVBQWUsR0FBRyxLQUFLekMsZ0JBQTdCOztFQUNBLFVBQUl5QyxlQUFlLENBQUNuQixXQUFwQixFQUFpQztFQUMvQjtFQUNELE9BUlU7OztFQVdYLFVBQU1vQix1QkFBdUIsR0FBRyxLQUFLckIsd0JBQXJDO0VBQ0EsVUFBTXNCLGlCQUFpQixHQUFHRCx1QkFBdUIsSUFBSS9QLENBQUMsS0FBS0wsU0FBakMsSUFBOENvUSx1QkFBdUIsQ0FBQ3BPLElBQXhCLEtBQWlDM0IsQ0FBQyxDQUFDMkIsSUFBM0c7O0VBQ0EsVUFBSXFPLGlCQUFKLEVBQXVCO0VBQ3JCO0VBQ0Q7O0VBRURGLE1BQUFBLGVBQWUsQ0FBQ25CLFdBQWhCLEdBQThCLElBQTlCO0VBQ0FtQixNQUFBQSxlQUFlLENBQUNkLGNBQWhCLEdBQWlDaFAsQ0FBQyxLQUFLTCxTQUF2QztFQUNBbVEsTUFBQUEsZUFBZSxDQUFDZixlQUFoQixHQUFrQy9PLENBQWxDO0VBQ0E4UCxNQUFBQSxlQUFlLENBQUNqQixxQkFBaEIsR0FBd0NpQixlQUFlLENBQUNkLGNBQWhCLEdBQWlDLEtBQWpDLEdBQXlDaFAsQ0FBQyxLQUFLTCxTQUFOLEtBQy9FSyxDQUFDLENBQUMyQixJQUFGLEtBQVcsV0FBWCxJQUEwQjNCLENBQUMsQ0FBQzJCLElBQUYsS0FBVyxZQUFyQyxJQUFxRDNCLENBQUMsQ0FBQzJCLElBQUYsS0FBVyxhQURlLENBQWpGO0VBSUEsVUFBTXNPLGlCQUFpQixHQUFHalEsQ0FBQyxLQUFLTCxTQUFOLElBQW1CbU0sZ0JBQWdCLENBQUNuQixNQUFqQixHQUEwQixDQUE3QyxJQUFrRG1CLGdCQUFnQixDQUFDb0UsSUFBakIsQ0FDMUUsVUFBQy9LLE1BQUQ7RUFBQSxlQUFZLE1BQUksQ0FBQ2dDLFFBQUwsQ0FBY21GLG1CQUFkLENBQWtDbkgsTUFBbEMsQ0FBWjtFQUFBLE9BRDBFLENBQTVFOztFQUVBLFVBQUk4SyxpQkFBSixFQUF1QjtFQUNyQjtFQUNBLGFBQUtFLHFCQUFMO0VBQ0E7RUFDRDs7RUFFRCxVQUFJblEsQ0FBQyxLQUFLTCxTQUFWLEVBQXFCO0VBQ25CbU0sUUFBQUEsZ0JBQWdCLENBQUNzRSxJQUFqQjtFQUFzQjtFQUE2QnBRLFFBQUFBLENBQUMsQ0FBQ21GLE1BQXJEO0VBQ0EsYUFBS2tMLDZCQUFMLENBQW1DclEsQ0FBbkM7RUFDRDs7RUFFRDhQLE1BQUFBLGVBQWUsQ0FBQ2hCLG9CQUFoQixHQUF1QyxLQUFLd0IsdUJBQUwsQ0FBNkJ0USxDQUE3QixDQUF2Qzs7RUFDQSxVQUFJOFAsZUFBZSxDQUFDaEIsb0JBQXBCLEVBQTBDO0VBQ3hDLGFBQUt5QixrQkFBTDtFQUNEOztFQUVEbkIsTUFBQUEscUJBQXFCLENBQUMsWUFBTTtFQUMxQjtFQUNBdEQsUUFBQUEsZ0JBQWdCLEdBQUcsRUFBbkI7O0VBRUEsWUFBSSxDQUFDZ0UsZUFBZSxDQUFDaEIsb0JBQWpCLElBQXlDOU8sQ0FBQyxLQUFLTCxTQUEvQyxLQUE2REssQ0FBQyxDQUFDWSxHQUFGLEtBQVUsR0FBVixJQUFpQlosQ0FBQyxDQUFDd1EsT0FBRixLQUFjLEVBQTVGLENBQUosRUFBcUc7RUFDbkc7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0FWLFVBQUFBLGVBQWUsQ0FBQ2hCLG9CQUFoQixHQUF1QyxNQUFJLENBQUN3Qix1QkFBTCxDQUE2QnRRLENBQTdCLENBQXZDOztFQUNBLGNBQUk4UCxlQUFlLENBQUNoQixvQkFBcEIsRUFBMEM7RUFDeEMsWUFBQSxNQUFJLENBQUN5QixrQkFBTDtFQUNEO0VBQ0Y7O0VBRUQsWUFBSSxDQUFDVCxlQUFlLENBQUNoQixvQkFBckIsRUFBMkM7RUFDekM7RUFDQSxVQUFBLE1BQUksQ0FBQ3pCLGdCQUFMLEdBQXdCLE1BQUksQ0FBQ0MsdUJBQUwsRUFBeEI7RUFDRDtFQUNGLE9BckJvQixDQUFyQjtFQXNCRDtFQUVEOzs7Ozs7OzhDQUl3QnROLEdBQUc7RUFDekIsYUFBUUEsQ0FBQyxLQUFLTCxTQUFOLElBQW1CSyxDQUFDLENBQUMyQixJQUFGLEtBQVcsU0FBL0IsR0FBNEMsS0FBS3dGLFFBQUwsQ0FBYytFLGVBQWQsRUFBNUMsR0FBOEUsSUFBckY7RUFDRDtFQUVEOzs7Ozs7K0JBR1NsSCxPQUFPO0VBQ2QsV0FBSzBJLFNBQUwsQ0FBZTFJLEtBQWY7RUFDRDtFQUVEOzs7OzJDQUNxQjtFQUFBOztFQUFBLG1DQUNvQytHLG1CQUFtQixDQUFDdkQsT0FEeEQ7RUFBQSxVQUNaSyxzQkFEWSwwQkFDWkEsc0JBRFk7RUFBQSxVQUNZQyxvQkFEWiwwQkFDWUEsb0JBRFo7RUFBQSxtQ0FFc0JpRCxtQkFBbUIsQ0FBQzdELFVBRjFDO0VBQUEsVUFFWkssZUFGWSwwQkFFWkEsZUFGWTtFQUFBLFVBRUtELGFBRkwsMEJBRUtBLGFBRkw7RUFBQSxVQUdaWSx1QkFIWSxHQUdlNkMsbUJBQW1CLENBQUNoRCxPQUhuQyxDQUdaRyx1QkFIWTtFQUtuQixXQUFLbUcsZUFBTDtFQUVBLFVBQUlvQixjQUFjLEdBQUcsRUFBckI7RUFDQSxVQUFJQyxZQUFZLEdBQUcsRUFBbkI7O0VBRUEsVUFBSSxDQUFDLEtBQUt2SixRQUFMLENBQWM4RSxXQUFkLEVBQUwsRUFBa0M7RUFBQSxvQ0FDRCxLQUFLMEUsNEJBQUwsRUFEQztFQUFBLFlBQ3pCQyxVQUR5Qix5QkFDekJBLFVBRHlCO0VBQUEsWUFDYkMsUUFEYSx5QkFDYkEsUUFEYTs7RUFFaENKLFFBQUFBLGNBQWMsYUFBTUcsVUFBVSxDQUFDM0YsQ0FBakIsaUJBQXlCMkYsVUFBVSxDQUFDMUYsQ0FBcEMsT0FBZDtFQUNBd0YsUUFBQUEsWUFBWSxhQUFNRyxRQUFRLENBQUM1RixDQUFmLGlCQUF1QjRGLFFBQVEsQ0FBQzNGLENBQWhDLE9BQVo7RUFDRDs7RUFFRCxXQUFLL0QsUUFBTCxDQUFjMEYsaUJBQWQsQ0FBZ0NoRSxzQkFBaEMsRUFBd0Q0SCxjQUF4RDtFQUNBLFdBQUt0SixRQUFMLENBQWMwRixpQkFBZCxDQUFnQy9ELG9CQUFoQyxFQUFzRDRILFlBQXRELEVBakJtQjs7RUFtQm5CcEIsTUFBQUEsWUFBWSxDQUFDLEtBQUtqQixnQkFBTixDQUFaO0VBQ0FpQixNQUFBQSxZQUFZLENBQUMsS0FBS2hCLDJCQUFOLENBQVo7RUFDQSxXQUFLd0MsMkJBQUw7RUFDQSxXQUFLM0osUUFBTCxDQUFja0YsV0FBZCxDQUEwQjlELGVBQTFCLEVBdEJtQjs7RUF5Qm5CLFdBQUtwQixRQUFMLENBQWMyRixtQkFBZDtFQUNBLFdBQUszRixRQUFMLENBQWNpRixRQUFkLENBQXVCOUQsYUFBdkI7RUFDQSxXQUFLK0YsZ0JBQUwsR0FBd0J0SSxVQUFVLENBQUM7RUFBQSxlQUFNLE9BQUksQ0FBQ3lJLHdCQUFMLEVBQU47RUFBQSxPQUFELEVBQXdDdEYsdUJBQXhDLENBQWxDO0VBQ0Q7RUFFRDs7Ozs7OztxREFJK0I7RUFBQSxrQ0FDb0IsS0FBS21FLGdCQUR6QjtFQUFBLFVBQ3RCMEIsZUFEc0IseUJBQ3RCQSxlQURzQjtFQUFBLFVBQ0xGLHFCQURLLHlCQUNMQSxxQkFESztFQUc3QixVQUFJK0IsVUFBSjs7RUFDQSxVQUFJL0IscUJBQUosRUFBMkI7RUFDekIrQixRQUFBQSxVQUFVLEdBQUcvRix3QkFBd0I7RUFDbkM7RUFBdUJrRSxRQUFBQSxlQURZLEVBRW5DLEtBQUs1SCxRQUFMLENBQWM0RixtQkFBZCxFQUZtQyxFQUVFLEtBQUs1RixRQUFMLENBQWMyRixtQkFBZCxFQUZGLENBQXJDO0VBSUQsT0FMRCxNQUtPO0VBQ0w4RCxRQUFBQSxVQUFVLEdBQUc7RUFDWDNGLFVBQUFBLENBQUMsRUFBRSxLQUFLaUMsTUFBTCxDQUFZQyxLQUFaLEdBQW9CLENBRFo7RUFFWGpDLFVBQUFBLENBQUMsRUFBRSxLQUFLZ0MsTUFBTCxDQUFZRSxNQUFaLEdBQXFCO0VBRmIsU0FBYjtFQUlELE9BZDRCOzs7RUFnQjdCd0QsTUFBQUEsVUFBVSxHQUFHO0VBQ1gzRixRQUFBQSxDQUFDLEVBQUUyRixVQUFVLENBQUMzRixDQUFYLEdBQWdCLEtBQUtzQyxZQUFMLEdBQW9CLENBRDVCO0VBRVhyQyxRQUFBQSxDQUFDLEVBQUUwRixVQUFVLENBQUMxRixDQUFYLEdBQWdCLEtBQUtxQyxZQUFMLEdBQW9CO0VBRjVCLE9BQWI7RUFLQSxVQUFNc0QsUUFBUSxHQUFHO0VBQ2Y1RixRQUFBQSxDQUFDLEVBQUcsS0FBS2lDLE1BQUwsQ0FBWUMsS0FBWixHQUFvQixDQUFyQixHQUEyQixLQUFLSSxZQUFMLEdBQW9CLENBRG5DO0VBRWZyQyxRQUFBQSxDQUFDLEVBQUcsS0FBS2dDLE1BQUwsQ0FBWUUsTUFBWixHQUFxQixDQUF0QixHQUE0QixLQUFLRyxZQUFMLEdBQW9CO0VBRnBDLE9BQWpCO0VBS0EsYUFBTztFQUFDcUQsUUFBQUEsVUFBVSxFQUFWQSxVQUFEO0VBQWFDLFFBQUFBLFFBQVEsRUFBUkE7RUFBYixPQUFQO0VBQ0Q7RUFFRDs7Ozt1REFDaUM7RUFBQTs7RUFDL0I7RUFDQTtFQUYrQixVQUd4QnRJLGVBSHdCLEdBR0x3RCxtQkFBbUIsQ0FBQzdELFVBSGYsQ0FHeEJLLGVBSHdCO0VBQUEsbUNBSWEsS0FBSzhFLGdCQUpsQjtFQUFBLFVBSXhCdUIsb0JBSndCLDBCQUl4QkEsb0JBSndCO0VBQUEsVUFJRkQsV0FKRSwwQkFJRkEsV0FKRTtFQUsvQixVQUFNb0Msa0JBQWtCLEdBQUduQyxvQkFBb0IsSUFBSSxDQUFDRCxXQUFwRDs7RUFFQSxVQUFJb0Msa0JBQWtCLElBQUksS0FBS3hDLDRCQUEvQixFQUE2RDtFQUMzRCxhQUFLdUMsMkJBQUw7RUFDQSxhQUFLM0osUUFBTCxDQUFjaUYsUUFBZCxDQUF1QjdELGVBQXZCO0VBQ0EsYUFBSytGLDJCQUFMLEdBQW1DdkksVUFBVSxDQUFDLFlBQU07RUFDbEQsVUFBQSxPQUFJLENBQUNvQixRQUFMLENBQWNrRixXQUFkLENBQTBCOUQsZUFBMUI7RUFDRCxTQUY0QyxFQUUxQ1EsT0FBTyxDQUFDSSxrQkFGa0MsQ0FBN0M7RUFHRDtFQUNGO0VBRUQ7Ozs7b0RBQzhCO0VBQUEsVUFDckJiLGFBRHFCLEdBQ0p5RCxtQkFBbUIsQ0FBQzdELFVBRGhCLENBQ3JCSSxhQURxQjtFQUU1QixXQUFLbkIsUUFBTCxDQUFja0YsV0FBZCxDQUEwQi9ELGFBQTFCO0VBQ0EsV0FBS2lHLDRCQUFMLEdBQW9DLEtBQXBDO0VBQ0EsV0FBS3BILFFBQUwsQ0FBYzJGLG1CQUFkO0VBQ0Q7Ozs4Q0FFdUI7RUFBQTs7RUFDdEIsV0FBSzRCLHdCQUFMLEdBQWdDLEtBQUtyQixnQkFBTCxDQUFzQjBCLGVBQXREO0VBQ0EsV0FBSzFCLGdCQUFMLEdBQXdCLEtBQUtDLHVCQUFMLEVBQXhCLENBRnNCO0VBSXRCOztFQUNBdkgsTUFBQUEsVUFBVSxDQUFDO0VBQUEsZUFBTSxPQUFJLENBQUMySSx3QkFBTCxHQUFnQy9PLFNBQXRDO0VBQUEsT0FBRCxFQUFrRG9NLG1CQUFtQixDQUFDaEQsT0FBcEIsQ0FBNEJLLFlBQTlFLENBQVY7RUFDRDtFQUVEOzs7Ozs7b0NBR2M7RUFBQTs7RUFDWixVQUFNMEcsZUFBZSxHQUFHLEtBQUt6QyxnQkFBN0IsQ0FEWTs7RUFHWixVQUFJLENBQUN5QyxlQUFlLENBQUNuQixXQUFyQixFQUFrQztFQUNoQztFQUNEOztFQUVELFVBQU1xQyxLQUFLO0VBQUc7RUFBcUMsZUFBYyxFQUFkLEVBQWtCbEIsZUFBbEIsQ0FBbkQ7O0VBRUEsVUFBSUEsZUFBZSxDQUFDZCxjQUFwQixFQUFvQztFQUNsQ0ksUUFBQUEscUJBQXFCLENBQUM7RUFBQSxpQkFBTSxPQUFJLENBQUM2QixvQkFBTCxDQUEwQkQsS0FBMUIsQ0FBTjtFQUFBLFNBQUQsQ0FBckI7RUFDQSxhQUFLYixxQkFBTDtFQUNELE9BSEQsTUFHTztFQUNMLGFBQUtWLCtCQUFMO0VBQ0FMLFFBQUFBLHFCQUFxQixDQUFDLFlBQU07RUFDMUIsVUFBQSxPQUFJLENBQUMvQixnQkFBTCxDQUFzQnVCLG9CQUF0QixHQUE2QyxJQUE3Qzs7RUFDQSxVQUFBLE9BQUksQ0FBQ3FDLG9CQUFMLENBQTBCRCxLQUExQjs7RUFDQSxVQUFBLE9BQUksQ0FBQ2IscUJBQUw7RUFDRCxTQUpvQixDQUFyQjtFQUtEO0VBQ0Y7OzttQ0FFWTtFQUNYLFdBQUt2QyxXQUFMO0VBQ0Q7RUFFRDs7Ozs7OztpREFJb0U7RUFBQSxVQUE5Q2lCLHFCQUE4QyxRQUE5Q0EscUJBQThDO0VBQUEsVUFBdkJDLG9CQUF1QixRQUF2QkEsb0JBQXVCOztFQUNsRSxVQUFJRCxxQkFBcUIsSUFBSUMsb0JBQTdCLEVBQW1EO0VBQ2pELGFBQUtMLDhCQUFMO0VBQ0Q7RUFDRjs7OytCQUVRO0VBQUE7O0VBQ1AsVUFBSSxLQUFLeEIsWUFBVCxFQUF1QjtFQUNyQmlFLFFBQUFBLG9CQUFvQixDQUFDLEtBQUtqRSxZQUFOLENBQXBCO0VBQ0Q7O0VBQ0QsV0FBS0EsWUFBTCxHQUFvQm1DLHFCQUFxQixDQUFDLFlBQU07RUFDOUMsUUFBQSxPQUFJLENBQUNDLGVBQUw7O0VBQ0EsUUFBQSxPQUFJLENBQUNwQyxZQUFMLEdBQW9CLENBQXBCO0VBQ0QsT0FId0MsQ0FBekM7RUFJRDtFQUVEOzs7O3dDQUNrQjtFQUFBOztFQUNoQixXQUFLQyxNQUFMLEdBQWMsS0FBSy9GLFFBQUwsQ0FBYzJGLG1CQUFkLEVBQWQ7RUFDQSxVQUFNcUUsTUFBTSxHQUFHMUssSUFBSSxDQUFDMkssR0FBTCxDQUFTLEtBQUtsRSxNQUFMLENBQVlFLE1BQXJCLEVBQTZCLEtBQUtGLE1BQUwsQ0FBWUMsS0FBekMsQ0FBZixDQUZnQjtFQUtoQjtFQUNBO0VBQ0E7RUFDQTtFQUNBOztFQUNBLFVBQU1rRSxnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLEdBQU07RUFDN0IsWUFBTUMsVUFBVSxHQUFHN0ssSUFBSSxDQUFDOEssSUFBTCxDQUFVOUssSUFBSSxDQUFDK0ssR0FBTCxDQUFTLE9BQUksQ0FBQ3RFLE1BQUwsQ0FBWUMsS0FBckIsRUFBNEIsQ0FBNUIsSUFBaUMxRyxJQUFJLENBQUMrSyxHQUFMLENBQVMsT0FBSSxDQUFDdEUsTUFBTCxDQUFZRSxNQUFyQixFQUE2QixDQUE3QixDQUEzQyxDQUFuQjtFQUNBLGVBQU9rRSxVQUFVLEdBQUd2RixtQkFBbUIsQ0FBQ2hELE9BQXBCLENBQTRCQyxPQUFoRDtFQUNELE9BSEQ7O0VBS0EsV0FBS3dFLFVBQUwsR0FBa0IsS0FBS3JHLFFBQUwsQ0FBYzhFLFdBQWQsS0FBOEJrRixNQUE5QixHQUF1Q0UsZ0JBQWdCLEVBQXpFLENBZmdCOztFQWtCaEIsV0FBSzlELFlBQUwsR0FBb0I5RyxJQUFJLENBQUNDLEtBQUwsQ0FBV3lLLE1BQU0sR0FBR3BGLG1CQUFtQixDQUFDaEQsT0FBcEIsQ0FBNEJFLG9CQUFoRCxDQUFwQjtFQUNBLFdBQUttRixRQUFMLEdBQWdCLEtBQUtaLFVBQUwsR0FBa0IsS0FBS0QsWUFBdkM7RUFFQSxXQUFLa0Usb0JBQUw7RUFDRDtFQUVEOzs7OzZDQUN1QjtFQUFBLG1DQUdqQjFGLG1CQUFtQixDQUFDdkQsT0FISDtFQUFBLFVBRW5CRyxXQUZtQiwwQkFFbkJBLFdBRm1CO0VBQUEsVUFFTkYsUUFGTSwwQkFFTkEsUUFGTTtFQUFBLFVBRUlDLE9BRkosMEJBRUlBLE9BRko7RUFBQSxVQUVhRSxZQUZiLDBCQUVhQSxZQUZiO0VBS3JCLFdBQUt6QixRQUFMLENBQWMwRixpQkFBZCxDQUFnQ2xFLFdBQWhDLFlBQWdELEtBQUs0RSxZQUFyRDtFQUNBLFdBQUtwRyxRQUFMLENBQWMwRixpQkFBZCxDQUFnQ2pFLFlBQWhDLEVBQThDLEtBQUt3RixRQUFuRDs7RUFFQSxVQUFJLEtBQUtqSCxRQUFMLENBQWM4RSxXQUFkLEVBQUosRUFBaUM7RUFDL0IsYUFBS2tDLGdCQUFMLEdBQXdCO0VBQ3RCL0MsVUFBQUEsSUFBSSxFQUFFM0UsSUFBSSxDQUFDaUwsS0FBTCxDQUFZLEtBQUt4RSxNQUFMLENBQVlDLEtBQVosR0FBb0IsQ0FBckIsR0FBMkIsS0FBS0ksWUFBTCxHQUFvQixDQUExRCxDQURnQjtFQUV0QmpDLFVBQUFBLEdBQUcsRUFBRTdFLElBQUksQ0FBQ2lMLEtBQUwsQ0FBWSxLQUFLeEUsTUFBTCxDQUFZRSxNQUFaLEdBQXFCLENBQXRCLEdBQTRCLEtBQUtHLFlBQUwsR0FBb0IsQ0FBM0Q7RUFGaUIsU0FBeEI7RUFLQSxhQUFLcEcsUUFBTCxDQUFjMEYsaUJBQWQsQ0FBZ0NwRSxRQUFoQyxZQUE2QyxLQUFLMEYsZ0JBQUwsQ0FBc0IvQyxJQUFuRTtFQUNBLGFBQUtqRSxRQUFMLENBQWMwRixpQkFBZCxDQUFnQ25FLE9BQWhDLFlBQTRDLEtBQUt5RixnQkFBTCxDQUFzQjdDLEdBQWxFO0VBQ0Q7RUFDRjtFQUVEOzs7O21DQUNhcUcsV0FBVztFQUFBLFVBQ2Z2SixTQURlLEdBQ0YyRCxtQkFBbUIsQ0FBQzdELFVBRGxCLENBQ2ZFLFNBRGU7O0VBRXRCLFVBQUl1SixTQUFKLEVBQWU7RUFDYixhQUFLeEssUUFBTCxDQUFjaUYsUUFBZCxDQUF1QmhFLFNBQXZCO0VBQ0QsT0FGRCxNQUVPO0VBQ0wsYUFBS2pCLFFBQUwsQ0FBY2tGLFdBQWQsQ0FBMEJqRSxTQUExQjtFQUNEO0VBQ0Y7OztvQ0FFYTtFQUFBOztFQUNaZ0gsTUFBQUEscUJBQXFCLENBQUM7RUFBQSxlQUNwQixPQUFJLENBQUNqSSxRQUFMLENBQWNpRixRQUFkLENBQXVCTCxtQkFBbUIsQ0FBQzdELFVBQXBCLENBQStCRyxVQUF0RCxDQURvQjtFQUFBLE9BQUQsQ0FBckI7RUFFRDs7O21DQUVZO0VBQUE7O0VBQ1grRyxNQUFBQSxxQkFBcUIsQ0FBQztFQUFBLGVBQ3BCLE9BQUksQ0FBQ2pJLFFBQUwsQ0FBY2tGLFdBQWQsQ0FBMEJOLG1CQUFtQixDQUFDN0QsVUFBcEIsQ0FBK0JHLFVBQXpELENBRG9CO0VBQUEsT0FBRCxDQUFyQjtFQUVEOzs7O0lBNWdCK0JwQjs7RUNyRGxDOzs7O01BR00ySzs7Ozs7RUFDSjtFQUNBLHVCQUFxQjtFQUFBOztFQUFBOztFQUFBOztFQUFBLHNDQUFOdk0sSUFBTTtFQUFOQSxNQUFBQSxJQUFNO0VBQUE7O0VBQ25CLHdJQUFTQSxJQUFUO0VBRUE7O0VBQ0EsVUFBS2xCLFFBQUwsR0FBZ0IsS0FBaEI7RUFFQTs7RUFDQSxVQUFLME4sVUFBTDtFQVBtQjtFQVFwQjtFQUVEOzs7Ozs7Ozs7O0VBd0RBOzs7Ozs7O3NDQU9nQjtFQUNkLFdBQUtwSyxXQUFMLENBQWlCcUssWUFBakIsQ0FBOEIsS0FBS0QsVUFBbkM7RUFDRDs7O2lDQUVVO0VBQ1QsV0FBS3BLLFdBQUwsQ0FBaUJzSyxRQUFqQjtFQUNEOzs7bUNBRVk7RUFDWCxXQUFLdEssV0FBTCxDQUFpQnVLLFVBQWpCO0VBQ0Q7OzsrQkFFUTtFQUNQLFdBQUt2SyxXQUFMLENBQWlCeUcsTUFBakI7RUFDRDtFQUVEOzs7Ozs7OzZDQUl1QjtFQUNyQixhQUFPLElBQUluQyxtQkFBSixDQUF3QjZGLFNBQVMsQ0FBQ0ssYUFBVixDQUF3QixJQUF4QixDQUF4QixDQUFQO0VBQ0Q7RUFFRDs7OzsyQ0FDcUI7RUFDbkIsV0FBS04sU0FBTCxHQUFpQiwwQkFBMEIsS0FBS3BLLEtBQUwsQ0FBVzJLLE9BQXREO0VBQ0Q7Ozs7RUE3Q0Q7MEJBQ2dCO0VBQ2QsYUFBTyxLQUFLTCxVQUFaO0VBQ0Q7RUFFRDs7d0JBQ2NGLFdBQVc7RUFDdkIsV0FBS0UsVUFBTCxHQUFrQmpQLE9BQU8sQ0FBQytPLFNBQUQsQ0FBekI7RUFDQSxXQUFLUSxhQUFMO0VBQ0Q7OzsrQkFqRGU5SyxNQUFzQztFQUFBLHFGQUFKLEVBQUk7RUFBQSxrQ0FBL0I0RSxXQUErQjtFQUFBLFVBQS9CQSxXQUErQixpQ0FBakJ0TSxTQUFpQjs7RUFDcEQsVUFBTXlTLE1BQU0sR0FBRyxJQUFJUixTQUFKLENBQWN2SyxJQUFkLENBQWYsQ0FEb0Q7O0VBR3BELFVBQUk0RSxXQUFXLEtBQUt0TSxTQUFwQixFQUErQjtFQUM3QnlTLFFBQUFBLE1BQU0sQ0FBQ1QsU0FBUDtFQUFtQjtFQUF3QjFGLFFBQUFBLFdBQTNDO0VBQ0Q7O0VBQ0QsYUFBT21HLE1BQVA7RUFDRDtFQUVEOzs7Ozs7O29DQUlxQkMsVUFBVTtFQUM3QixVQUFNQyxPQUFPLEdBQUdDLGtCQUFBLENBQXdCQyxXQUFXLENBQUNDLFNBQXBDLENBQWhCO0VBRUEsYUFBTztFQUNMekcsUUFBQUEsc0JBQXNCLEVBQUU7RUFBQSxpQkFBTXVHLG9CQUFBLENBQTBCOVMsTUFBMUIsQ0FBTjtFQUFBLFNBRG5CO0VBRUx3TSxRQUFBQSxXQUFXLEVBQUU7RUFBQSxpQkFBTW9HLFFBQVEsQ0FBQ1YsU0FBZjtFQUFBLFNBRlI7RUFHTHpGLFFBQUFBLGVBQWUsRUFBRTtFQUFBLGlCQUFNbUcsUUFBUSxDQUFDOUssS0FBVCxDQUFlK0ssT0FBZixFQUF3QixTQUF4QixDQUFOO0VBQUEsU0FIWjtFQUlMbkcsUUFBQUEsaUJBQWlCLEVBQUU7RUFBQSxpQkFBTWtHLFFBQVEsQ0FBQ2xPLFFBQWY7RUFBQSxTQUpkO0VBS0xpSSxRQUFBQSxRQUFRLEVBQUUsa0JBQUN4SCxTQUFEO0VBQUEsaUJBQWV5TixRQUFRLENBQUM5SyxLQUFULENBQWVtTCxTQUFmLENBQXlCQyxHQUF6QixDQUE2Qi9OLFNBQTdCLENBQWY7RUFBQSxTQUxMO0VBTUx5SCxRQUFBQSxXQUFXLEVBQUUscUJBQUN6SCxTQUFEO0VBQUEsaUJBQWV5TixRQUFRLENBQUM5SyxLQUFULENBQWVtTCxTQUFmLENBQXlCM0ksTUFBekIsQ0FBZ0NuRixTQUFoQyxDQUFmO0VBQUEsU0FOUjtFQU9MMEgsUUFBQUEsbUJBQW1CLEVBQUUsNkJBQUNuSCxNQUFEO0VBQUEsaUJBQVlrTixRQUFRLENBQUM5SyxLQUFULENBQWVuQixRQUFmLENBQXdCakIsTUFBeEIsQ0FBWjtFQUFBLFNBUGhCO0VBUUxvSCxRQUFBQSwwQkFBMEIsRUFBRSxvQ0FBQ25KLE9BQUQsRUFBVTJFLE9BQVY7RUFBQSxpQkFDMUJzSyxRQUFRLENBQUM5SyxLQUFULENBQWV6SCxnQkFBZixDQUFnQ3NELE9BQWhDLEVBQXlDMkUsT0FBekMsRUFBa0R3SyxjQUFBLEVBQWxELENBRDBCO0VBQUEsU0FSdkI7RUFVTC9GLFFBQUFBLDRCQUE0QixFQUFFLHNDQUFDcEosT0FBRCxFQUFVMkUsT0FBVjtFQUFBLGlCQUM1QnNLLFFBQVEsQ0FBQzlLLEtBQVQsQ0FBZWhCLG1CQUFmLENBQW1DbkQsT0FBbkMsRUFBNEMyRSxPQUE1QyxFQUFxRHdLLGNBQUEsRUFBckQsQ0FENEI7RUFBQSxTQVZ6QjtFQVlMOUYsUUFBQUEsa0NBQWtDLEVBQUUsNENBQUNySixPQUFELEVBQVUyRSxPQUFWO0VBQUEsaUJBQ2xDbEksUUFBUSxDQUFDK1MsZUFBVCxDQUF5QjlTLGdCQUF6QixDQUEwQ3NELE9BQTFDLEVBQW1EMkUsT0FBbkQsRUFBNER3SyxjQUFBLEVBQTVELENBRGtDO0VBQUEsU0FaL0I7RUFjTDdGLFFBQUFBLG9DQUFvQyxFQUFFLDhDQUFDdEosT0FBRCxFQUFVMkUsT0FBVjtFQUFBLGlCQUNwQ2xJLFFBQVEsQ0FBQytTLGVBQVQsQ0FBeUJyTSxtQkFBekIsQ0FBNkNuRCxPQUE3QyxFQUFzRDJFLE9BQXRELEVBQStEd0ssY0FBQSxFQUEvRCxDQURvQztFQUFBLFNBZGpDO0VBZ0JMNUYsUUFBQUEscUJBQXFCLEVBQUUsK0JBQUM1RSxPQUFEO0VBQUEsaUJBQWF0SSxNQUFNLENBQUNLLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDaUksT0FBbEMsQ0FBYjtFQUFBLFNBaEJsQjtFQWlCTDZFLFFBQUFBLHVCQUF1QixFQUFFLGlDQUFDN0UsT0FBRDtFQUFBLGlCQUFhdEksTUFBTSxDQUFDOEcsbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUN3QixPQUFyQyxDQUFiO0VBQUEsU0FqQnBCO0VBa0JMOEUsUUFBQUEsaUJBQWlCLEVBQUUsMkJBQUM1RSxPQUFELEVBQVV0RCxLQUFWO0VBQUEsaUJBQW9CME4sUUFBUSxDQUFDOUssS0FBVCxDQUFlc0wsS0FBZixDQUFxQkMsV0FBckIsQ0FBaUM3SyxPQUFqQyxFQUEwQ3RELEtBQTFDLENBQXBCO0VBQUEsU0FsQmQ7RUFtQkxtSSxRQUFBQSxtQkFBbUIsRUFBRTtFQUFBLGlCQUFNdUYsUUFBUSxDQUFDOUssS0FBVCxDQUFld0wscUJBQWYsRUFBTjtFQUFBLFNBbkJoQjtFQW9CTGhHLFFBQUFBLG1CQUFtQixFQUFFO0VBQUEsaUJBQU87RUFBQzlCLFlBQUFBLENBQUMsRUFBRXhMLE1BQU0sQ0FBQ3VULFdBQVg7RUFBd0I5SCxZQUFBQSxDQUFDLEVBQUV6TCxNQUFNLENBQUN3VDtFQUFsQyxXQUFQO0VBQUE7RUFwQmhCLE9BQVA7RUFzQkQ7Ozs7SUF2RHFCN0w7RUF5R3hCOzs7Ozs7O01BS004TDs7O0VBRU47OztFQUNBQSxvQkFBb0IsQ0FBQ1QsU0FBckIsQ0FBK0JsTCxLQUEvQjtFQUVBOzs7OztFQUlBMkwsb0JBQW9CLENBQUNULFNBQXJCLENBQStCZCxTQUEvQjtFQUVBOzs7OztFQUlBdUIsb0JBQW9CLENBQUNULFNBQXJCLENBQStCdE8sUUFBL0I7O01DckphZ1AsVUFBYjtFQUFBO0VBQUE7RUFBQTs7RUFBQTtFQUFBO0VBQUEsb0NBU3lCQyxHQVR6QixFQVM4QjtFQUMxQixhQUFPQSxHQUFHLENBQUNELFVBQVUsQ0FBQ2IsT0FBWixDQUFILENBQXdCLFNBQXhCLENBQVA7RUFDRDtFQVhIO0VBQUE7RUFBQSx3QkFDdUI7RUFDbkI7RUFDQSxhQUNFYSxVQUFVLENBQUNFLFFBQVgsS0FDQ0YsVUFBVSxDQUFDRSxRQUFYLEdBQXNCL0ksa0JBQWtCLENBQUNrSSxXQUFXLENBQUNDLFNBQWIsQ0FEekMsQ0FERjtFQUlEO0VBUEg7O0VBYUUsc0JBQVk5UixFQUFaLEVBQWdCMlMsT0FBaEIsRUFBeUI7RUFBQTs7RUFBQSxtRkFFckIsU0FDRTtFQUNFdEgsTUFBQUEsc0JBQXNCLEVBQUUsa0NBQU07RUFDNUIsZUFBT2hDLG9CQUFvQixDQUFDdkssTUFBRCxDQUEzQjtFQUNELE9BSEg7RUFJRXdNLE1BQUFBLFdBQVcsRUFBRSx1QkFBTTtFQUNqQixlQUFPLEtBQVA7RUFDRCxPQU5IO0VBT0VDLE1BQUFBLGVBQWUsRUFBRSwyQkFBTTtFQUNyQixlQUFPdkwsRUFBRSxDQUFDdUYsR0FBSCxDQUFPaU4sVUFBVSxDQUFDYixPQUFsQixFQUEyQixTQUEzQixDQUFQO0VBQ0QsT0FUSDtFQVVFbkcsTUFBQUEsaUJBQWlCLEVBQUUsNkJBQU07RUFDdkIsZUFBT3hMLEVBQUUsQ0FBQ3dELFFBQVY7RUFDRCxPQVpIO0VBYUVpSSxNQUFBQSxRQWJGLG9CQWFXeEgsU0FiWCxFQWFzQjtFQUNsQmpFLFFBQUFBLEVBQUUsQ0FBQzRTLElBQUgsQ0FBUTVTLEVBQUUsQ0FBQzJELE9BQVgsRUFBb0JNLFNBQXBCLEVBQStCLElBQS9CO0VBQ0QsT0FmSDtFQWdCRXlILE1BQUFBLFdBaEJGLHVCQWdCY3pILFNBaEJkLEVBZ0J5QjtFQUNyQmpFLFFBQUFBLEVBQUUsQ0FBQzZTLE9BQUgsQ0FBVzdTLEVBQUUsQ0FBQzJELE9BQWQsRUFBdUJNLFNBQXZCO0VBQ0QsT0FsQkg7RUFtQkUwSCxNQUFBQSxtQkFBbUIsRUFBRSw2QkFBQW5ILE1BQU07RUFBQSxlQUFJeEUsRUFBRSxDQUFDdUYsR0FBSCxDQUFPRSxRQUFQLENBQWdCakIsTUFBaEIsQ0FBSjtFQUFBLE9BbkI3QjtFQW9CRW9ILE1BQUFBLDBCQUEwQixFQUFFLG9DQUFDaEosR0FBRCxFQUFNd0UsT0FBTixFQUFrQjtFQUM1Q3BILFFBQUFBLEVBQUUsQ0FBQ3VGLEdBQUgsQ0FBT3BHLGdCQUFQLENBQXdCeUQsR0FBeEIsRUFBNkJ3RSxPQUE3QixFQUFzQ3hJLGNBQVksRUFBbEQ7RUFDRCxPQXRCSDtFQXVCRWlOLE1BQUFBLDRCQUE0QixFQUFFLHNDQUFDakosR0FBRCxFQUFNd0UsT0FBTixFQUFrQjtFQUM5Q3BILFFBQUFBLEVBQUUsQ0FBQ3VGLEdBQUgsQ0FBT0ssbUJBQVAsQ0FBMkJoRCxHQUEzQixFQUFnQ3dFLE9BQWhDLEVBQXlDeEksY0FBWSxFQUFyRDtFQUNELE9BekJIO0VBMEJFa04sTUFBQUEsa0NBQWtDLEVBQUUsNENBQUNySixPQUFELEVBQVUyRSxPQUFWO0VBQUEsZUFDbENsSSxRQUFRLENBQUMrUyxlQUFULENBQXlCOVMsZ0JBQXpCLENBQ0VzRCxPQURGLEVBRUUyRSxPQUZGLEVBR0V4SSxjQUFZLEVBSGQsQ0FEa0M7RUFBQSxPQTFCdEM7RUFnQ0VtTixNQUFBQSxvQ0FBb0MsRUFBRSw4Q0FBQ3RKLE9BQUQsRUFBVTJFLE9BQVY7RUFBQSxlQUNwQ2xJLFFBQVEsQ0FBQytTLGVBQVQsQ0FBeUJyTSxtQkFBekIsQ0FDRW5ELE9BREYsRUFFRTJFLE9BRkYsRUFHRXhJLGNBQVksRUFIZCxDQURvQztFQUFBLE9BaEN4QztFQXNDRW9OLE1BQUFBLHFCQUFxQixFQUFFLCtCQUFBNUUsT0FBTyxFQUFJO0VBQ2hDLGVBQU90SSxNQUFNLENBQUNLLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDaUksT0FBbEMsQ0FBUDtFQUNELE9BeENIO0VBeUNFNkUsTUFBQUEsdUJBQXVCLEVBQUUsaUNBQUE3RSxPQUFPLEVBQUk7RUFDbEMsZUFBT3RJLE1BQU0sQ0FBQzhHLG1CQUFQLENBQTJCLFFBQTNCLEVBQXFDd0IsT0FBckMsQ0FBUDtFQUNELE9BM0NIO0VBNENFOEUsTUFBQUEsaUJBQWlCLEVBQUUsMkJBQUM1RSxPQUFELEVBQVV0RCxLQUFWLEVBQW9CO0VBQ3JDaEUsUUFBQUEsRUFBRSxDQUFDNFMsSUFBSCxDQUFRNVMsRUFBRSxDQUFDOFMsTUFBWCxFQUFtQnhMLE9BQW5CLEVBQTRCdEQsS0FBNUI7RUFDRCxPQTlDSDtFQStDRW1JLE1BQUFBLG1CQUFtQixFQUFFLCtCQUFNO0VBQ3pCLGVBQU9uTSxFQUFFLENBQUN1RixHQUFILENBQU82TSxxQkFBUCxFQUFQO0VBQ0QsT0FqREg7RUFrREVoRyxNQUFBQSxtQkFBbUIsRUFBRSwrQkFBTTtFQUN6QixlQUFPO0VBQUU5QixVQUFBQSxDQUFDLEVBQUV4TCxNQUFNLENBQUN1VCxXQUFaO0VBQXlCOUgsVUFBQUEsQ0FBQyxFQUFFekwsTUFBTSxDQUFDd1Q7RUFBbkMsU0FBUDtFQUNEO0VBcERILEtBREYsRUF1REVLLE9BdkRGLENBRnFCO0VBNER4Qjs7RUF6RUg7RUFBQSxFQUFnQ3ZILG1CQUFoQztBQTRFQSxFQUFPLElBQU0ySCxXQUFXLEdBQUc7RUFDekJuUyxFQUFBQSxJQUR5QixrQkFDbEI7RUFDTCxXQUFPO0VBQ0wrQyxNQUFBQSxPQUFPLEVBQUUsRUFESjtFQUVMbVAsTUFBQUEsTUFBTSxFQUFFO0VBRkgsS0FBUDtFQUlELEdBTndCO0VBT3pCcE4sRUFBQUEsT0FQeUIscUJBT2Y7RUFDUixTQUFLK0wsTUFBTCxHQUFjLElBQUllLFVBQUosQ0FBZSxJQUFmLENBQWQ7RUFDQSxTQUFLZixNQUFMLENBQVl6SyxJQUFaO0VBQ0QsR0FWd0I7RUFXekJyQixFQUFBQSxhQVh5QiwyQkFXVDtFQUNkLFNBQUs4TCxNQUFMLENBQVl0SyxPQUFaO0VBQ0Q7RUFid0IsQ0FBcEI7OztBQ3JFUDs7Ozs7O0dBQUE7O0VDZGUsU0FBUzZMLGtCQUFULENBQTRCQyxnQkFBNUIsRUFBOENDLFdBQTlDLEVBQTJEQyxhQUEzRCxFQUEwRUMsT0FBMUUsRUFBbUZDLG9CQUFuRixFQUF5R0M7RUFBaUI7RUFBMUgsRUFBNklDLFlBQTdJLEVBQTJKQyxjQUEzSixFQUEyS0MsaUJBQTNLLEVBQThMQyxvQkFBOUwsRUFBb047RUFDL04sTUFBSSxPQUFPSCxZQUFQLEtBQXdCLFVBQTVCLEVBQXdDO0VBQ3BDRSxJQUFBQSxpQkFBaUIsR0FBR0QsY0FBcEI7RUFDQUEsSUFBQUEsY0FBYyxHQUFHRCxZQUFqQjtFQUNBQSxJQUFBQSxZQUFZLEdBQUcsS0FBZjtFQUNILEdBTDhOOzs7RUFPL04sTUFBTVosT0FBTyxHQUFHLE9BQU9RLGFBQVAsS0FBeUIsVUFBekIsR0FBc0NBLGFBQWEsQ0FBQ1IsT0FBcEQsR0FBOERRLGFBQTlFLENBUCtOOztFQVMvTixNQUFJRixnQkFBZ0IsSUFBSUEsZ0JBQWdCLENBQUMzUyxNQUF6QyxFQUFpRDtFQUM3Q3FTLElBQUFBLE9BQU8sQ0FBQ3JTLE1BQVIsR0FBaUIyUyxnQkFBZ0IsQ0FBQzNTLE1BQWxDO0VBQ0FxUyxJQUFBQSxPQUFPLENBQUNnQixlQUFSLEdBQTBCVixnQkFBZ0IsQ0FBQ1UsZUFBM0M7RUFDQWhCLElBQUFBLE9BQU8sQ0FBQ2lCLFNBQVIsR0FBb0IsSUFBcEIsQ0FINkM7O0VBSzdDLFFBQUlQLG9CQUFKLEVBQTBCO0VBQ3RCVixNQUFBQSxPQUFPLENBQUN0UyxVQUFSLEdBQXFCLElBQXJCO0VBQ0g7RUFDSixHQWpCOE47OztFQW1CL04sTUFBSStTLE9BQUosRUFBYTtFQUNUVCxJQUFBQSxPQUFPLENBQUNrQixRQUFSLEdBQW1CVCxPQUFuQjtFQUNIOztFQUNELE1BQUlVLElBQUo7O0VBQ0EsTUFBSVIsZ0JBQUosRUFBc0I7RUFDbEI7RUFDQVEsSUFBQUEsSUFBSSxHQUFHLGNBQVV0VCxPQUFWLEVBQW1CO0VBQ3RCO0VBQ0FBLE1BQUFBLE9BQU8sR0FDSEEsT0FBTztFQUNGLFdBQUt1VCxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZQyxVQURoQztFQUVLLFdBQUt6UyxNQUFMLElBQWUsS0FBS0EsTUFBTCxDQUFZd1MsTUFBM0IsSUFBcUMsS0FBS3hTLE1BQUwsQ0FBWXdTLE1BQVosQ0FBbUJDLFVBSGpFLENBRnNCO0VBTXRCOztFQUNBLFVBQUksQ0FBQ3hULE9BQUQsSUFBWSxPQUFPeVQsbUJBQVAsS0FBK0IsV0FBL0MsRUFBNEQ7RUFDeER6VCxRQUFBQSxPQUFPLEdBQUd5VCxtQkFBVjtFQUNILE9BVHFCOzs7RUFXdEIsVUFBSWYsV0FBSixFQUFpQjtFQUNiQSxRQUFBQSxXQUFXLENBQUNnQixJQUFaLENBQWlCLElBQWpCLEVBQXVCVCxpQkFBaUIsQ0FBQ2pULE9BQUQsQ0FBeEM7RUFDSCxPQWJxQjs7O0VBZXRCLFVBQUlBLE9BQU8sSUFBSUEsT0FBTyxDQUFDMlQscUJBQXZCLEVBQThDO0VBQzFDM1QsUUFBQUEsT0FBTyxDQUFDMlQscUJBQVIsQ0FBOEJuQyxHQUE5QixDQUFrQ3NCLGdCQUFsQztFQUNIO0VBQ0osS0FsQkQsQ0FGa0I7RUFzQmxCOzs7RUFDQVgsSUFBQUEsT0FBTyxDQUFDeUIsWUFBUixHQUF1Qk4sSUFBdkI7RUFDSCxHQXhCRCxNQXlCSyxJQUFJWixXQUFKLEVBQWlCO0VBQ2xCWSxJQUFBQSxJQUFJLEdBQUdQLFlBQVksR0FDYixZQUFZO0VBQ1ZMLE1BQUFBLFdBQVcsQ0FBQ2dCLElBQVosQ0FBaUIsSUFBakIsRUFBdUJSLG9CQUFvQixDQUFDLEtBQUtqUyxLQUFMLENBQVdDLFFBQVgsQ0FBb0IyUyxVQUFyQixDQUEzQztFQUNILEtBSGMsR0FJYixVQUFVN1QsT0FBVixFQUFtQjtFQUNqQjBTLE1BQUFBLFdBQVcsQ0FBQ2dCLElBQVosQ0FBaUIsSUFBakIsRUFBdUJWLGNBQWMsQ0FBQ2hULE9BQUQsQ0FBckM7RUFDSCxLQU5MO0VBT0g7O0VBQ0QsTUFBSXNULElBQUosRUFBVTtFQUNOLFFBQUluQixPQUFPLENBQUN0UyxVQUFaLEVBQXdCO0VBQ3BCO0VBQ0EsVUFBTWlVLGNBQWMsR0FBRzNCLE9BQU8sQ0FBQ3JTLE1BQS9COztFQUNBcVMsTUFBQUEsT0FBTyxDQUFDclMsTUFBUixHQUFpQixTQUFTaVUsd0JBQVQsQ0FBa0NsVCxDQUFsQyxFQUFxQ2IsT0FBckMsRUFBOEM7RUFDM0RzVCxRQUFBQSxJQUFJLENBQUNJLElBQUwsQ0FBVTFULE9BQVY7RUFDQSxlQUFPOFQsY0FBYyxDQUFDalQsQ0FBRCxFQUFJYixPQUFKLENBQXJCO0VBQ0gsT0FIRDtFQUlILEtBUEQsTUFRSztFQUNEO0VBQ0EsVUFBTWdVLFFBQVEsR0FBRzdCLE9BQU8sQ0FBQ3hNLFlBQXpCO0VBQ0F3TSxNQUFBQSxPQUFPLENBQUN4TSxZQUFSLEdBQXVCcU8sUUFBUSxHQUFHLEdBQUdDLE1BQUgsQ0FBVUQsUUFBVixFQUFvQlYsSUFBcEIsQ0FBSCxHQUErQixDQUFDQSxJQUFELENBQTlEO0VBQ0g7RUFDSjs7RUFDRCxTQUFPWCxhQUFQO0VBQ0g7OztBRHpFRCxFQUVBO0VBQ0E7RUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FFR0EscUJBQWV2VCxVQUFVLENBQUM7RUFDeEI4VSxFQUFBQSxTQUFTLEVBQVRBO0VBRHdCLENBQUQsQ0FBekI7OztBQ1dBOzs7Ozs7Ozs7R0FBQTs7O0FBbEJBLEVBRUE7RUFDQTtBQUNBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0RBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUE7OztBQUhBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNFQSxxQkFBZS9VLFVBQVUsQ0FBQztFQUN4QmdWLEVBQUFBLFNBQVMsRUFBVEE7RUFEd0IsQ0FBRCxDQUF6Qjs7Ozs7Ozs7OztBQ0dBOzs7OztHQUFBOzs7QUFUQSxFQUVBO0VBQ0E7QUFDQUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNVQTs7Ozs7Ozs7O0dBQUE7OztBQWRBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDVUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBQUE7OztBQWRBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNpQkE7Ozs7Ozs7Ozs7R0FBQTs7O0FBckJBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDS0E7Ozs7O0dBQUE7OztBQVRBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNLQTs7R0FBQTs7O0FBVEEsRUFFQTtFQUNBO0FBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNHQTs7R0FBQTs7O0FBUEEsRUFFQTtFQUNBO0FBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0tBOzs7Ozs7Ozs7Ozs7R0FBQTs7O0FBVEEsRUFFQTtFQUNBO0FBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNHQTs7R0FBQTs7O0FBUEEsRUFFQTtFQUNBO0FBQ0FBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNEQTs7Ozs7Ozs7Ozs7O0dBQUE7OztBQUhBLEVBRUE7RUFDQTtBQUNBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
